diff -rubB --new-file linux-3.10.69/arch/x86/buffalo/buffalocore.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/buffalocore.c
--- linux-3.10.69/arch/x86/buffalo/buffalocore.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/buffalocore.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,437 @@
+/*
+ *  Driver routines for BUFFALO Platform
+ *
+ *  Copyright (C)  BUFFALO INC.
+ *
+ *  This software may be used and distributed according to the terms of
+ *  the GNU General Public License (GPL), incorporated herein by reference.
+ *  Drivers based on or derived from this code fall under the GPL and must
+ *  retain the authorship, copyright and license notice.  This file is not
+ *  a complete program and may only be used when the entire operating
+ *  system is licensed under the GPL.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+//#include "kernevntProc.h"
+#include "buffalo/kernevnt.h"
+
+/* Globals */
+// same as Buffalo Kernel Ver.
+#define BUFCORE_VERSION "0.16"
+
+/* Module parameters */
+MODULE_AUTHOR("BUFFALO");
+MODULE_DESCRIPTION("Buffalo Platform Linux Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(BUFCORE_VERSION);
+
+/* Definitions */
+//#define DEBUG
+
+#define USE_PROC_BUFFALO
+
+// ----------------------------------------------------
+
+/* Definitions for DEBUG */
+#ifdef DEBUG
+ #define FUNCTRACE(x)  x
+
+#else
+ #define FUNCTRACE(x)
+
+#endif
+
+/* Function prototypes */
+
+/* variables */
+int bfMagicKey = MagicKeyHwPoff;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+extern char saved_command_line[];
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21) */
+
+static char bootver[32];
+static char buffalo_series_name[32];
+static char buffalo_product_name[32];
+static char buffalo_product_id[32];
+
+//----------------------------------------------------------------------
+static int kernelfw_proc_show(struct seq_file *m, void *v)
+{
+	char *p, *pe;
+
+	if (!(buffalo_series_name[0] >= 'a' && buffalo_series_name[0] <= 'z') &&
+		!(buffalo_series_name[0] >= 'A' && buffalo_series_name[0] <= 'Z'))
+	{
+		memset(bootver, 0, sizeof(bootver));
+		memset(buffalo_series_name, 0, sizeof(buffalo_series_name));
+		memset(buffalo_product_name, 0, sizeof(buffalo_product_name));
+		memset(buffalo_product_id, 0, sizeof(buffalo_product_id));
+
+		p = strstr(saved_command_line,"BOOTVER=");
+		if (p)
+		{
+			pe = strstr(p, " ");
+
+			if(pe && (pe - p) < sizeof(bootver))
+				strncpy(bootver, p, pe - p);
+			else
+				strncpy(bootver, p, sizeof(bootver));
+		}
+		else
+			sprintf(bootver, "%s", "BOOTVER=Unknown");
+
+		p = strstr(saved_command_line, "SERIES=");
+		if (p)
+		{
+			p += strlen("SERIES=");
+			pe = strstr(p, " ");
+
+			if (pe && (pe - p) < sizeof(buffalo_series_name))
+				strncpy(buffalo_series_name, p, pe - p);
+			else
+				strncpy(buffalo_series_name, p, sizeof(buffalo_series_name));
+		}
+		else
+			sprintf(buffalo_series_name, "TeraStation");
+
+		p = strstr(saved_command_line, "PRODUCTNAME=");
+		if (p)
+		{
+			p += strlen("PRODUCTNAME=");
+			pe = strstr(p, " ");
+
+			if (pe && (pe - p) < sizeof(buffalo_product_name))
+				strncpy(buffalo_product_name, p, pe - p);
+			else
+				strncpy(buffalo_product_name, p, sizeof(buffalo_product_name));
+		}
+		else
+		{
+#if defined(CONFIG_BUFFALO_MATSU_PLATFORM)
+			sprintf(buffalo_product_name, "TS-QVHL/R5(SAIMEI)");
+#elif defined(CONFIG_BUFFALO_KIRI_PLATFORM)
+			sprintf(buffalo_product_name, "TS-2RZ/R6(KOHNINN)");
+#elif defined(CONFIG_BUFFALO_USI_PLATFORM)
+			p = strstr(saved_command_line, "ts4400=yes");
+			if (p)
+			{
+				sprintf(buffalo_product_name, "TS4400(UDA)");
+			}
+			else
+			{
+				sprintf(buffalo_product_name, "TS5000(GENSHO)");
+			}
+#else
+	#error
+#endif
+		}
+
+		p = strstr(saved_command_line, "PRODUCTID=");
+		if (p)
+		{
+			p += strlen("PRODUCTID=");
+			pe = strstr(p, " ");
+
+			if (pe && (pe - p) < sizeof(buffalo_product_id))
+				strncpy(buffalo_product_id, p, pe - p);
+			else
+				strncpy(buffalo_product_id, p, sizeof(buffalo_product_id));
+		}
+		else
+#if defined(CONFIG_BUFFALO_MATSU_PLATFORM)
+			sprintf(buffalo_product_id, "0x00002013");
+#elif defined(CONFIG_BUFFALO_KIRI_PLATFORM)
+			sprintf(buffalo_product_id, "0x00002017");
+#elif defined(CONFIG_BUFFALO_USI_PLATFORM)
+			sprintf(buffalo_product_id, "0x00002019");
+#else
+	#error
+#endif
+	}
+
+        seq_printf(m, "SERIES=%s\n", buffalo_series_name);
+        seq_printf(m, "PRODUCTNAME=%s\n", buffalo_product_name);
+
+        seq_printf(m, "VERSION=%s\n",BUFCORE_VERSION);
+        seq_printf(m, "SUBVERSION=FLASH 0.00\n");
+
+        seq_printf(m, "PRODUCTID=%s\n", buffalo_product_id);
+
+	seq_printf(m, "BUILDDATE=2015/02/25 17:59:58\n");
+        seq_printf(m, "%s\n",bootver);
+
+        return 0;
+}
+
+static int kernelfw_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, kernelfw_proc_show, NULL);
+}
+
+static const struct file_operations buffalo_kernelfw_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open           = kernelfw_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release
+};
+
+#if defined(CONFIG_BUFFALO_USE_MICON) || defined(CONFIG_BUFFALO_MATSU_PLATFORM)
+//----------------------------------------------------------------------
+static int micon_proc_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "on\n");
+	return 0;
+}
+
+static int micon_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, micon_proc_show, NULL);
+}
+
+static const struct file_operations buffalo_micon_proc_fops = {
+	.owner          = THIS_MODULE,
+	.open           = micon_proc_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static int miconint_proc_show(struct seq_file *m, void *v)
+{
+	return 0;
+}
+
+static int miconint_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, miconint_proc_show, NULL);
+}
+
+static const struct file_operations  buffalo_miconint_proc_fops = {
+	.owner          = THIS_MODULE,
+	.open           = miconint_proc_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+}
+#endif
+
+//----------------------------------------------------------------------
+// begin booting
+int buffalo_booting = 1;
+
+static int booting_read_proc(struct file *fp, char *data, size_t count, loff_t *off)
+{
+	int len = 0;
+
+    if(!*off) {
+        char buffer[32];
+	    len = sprintf(buffer, "%d\n", buffalo_booting);
+
+        len=count-*off>=len?len:count-*off;
+        if(len>0) {
+            memcpy(data,buffer,len);
+        }
+        *off=len;
+    }
+	return len;
+}
+
+static int booting_write_proc(struct file *fp, const char *data, size_t count, loff_t *off)
+{
+    if(count>=2) {
+	    if (strncmp(data, "0\n", count) == 0)
+	    {
+		    buffalo_booting = 0;
+	    }
+	    else if (strncmp(data, "1\n", count) == 0)
+	    {
+		    buffalo_booting = 1;
+	    }
+    }
+    else {
+		printk(">%s: short buffer.", __FUNCTION__);
+    }
+	return count;
+}
+
+static const struct file_operations booting_entry_fops =
+{
+	.owner = THIS_MODULE,
+	.read = &booting_read_proc,
+	.write = &booting_write_proc,
+};
+// end booting
+
+static int
+bfGetMagicKey(void)
+{
+	return bfMagicKey;
+}
+
+static void
+bfSetMagicKey(int key)
+{ 
+	bfMagicKey = key;
+}
+
+static int
+BuffaloCpuStatusReadProc(struct file *fp, char *data, size_t count, loff_t *off)
+{
+	int len = 0;
+
+    if(!*off) {
+        char page[32];
+	    unsigned int CpuStatus = bfGetMagicKey();
+
+	switch(CpuStatus){
+	case MagicKeyReboot:
+		len = sprintf(page, "reboot\n");
+		break;
+	case MagicKeyRebootUbootPassed:
+		len = sprintf(page, "reboot_uboot_passed\n");
+		break;
+	case MagicKeyNormalState:
+		len = sprintf(page, "normal_state\n");
+		break;
+	case MagicKeyHwPoff:
+		len = sprintf(page, "hwpoff\n");
+		break;
+	case MagicKeySwPoff:
+		len = sprintf(page, "swpoff\n");
+		break;
+	case MagicKeySWPoffUbootPassed:
+		len = sprintf(page, "swpoff_uboot_passed\n");
+		break;
+	case MagicKeyFWUpdating:
+		len = sprintf(page, "fwup\n");
+		break;
+	case MagicKeyUpsShutdown:
+		len = sprintf(page, "ups_shutdown\n");
+		break;
+	case MagicKeyWOLReadyState:
+		len = sprintf(page, "WOLReady\n");
+		break;
+	default:
+		len = sprintf(page, "Unknown(CpuStatus=%d)\n", CpuStatus);
+		break;
+	}
+
+            len=count-*off>=len?len:count-*off;
+            if(len>0) {
+                memcpy(data+*off,page,len);
+            }
+            *off=len;
+    }
+    return(len);
+}
+
+static int BuffaloCpuStatusWriteProc(struct file *fp, const char *data, size_t count, loff_t *off)
+{
+	char status[256];
+	if (count > 256)
+		return count;
+
+	memcpy(status, data, count);
+
+	if (status[count - 1] == '\n')
+		status[count - 1] = '\0';
+	else
+		status[count] = '\0';
+
+	if(strcmp(status, "reboot") == 0){
+		bfSetMagicKey(MagicKeyReboot);
+	}else if(strcmp(status, "reboot_uboot_passed") == 0){
+		bfSetMagicKey(MagicKeyRebootUbootPassed);
+	}else if(strcmp(status, "normal_state") == 0){
+		bfSetMagicKey(MagicKeyNormalState);
+	}else if(strcmp(status, "hwpoff") == 0){
+		bfSetMagicKey(MagicKeyHwPoff);
+	}else if(strcmp(status, "swpoff") == 0){
+		bfSetMagicKey(MagicKeySwPoff);
+	}else if(strcmp(status, "swpoff_uboot_passed") == 0){
+		bfSetMagicKey(MagicKeySWPoffUbootPassed);
+	}else if(strcmp(status, "fwup") == 0){
+		bfSetMagicKey(MagicKeyFWUpdating);
+	}else if(strcmp(status, "ups_shutdown") == 0){
+		bfSetMagicKey(MagicKeyUpsShutdown);
+	}else if(strcmp(status, "WOLReady") == 0){
+		bfSetMagicKey(MagicKeyWOLReadyState);
+	}else{
+
+	}
+
+	return count;
+}
+
+static const struct file_operations cpu_status_entry_fops =
+{		
+	.owner = THIS_MODULE,
+	.read = &BuffaloCpuStatusReadProc,
+	.write = &BuffaloCpuStatusWriteProc,
+};
+
+
+struct proc_dir_entry *
+get_proc_buffalo(void)
+{
+	static struct proc_dir_entry *buffalo = NULL;
+
+	if (buffalo == NULL)
+		buffalo = proc_mkdir("buffalo", NULL);
+
+	return buffalo;
+}
+
+//----------------------------------------------------------------------
+int __init buffaloDriver_init (void)
+{
+        struct proc_dir_entry *generic, *buffalo, *booting;
+        FUNCTRACE(printk(">%s\n",__FUNCTION__));
+
+	buffalo = get_proc_buffalo();
+	proc_create("firmware", 0, buffalo, &buffalo_kernelfw_proc_fops);
+
+#if defined(CONFIG_BUFFALO_USE_MICON) || defined(CONFIG_BUFFALO_MATSU_PLATFORM)
+        proc_create("micon", 0, buffalo, &buffalo_micon_proc_fops);
+	proc_create("miconint_en", 0, buffalo, &buffalo_miconint_proc_fops);
+#endif
+
+	proc_create("cpu_status", 0, buffalo, &cpu_status_entry_fops);
+
+	proc_create("booting", 0, buffalo, &booting_entry_fops);
+
+	//BuffaloKernevnt_init();
+
+	return 0;
+}
+
+//----------------------------------------------------------------------
+void buffaloDriver_exit(void)
+{
+	FUNCTRACE(printk(">%s\n",__FUNCTION__));
+
+	//BuffaloKernevnt_exit();
+	remove_proc_entry("buffalo/booting", 0);
+	remove_proc_entry("buffalo/cpu_status", 0);
+#if defined(CONFIG_BUFFALO_USE_MICON) || defined(CONFIG_BUFFALO_MATSU_PLATFORM)
+	remove_proc_entry("buffalo/miconint_en", 0);
+	remove_proc_entry("buffalo/micon", 0);
+#endif
+	remove_proc_entry("buffalo/firmware", 0);
+	remove_proc_entry ("buffalo", 0);
+}
+
+module_init(buffaloDriver_init);
+module_exit(buffaloDriver_exit);
diff -rubB --new-file linux-3.10.69/arch/x86/buffalo/buffalocore.c.in F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/buffalocore.c.in
--- linux-3.10.69/arch/x86/buffalo/buffalocore.c.in	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/buffalocore.c.in	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,435 @@
+/*
+ *  Driver routines for BUFFALO Platform
+ *
+ *  Copyright (C)  BUFFALO INC.
+ *
+ *  This software may be used and distributed according to the terms of
+ *  the GNU General Public License (GPL), incorporated herein by reference.
+ *  Drivers based on or derived from this code fall under the GPL and must
+ *  retain the authorship, copyright and license notice.  This file is not
+ *  a complete program and may only be used when the entire operating
+ *  system is licensed under the GPL.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <asm/uaccess.h>
+
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+
+//#include "kernevntProc.h"
+#include "buffalo/kernevnt.h"
+
+/* Globals */
+// same as Buffalo Kernel Ver.
+#define BUFCORE_VERSION "0.16"
+
+/* Module parameters */
+MODULE_AUTHOR("BUFFALO");
+MODULE_DESCRIPTION("Buffalo Platform Linux Driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(BUFCORE_VERSION);
+
+/* Definitions */
+//#define DEBUG
+
+#define USE_PROC_BUFFALO
+
+// ----------------------------------------------------
+
+/* Definitions for DEBUG */
+#ifdef DEBUG
+ #define FUNCTRACE(x)  x
+
+#else
+ #define FUNCTRACE(x)
+
+#endif
+
+/* Function prototypes */
+
+/* variables */
+int bfMagicKey = MagicKeyHwPoff;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21)
+extern char saved_command_line[];
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,21) */
+
+static char bootver[32];
+static char buffalo_series_name[32];
+static char buffalo_product_name[32];
+static char buffalo_product_id[32];
+
+//----------------------------------------------------------------------
+static int kernelfw_proc_show(struct seq_file *m, void *v)
+{
+	char *p, *pe;
+
+	if (!(buffalo_series_name[0] >= 'a' && buffalo_series_name[0] <= 'z') &&
+		!(buffalo_series_name[0] >= 'A' && buffalo_series_name[0] <= 'Z'))
+	{
+		memset(bootver, 0, sizeof(bootver));
+		memset(buffalo_series_name, 0, sizeof(buffalo_series_name));
+		memset(buffalo_product_name, 0, sizeof(buffalo_product_name));
+		memset(buffalo_product_id, 0, sizeof(buffalo_product_id));
+
+		p = strstr(saved_command_line,"BOOTVER=");
+		if (p)
+		{
+			pe = strstr(p, " ");
+
+			if(pe && (pe - p) < sizeof(bootver))
+				strncpy(bootver, p, pe - p);
+			else
+				strncpy(bootver, p, sizeof(bootver));
+		}
+		else
+			sprintf(bootver, "%s", "BOOTVER=Unknown");
+
+		p = strstr(saved_command_line, "SERIES=");
+		if (p)
+		{
+			p += strlen("SERIES=");
+			pe = strstr(p, " ");
+
+			if (pe && (pe - p) < sizeof(buffalo_series_name))
+				strncpy(buffalo_series_name, p, pe - p);
+			else
+				strncpy(buffalo_series_name, p, sizeof(buffalo_series_name));
+		}
+		else
+			sprintf(buffalo_series_name, "TeraStation");
+
+		p = strstr(saved_command_line, "PRODUCTNAME=");
+		if (p)
+		{
+			p += strlen("PRODUCTNAME=");
+			pe = strstr(p, " ");
+
+			if (pe && (pe - p) < sizeof(buffalo_product_name))
+				strncpy(buffalo_product_name, p, pe - p);
+			else
+				strncpy(buffalo_product_name, p, sizeof(buffalo_product_name));
+		}
+		else
+		{
+#if defined(CONFIG_BUFFALO_MATSU_PLATFORM)
+			sprintf(buffalo_product_name, "TS-QVHL/R5(SAIMEI)");
+#elif defined(CONFIG_BUFFALO_KIRI_PLATFORM)
+			sprintf(buffalo_product_name, "TS-2RZ/R6(KOHNINN)");
+#elif defined(CONFIG_BUFFALO_USI_PLATFORM)
+			p = strstr(saved_command_line, "ts4400=yes");
+			if (p)
+			{
+				sprintf(buffalo_product_name, "TS4400(UDA)");
+			}
+			else
+			{
+				sprintf(buffalo_product_name, "TS5000(GENSHO)");
+			}
+#else
+	#error
+#endif
+		}
+
+		p = strstr(saved_command_line, "PRODUCTID=");
+		if (p)
+		{
+			p += strlen("PRODUCTID=");
+			pe = strstr(p, " ");
+
+			if (pe && (pe - p) < sizeof(buffalo_product_id))
+				strncpy(buffalo_product_id, p, pe - p);
+			else
+				strncpy(buffalo_product_id, p, sizeof(buffalo_product_id));
+		}
+		else
+#if defined(CONFIG_BUFFALO_MATSU_PLATFORM)
+			sprintf(buffalo_product_id, "0x00002013");
+#elif defined(CONFIG_BUFFALO_KIRI_PLATFORM)
+			sprintf(buffalo_product_id, "0x00002017");
+#elif defined(CONFIG_BUFFALO_USI_PLATFORM)
+			sprintf(buffalo_product_id, "0x00002019");
+#else
+	#error
+#endif
+	}
+
+        seq_printf(m, "SERIES=%s\n", buffalo_series_name);
+        seq_printf(m, "PRODUCTNAME=%s\n", buffalo_product_name);
+
+        seq_printf(m, "VERSION=%s\n",BUFCORE_VERSION);
+        seq_printf(m, "SUBVERSION=FLASH 0.00\n");
+
+        seq_printf(m, "PRODUCTID=%s\n", buffalo_product_id);
+
+	seq_printf(m, "BUILDDATE=<<<!!!BUFFALO_BUILD_DATE!!!>>>\n");
+        seq_printf(m, "%s\n",bootver);
+
+        return 0;
+}
+
+static int kernelfw_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, kernelfw_proc_show, NULL);
+}
+
+static const struct file_operations buffalo_kernelfw_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open           = kernelfw_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release
+};
+
+#if defined(CONFIG_BUFFALO_USE_MICON) || defined(CONFIG_BUFFALO_MATSU_PLATFORM)
+//----------------------------------------------------------------------
+static int micon_proc_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "on\n");
+	return 0;
+}
+
+static int micon_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, micon_proc_show, NULL);
+}
+
+static const struct file_operations buffalo_micon_proc_fops = {
+	.owner          = THIS_MODULE,
+	.open           = micon_proc_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+};
+
+static int miconint_proc_show(struct seq_file *m, void *v)
+{
+	return 0;
+}
+
+static int miconint_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, miconint_proc_show, NULL);
+}
+
+static const struct file_operations  buffalo_miconint_proc_fops = {
+	.owner          = THIS_MODULE,
+	.open           = miconint_proc_open,
+	.read           = seq_read,
+	.llseek         = seq_lseek,
+	.release        = single_release,
+}
+#endif
+
+//----------------------------------------------------------------------
+// begin booting
+int buffalo_booting = 1;
+
+static int booting_read_proc(struct file *fp, char *data, size_t count, loff_t *off)
+{
+	int len = 0;
+
+    if(!*off) {
+        char buffer[32];
+	    len = sprintf(buffer, "%d\n", buffalo_booting);
+
+        len=count-*off>=len?len:count-*off;
+        if(len>0) {
+            memcpy(data,buffer,len);
+        }
+        *off=len;
+    }
+	return len;
+}
+
+static int booting_write_proc(struct file *fp, const char *data, size_t count, loff_t *off)
+{
+    if(count>=2) {
+	    if (strncmp(data, "0\n", count) == 0)
+	    {
+		    buffalo_booting = 0;
+	    }
+	    else if (strncmp(data, "1\n", count) == 0)
+	    {
+		    buffalo_booting = 1;
+	    }
+    }
+    else {
+		printk(">%s: short buffer.", __FUNCTION__);
+    }
+	return count;
+}
+
+static const struct file_operations booting_entry_fops =
+{
+	.owner = THIS_MODULE,
+	.read = &booting_read_proc,
+	.write = &booting_write_proc,
+};
+// end booting
+
+static int
+bfGetMagicKey(void)
+{
+	return bfMagicKey;
+}
+
+static void
+bfSetMagicKey(int key)
+{ 
+	bfMagicKey = key;
+}
+
+static int
+ReadCpuStatus(struct seq_file *m, void *v)
+{
+	unsigned int CpuStatus = bfGetMagicKey();
+
+	switch (CpuStatus) {
+		case MagicKeyReboot:
+			seq_printf(m, "reboot\n");
+			break;
+		case MagicKeyRebootUbootPassed:
+			seq_printf(m, "reboot_uboot_passed\n");
+			break;
+		case MagicKeyNormalState:
+			seq_printf(m, "normal_state\n");
+			break;
+		case MagicKeyHwPoff:
+			seq_printf(m, "hwpoff\n");
+			break;
+		case MagicKeySwPoff:
+			seq_printf(m, "swpoff\n");
+			break;
+		case MagicKeySWPoffUbootPassed:
+			seq_printf(m, "swpoff_uboot_passed\n");
+			break;
+		case MagicKeyFWUpdating:
+			seq_printf(m, "fwup\n");
+			break;
+		case MagicKeyUpsShutdown:
+			seq_printf(m, "ups_shutdown\n");
+			break;
+		case MagicKeyWOLReadyState:
+			seq_printf(m, "WOLReady\n");
+			break;
+		default:
+			seq_printf(m, "Unknown(CpuStatus=%d)\n", CpuStatus);
+			break;
+	}
+
+	return 0;
+}
+
+static int BuffaloCpuStatusOpenProc(struct inode *inode, struct file *file)
+{
+        return single_open(file, ReadCpuStatus, PDE_DATA(file_inode(file)));
+}
+
+static int BuffaloCpuStatusWriteProc(struct file *fp, const char *data, size_t count, loff_t *off)
+{
+	char status[256];
+	if (count > 256)
+		return count;
+
+	memcpy(status, data, count);
+
+	if (status[count - 1] == '\n')
+		status[count - 1] = '\0';
+	else
+		status[count] = '\0';
+
+	if(strcmp(status, "reboot") == 0){
+		bfSetMagicKey(MagicKeyReboot);
+	}else if(strcmp(status, "reboot_uboot_passed") == 0){
+		bfSetMagicKey(MagicKeyRebootUbootPassed);
+	}else if(strcmp(status, "normal_state") == 0){
+		bfSetMagicKey(MagicKeyNormalState);
+	}else if(strcmp(status, "hwpoff") == 0){
+		bfSetMagicKey(MagicKeyHwPoff);
+	}else if(strcmp(status, "swpoff") == 0){
+		bfSetMagicKey(MagicKeySwPoff);
+	}else if(strcmp(status, "swpoff_uboot_passed") == 0){
+		bfSetMagicKey(MagicKeySWPoffUbootPassed);
+	}else if(strcmp(status, "fwup") == 0){
+		bfSetMagicKey(MagicKeyFWUpdating);
+	}else if(strcmp(status, "ups_shutdown") == 0){
+		bfSetMagicKey(MagicKeyUpsShutdown);
+	}else if(strcmp(status, "WOLReady") == 0){
+		bfSetMagicKey(MagicKeyWOLReadyState);
+	}else{
+
+	}
+
+	return count;
+}
+
+static const struct file_operations cpu_status_entry_fops =
+{		
+	.owner = THIS_MODULE,
+	.open = &BuffaloCpuStatusOpenProc,
+	.write = &BuffaloCpuStatusWriteProc,
+	.read = seq_read,
+        .llseek = seq_lseek,
+        .release = single_release
+};
+
+
+struct proc_dir_entry *
+get_proc_buffalo(void)
+{
+	static struct proc_dir_entry *buffalo = NULL;
+
+	if (buffalo == NULL)
+		buffalo = proc_mkdir("buffalo", NULL);
+
+	return buffalo;
+}
+
+//----------------------------------------------------------------------
+int __init buffaloDriver_init (void)
+{
+        struct proc_dir_entry *generic, *buffalo, *booting;
+        FUNCTRACE(printk(">%s\n",__FUNCTION__));
+
+	buffalo = get_proc_buffalo();
+	proc_create("firmware", 0, buffalo, &buffalo_kernelfw_proc_fops);
+
+#if defined(CONFIG_BUFFALO_USE_MICON) || defined(CONFIG_BUFFALO_MATSU_PLATFORM)
+        proc_create("micon", 0, buffalo, &buffalo_micon_proc_fops);
+	proc_create("miconint_en", 0, buffalo, &buffalo_miconint_proc_fops);
+#endif
+
+	proc_create("cpu_status", 0, buffalo, &cpu_status_entry_fops);
+
+	proc_create("booting", 0, buffalo, &booting_entry_fops);
+
+	//BuffaloKernevnt_init();
+
+	return 0;
+}
+
+//----------------------------------------------------------------------
+void buffaloDriver_exit(void)
+{
+	FUNCTRACE(printk(">%s\n",__FUNCTION__));
+
+	//BuffaloKernevnt_exit();
+	remove_proc_entry("buffalo/booting", 0);
+	remove_proc_entry("buffalo/cpu_status", 0);
+#if defined(CONFIG_BUFFALO_USE_MICON) || defined(CONFIG_BUFFALO_MATSU_PLATFORM)
+	remove_proc_entry("buffalo/miconint_en", 0);
+	remove_proc_entry("buffalo/micon", 0);
+#endif
+	remove_proc_entry("buffalo/firmware", 0);
+	remove_proc_entry ("buffalo", 0);
+}
+
+module_init(buffaloDriver_init);
+module_exit(buffaloDriver_exit);
diff -rubB --new-file linux-3.10.69/arch/x86/buffalo/buffalocore.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/buffalocore.h
--- linux-3.10.69/arch/x86/buffalo/buffalocore.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/buffalocore.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,17 @@
+#if !defined(_BUFFALOCORE_H_)
+#define _BUFFALOCORE_H_
+
+#if defined(CONFIG_ARCH_FEROCEON_KW)
+struct bf_proc_entry_tab {
+  const char *name;
+  int isDirectory;
+  read_proc_t *read_proc;
+  write_proc_t *write_proc;
+  void *data;
+  MV_BOARD_GPP_CLASS class;
+};
+#endif
+
+struct proc_dir_entry *get_proc_buffalo(void);
+
+#endif
diff -rubB --new-file linux-3.10.69/arch/x86/buffalo/buffalo_upsdrv.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/buffalo_upsdrv.c
--- linux-3.10.69/arch/x86/buffalo/buffalo_upsdrv.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/buffalo_upsdrv.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,147 @@
+/*
+ *  LinkStation/TeraStation UPS port Driver
+ *
+ *  Copyright (C)  BUFFALO INC.
+ *
+ *  This software may be used and distributed according to the terms of
+ *  the GNU General Public License (GPL), incorporated herein by reference.
+ *  Drivers based on or derived from this code fall under the GPL and must
+ *  retain the authorship, copyright and license notice.  This file is not
+ *  a complete program and may only be used when the entire operating
+ *  system is licensed under the GPL.
+ *
+ */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#include <linux/config.h>
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSIOIN(2,6,19) */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/serial_reg.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+#include <linux/delay.h>
+
+#define UPSPORT	0
+#if defined(CONFIG_BUFFALO_USE_UPS)
+
+struct uart_port *uart_ports[CONFIG_SERIAL_8250_NR_UARTS];
+
+#define BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN
+
+static struct proc_dir_entry *proc_buffalo_ups;
+
+static unsigned int OmronShutdownEnable = 0;
+
+extern struct uart_port *uart_ports[];
+
+static int BuffaloUps_OmronShutdownEnable_read_proc(struct seq_file *m, void *v)
+{
+	if (OmronShutdownEnable)
+		seq_printf(m, "on\n");
+	else
+		seq_printf(m, "off\n");
+
+	return 0;
+}
+
+static int BuffaloUps_OmronShutdownEnable_open_proc(struct inode *inode, struct file *file)
+{
+	return single_open(file, BuffaloUps_OmronShutdownEnable_read_proc, NULL);
+}
+
+static int BuffaloUps_OmronShutdownEnable_write_proc(struct file *fp, const char *buffer, size_t count, loff_t *off)
+{
+	if (strncmp(buffer, "on", 2) == 0)
+		OmronShutdownEnable = 1;
+	else if (strncmp(buffer, "off", 3) == 0)
+		OmronShutdownEnable = 0;
+
+	return count;
+}
+
+static const struct file_operations omron_shutdown_enable_entry_fops =
+{
+	.owner		= THIS_MODULE,
+        .open		= &BuffaloUps_OmronShutdownEnable_open_proc,
+        .write		= &BuffaloUps_OmronShutdownEnable_write_proc,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release
+};
+
+void BuffaloUps_ShutdownUps(void)
+{
+	int timeout = 15;
+	int i = 0;
+
+	if(OmronShutdownEnable == 1)
+	{
+		unsigned int mctrl = uart_ports[UPSPORT]->ops->get_mctrl(uart_ports[UPSPORT]);
+		printk("Shuttting down OMRON ups ... \n");
+
+#if defined(CONFIG_ARCH_FEROCEON_KW) || defined(CONFIG_ARCH_FEROCEON_MV78XX0)
+		mctrl &= ~TIOCM_DTR;	// ARMの場合は、TIOCM_DTRが論理反転していたため。
+#else
+		mctrl |= TIOCM_DTR;
+#endif
+		uart_ports[UPSPORT]->ops->set_mctrl(uart_ports[UPSPORT], mctrl);
+
+		while(timeout)
+		{
+#if 0
+			// force shutdown UPS output and recover.
+			mctrl = uart_ports[UPSPORT]->ops->get_mctrl(uart_ports[UPSPORT]);
+			if(!(mctrl & TIOCM_CTS))
+			{
+				printk("AC recovered. Exiting shutting down loop!\n");
+				break;
+			}
+#endif
+			for(i = 0; i < 1000; i++)
+			{
+				udelay(1000);
+			}
+			timeout--;
+		}
+		if(timeout == 0)
+			printk("Failed?\n");
+	}
+}
+//--------------------------------------------------------------
+/*
+ * Initialize driver.
+ */
+int __init BuffaloUpsdrv_init (void)
+{
+	printk("Initializing Buffalo UPS driver\n"); 
+	
+	proc_buffalo_ups = proc_mkdir("buffalo/ups", 0);
+
+#if defined(BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN)
+	proc_create("omron_shutdown_enable", 0, proc_buffalo_ups, &omron_shutdown_enable_entry_fops);
+	printk("  OMRON contact type ups shutdown support enabled!\n");
+#endif	// of BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN
+
+	return 0;
+}
+
+//--------------------------------------------------------------
+void BuffaloUpsdrv_exit(void)
+{
+	printk("Exiting Buffalo UPS driver\n");
+
+#if defined(BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN)
+	remove_proc_entry("buffalo/ups/omron_shutdown_enable", 0);
+#endif	// of BUFFALO_SUPPORT_OMRON_UPS_SHUTDOWN
+	remove_proc_entry("buffalo/ups", 0);
+}
+
+module_init(BuffaloUpsdrv_init);
+module_exit(BuffaloUpsdrv_exit);
+MODULE_LICENSE("GPL");
+
+#endif  //CONFIG_BUFFALO_USE_UPS
diff -rubB --new-file linux-3.10.69/arch/x86/buffalo/kernevnt.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/kernevnt.c
--- linux-3.10.69/arch/x86/buffalo/kernevnt.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/kernevnt.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,312 @@
+/*
+ *  LinkStation/TeraStation Kernel Event Driver
+ *
+ *  Copyright (C)  BUFFALO INC.
+ *
+ *  This software may be used and distributed according to the terms of
+ *  the GNU General Public License (GPL), incorporated herein by reference.
+ *  Drivers based on or derived from this code fall under the GPL and must
+ *  retain the authorship, copyright and license notice.  This file is not
+ *  a complete program and may only be used when the entire operating
+ *  system is licensed under the GPL.
+ *
+ */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#include <linux/config.h>
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,31)
+#include <linux/sched.h>
+#endif
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+
+#include <asm/string.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/serial.h>
+#include "buffalo/kernevnt.h"
+#if defined(CONFIG_ARCH_FEROCEON_KW)
+#include "buffalo/kernevntProc.h"
+#include "mv_network/mv_ethernet/mv_netdev.h"
+#else
+#include "kernevntProc.h"
+#endif
+
+#define bzero(p,sz) memset(p,0,sz)
+
+//#define DEBUG
+//#define FUNCMSG
+
+#ifdef DEBUG
+ #define TRACE(x) x
+#else
+ #define TRACE(x)
+#endif
+
+static spinlock_t BuffaloMicon_event_lock = __SPIN_LOCK_UNLOCKED();
+wait_queue_head_t buffalo_kernevnt_WaitQueue;
+static int initialized=0;
+static struct tag_MiconDevice {
+	struct {
+		char cmd[MAX_CMDLEN+1];
+	} cmdqueue[MAX_QUELEN];
+	int rindex,windex;
+} MiconDevice;
+
+//--------------------------------------------------------------
+void buffalo_kernevnt_queuein(const char *cmd)
+{
+	if (!initialized){
+		return;
+	}
+	if (MiconDevice.cmdqueue[MiconDevice.windex].cmd[0]==0){
+		unsigned long flags;
+		
+		spin_lock_irqsave (&BuffaloMicon_event_lock, flags);
+		
+		strncpy(MiconDevice.cmdqueue[MiconDevice.windex].cmd, cmd, MAX_CMDLEN-1);
+		MiconDevice.windex++;
+		if (MiconDevice.windex == sizeof(MiconDevice.cmdqueue)/sizeof(MiconDevice.cmdqueue[0])){
+			MiconDevice.windex=0;
+		}
+		
+		spin_unlock_irqrestore (&BuffaloMicon_event_lock, flags);
+		
+		TRACE(printk("queue in : r=%d w=%d [%s]\n",MiconDevice.rindex,MiconDevice.windex, cmd));
+	}else{
+		TRACE(printk("queue full [%s]\n",cmd));
+	}
+	wake_up_interruptible(&buffalo_kernevnt_WaitQueue);
+}
+
+//--------------------------------------------------------------
+int buffalo_kernevnt_queueout(unsigned char *cmd, int *len)
+{
+	if (!initialized){
+		return -1;
+	}
+	if (MiconDevice.cmdqueue[MiconDevice.rindex].cmd[0]!=0){
+		unsigned long flags;
+		int index;
+		index = MiconDevice.rindex;
+		
+		TRACE(printk("queue out : r=%d w=%d [%s]\n",MiconDevice.rindex,MiconDevice.windex, MiconDevice.cmdqueue[index].cmd));
+		
+		spin_lock_irqsave (&BuffaloMicon_event_lock, flags);
+		
+		if (MiconDevice.cmdqueue[index].cmd[0]!=0){
+			strncpy(cmd, MiconDevice.cmdqueue[index].cmd,MAX_CMDLEN);
+			*len = strlen(cmd)+1;  // for NULL terminate.
+			MiconDevice.cmdqueue[index].cmd[0]=0;
+		}
+		MiconDevice.rindex++;
+		if (MiconDevice.rindex == sizeof(MiconDevice.cmdqueue)/sizeof(MiconDevice.cmdqueue[0])){
+			MiconDevice.rindex=0;
+		}
+		
+		spin_unlock_irqrestore (&BuffaloMicon_event_lock, flags);
+		
+		return index;
+	}else{
+		TRACE(printk("queue none\n"));
+	}
+	return -1;
+}
+
+#ifdef CONFIG_MD
+//--------------------------------------------------------------
+void kernevnt_RaidRecovery(int devno, int on, int isRecovery, int major, int minor)
+{
+	static int opencnt=0;
+	char buff[64];
+#ifdef FUNCMSG
+	printk(">%s:md%d on=%d cnt=%d isRecovery=%d %d %d\n",__FUNCTION__,devno,on,opencnt,isRecovery,major,minor);
+#endif
+	
+	if (on) opencnt++;
+	else    opencnt--;
+	
+	if (isRecovery){
+		sprintf(buff,"raidrecovery %d %d %d %d %d %d",devno,on,opencnt,isRecovery,major,minor);
+	}else{
+		sprintf(buff,"raidresync %d %d %d %d",devno,on,opencnt,isRecovery);
+	}
+	buffalo_kernevnt_queuein(buff);
+}
+//--------------------------------------------------------------
+void kernevnt_RaidScan(int devno, int on)
+{
+	static int opencnt=0;
+	char buff[64];
+#ifdef FUNCMSG
+	printk(">%s:md%d on=%d cnt=%d\n",__FUNCTION__,devno,on,opencnt);
+#endif
+	
+	if (on) opencnt++;
+	else    opencnt--;
+	
+	sprintf(buff,"raidscan %d %d %d",devno,on,opencnt);
+	buffalo_kernevnt_queuein(buff);
+}
+//--------------------------------------------------------------
+void kernevnt_RaidDegraded(int devno, int major, int minor)
+{
+	char buff[64];
+#ifdef FUNCMSG
+	printk(">%s:md%d %d %d\n",__FUNCTION__,devno,major,minor);
+#endif
+	
+	sprintf(buff,"raiddegraded %d %d %d",devno,major,minor);
+	buffalo_kernevnt_queuein(buff);
+}
+//--------------------------------------------------------------
+void kernevnt_RaidReshape(int devno, int on)
+{
+	static int opencnt=0;
+	char buff[64];
+
+	if (on) opencnt++;
+	else    opencnt--;
+
+	sprintf(buff, "raidreshape %d %d %d", devno, on, opencnt);
+	buffalo_kernevnt_queuein(buff);
+}
+
+#endif //#ifdef CONFIG_MD
+
+//--------------------------------------------------------------
+void kernevnt_FlashUpdate(int on)
+{
+#ifdef FUNCMSG
+	printk(">%s (%d)\n",__FUNCTION__,on);
+#endif
+	char msg[32];
+	sprintf(msg,"flashupdate %d",on);
+	buffalo_kernevnt_queuein(msg);
+}
+
+//--------------------------------------------------------------
+void kernevnt_LanAct(void *data)
+{
+#if defined(CONFIG_ARCH_FEROCEON_KW)
+	mv_eth_priv *priv = (mv_eth_priv *)data;
+	char msg[32];
+	int port = priv->port;
+	u32 port_status;
+	int linkspeed;
+
+	port_status = MV_REG_READ(ETH_PORT_STATUS_REG(port));
+	if (port_status & ETH_LINK_UP_MASK) {
+		if(port_status & ETH_GMII_SPEED_1000_MASK) {
+			linkspeed = 1000;
+		}
+		else {
+			linkspeed = ((port_status & ETH_MII_SPEED_100_MASK) ? 100 : 10 );
+		}
+	}
+	else {
+		linkspeed = 0;
+	}
+
+	sprintf(msg,"lanact %d %s eth%d",
+		linkspeed,
+		(port_status & ETH_FULL_DUPLEX_MASK) ? "full" : "half",
+		port);
+	
+	buffalo_kernevnt_queuein(msg);
+#endif
+}
+
+void kernevnt_SwitchHubAct(const char *msg)
+{
+	buffalo_kernevnt_queuein(msg);
+}
+
+//--------------------------------------------------------------
+void kernevnt_IOErr(const char *kdevname, const char *dir, unsigned long sector, unsigned int errcnt)
+{
+#ifdef FUNCMSG
+		printk(">%s(%s): I/O error, dev %s, sector %lu\n",
+			__FUNCTION__,kdevname, dir, sector, errcnt);
+#endif
+	char msg[64];
+	sprintf(msg,"ioerr %s %s %ld %u",kdevname, dir, sector, errcnt);
+	buffalo_kernevnt_queuein(msg);
+}
+
+//--------------------------------------------------------------
+void kernevnt_DriveDead(const char *drvname)
+{
+#ifdef FUNCMSG
+		printk(">%s: drive %s is dead.\n",__FUNCTION__,drvname);
+#endif
+	char msg[64];
+	sprintf(msg,"drivedead %s",drvname);
+	buffalo_kernevnt_queuein(msg);
+}
+
+//--------------------------------------------------------------
+void kernevnt_I2cErr(void)
+{
+	printk(">%s\n",__FUNCTION__);
+	buffalo_kernevnt_queuein("i2c_error");
+}
+
+//--------------------------------------------------------------
+void kernevnt_MiconInt(void)
+{
+#ifdef FUNCMSG
+		printk(">%s\n",__FUNCTION__);
+#endif
+	buffalo_kernevnt_queuein("micon_interrupts");
+}
+
+//--------------------------------------------------------------
+void kernevnt_EnetOverload(const char *name)
+{
+#ifdef FUNCMSG
+		printk(">%s\n",__FUNCTION__);
+#endif
+	char msg[64];
+	sprintf(msg,"enetover %s",name);
+	buffalo_kernevnt_queuein(msg);
+}
+
+//--------------------------------------------------------------
+/*
+ * Initialize driver.
+ */
+int __init BuffaloMicon_init (void)
+{
+	printk("Initializing Buffalo micon driver\n"); 
+	
+	// Initialize Local valiables
+	bzero(&MiconDevice, sizeof(MiconDevice));
+	init_waitqueue_head(&buffalo_kernevnt_WaitQueue);
+	initialized=1;
+	return 0;
+}
+
+//--------------------------------------------------------------
+void BuffaloMicon_exit(void)
+{
+	printk("Exiting Buffalo Micon driver\n");
+	initialized=0;
+
+}
+
+EXPORT_SYMBOL(buffalo_kernevnt_queuein);
+EXPORT_SYMBOL(buffalo_kernevnt_queueout);
+EXPORT_SYMBOL(buffalo_kernevnt_WaitQueue);
+
+module_init(BuffaloMicon_init);
+module_exit(BuffaloMicon_exit);
+MODULE_LICENSE("GPL");
+
diff -rubB --new-file linux-3.10.69/arch/x86/buffalo/kernevntProc.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/kernevntProc.c
--- linux-3.10.69/arch/x86/buffalo/kernevntProc.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/kernevntProc.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,116 @@
+/*
+ *  LinkStation/TeraStation Kernel Event Proc Driver
+ *
+ *  Copyright (C)  BUFFALO INC.
+ *
+ *  This software may be used and distributed according to the terms of
+ *  the GNU General Public License (GPL), incorporated herein by reference.
+ *  Drivers based on or derived from this code fall under the GPL and must
+ *  retain the authorship, copyright and license notice.  This file is not
+ *  a complete program and may only be used when the entire operating
+ *  system is licensed under the GPL.
+ *
+ */
+#include <linux/version.h>
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+#include <linux/config.h>
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19) */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
+#include <linux/sched.h>
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19) */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/string.h>
+
+#if defined(CONFIG_ARCH_FEROCEON_KW)
+#include "buffalo/buffalocore.h"
+#include "buffalo/kernevntProc.h"
+#else
+#include "buffalocore.h"
+#include "kernevntProc.h"
+#endif
+
+#define bzero(p,sz) memset(p,0,sz)
+
+//#define DEBUG
+
+#ifdef DEBUG
+ #define TRACE(x) x
+#else
+ #define TRACE(x)
+#endif
+
+extern void buffalo_kernevnt_queuein(const char *cmd);
+extern int buffalo_kernevnt_queueout(unsigned char *cmd, int *len);
+extern wait_queue_head_t  buffalo_kernevnt_WaitQueue;
+
+
+
+
+// event notice from kernel
+static ssize_t BuffaloKernevnt_read_proc(struct file *fp, char *data,
+                                         size_t count, loff_t *off)
+{
+	int len = 0;
+	char retbuff[MAX_CMDLEN+1+2];
+	static int finished = 0;
+	
+	if (finished) {
+		finished = 0;
+		return 0;
+	}	
+	
+	TRACE(printk(">%s count=%d off=%ld\n",__FUNCTION__,count,off));
+	if (count < 0)
+		return -EINVAL;
+	
+	if (*off>0 || wait_event_interruptible(buffalo_kernevnt_WaitQueue, buffalo_kernevnt_queueout(retbuff,&len)>=0 )!=0){
+		return 0;
+	}
+	
+	if (len>count){
+		// buffer too short
+		return -EINVAL;
+	}
+	finished = 1;
+	memcpy(data,retbuff,len);
+	
+	return len;
+}
+
+static struct file_operations fops = {
+  .read = BuffaloKernevnt_read_proc
+};
+
+/*
+ * Initialize driver.
+ */
+int BuffaloKernevnt_init (void)
+{
+	TRACE(printk(">%s\n",__FUNCTION__));
+	printk("Kernel event proc (C) BUFFALO INC. V.1.00 installed.\n"); 
+	
+	proc_create("kernevnt",0,get_proc_buffalo(),&fops);
+
+	return 0;
+}
+
+void BuffaloKernevnt_exit(void)
+{
+	TRACE(printk(">%s\n",__FUNCTION__));
+	remove_proc_entry("kernevnt", get_proc_buffalo());
+	printk("Kernel event proc removed.\n");
+}
+
+
+module_init(BuffaloKernevnt_init);
+module_exit(BuffaloKernevnt_exit);
+
+MODULE_LICENSE("GPL");
+
diff -rubB --new-file linux-3.10.69/arch/x86/buffalo/kernevntProc.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/kernevntProc.h
--- linux-3.10.69/arch/x86/buffalo/kernevntProc.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/kernevntProc.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,11 @@
+#ifndef _KERNEVNTPROC_H_
+#define _KERNEVNTPROC_H_
+
+#define MAX_CMDLEN  32
+#define MAX_QUELEN  32
+
+int BuffaloKernevnt_init (void);
+void BuffaloKernevnt_exit(void);
+
+#endif
+
diff -rubB --new-file linux-3.10.69/arch/x86/buffalo/Makefile F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/Makefile
--- linux-3.10.69/arch/x86/buffalo/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/buffalo/Makefile	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,4 @@
+obj-$(CONFIG_BUFFALO_PLATFORM)		+= buffalocore.o
+obj-$(CONFIG_BUFFALO_PLATFORM)		+= kernevntProc.o
+obj-$(CONFIG_BUFFALO_PLATFORM)		+= kernevnt.o
+obj-$(CONFIG_BUFFALO_PLATFORM)		+= buffalo_upsdrv.o
diff -rubB --new-file linux-3.10.69/arch/x86/Kconfig F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/Kconfig
--- linux-3.10.69/arch/x86/Kconfig	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/Kconfig	2017-05-02 03:31:56.000000000 +0200
@@ -1011,6 +1011,134 @@
 	  Say Y if you intend to run this kernel on a Dell Inspiron 8000.
 	  Say N otherwise.
 
+menu "BUFFALO Features"
+
+config BUFFALO_PLATFORM
+	bool "BUFFALO_PLATFORM"
+	---help---
+	  Hardware/Software is BUFFALO platfrom
+
+config BUFFALO_MATSU_PLATFORM
+	bool "MATSU_PLATFORM"
+	depends on BUFFALO_PLATFORM
+	depends on X86
+	---help---
+	  Enable hdd control driver / button control driver for matsu platform.
+
+config BUFFALO_MATSU_USE_EVT_BOARD
+	bool "MATSU_EVT_BOARD"
+	depends on BUFFALO_MATSU_PLATFORM
+	---help---
+	  EVT board and DVT board has difference for GPIO pin.
+	  If this value set to enable, use EVT GPIO settings.
+
+config BUFFALO_KIRI_PLATFORM
+	bool "KIRI_PLATFORM"
+	depends on BUFFALO_PLATFORM
+	depends on X86
+	---help---
+	  Enable hdd control driver / button control driver for kiri platform.
+
+config BUFFALO_USI_PLATFORM
+	bool "USI_PLATFORM"
+	depends on BUFFALO_PLATFORM
+	depends on X86
+	--help---
+	  Enable below drivers for usi platform.
+	  * hdd control driver(hot plug / power control)
+	  * fan control driver
+	  * button control driver
+	  * CMOS settings control driver
+
+config BUFFALO_USE_KERNEVNT
+	bool "BUFFALO_USE_KERNEVNT"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  Use kernelevent
+
+config BUFFALO_USE_MD_KERNEVNT
+	bool "BUFFALO_USE_MD_KERNEVNT"
+	depends on BUFFALO_PLATFORM
+	depends on BUFFALO_USE_KERNEVNT
+	---help---
+	  Use kernelevent of md driver.
+
+config BUFFALO_USE_MD_DEGRADE_KERNEVNT
+	bool "BUFFALO_USE_MD_DEGRADE_KERNEVNT"
+	depends on BUFFALO_PLATFORM
+	depends on BUFFALO_USE_MD_KERNEVNT
+	---help---
+	  Use kernelevent of md driver.
+
+config BUFFALO_USE_MD_SCAN_KERNEVNT
+	bool "BUFFALO_USE_MD_SCAN_KERNEVNT"
+	depends on BUFFALO_PLATFORM
+	depends on BUFFALO_USE_MD_KERNEVNT
+	---help---
+	  Use kernelevent of md driver.
+
+config BUFFALO_USE_MD_REBUILD_KERNEVNT
+	bool "BUFFALO_USE_MD_REBUILD_KERNEVNT"
+	depends on BUFFALO_PLATFORM
+	depends on BUFFALO_USE_MD_KERNEVNT
+	---help---
+	  Use kernelevent of md driver.
+
+config BUFFALO_IOERRS
+	bool "BUFFALO_IOERRS"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  disk I/O error counter
+
+config BUFFALO_ERRCNT
+	bool "BUFFALO_ERRCNT"
+	depends on BUFFALO_PLATFORM
+	depends on BUFFALO_IOERRS
+	---help---
+	disk I/O error counter and auto MD degrading.
+
+config BUFFALO_SKIP_RESYNC
+	bool "BUFFALO_SKIP_RESYNC"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  skip resync of md device
+
+config BUFFALO_IGNORE_LUN
+	bool "BUFFALO_IGNORE_LUN"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  ignore lun of SCSI device
+
+config BUFFALO_SCSI_GUID
+	bool "BUFFALO_SCSI_GUID"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  add guid of SCSI device
+
+config BUFFALO_EXT23_EXTENSION
+	bool "BUFFALO_EXT23_EXTENSION"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  extend ext2/ext3 magic number
+
+config BUFFALO_USE_UPS
+	bool "BUFFALO_USE_UPS"
+	---help---
+	Enable kernel support of ups shutdown.
+
+config BUFFALO_DISABLE_NCQ
+	bool "BUFFALO_DISABLE_NCQ"
+	depends on BUFFALO_PLATFORM
+	---help---
+	  BUFFALO Disable Command Queuing Function
+
+config BUFFALO_ADD_RECVFILE
+	bool "BUFFALO_ADD_RECVFILE"
+	---help---
+	Enable recvfile system call.
+
+endmenu
+
 config X86_REBOOTFIXUPS
 	bool "Enable X86 board specific fixups for reboot"
 	depends on X86_32
diff -rubB --new-file linux-3.10.69/arch/x86/Makefile F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/Makefile
--- linux-3.10.69/arch/x86/Makefile	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/Makefile	2017-05-02 03:31:56.000000000 +0200
@@ -186,6 +186,13 @@
 
 drivers-$(CONFIG_FB) += arch/x86/video/
 
+ifeq ($(CONFIG_BUFFALO_PLATFORM),y)
+drivers-$(CONFIG_BUFFALO_PLATFORM) += arch/x86/buffalo/
+drivers-$(CONFIG_BUFFALO_MATSU_PLATFORM) += arch/x86/plat-matsu/
+drivers-$(CONFIG_BUFFALO_KIRI_PLATFORM) += arch/x86/plat-kiri/
+drivers-$(CONFIG_BUFFALO_USI_PLATFORM) += arch/x86/plat-usi/
+endif
+
 ####
 # boot loader support. Several targets are kept for legacy purposes
 
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/bz_ctrl.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/bz_ctrl.c
--- linux-3.10.69/arch/x86/plat-kiri/bz_ctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/bz_ctrl.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,401 @@
+/*
+ *	-----------------------------
+ *	Author : Gary Chen
+ *	Date   : 2012/06/12
+ *	-----------------------------
+ *	Original Author : Simon Chang
+ */
+
+#include <asm/io.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <asm/delay.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/cdev.h>
+#include <linux/timer.h>
+#include <asm/param.h>
+
+
+//#define DEVNO			127			//device number
+#define kiri_bz_major	127
+#define kiri_bz_minor	0
+#define dev_count 		1
+#define	DEVNAME			"kiri_bz"	//device name
+
+#define TIMER_PORT		0x43
+#define COUNT_PORT		0x42
+#define SPK_PORT			0x61
+#define SYS_OCS_TICK	1193182
+
+#define TIMER_DELAY		HZ
+
+#define BZ_PATTERN_CONTINUOUS	0
+#define BZ_PATTERN_ON_OFF			1
+#define BZ_OPERATION_OFF			0
+#define BZ_OPERATION_ON				1
+
+#define IOCTL_GET_BZ_OPERATION	0
+#define IOCTL_SET_BZ_OPERATION	1
+#define IOCTL_GET_BZ_PATTERN		6
+#define IOCTL_SET_BZ_PATTERN		3
+#define IOCTL_GET_BZ_FREQ				4
+#define IOCTL_SET_BZ_FREQ				7
+
+//int bz_major = DEVNO;
+//char *bz_devname = DEVNAME;
+
+extern struct class *kiri_cls;
+struct device *bz_dev;
+dev_t	kirit_bz;
+unsigned int bz_freq = 262;		// default frequency is "Do"
+int bz_pattern = BZ_PATTERN_CONTINUOUS;
+int bz_operation = BZ_OPERATION_OFF;
+static struct timer_list bz_timer;
+
+
+
+/*******************************************************************************
+* function: timer_function
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static void timer_function(unsigned long data)
+{
+	if (data == BZ_OPERATION_ON) {
+		outb(inb(SPK_PORT) & 0xfc, SPK_PORT);				// turn off buzzer
+		bz_timer.data = BZ_OPERATION_OFF;
+	}
+	else {
+		outb(inb(SPK_PORT) | 3, SPK_PORT);				// turn on buzzer
+		bz_timer.data = BZ_OPERATION_ON;
+	}
+	mod_timer(&bz_timer, jiffies + TIMER_DELAY);
+}
+
+/*******************************************************************************
+* function: bz_ioctl
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+int bz_ioctl(struct file *file,unsigned int cmd, unsigned long para)
+{
+	int ret = 0;
+	int temp_pattern;
+
+	switch (cmd) {
+		case IOCTL_GET_BZ_OPERATION:
+			ret = bz_operation;
+			if (bz_operation) printk("on\n");
+			else printk("off\n");
+		break;
+
+		case IOCTL_SET_BZ_OPERATION:
+			if(para == BZ_OPERATION_ON) {
+				if (bz_operation == BZ_OPERATION_ON) return 0;
+				bz_operation = BZ_OPERATION_ON;
+			}
+			else if(para == BZ_OPERATION_OFF) {
+				if (bz_operation == BZ_OPERATION_OFF) return 0;
+				bz_operation = BZ_OPERATION_OFF;
+			}
+			else
+				goto IOCTL_WRONG_CMD;
+
+			if (bz_operation) {		// turn on
+				if (bz_pattern) {
+ 					init_timer(&bz_timer);
+					bz_timer.expires = jiffies + TIMER_DELAY;
+					bz_timer.data = BZ_OPERATION_ON;
+					bz_timer.function = timer_function;
+					add_timer(&bz_timer);
+				}
+				outb(inb(SPK_PORT) | 3, SPK_PORT);				// turn on buzzer
+			}
+			else {		// turn off
+				if (bz_pattern) del_timer(&bz_timer);
+				outb(inb(SPK_PORT) & 0xfc, SPK_PORT);				// turn off buzzer
+			}
+		break;
+
+		case IOCTL_GET_BZ_PATTERN:
+			ret = bz_pattern;
+			printk("  ret=%d\n", bz_pattern);
+			if (bz_pattern) printk("on-off\n");
+			else printk("continuous\n");
+		break;
+
+		case IOCTL_SET_BZ_PATTERN:
+			if(para == BZ_PATTERN_ON_OFF)
+				temp_pattern = BZ_PATTERN_ON_OFF;
+			else if(para == BZ_PATTERN_CONTINUOUS)
+				temp_pattern = BZ_PATTERN_CONTINUOUS;
+			else goto IOCTL_WRONG_CMD;
+
+			if (temp_pattern == bz_pattern) return 0;
+
+			if (bz_operation == BZ_OPERATION_ON) {
+				if (temp_pattern == BZ_PATTERN_ON_OFF) {
+ 					init_timer(&bz_timer);
+					bz_timer.expires = jiffies + TIMER_DELAY;
+					bz_timer.data = BZ_OPERATION_ON;
+					bz_timer.function = timer_function;
+					add_timer(&bz_timer);
+				}
+				else {
+					del_timer(&bz_timer);
+				}
+				outb(inb(SPK_PORT) | 3, SPK_PORT);				// turn on buzzer
+			}
+			bz_pattern = temp_pattern;
+		break;
+
+		case IOCTL_GET_BZ_FREQ:
+			ret = bz_freq;
+			printk("%d\n", bz_freq);
+		break;
+
+		case IOCTL_SET_BZ_FREQ:
+			bz_freq = (unsigned int)para;
+			if (bz_freq == 0) goto IOCTL_WRONG_CMD;
+			outb(0xb6, TIMER_PORT);
+			outb((unsigned char)(SYS_OCS_TICK/bz_freq), COUNT_PORT);			/* write LSB */
+			outb((unsigned char)((SYS_OCS_TICK/bz_freq) >> 8), COUNT_PORT);		/* write MSB */
+		break;
+
+		default:
+			goto IOCTL_WRONG_CMD;
+		break;
+	}
+	return ret;
+
+IOCTL_WRONG_CMD:
+	printk("wrong command\n");
+	return ret;
+}
+
+/*
+struct file_operations bz_fops = {
+	open: bz_open,
+	unlocked_ioctl: bz_ioctl,
+	release: bz_close,
+	owner: THIS_MODULE,
+};
+*/
+
+/*******************************************************************************
+* function: KiriClassGet
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static struct class *KiriClassGet(void)
+{
+	struct class *tmp_cls;
+
+	if(kiri_cls)
+		return kiri_cls;
+
+	tmp_cls = class_create(THIS_MODULE, "kiri");
+	if(IS_ERR(tmp_cls)) {
+		printk("%s : class_create failed.", __FUNCTION__);
+		return NULL;
+	}
+
+	kiri_cls = tmp_cls;
+	return kiri_cls;
+}
+
+
+/*******************************************************************************
+* function: show_bz_freq
+* function: store_bz_freq
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_bz_freq(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", bz_freq);
+}
+static ssize_t store_bz_freq(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long temp_freq;
+
+	temp_freq = simple_strtoul(buf, NULL, 10);
+	if (temp_freq == 0) return -EINVAL;
+	bz_freq = (unsigned int)temp_freq;
+	temp_freq = (u16)(SYS_OCS_TICK / bz_freq);
+	outb(0xb6, TIMER_PORT);
+	outb((unsigned char)temp_freq, COUNT_PORT);				/* write LSB */
+	outb((unsigned char)(temp_freq >> 8), COUNT_PORT);		/* write MSB */
+
+	return count;
+}
+DEVICE_ATTR(freq, 0644, show_bz_freq, store_bz_freq);
+
+/*******************************************************************************
+* function: show_bz_pattern
+* function: store_bz_pattern
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_bz_pattern(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (bz_pattern) return sprintf(buf, "on-off\n");
+	else return sprintf(buf, "continuous\n");
+
+}
+static ssize_t store_bz_pattern(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int temp_pattern = -1;
+
+	if((strncmp(buf, "on-off", strlen("on-off")) == 0))
+		temp_pattern = BZ_PATTERN_ON_OFF;
+	else if((strncmp(buf, "continuous", strlen("continuous")) == 0))
+		temp_pattern = BZ_PATTERN_CONTINUOUS;
+
+	if (temp_pattern == bz_pattern) return count;
+
+	if (bz_operation == BZ_OPERATION_ON) {
+		if (temp_pattern == BZ_PATTERN_ON_OFF) {
+ 			init_timer(&bz_timer);
+			bz_timer.expires = jiffies + TIMER_DELAY;
+			bz_timer.data = BZ_OPERATION_ON;
+			bz_timer.function = timer_function;
+			add_timer(&bz_timer);
+		}
+		else {
+			del_timer(&bz_timer);
+		}
+		outb(inb(SPK_PORT) | 3, SPK_PORT);				// turn on buzzer
+	}
+
+	bz_pattern = temp_pattern;
+
+	return count;
+}
+DEVICE_ATTR(pattern, 0644, show_bz_pattern, store_bz_pattern);
+
+/*******************************************************************************
+* function: show_bz_operation
+* function: store_bz_operation
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_bz_operation(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (bz_operation) return sprintf(buf, "on\n");
+	else return sprintf(buf, "off\n");
+
+}
+static ssize_t store_bz_operation(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	if((strncmp(buf, "on", strlen("on")) == 0)) {
+		if (bz_operation == BZ_OPERATION_ON) return count;
+		bz_operation = BZ_OPERATION_ON;
+	}
+	else if((strncmp(buf, "off", strlen("off")) == 0)) {
+		if (bz_operation == BZ_OPERATION_OFF) return count;
+		bz_operation = BZ_OPERATION_OFF;
+	}
+	else
+		return count;
+
+	if (bz_operation) {		// turn on
+		if (bz_pattern) {
+ 			init_timer(&bz_timer);
+			bz_timer.expires = jiffies + TIMER_DELAY;
+			bz_timer.data = BZ_OPERATION_ON;
+			bz_timer.function = timer_function;
+			add_timer(&bz_timer);
+		}
+		outb(inb(SPK_PORT) | 3, SPK_PORT);				// turn on buzzer
+	}
+	else {		// turn off
+		if (bz_pattern) del_timer(&bz_timer);
+		outb(inb(SPK_PORT) & 0xfc, SPK_PORT);				// turn off buzzer
+	}
+
+	return count;
+}
+DEVICE_ATTR(operation, 0644, show_bz_operation, store_bz_operation);
+
+
+
+/*******************************************************************************
+* function: kiri_bz_ctrl_init
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static int __init kiri_bz_ctrl_init(void)
+{
+	int ret;
+	struct class *cls;
+
+	//printk(KERN_ALERT "buzzer control module init...\n");
+
+	/* Register device, and may be allocating major# */
+	kirit_bz = MKDEV(kiri_bz_major, kiri_bz_minor);
+	
+	ret = register_chrdev_region(kirit_bz, dev_count, DEVNAME);
+	if(ret<0){
+		printk("%s cannot register\n", DEVNAME);
+		return (ret);
+	}
+
+	cls = KiriClassGet();
+	if (kiri_cls)
+	{
+		bz_dev = device_create(kiri_cls, NULL, kirit_bz, NULL, "bz");
+		ret = device_create_file(bz_dev, &dev_attr_freq);
+		ret = device_create_file(bz_dev, &dev_attr_pattern);
+		ret = device_create_file(bz_dev, &dev_attr_operation);
+	}
+
+	// set default frequency
+	outb(0xb6, TIMER_PORT);
+	outb((unsigned char)(SYS_OCS_TICK/bz_freq), COUNT_PORT);			/* write LSB */
+	outb((unsigned char)((SYS_OCS_TICK/bz_freq) >> 8), COUNT_PORT);		/* write MSB */
+	
+	printk("bz_ctrl module has been initialized.\n");
+
+	return 0;
+}
+
+/*******************************************************************************
+* function: kiri_bz_ctrl_exit_cleanup
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static void __exit kiri_bz_ctrl_exit_cleanup(void)
+{
+	//int ret;
+
+	//printk(KERN_ALERT "buzzer control module exit...\n");
+
+	outb(inb(SPK_PORT) & 0xfc, SPK_PORT);				// turn off buzzer
+
+	device_remove_file(bz_dev, &dev_attr_freq);
+	device_remove_file(bz_dev, &dev_attr_pattern);
+	device_remove_file(bz_dev, &dev_attr_operation);
+	device_destroy(kiri_cls, kirit_bz);
+	/* class_destroy(kiri_cls); */
+	//unregister_chrdev(bz_major, bz_devname);
+	unregister_chrdev_region(kirit_bz, dev_count);
+	printk("bz_ctrl module has been removed.\n");
+}
+
+module_init(kiri_bz_ctrl_init);
+module_exit(kiri_bz_ctrl_exit_cleanup);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/hdd_ctrl.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/hdd_ctrl.c
--- linux-3.10.69/arch/x86/plat-kiri/hdd_ctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/hdd_ctrl.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,1216 @@
+/*
+ *	-----------------------------
+ *	Author : Gary Chen
+ *	Date   : 2012/06/18
+ *	-----------------------------
+ *	Original Author : Simon Chang
+ */
+
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/timer.h>
+#include <asm/uaccess.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/workqueue.h>
+
+
+#define HDD_CTRL_MODULE_VERSION "0.3"
+#define HDD_CTRL_MODULE_NAME "hdd control module"
+
+
+#define MAX_SUPPORTED_DISKS	12
+
+/* Define for procfs directory and file */
+#if defined(CONFIG_BUFFALO_PLATFORM)
+	#include <buffalo/kernevnt.h>
+	#define MODULE_DIR		"buffalo"
+	#define MODULE_GPIO_DIR		MODULE_DIR"/gpio"
+	#define HDD_PRESENT_DIR		MODULE_GPIO_DIR"/hotplug"
+	#define HDD_POWER_DIR		MODULE_GPIO_DIR"/power_control"
+#else
+	#define MODULE_DIR		"kiri"
+	#define MODULE_GPIO_DIR		"kiri/gpio"
+	#define HDD_PRESENT_DIR		"kiri/gpio/hotplug"
+	#define HDD_POWER_DIR		"kiri/gpio/power_control"
+#endif
+
+/* Define for PCA9505 GPIO expander */
+#define GPI_PORT0		0x00
+#define GPI_PORT1		0x01
+#define GPI_PORT2		0x02
+#define GPI_PORT3		0x03
+#define GPI_PORT4		0x04
+
+#define GPO_PORT0		0x08
+#define GPO_PORT1		0x09
+#define GPO_PORT2		0x0a
+#define GPO_PORT3   0x0b
+#define GPO_PORT4   0x0c
+
+/* Define for LED Command */
+#define LED_CMD_ERR		0
+#define LED_CMD_ON		1
+#define LED_CMD_OFF		2
+#define LED_CMD_BLINK	3
+
+#define HDD_PRESENT0_BIT	(1 << 0)
+#define HDD_PRESENT1_BIT	(1 << 1)
+#define HDD_PRESENT2_BIT	(1 << 2)
+#define HDD_PRESENT3_BIT	(1 << 3)
+#define HDD_PRESENT4_BIT	(1 << 4)
+#define HDD_PRESENT5_BIT	(1 << 5)
+#define HDD_PRESENT6_BIT	(1 << 6)
+#define HDD_PRESENT7_BIT	(1 << 7)
+#define HDD_PRESENT8_BIT	(1 << 0)
+#define HDD_PRESENT9_BIT	(1 << 1)
+#define HDD_PRESENT10_BIT	(1 << 2)
+#define HDD_PRESENT11_BIT	(1 << 3)
+
+#define HDD_PRESENT0_MASK	(~HDD_PRESENT0_BIT)
+#define HDD_PRESENT1_MASK	(~HDD_PRESENT1_BIT)
+#define HDD_PRESENT2_MASK	(~HDD_PRESENT2_BIT)
+#define HDD_PRESENT3_MASK	(~HDD_PRESENT3_BIT)
+#define HDD_PRESENT4_MASK	(~HDD_PRESENT4_BIT)
+#define HDD_PRESENT5_MASK	(~HDD_PRESENT5_BIT)
+#define HDD_PRESENT6_MASK	(~HDD_PRESENT6_BIT)
+#define HDD_PRESENT7_MASK	(~HDD_PRESENT7_BIT)
+#define HDD_PRESENT8_MASK	(~HDD_PRESENT8_BIT)
+#define HDD_PRESENT9_MASK	(~HDD_PRESENT9_BIT)
+#define HDD_PRESENT10_MASK	(~HDD_PRESENT10_BIT)
+#define HDD_PRESENT11_MASK	(~HDD_PRESENT11_BIT)
+
+#define HDD_POWER0_BIT		(1 << 4)
+#define HDD_POWER1_BIT		(1 << 5)
+#define HDD_POWER2_BIT		(1 << 6)
+#define HDD_POWER3_BIT		(1 << 7)&0x00ff // add this & to avoid the compiling warning.
+#define HDD_POWER4_BIT		(1 << 0)
+#define HDD_POWER5_BIT		(1 << 1)
+#define HDD_POWER6_BIT		(1 << 2)
+#define HDD_POWER7_BIT		(1 << 3)
+#define HDD_POWER8_BIT		(1 << 4)
+#define HDD_POWER9_BIT		(1 << 5)
+#define HDD_POWER10_BIT		(1 << 6)
+#define HDD_POWER11_BIT		(1 << 7)&0x00ff // add this & to avoid the compiling warning.
+
+#define HDD_POWER0_MASK		(~HDD_POWER0_BIT)
+#define HDD_POWER1_MASK		(~HDD_POWER1_BIT)
+#define HDD_POWER2_MASK		(~HDD_POWER2_BIT)
+#define HDD_POWER3_MASK		(~HDD_POWER3_BIT)
+#define HDD_POWER4_MASK		(~HDD_POWER4_BIT)
+#define HDD_POWER5_MASK		(~HDD_POWER5_BIT)
+#define HDD_POWER6_MASK		(~HDD_POWER6_BIT)
+#define HDD_POWER7_MASK		(~HDD_POWER7_BIT)
+#define HDD_POWER8_MASK		(~HDD_POWER8_BIT)
+#define HDD_POWER9_MASK		(~HDD_POWER9_BIT)
+#define HDD_POWER10_MASK	(~HDD_POWER10_BIT)
+#define HDD_POWER11_MASK	(~HDD_POWER11_BIT)
+
+#define HDD_ERRLED0_BIT		(1 << 0)
+#define HDD_ERRLED1_BIT		(1 << 1)
+#define HDD_ERRLED2_BIT		(1 << 2)
+#define HDD_ERRLED3_BIT		(1 << 3)
+#define HDD_ERRLED4_BIT		(1 << 4)
+#define HDD_ERRLED5_BIT		(1 << 5)
+#define HDD_ERRLED6_BIT		(1 << 6)
+#define HDD_ERRLED7_BIT		(1 << 7)
+#define HDD_ERRLED8_BIT		(1 << 0)
+#define HDD_ERRLED9_BIT		(1 << 1)
+#define HDD_ERRLED10_BIT	(1 << 2)
+#define HDD_ERRLED11_BIT	(1 << 3)
+
+#define HDD_ERRLED0_MASK	(~HDD_ERRLED0_BIT)
+#define HDD_ERRLED1_MASK	(~HDD_ERRLED1_BIT)
+#define HDD_ERRLED2_MASK	(~HDD_ERRLED2_BIT)
+#define HDD_ERRLED3_MASK	(~HDD_ERRLED3_BIT)
+#define HDD_ERRLED4_MASK	(~HDD_ERRLED4_BIT)
+#define HDD_ERRLED5_MASK	(~HDD_ERRLED5_BIT)
+#define HDD_ERRLED6_MASK	(~HDD_ERRLED6_BIT)
+#define HDD_ERRLED7_MASK	(~HDD_ERRLED7_BIT)
+#define HDD_ERRLED8_MASK	(~HDD_ERRLED8_BIT)
+#define HDD_ERRLED9_MASK	(~HDD_ERRLED9_BIT)
+#define HDD_ERRLED10_MASK	(~HDD_ERRLED10_BIT)
+#define HDD_ERRLED11_MASK	(~HDD_ERRLED11_BIT)
+
+struct kiri_hdd_info_st {
+	u8 hdd_gpio_present_port;
+	u8 hdd_present_bit;
+	u8 hdd_gpio_power_port;
+	u8 hdd_power_bit;
+	u8 hdd_power_mask;
+};
+
+static struct kiri_hdd_info_st kiri_hdd_info[] = {
+	{GPI_PORT0,	HDD_PRESENT0_BIT,	GPO_PORT1,	HDD_POWER0_BIT,		HDD_POWER0_MASK},
+	{GPI_PORT0,	HDD_PRESENT1_BIT,	GPO_PORT1,	HDD_POWER1_BIT,		HDD_POWER1_MASK},
+	{GPI_PORT0,	HDD_PRESENT2_BIT,	GPO_PORT1,	HDD_POWER2_BIT,		HDD_POWER2_MASK},
+	{GPI_PORT0,	HDD_PRESENT3_BIT,	GPO_PORT1,	HDD_POWER3_BIT,		HDD_POWER3_MASK},
+	{GPI_PORT0,	HDD_PRESENT4_BIT,	GPO_PORT2,	HDD_POWER4_BIT,		HDD_POWER4_MASK},
+	{GPI_PORT0,	HDD_PRESENT5_BIT,	GPO_PORT2,	HDD_POWER5_BIT,		HDD_POWER5_MASK},
+	{GPI_PORT0,	HDD_PRESENT6_BIT,	GPO_PORT2,	HDD_POWER6_BIT,		HDD_POWER6_MASK},
+	{GPI_PORT0,	HDD_PRESENT7_BIT,	GPO_PORT2,	HDD_POWER7_BIT,		HDD_POWER7_MASK},
+	{GPI_PORT1,	HDD_PRESENT8_BIT,	GPO_PORT2,	HDD_POWER8_BIT,		HDD_POWER8_MASK},
+	{GPI_PORT1,	HDD_PRESENT9_BIT,	GPO_PORT2,	HDD_POWER9_BIT,		HDD_POWER9_MASK},
+	{GPI_PORT1,	HDD_PRESENT10_BIT,	GPO_PORT2,	HDD_POWER10_BIT,	HDD_POWER10_MASK},
+	{GPI_PORT1,	HDD_PRESENT11_BIT,	GPO_PORT2,	HDD_POWER11_BIT,	HDD_POWER11_MASK},
+};
+
+/* Global variables of proc filesystem */
+static struct proc_dir_entry *hdd_power_dir;
+static struct proc_dir_entry *hdd_present_dir;
+
+/* Global variables of sysfs filesystem */
+extern struct class *kiri_cls;
+extern struct device *led_dev;
+extern dev_t kirit_led;
+
+#define kiri_led_major	126
+#define kiri_led_minor	0
+#define dev_count 			1
+#define	DEVNAME					"kiri_led"
+
+
+/* for hotplug */
+
+typedef enum _sata_plug_state {
+	SATA_STAT_UNKNOWN,
+	SATA_STAT_PLUGGED,
+	SATA_STAT_UNPLUGGED,
+}SATA_PLUG_STATE;
+
+struct sata_hotplug_data_st {
+	SATA_PLUG_STATE presentpinstat;
+	SATA_PLUG_STATE prevplugstat;
+	unsigned int loops;
+};
+
+/* for polling timer */
+#define SATA_POL_INTERVAL       HZ*3
+#define SATA_POL_LOOPS          2
+
+#define PLUGGED_EVENT_MSG       "SATA %d plugged"
+#define UNPLUGGED_EVENT_MSG     "SATA %d unplugged"
+
+struct timer_list sata_hotplug_polling_timer;
+struct sata_hotplug_data_st sata_hotplug_data[MAX_SUPPORTED_DISKS];
+
+//static spinlock_t status_lock;
+static struct workqueue_struct *interrupt_work_wq;
+static struct work_struct interrupt_work;
+
+
+#define PCA9505_SLAVE_ADDR	0x20
+
+/* Addresses to scan */
+static const unsigned short hdd_gpio_i2c[] = { PCA9505_SLAVE_ADDR, I2C_CLIENT_END };
+struct i2c_client *kiri_gpio_exp_client;
+struct kiri_hdd_data {
+	struct mutex update_lock;
+	u8 gpio_port_data;
+};
+
+/*******************************************************************************
+* function: read_hdd_present_status
+* argument:
+* retvalue:
+*******************************************************************************/
+static int read_hdd_present_status(struct seq_file *m, void *v)
+{
+	struct kiri_hdd_info_st *hdd_info = (struct kiri_hdd_info_st *)m->private;
+	struct kiri_hdd_data *gpio_data = i2c_get_clientdata(kiri_gpio_exp_client);
+
+	mutex_lock(&gpio_data->update_lock);
+	gpio_data->gpio_port_data = (u8)i2c_smbus_read_byte_data(kiri_gpio_exp_client, hdd_info->hdd_gpio_present_port);
+	mutex_unlock(&gpio_data->update_lock);
+
+	if (gpio_data->gpio_port_data & hdd_info->hdd_present_bit)
+		seq_printf(m, "unplugged\n");
+	else
+		seq_printf(m, "plugged\n");
+
+	return 0;
+}
+
+static int open_hdd_present_status(struct inode *inode, struct file *file)
+{
+	return single_open(file, read_hdd_present_status, PDE_DATA(file_inode(file)));
+}
+
+static struct file_operations hdd_present_fops = {
+	.owner		= THIS_MODULE,
+        .open		= open_hdd_present_status,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release
+};
+
+
+/*******************************************************************************
+* function: read_hdd_power_status
+* argument:
+* retvalue:
+*******************************************************************************/
+static int read_hdd_power_status(struct seq_file *m, void *v)
+{
+	struct kiri_hdd_info_st *hdd_info = (struct kiri_hdd_info_st *)m->private;
+	struct kiri_hdd_data *gpio_data = i2c_get_clientdata(kiri_gpio_exp_client);
+
+	mutex_lock(&gpio_data->update_lock);
+	gpio_data->gpio_port_data = (u8)i2c_smbus_read_byte_data(kiri_gpio_exp_client, hdd_info->hdd_gpio_power_port);
+	mutex_unlock(&gpio_data->update_lock);
+
+	if (gpio_data->gpio_port_data & hdd_info->hdd_power_bit)
+		seq_printf(m, "on\n");
+	else
+		seq_printf(m, "off\n");
+
+	return 0;
+}
+
+/*******************************************************************************
+* function: set_hdd_power
+* argument:
+* retvalue:
+*******************************************************************************/
+static int set_hdd_power(struct file *file, const char *buffer, size_t count, loff_t *offset)
+{
+	struct kiri_hdd_info_st *hdd_info = (struct kiri_hdd_info_st *)PDE_DATA(file_inode(file));
+	struct kiri_hdd_data *gpio_data = i2c_get_clientdata(kiri_gpio_exp_client);
+
+	mutex_lock(&gpio_data->update_lock);
+	gpio_data->gpio_port_data = (u8)i2c_smbus_read_byte_data(kiri_gpio_exp_client, hdd_info->hdd_gpio_power_port);
+	mutex_unlock(&gpio_data->update_lock);
+
+	if (strncmp(buffer, "off", 3) == 0) {
+		if (gpio_data->gpio_port_data & hdd_info->hdd_power_bit) {
+			gpio_data->gpio_port_data &= hdd_info->hdd_power_mask;
+			mutex_lock(&gpio_data->update_lock);
+			i2c_smbus_write_byte_data(kiri_gpio_exp_client, hdd_info->hdd_gpio_power_port, gpio_data->gpio_port_data);
+			mutex_unlock(&gpio_data->update_lock);
+		}
+	}
+	else if (strncmp(buffer, "on", 2) == 0) {
+		if ((gpio_data->gpio_port_data & hdd_info->hdd_power_bit) != hdd_info->hdd_power_bit) {
+			gpio_data->gpio_port_data |= hdd_info->hdd_power_bit;
+			mutex_lock(&gpio_data->update_lock);
+			i2c_smbus_write_byte_data(kiri_gpio_exp_client, hdd_info->hdd_gpio_power_port, gpio_data->gpio_port_data);
+			mutex_unlock(&gpio_data->update_lock);
+		}
+	}
+	else {
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static int open_hdd_power_status(struct inode *inode, struct file *file)
+{
+	return single_open(file, read_hdd_power_status, PDE_DATA(file_inode(file)));
+}
+
+static struct file_operations hdd_power_fops = {
+	.owner		= THIS_MODULE,
+        .open		= open_hdd_power_status,
+	.write		= set_hdd_power,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release
+};
+
+
+/*******************************************************************************
+* function: set_hdd_lederr_on
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+void set_hdd_lederr_on(int hddno)
+{
+	struct kiri_hdd_data *gpio_data = i2c_get_clientdata(kiri_gpio_exp_client);
+	u8 temp = 0x01;
+	u8 port;
+
+	if (hddno < 8) {
+		temp <<= hddno;
+		port = GPO_PORT3;
+	}
+	else if (hddno < 12) {
+		hddno -= 8;
+		temp <<= hddno;
+		port = GPO_PORT4;
+	}
+	else return;
+
+	mutex_lock(&gpio_data->update_lock);
+	gpio_data->gpio_port_data = (u8)i2c_smbus_read_byte_data(kiri_gpio_exp_client, port);
+	gpio_data->gpio_port_data &= ~temp;
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, port, gpio_data->gpio_port_data);
+	mutex_unlock(&gpio_data->update_lock);
+}
+
+/*******************************************************************************
+* function: set_hdd_lederr_off
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+void set_hdd_lederr_off(int hddno)
+{
+	struct kiri_hdd_data *gpio_data = i2c_get_clientdata(kiri_gpio_exp_client);
+	u8 temp = 0x01;
+	u8 port;
+
+	if (hddno < 8) {
+		temp <<= hddno;
+		port = GPO_PORT3;
+	}
+	else if (hddno < 12) {
+		hddno -= 8;
+		temp <<= hddno;
+		port = GPO_PORT4;
+	}
+	else return;
+
+	mutex_lock(&gpio_data->update_lock);
+	gpio_data->gpio_port_data = (u8)i2c_smbus_read_byte_data(kiri_gpio_exp_client, port);
+	gpio_data->gpio_port_data |= temp;
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, port, gpio_data->gpio_port_data);
+	mutex_unlock(&gpio_data->update_lock);
+}
+
+/*******************************************************************************
+* function: get_hdd_lederr_status
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+int get_hdd_lederr_status(int hddno)
+{
+	struct kiri_hdd_data *gpio_data = i2c_get_clientdata(kiri_gpio_exp_client);
+	u8 temp = 0x01;
+	u8 port;
+
+	if (hddno < 8) {
+		temp <<= hddno;
+		port = GPO_PORT3;
+	}
+	else if (hddno < 12) {
+		hddno -= 8;
+		temp <<= hddno;
+		port = GPO_PORT4;
+	}
+	else return -EINVAL;
+
+	mutex_lock(&gpio_data->update_lock);
+	gpio_data->gpio_port_data = (u8)i2c_smbus_read_byte_data(kiri_gpio_exp_client, port);
+	mutex_unlock(&gpio_data->update_lock);
+
+	return (gpio_data->gpio_port_data & temp);
+}
+
+/*******************************************************************************
+* function: check_led_cmd_param
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static int check_led_cmd_param(char *buf, size_t count)
+{
+	if (strncmp(buf, "on", 2) == 0) {
+		if (count == 2) {
+			return LED_CMD_ON;
+		}
+		else if (count == 3) {
+			if (buf[2] == '\n') return LED_CMD_ON;
+			else return LED_CMD_ERR;
+		}
+		else return LED_CMD_ERR;
+	}
+	else if (strncmp(buf, "off", 3) == 0) {
+		if (count == 3) {
+			return LED_CMD_OFF;
+		}
+		else if (count == 4) {
+			if (buf[3] == '\n') return LED_CMD_OFF;
+			else return LED_CMD_ERR;
+		}
+		else return LED_CMD_ERR;
+	}
+	else if (strncmp(buf, "blink", 5) == 0) {
+		if (count == 5) {
+			return LED_CMD_BLINK;
+		}
+		else if (count == 6) {
+			if (buf[5] == '\n') return LED_CMD_BLINK;
+			else return LED_CMD_ERR;
+		}
+		else return LED_CMD_ERR;
+	}
+	else return LED_CMD_ERR;
+
+}
+
+/*******************************************************************************
+* function: show_Lederr0
+* function: store_Lederr0
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr0(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(0))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr0(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(0);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(0);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr0, 0644, show_Lederr0, store_Lederr0);
+
+/*******************************************************************************
+* function: show_Lederr1
+* function: store_Lederr1
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr1(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(1))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr1(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(1);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(1);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr1, 0644, show_Lederr1, store_Lederr1);
+
+/*******************************************************************************
+* function: show_Lederr2
+* function: store_Lederr2
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr2(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(2))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr2(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(2);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(2);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr2, 0644, show_Lederr2, store_Lederr2);
+
+/*******************************************************************************
+* function: show_Lederr3
+* function: store_Lederr3
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr3(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(3))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr3(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(3);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(3);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr3, 0644, show_Lederr3, store_Lederr3);
+
+/*******************************************************************************
+* function: show_Lederr4
+* function: store_Lederr4
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr4(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(4))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr4(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(4);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(4);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr4, 0644, show_Lederr4, store_Lederr4);
+
+/*******************************************************************************
+* function: show_Lederr5
+* function: store_Lederr5
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr5(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(5))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr5(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(5);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(5);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr5, 0644, show_Lederr5, store_Lederr5);
+
+/*******************************************************************************
+* function: show_Lederr6
+* function: store_Lederr6
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr6(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(6))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr6(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(6);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(6);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr6, 0644, show_Lederr6, store_Lederr6);
+
+/*******************************************************************************
+* function: show_Lederr7
+* function: store_Lederr7
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr7(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(7))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr7(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(7);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(7);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr7, 0644, show_Lederr7, store_Lederr7);
+
+/*******************************************************************************
+* function: show_Lederr8
+* function: store_Lederr8
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr8(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(8))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr8(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(8);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(8);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr8, 0644, show_Lederr8, store_Lederr8);
+
+/*******************************************************************************
+* function: show_Lederr9
+* function: store_Lederr9
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr9(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(9))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr9(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(9);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(9);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr9, 0644, show_Lederr9, store_Lederr9);
+
+/*******************************************************************************
+* function: show_Lederr10
+* function: store_Lederr10
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr10(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(10))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr10(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(10);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(10);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr10, 0644, show_Lederr10, store_Lederr10);
+
+/*******************************************************************************
+* function: show_Lederr11
+* function: store_Lederr11
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_Lederr11(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(11))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr11(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(11);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(11);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr11, 0644, show_Lederr11, store_Lederr11);
+
+/*******************************************************************************
+* function: kiri_gpio_exp_detect
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static int kiri_gpio_exp_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	strlcpy(info->type, "kiri_hdd_gpio", I2C_NAME_SIZE);
+
+	return 0;
+}
+
+/*******************************************************************************
+* function: kiri_gpio_exp_probe
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static int kiri_gpio_exp_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct kiri_hdd_data *data;
+	struct kiri_hdd_data *gpio_data;
+	
+	if (!(data = kzalloc(sizeof(struct kiri_hdd_data), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+
+	kiri_gpio_exp_client = client;
+	data->gpio_port_data = 0;
+	i2c_set_clientdata(kiri_gpio_exp_client, data);
+	mutex_init(&data->update_lock);
+
+	// for init PCA9505, because BIOS is not ready.
+	gpio_data = i2c_get_clientdata(kiri_gpio_exp_client);
+	mutex_lock(&gpio_data->update_lock);
+	/* hdd control setting */
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, 0x18, 0xff);
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, 0x19, 0x0f);
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, 0x1a, 0x00);
+	/* interrupt setting of sata hotplug status */
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, 0x20, 0xff);
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, 0x21, 0x0f);
+	/* lederror setting */
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, 0x1b, 0x00);
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, 0x1c, 0x00);
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, 0x0b, 0xff);
+	i2c_smbus_write_byte_data(kiri_gpio_exp_client, 0x0c, 0xff);
+	
+	mutex_unlock(&gpio_data->update_lock);
+
+
+
+	return 0;
+}
+
+/*******************************************************************************
+* function: kiri_gpio_exp_remove
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static int kiri_gpio_exp_remove(struct i2c_client *client)
+{
+	kfree(i2c_get_clientdata(client));
+	return 0;
+}
+
+static const struct i2c_device_id kiri_gpio_exp_id[] = {
+	{ "kiri_hdd_gpio", 0 },
+	{ }
+};
+
+static struct i2c_driver kiri_gpio_exp_driver = {
+	.driver = {
+		.name	= "kiri_hdd_gpio",
+	},
+	.probe		= kiri_gpio_exp_probe,
+	.remove		= kiri_gpio_exp_remove,
+	.id_table	= kiri_gpio_exp_id,
+	.class		= I2C_CLASS_SPD,
+	.detect		= kiri_gpio_exp_detect,
+	.address_list	= hdd_gpio_i2c,
+};
+
+/*******************************************************************************
+* function: KiriClassGet
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static struct class *KiriClassGet(void)
+{
+	struct class *tmp_cls;
+
+	if(kiri_cls)
+		return kiri_cls;
+
+	tmp_cls = class_create(THIS_MODULE, "kiri");
+	if(IS_ERR(tmp_cls)) {
+		printk("%s : class_create failed.", __FUNCTION__);
+		return NULL;
+	}
+
+	kiri_cls = tmp_cls;
+	return kiri_cls;
+}
+
+/*******************************************************************************
+* function: init_proc_files
+* argument:
+* retvalue:
+* description: create procfs for hdd control:
+/ --- proc --- kiri --- gpio -+- hotplug -+- sata0
+                              |           +- sata1
+                              |           +- sata2
+                              |           +- sata3
+                              |           +- sata4
+                              |           +- sata5
+                              |           +- sata6
+                              |           +- sata7
+                              |           +- sata8
+                              |           +- sata9
+                              |           +- sata10
+                              |           +- sata11
+                              |
+                              +- power_control -+- hdd0
+                                                +- hdd1
+                                                +- hdd2
+                                                +- hdd3
+                                                +- hdd4
+                                                +- hdd5
+                                                +- hdd6
+                                                +- hdd7
+                                                +- hdd8
+                                                +- hdd9
+                                                +- hdd10
+                                                +- hdd11
+*******************************************************************************/
+static int init_proc_files(void)
+{
+	int retval = 0;
+	int i = 0;
+	char buf[32];
+
+	/* declare for file and directory of procfs */
+	// add process of create "kiri" directory only, because new kernel do not accept
+	// path name "kiri/gpio".
+	#if !defined(CONFIG_BUFFALO_PLATFORM)
+		static struct proc_dir_entry *hdd_ctrl_dir;
+	#endif
+	static struct proc_dir_entry *hdd_ctrl_gpio_dir;
+	static struct proc_dir_entry *hdd_present_status_file[MAX_SUPPORTED_DISKS];
+	static struct proc_dir_entry *hdd_power_status_file[MAX_SUPPORTED_DISKS];
+
+	//printk("  %s enter...\n", __func__);
+	
+	#if !defined(CONFIG_BUFFALO_PLATFORM)
+		// Create /proc/kiri directory
+		hdd_ctrl_dir = proc_mkdir(MODULE_DIR, NULL);
+		if(hdd_ctrl_dir == NULL) {
+			//printk(KERN_ALERT "/proc/kiri directory create fail.....\n");
+			goto MODULE_DIR_FAIL;
+		}
+	#endif
+	//printk(KERN_ALERT "/proc/kiri directory create successful.....\n");
+
+	// Create /proc/kiri/gpio directory
+	hdd_ctrl_gpio_dir = proc_mkdir(MODULE_GPIO_DIR, NULL);
+	if(hdd_ctrl_gpio_dir == NULL) {
+		//printk(KERN_ALERT "/proc/kiri/gpio directory create fail.....\n");
+		goto MODULE_GPIO_DIR_FAIL;
+	}
+	//printk(KERN_ALERT "/proc/kiri/gpio directory create successful.....\n");
+
+	// Create /proc/kiri/gpio/hotplug directory
+	hdd_present_dir = proc_mkdir(HDD_PRESENT_DIR, NULL);
+	if(hdd_present_dir == NULL) {
+		//printk(KERN_ALERT "hotplug directory create fail.....\n");
+		goto PRESENT_DIR_FAIL;
+	}
+	//printk(KERN_ALERT "hotplug directory create successful.....\n");
+
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		hdd_present_status_file[i] = proc_create_data(buf, 0, hdd_present_dir, &hdd_present_fops, &kiri_hdd_info[i]);
+		if(hdd_present_status_file[i] == NULL)
+		{
+			//printk(KERN_ALERT "HDD%d_PRESENT_STATUS_FILE create fail.....\n", i);
+			goto HDD_PRESENT_STATUS_FILE_FAIL;
+		}
+		//printk(KERN_ALERT "HDD%d_PRESENT_STATUS_FILE create successful.....\n", i);
+	}
+
+	// Create /proc/kiri/gpio/power_control directory
+	hdd_power_dir = proc_mkdir(HDD_POWER_DIR, NULL);
+	if(hdd_power_dir == NULL) {
+		//printk(KERN_ALERT "power_control directory create fail.....\n");
+		goto HDD_POWER_DIR_FAIL;
+	}
+	//printk(KERN_ALERT "power_control directory create successful.....\n");
+
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		hdd_power_status_file[i] = proc_create_data(buf, 0644, hdd_power_dir, &hdd_power_fops, &kiri_hdd_info[i]);
+		if(hdd_power_status_file[i] == NULL)
+		{
+			//printk(KERN_ALERT "HDD%d_POWER_STATUS_FILE create fail.....\n", i);
+			goto HDD_POWER_STATUS_FILE_FAIL;
+		}
+		//printk(KERN_ALERT "HDD%d_POWER_STATUS_FILE create successful.....\n", i);
+	}
+
+	goto INIT_OK;
+
+HDD_POWER_STATUS_FILE_FAIL:
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		remove_proc_entry(buf, hdd_power_dir);
+	}
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+
+HDD_POWER_DIR_FAIL:
+HDD_PRESENT_STATUS_FILE_FAIL:
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		remove_proc_entry(buf, hdd_present_dir);
+	}
+
+	remove_proc_entry(HDD_PRESENT_DIR, NULL);
+
+PRESENT_DIR_FAIL:
+	remove_proc_entry(MODULE_DIR, NULL);
+
+MODULE_GPIO_DIR_FAIL:
+	remove_proc_entry(MODULE_GPIO_DIR, NULL);
+
+#if !defined(CONFIG_BUFFALO_PLATFORM)
+	MODULE_DIR_FAIL:
+		retval = -ENOMEM;
+#endif
+
+INIT_OK:
+	return retval;
+}
+
+/* -------------------------------------polling of hotplug status------------------------------------- */
+
+static void SataHotplugPollingUpdatePinstat(void)
+{
+	struct kiri_hdd_data *gpio_data = i2c_get_clientdata(kiri_gpio_exp_client);
+	unsigned int i = 0;
+	
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		mutex_lock(&gpio_data->update_lock);
+		sata_hotplug_data[i].presentpinstat = (i2c_smbus_read_byte_data(kiri_gpio_exp_client,kiri_hdd_info[i].hdd_gpio_present_port) & kiri_hdd_info[i].hdd_present_bit)? SATA_STAT_UNPLUGGED:SATA_STAT_PLUGGED;
+		mutex_unlock(&gpio_data->update_lock);
+	}
+
+}
+
+static void SataHotplugPolling(unsigned long data)
+{
+	//printk("%s : entered\n", __FUNCTION__);
+	unsigned int i = 0;
+	char buf[100] = { 0 };
+	int ret;
+
+	//Get hotplug status from i2c
+	//spin_lock(&status_lock);
+	ret = queue_work(interrupt_work_wq, &interrupt_work);
+	//spin_unlock(&status_lock);
+	
+	
+
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		//printk("sata_hotplug_data[%d].prevplugstat=%d : sata_hotplug_data[%d].presentpinstat=%d\n", i, sata_hotplug_data[i].prevplugstat, i, sata_hotplug_data[i].presentpinstat);
+		if(sata_hotplug_data[i].prevplugstat == sata_hotplug_data[i].presentpinstat)
+		{
+			sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+			continue;
+		}
+		--sata_hotplug_data[i].loops;
+		//printk("sata_hotplug_data[%d].loops=%d\n", i, sata_hotplug_data[i].loops);
+
+		if(sata_hotplug_data[i].loops == 0)
+		{
+			if(sata_hotplug_data[i].presentpinstat == SATA_STAT_PLUGGED){
+				snprintf(buf, sizeof(buf), PLUGGED_EVENT_MSG, i);
+				printk("%s\n", buf);
+			}
+			else{
+				snprintf(buf, sizeof(buf), UNPLUGGED_EVENT_MSG, i);
+				printk("%s\n", buf);
+			}
+
+			#if defined(CONFIG_BUFFALO_PLATFORM)
+				buffalo_kernevnt_queuein(buf);
+			#endif
+			
+			sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+			sata_hotplug_data[i].prevplugstat = sata_hotplug_data[i].presentpinstat;
+		}
+	}
+	sata_hotplug_polling_timer.expires += SATA_POL_INTERVAL;
+	add_timer(&sata_hotplug_polling_timer);
+}
+
+static unsigned long SataHotplugPollingStart(void)
+{
+	unsigned int i = 0;
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sata_hotplug_data[i].prevplugstat = SATA_STAT_UNKNOWN;
+		sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+	}
+
+        init_timer(&sata_hotplug_polling_timer);
+        sata_hotplug_polling_timer.expires = jiffies + SATA_POL_INTERVAL;
+        sata_hotplug_polling_timer.function = SataHotplugPolling;
+        sata_hotplug_polling_timer.data = (unsigned long) NULL;
+        add_timer(&sata_hotplug_polling_timer);
+
+        return 0;
+}
+
+/*******************************************************************************
+* function: hdd_ctrl_init
+* argument:
+* retvalue:
+*******************************************************************************/
+static int __init hdd_ctrl_init(void)
+{
+	//int ret;
+	int rv = 0;
+	struct class *cls;
+	
+	//printk(KERN_ALERT "[%s init proc]\n", HDD_CTRL_MODULE_NAME);
+
+	if (i2c_add_driver(&kiri_gpio_exp_driver)) return -ENODEV;
+
+	/* create files within proc filesystem */
+	if (init_proc_files()) return -ENOMEM;
+
+	/* create files within sysfs filesystem */
+	cls = KiriClassGet();
+	if(kiri_cls){
+		if(led_dev == NULL){
+			led_dev = device_create(kiri_cls, NULL, kirit_led, NULL, "led");
+		}
+
+		rv = device_create_file(led_dev, &dev_attr_Lederr0);
+		rv = device_create_file(led_dev, &dev_attr_Lederr1);
+		rv = device_create_file(led_dev, &dev_attr_Lederr2);
+		rv = device_create_file(led_dev, &dev_attr_Lederr3);
+		rv = device_create_file(led_dev, &dev_attr_Lederr4);
+		rv = device_create_file(led_dev, &dev_attr_Lederr5);
+		rv = device_create_file(led_dev, &dev_attr_Lederr6);
+		rv = device_create_file(led_dev, &dev_attr_Lederr7);
+		rv = device_create_file(led_dev, &dev_attr_Lederr8);
+		rv = device_create_file(led_dev, &dev_attr_Lederr9);
+		rv = device_create_file(led_dev, &dev_attr_Lederr10);
+		rv = device_create_file(led_dev, &dev_attr_Lederr11);
+
+	}
+	
+	//spin_lock_init(&status_lock);	
+	interrupt_work_wq = create_singlethread_workqueue("interrupt_queue");
+	if(interrupt_work_wq){
+  	INIT_WORK(&interrupt_work, (void *)SataHotplugPollingUpdatePinstat);
+  	SataHotplugPollingStart();
+  	
+  	//printk(KERN_INFO "%s %s initialized...\n",HDD_CTRL_MODULE_NAME, HDD_CTRL_MODULE_VERSION);
+  	printk("hdd_ctrl module has been initialized.\n");
+  	return 0;
+	}
+	return -1;
+}
+/*******************************************************************************
+* function: hdd_ctrl_exit
+* argument:
+* retvalue:
+*******************************************************************************/
+static void __exit hdd_ctrl_exit(void)
+{
+	int i = 0;
+	char buf[32];
+
+	flush_workqueue(interrupt_work_wq);
+	destroy_workqueue(interrupt_work_wq);
+	del_timer(&sata_hotplug_polling_timer);
+	
+	device_remove_file(led_dev, &dev_attr_Lederr0);
+	device_remove_file(led_dev, &dev_attr_Lederr1);
+	device_remove_file(led_dev, &dev_attr_Lederr2);
+	device_remove_file(led_dev, &dev_attr_Lederr3);
+	device_remove_file(led_dev, &dev_attr_Lederr4);
+	device_remove_file(led_dev, &dev_attr_Lederr5);
+	device_remove_file(led_dev, &dev_attr_Lederr6);
+	device_remove_file(led_dev, &dev_attr_Lederr7);
+	device_remove_file(led_dev, &dev_attr_Lederr8);
+	device_remove_file(led_dev, &dev_attr_Lederr9);
+	device_remove_file(led_dev, &dev_attr_Lederr10);
+	device_remove_file(led_dev, &dev_attr_Lederr11);
+	
+	//device_destroy(kiri_cls, MKDEV(hdd_major, 0));
+	//class_destroy(kiri_cls);
+	
+	//printk(KERN_ALERT "[%s exit proc]\n", HDD_CTRL_MODULE_NAME);
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		remove_proc_entry(buf, hdd_power_dir);
+	}
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		remove_proc_entry(buf, hdd_present_dir);
+	}
+	
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+	remove_proc_entry(HDD_PRESENT_DIR, NULL);
+	remove_proc_entry(MODULE_GPIO_DIR, NULL);
+	#if !defined(CONFIG_BUFFALO_PLATFORM)
+ 		remove_proc_entry(MODULE_DIR, NULL);
+	#endif
+	
+	i2c_del_driver(&kiri_gpio_exp_driver);
+	printk("hdd_ctrl module has been removed.\n");
+}
+
+module_init (hdd_ctrl_init);
+module_exit (hdd_ctrl_exit);
+
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/hdd_ctrl_dummy.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/hdd_ctrl_dummy.c
--- linux-3.10.69/arch/x86/plat-kiri/hdd_ctrl_dummy.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/hdd_ctrl_dummy.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,281 @@
+/*
+ * HDD control driver - 0.1
+ * 1. Detect if HDD is presented or not.
+ * 2. Get the power status of HDD.
+ * 3. Set the power status of HDD.
+ *
+ * Author: Simon Chang, USI.
+ *
+ * HDD control driver - 0.2
+ * Extented to support 8 HDD
+ *
+ * Author: Wayne Lai, USI.
+ *
+ * History:
+ * 0.1 Initial version for 4 HDDs.
+ * 0.2 Extented to support 8 HDDs.
+ */
+
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/proc_fs.h>
+#include <linux/timer.h>
+#include <asm/uaccess.h>
+#include "hdd_ctrl_dummy.h"
+#include "buffalo/kernevnt.h"
+
+#define HDD_CTRL_MODULE_VERSION "0.2"
+#define HDD_CTRL_MODULE_NAME "hdd control module"
+
+static unsigned int ich9r_gpio_base_addr;
+
+struct matsu_hdd_info_st {
+	uint32_t HDD_GPIO_PRESENT_REG;
+	uint32_t HDD_PRESENT_BIT;
+	uint32_t HDD_GPIO_POWER_REG;
+	uint32_t HDD_POWER_BIT;
+	uint32_t HDD_POWER_MASK;
+};
+
+static struct matsu_hdd_info_st matsu_hdd_info[] = {
+	{GP_LVL,	HDD0_PRESENT_BIT,	GP_LVL,		HDD0_POWER_BIT,	HDD0_POWER_MASK},
+	{GP_LVL,	HDD1_PRESENT_BIT,	GP_LVL,		HDD1_POWER_BIT,	HDD1_POWER_MASK},
+	{GP_LVL,	HDD2_PRESENT_BIT,	GP_LVL,		HDD2_POWER_BIT,	HDD2_POWER_MASK},
+	{GP_LVL,	HDD3_PRESENT_BIT,	GP_LVL,		HDD3_POWER_BIT,	HDD3_POWER_MASK},
+	{GP_LVL,	HDD4_PRESENT_BIT,	GP_LVL,		HDD4_POWER_BIT,	HDD4_POWER_MASK},
+	{GP_LVL,	HDD5_PRESENT_BIT,	GP_LVL2,	HDD5_POWER_BIT,	HDD5_POWER_MASK},
+	{GP_LVL,	HDD6_PRESENT_BIT,	GP_LVL2,	HDD6_POWER_BIT,	HDD6_POWER_MASK},
+	{GP_LVL,	HDD7_PRESENT_BIT,	GP_LVL2,	HDD7_POWER_BIT,	HDD7_POWER_MASK},
+	{GP_LVL,	HDD8_PRESENT_BIT,	GP_LVL,		HDD8_POWER_BIT, HDD8_POWER_MASK},
+	{GP_LVL,	HDD9_PRESENT_BIT,	GP_LVL,		HDD9_POWER_BIT, HDD9_POWER_MASK},
+	{GP_LVL,	HDD10_PRESENT_BIT,	GP_LVL,		HDD10_POWER_BIT, HDD10_POWER_MASK},
+	{GP_LVL,	HDD11_PRESENT_BIT,	GP_LVL,		HDD11_POWER_BIT, HDD11_POWER_MASK},
+};
+
+static struct proc_dir_entry *hdd_power_dir;
+static struct proc_dir_entry *hdd_present_dir;
+
+struct timer_list sata_hotplug_polling_timer;
+struct sata_hotplug_data_st sata_hotplug_data[MAX_SUPPORTED_DISKS];
+
+/*******************************************************************************
+* function: read_hdd_present_status
+* argument:
+* retvalue:
+*******************************************************************************/
+static int read_hdd_present_status(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+	if (off > 0) {
+		*eof = 1;
+		return 0;
+	}
+
+	len = sprintf(page, "plugged\n");
+
+	*eof = 1;
+	return len;
+}
+
+/*******************************************************************************
+* function: read_hdd_power_status
+* argument:
+* retvalue:
+*******************************************************************************/
+static int read_hdd_power_status(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+
+	if (off > 0) {
+		*eof = 1;
+		return 0;
+	}
+
+	len = sprintf(page, "on\n");
+
+	*eof = 1;
+	return len;
+
+}
+
+/*******************************************************************************
+* function: set_hdd_power
+* argument:
+* retvalue:
+*******************************************************************************/
+static int set_hdd_power(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	return count;
+}
+
+/*******************************************************************************
+* function: init_proc_files
+* argument:
+* retvalue:
+* description: create procfs for hdd control:
+/ --- proc --- buffalo --- gpio -+- hotplug -+- sata0
+                                 |           +- sata1
+                                 |           +- sata2
+                                 |           +- sata3
+                                 |           +- sata4
+                                 |           +- sata5
+                                 |           +- sata6
+                                 |           +- sata7
+                                 |
+                                 +- power_control -+- hdd0
+                                                   +- hdd1
+                                                   +- hdd2
+                                                   +- hdd3
+                                                   +- hdd4
+                                                   +- hdd5
+                                                   +- hdd6
+                                                   +- hdd7
+*******************************************************************************/
+static int init_proc_files(void)
+{
+	int retval = 0;
+	int i = 0;
+	char buf[32];
+
+	/* declare for file and directory of procfs */
+	static struct proc_dir_entry *hdd_ctrl_dir;
+
+	static struct proc_dir_entry *hdd_present_status_file[MAX_SUPPORTED_DISKS];
+	static struct proc_dir_entry *hdd_power_status_file[MAX_SUPPORTED_DISKS];
+
+	// Create /proc/buffalo/gpio directory
+	hdd_ctrl_dir = proc_mkdir(MODULE_DIR, NULL);
+	if(hdd_ctrl_dir == NULL) {
+		printk(KERN_ALERT "buffalo/gpio directory create fail.....\n");
+		goto MODULE_DIR_FAIL;
+	}
+	printk(KERN_ALERT "buffalo/gpio directory create successful.....\n");
+
+	// Create /proc/buffalo/gpio/hotplug directory
+	hdd_present_dir = proc_mkdir(HDD_PRESENT_DIR, NULL);
+	if(hdd_present_dir == NULL) {
+		printk(KERN_ALERT "hotplug directory create fail.....\n");
+		goto PRESENT_DIR_FAIL;
+	}
+	printk(KERN_ALERT "hotplug directory create successful.....\n");
+
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		hdd_present_status_file[i] = create_proc_read_entry(buf, 0, hdd_present_dir, read_hdd_present_status, NULL);
+		if(hdd_present_status_file[i] == NULL)
+		{
+			printk(KERN_ALERT "HDD%d_PRESENT_STATUS_FILE create fail.....\n", i);
+			goto HDD_PRESENT_STATUS_FILE_FAIL;
+		}
+		printk(KERN_ALERT "HDD%d_PRESENT_STATUS_FILE create successful.....\n", i);
+		hdd_present_status_file[i]->data = (void *)&matsu_hdd_info[i];
+	}
+
+	// Create /proc/buffalo/gpio/power_control directory
+	hdd_power_dir = proc_mkdir(HDD_POWER_DIR, NULL);
+	if(hdd_power_dir == NULL) {
+		printk(KERN_ALERT "power_control directory create fail.....\n");
+		goto HDD_POWER_DIR_FAIL;
+	}
+	printk(KERN_ALERT "power_control directory create successful.....\n");
+
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		hdd_power_status_file[i] = create_proc_entry(buf, 0644, hdd_power_dir);
+		if(hdd_power_status_file[i] == NULL)
+		{
+			printk(KERN_ALERT "HDD%d_POWER_STATUS_FILE create fail.....\n", i);
+			goto HDD_POWER_STATUS_FILE_FAIL;
+		}
+		printk(KERN_ALERT "HDD%d_POWER_STATUS_FILE create successful.....\n", i);
+		hdd_power_status_file[i]->read_proc = &read_hdd_power_status;
+		hdd_power_status_file[i]->write_proc = &set_hdd_power;
+		hdd_power_status_file[i]->data = (void *)&matsu_hdd_info[i];
+	}
+
+	goto INIT_OK;
+
+HDD_POWER_STATUS_FILE_FAIL:
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		remove_proc_entry(buf, hdd_power_dir);
+	}
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+
+HDD_POWER_DIR_FAIL:
+HDD_PRESENT_STATUS_FILE_FAIL:
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		remove_proc_entry(buf, hdd_present_dir);
+	}
+
+	remove_proc_entry(HDD_PRESENT_DIR, NULL);
+
+PRESENT_DIR_FAIL:
+	remove_proc_entry(MODULE_DIR, NULL);
+
+MODULE_DIR_FAIL:
+	retval = -ENOMEM;
+
+INIT_OK:
+	return retval;
+}
+
+
+/*******************************************************************************
+* function: hdd_ctrl_init
+* argument:
+* retvalue:
+*******************************************************************************/
+static int __init hdd_ctrl_init(void)
+{
+	printk(KERN_ALERT "[%s init proc]\n", HDD_CTRL_MODULE_NAME);
+
+	/* create files within proc filesystem */
+	if (init_proc_files()) return -ENOMEM;
+
+	/* everything initialized */
+	printk(KERN_INFO "%s %s initialized...\n",HDD_CTRL_MODULE_NAME, HDD_CTRL_MODULE_VERSION);
+	return 0;
+}
+/*******************************************************************************
+* function: hdd_ctrl_exit
+* argument:
+* retvalue:
+*******************************************************************************/
+static void __exit hdd_ctrl_exit(void)
+{
+	printk(KERN_ALERT "[%s exit proc]\n", HDD_CTRL_MODULE_NAME);
+	int i = 0;
+	char buf[32];
+
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		remove_proc_entry(buf, hdd_power_dir);
+	}
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		remove_proc_entry(buf, hdd_present_dir);
+	}
+	remove_proc_entry(HDD_PRESENT_DIR, NULL);
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+	remove_proc_entry(MODULE_DIR, NULL);
+	printk(KERN_ALERT "hdd ctrl exit successfully....\n");
+}
+
+module_init (hdd_ctrl_init);
+module_exit (hdd_ctrl_exit);
+
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/hdd_ctrl_dummy.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/hdd_ctrl_dummy.h
--- linux-3.10.69/arch/x86/plat-kiri/hdd_ctrl_dummy.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/hdd_ctrl_dummy.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,148 @@
+#if defined(_HDD_CTRL_H__)
+#else
+#define _HDD_CTRL_H
+
+/* Define Vendor and product id for ich9r */
+#define INTEL_ICH9R_VENDOR_ID	0x8086
+#define INTEL_ICH9R_DEVICE_ID	0x2916
+
+#define GPIO_BAR_OFFSET		0x48
+#define GPIO_USE_SEL		0x00
+#define GP_IO_SEL		0x04
+#define GP_LVL			0x0c
+#define GP_LVL2			0x38
+#define GPO_BLINK		0x18
+#define GPI_INV			0x2c
+
+/* Define GPIO
+EVT board:
+SATA Hot 0 --> GPIO2
+SATA Hot 1 --> GPIO3
+SATA Hot 2 --> GPIO4
+SATA Hot 3 --> GPIO5
+SATA Hot 4 --> GPIO15
+SATA Hot 5 --> GPIO16
+SATA Hot 6 --> GPIO18
+SATA Hot 7 --> GPIO20
+
+HDD_Power0 --> GPIO17
+HDD_Power1 --> GPIO1
+HDD_Power2 --> GPIO6
+HDD_Power3 --> GPIO7
+HDD_Power4 --> GPIO25
+HDD_Power5 --> GPIO32
+HDD_Power6 --> GPIO33
+HDD_Power7 --> GPIO34
+
+DVT board:
+SATA Hot 0 --> GPIO2
+SATA Hot 1 --> GPIO3
+SATA Hot 2 --> GPIO4
+SATA Hot 3 --> GPIO5
+SATA Hot 4 --> GPIO15
+SATA Hot 5 --> GPIO9
+SATA Hot 6 --> GPIO13
+SATA Hot 7 --> GPIO11
+
+HDD_Power0 --> GPIO17
+HDD_Power1 --> GPIO1
+HDD_Power2 --> GPIO6
+HDD_Power3 --> GPIO7
+HDD_Power4 --> GPIO25
+HDD_Power5 --> GPIO32
+HDD_Power6 --> GPIO33
+HDD_Power7 --> GPIO34
+*/
+/* for EVT and DVT (common) */
+#define HDD0_PRESENT_BIT		0x00000004	/*GPIO2*/
+#define HDD1_PRESENT_BIT		0x00000008	/*GPIO3*/
+#define HDD2_PRESENT_BIT		0x00000010	/*GPIO4*/
+#define HDD3_PRESENT_BIT		0x00000020	/*GPIO5*/
+#define HDD4_PRESENT_BIT		0x00008000	/*GPIO15*/
+#if defined(CONFIG_BUFFALO_MATSU_USE_EVT_BOARD)
+/* for EVT */
+  #define HDD5_PRESENT_BIT		0x00010000	/*GPIO16*/
+  #define HDD6_PRESENT_BIT		0x00040000	/*GPIO18*/
+  #define HDD7_PRESENT_BIT		0x00100000	/*GPIO20*/
+#else
+/* for DVT */
+  #define HDD5_PRESENT_BIT		0x00000200	/*GPIO9*/
+  #define HDD6_PRESENT_BIT		0x00002000	/*GPIO13*/
+  #define HDD7_PRESENT_BIT		0x00000400	/*GPIO10, DVT2 board changed from GPI11 to GPI10*/
+  #define HDD8_PRESENT_BIT		0x00000400	/*dummy*/
+  #define HDD9_PRESENT_BIT		0x00000400	/*dummy*/
+  #define HDD10_PRESENT_BIT		0x00000400	/*dummy*/
+  #define HDD11_PRESENT_BIT		0x00000400	/*dummy*/
+#endif
+
+#define HDD0_POWER_BIT			0x00020000	/*GPIO17*/
+#define HDD1_POWER_BIT			0x00000002	/*GPIO1*/
+#define HDD2_POWER_BIT			0x00000040	/*GPIO6*/
+#define HDD3_POWER_BIT			0x00000080	/*GPIO7*/
+#define HDD4_POWER_BIT			0x02000000	/*GPIO25*/
+#define HDD5_POWER_BIT			0x00000001	/*GPIO32*/
+#define HDD6_POWER_BIT			0x00000002	/*GPIO33*/
+#define HDD7_POWER_BIT			0x00000004	/*GPIO34*/
+#define HDD8_POWER_BIT			0x00000004	/*dummy*/
+#define HDD9_POWER_BIT			0x00000004	/*dummy*/
+#define HDD10_POWER_BIT			0x00000004	/*dummy*/
+#define HDD11_POWER_BIT			0x00000004	/*dummy*/
+
+#define HDD0_PRESENT_MASK		0xfffffffb
+#define HDD1_PRESENT_MASK		0xfffffff7
+#define HDD2_PRESENT_MASK		0xffffffef
+#define HDD3_PRESENT_MASK		0xffffffdf
+#define HDD4_PRESENT_MASK		0xffff7fff
+#if defined(CONFIG_BUFFALO_MATSU_USE_EVT_BOARD)
+/* for EVT */
+  #define HDD5_PRESENT_MASK		0xfffeffff
+  #define HDD6_PRESENT_MASK		0xfffbffff
+  #define HDD7_PRESENT_MASK		0xffefffff
+#else
+/* for DVT */
+  #define HDD5_PRESENT_MASK		0xfffffdff
+  #define HDD6_PRESENT_MASK		0xffffdfff
+  #define HDD7_PRESENT_MASK		0xfffff7ff
+#endif
+  #define HDD8_PRESENT_MASK		0xfffff7ff
+  #define HDD9_PRESENT_MASK		0xfffff7ff
+  #define HDD10_PRESENT_MASK		0xfffff7ff
+  #define HDD11_PRESENT_MASK		0xfffff7ff
+
+#define HDD0_POWER_MASK			0xfffdffff
+#define HDD1_POWER_MASK			0xfffffffd
+#define HDD2_POWER_MASK			0xffffffbf
+#define HDD3_POWER_MASK			0xffffff7f
+#define HDD4_POWER_MASK			0xfdffffff
+#define HDD5_POWER_MASK			0xfffffffe
+#define HDD6_POWER_MASK			0xfffffffd
+#define HDD7_POWER_MASK			0xfffffffb
+#define HDD8_POWER_MASK			0xfffffffb
+#define HDD9_POWER_MASK			0xfffffffb
+#define HDD10_POWER_MASK			0xfffffffb
+#define HDD11_POWER_MASK			0xfffffffb
+
+/* Define for procfs directory and file */
+#define MODULE_DIR			"buffalo/gpio"
+#define HDD_PRESENT_DIR			"buffalo/gpio/hotplug"
+#define HDD_POWER_DIR			"buffalo/gpio/power_control"
+
+#define MAX_SUPPORTED_DISKS	12
+
+///////////////// for hotplug /////////////
+typedef enum _sata_plug_state {
+	SATA_STAT_UNKNOWN,
+	SATA_STAT_PLUGGED,
+	SATA_STAT_UNPLUGGED,
+}SATA_PLUG_STATE;
+
+struct sata_hotplug_data_st {
+	SATA_PLUG_STATE presentpinstat;
+	SATA_PLUG_STATE prevplugstat;
+	unsigned int loops;
+};
+
+
+///////////////// for hotplug /////////////
+#endif  /* _HDD_CTRL_H */
+
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/kiri_cmos.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_cmos.c
--- linux-3.10.69/arch/x86/plat-kiri/kiri_cmos.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_cmos.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,533 @@
+/*
+ *	-----------------------------
+ *	Author : Gary Chen
+ *	Date   : 2012/07/17
+ *	-----------------------------
+ */
+
+#include <asm/io.h>
+#include <linux/fs.h>
+#include <linux/pci.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include "kiri_cmos.h"
+
+
+/* Global variables */
+extern struct class *kiri_cls;
+struct device *cmos_dev;
+dev_t kirit_cmos;
+unsigned int pch_pm_base_addr;
+struct pci_dev *pdev = NULL;
+unsigned short afterg3_en;
+
+/* Device ID offset */
+unsigned char device_id_offset[32] = {0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
+																0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
+																0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
+																0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f};
+																
+/* ASCII string to integer */																
+struct strtoint_st strtoint_info[] = {
+	{0x30, 0x0}, {0x31, 0x1}, {0x32, 0x2}, {0x33, 0x3},
+	{0x34, 0x4}, {0x35, 0x5}, {0x36, 0x6}, {0x37, 0x7},
+	{0x38, 0x8}, {0x39, 0x9}, {0x61, 0xa}, {0x62, 0xb},
+	{0x63, 0xc}, {0x64, 0xd}, {0x65, 0xe}, {0x66, 0xf},
+	{0x41, 0xa}, {0x42, 0xb}, {0x43, 0xc}, {0x44, 0xd},
+	{0x45, 0xe}, {0x46, 0xf},
+};
+
+
+/* ----------------------------------------Wake on lan attribute-------------------------------------- */
+static ssize_t wol_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rv;
+	outb(WOL_OFFSET, CMOS_INDEX_PORT);
+	rv = inb(CMOS_DATA_PORT);
+	
+	if(rv==0){
+		return sprintf(buf, "on\n");
+	}
+	else if(rv==1){
+		return sprintf(buf, "off\n");
+	}
+	return sprintf(buf, "error:%d\n", rv);
+}
+static ssize_t wol_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int len = 0;
+	unsigned char wol_setting_value = 0;
+	unsigned char power_setting_value = 0;
+	
+	outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+	power_setting_value = inb(CMOS_DATA_PORT);
+
+	while(buf[len])
+		len++;
+		
+	if((len != 3) && (len != 4)){
+		printk("WRONG_STRING\n");
+		return count;
+	}
+
+	if((len == 3) && (strncmp(buf, "on", strlen("on")) == 0)){
+		outb(WOL_OFFSET, CMOS_INDEX_PORT);
+		outb(WOL_ENABLE, CMOS_DATA_PORT);
+		
+		wol_setting_value = inb(CMOS_DATA_PORT);
+		
+		if(wol_setting_value == WOL_ENABLE){
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(CMOS_CHANGE_CHECKSUM - wol_setting_value - (power_setting_value << 1) , CMOS_DATA_PORT);
+		}
+		else
+			printk("The written value is wrong\n");
+	}
+	
+	if((len == 4) && (strncmp(buf, "off", strlen("off")) == 0)){
+		outb(WOL_OFFSET, CMOS_INDEX_PORT);
+		outb(WOL_DISABLE, CMOS_DATA_PORT);
+		
+		wol_setting_value = inb(CMOS_DATA_PORT);
+		
+		if(wol_setting_value == WOL_DISABLE){
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(CMOS_CHANGE_CHECKSUM - wol_setting_value - (power_setting_value << 1) , CMOS_DATA_PORT);
+		}
+		else
+			printk("The written value is wrong\n");
+	}
+
+	return count;
+}
+
+DEVICE_ATTR(wol_setting, 0644, wol_show, wol_store);
+
+/* ---------------------------------------AC power loss attribute------------------------------------- */
+static ssize_t acpower_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rv;
+	outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+	rv = inb(CMOS_DATA_PORT);
+	
+	if(rv==0){
+		return sprintf(buf, "off\n");
+	}
+	else if(rv==1){
+		return sprintf(buf, "on\n");
+	}
+	else if(rv==2){
+		return sprintf(buf, "last status\n");
+	}
+	return sprintf(buf, "error:%d", rv);
+}
+static ssize_t acpower_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int len = 0;
+	int ret = 0;
+	unsigned char wol_setting_value = 0;
+	unsigned char power_setting_value = 0;
+	
+	outb(WOL_OFFSET, CMOS_INDEX_PORT);
+	wol_setting_value = inb(CMOS_DATA_PORT);
+
+	while(buf[len])
+		len++;
+		
+	if((len != 3) && (len != 4) && (len != 5)){
+		printk("WRONG_STRING\n");
+		return count;
+	}
+	
+	if((len == 3) && (strncmp(buf, "on", strlen("on")) == 0)){
+		outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+		outb(AC_POWER_LOSS_POWER_ON, CMOS_DATA_PORT);
+		
+		ret = pci_read_config_word(pdev, GEN_PMCON_3, &afterg3_en);
+		afterg3_en &=(~0x0001);
+		ret = pci_write_config_word(pdev, GEN_PMCON_3, afterg3_en);
+		
+		power_setting_value = inb(CMOS_DATA_PORT);
+		if(power_setting_value == AC_POWER_LOSS_POWER_ON){
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(CMOS_CHANGE_CHECKSUM - (power_setting_value << 1) - wol_setting_value , CMOS_DATA_PORT);
+		}
+		else
+			printk("The written value is wrong\n");
+	}
+	
+	if((len == 4) && (strncmp(buf, "off", strlen("off")) == 0)){
+		outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+		outb(AC_POWER_LOSS_POWER_OFF, CMOS_DATA_PORT);
+		
+		ret = pci_read_config_word(pdev, GEN_PMCON_3, &afterg3_en);
+		afterg3_en |= 0x0001;
+		ret = pci_write_config_word(pdev, GEN_PMCON_3, afterg3_en);
+		
+		power_setting_value = inb(CMOS_DATA_PORT);
+		if(power_setting_value == AC_POWER_LOSS_POWER_OFF){
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(CMOS_CHANGE_CHECKSUM - (power_setting_value << 1) - wol_setting_value , CMOS_DATA_PORT);
+		}
+		else
+			printk("The written value is wrong\n");
+	}
+
+	if((len ==5) && (strncmp(buf, "last", strlen("last")) == 0)){
+		outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+		outb(AC_POWER_LOSS_LAST_STATE, CMOS_DATA_PORT);
+		
+		ret = pci_read_config_word(pdev, GEN_PMCON_3, &afterg3_en);
+		afterg3_en &= 0xFFFE;
+		ret = pci_write_config_word(pdev, GEN_PMCON_3, afterg3_en);
+		
+		power_setting_value = inb(CMOS_DATA_PORT);
+		if(power_setting_value == AC_POWER_LOSS_LAST_STATE){
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(CMOS_CHANGE_CHECKSUM - (power_setting_value << 1) - wol_setting_value , CMOS_DATA_PORT);
+		}
+		else
+			printk("The written value is wrong\n");
+	}
+
+	return count;
+}
+
+DEVICE_ATTR(power_setting, 0644, acpower_show, acpower_store);
+
+/* --------------------------------------Device ID value attribute------------------------------------ */
+static ssize_t device_id_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i=0;
+	unsigned int rv[32]; 
+	
+	for(i=0; i<=31; i++){
+		outb(device_id_offset[i], CMOS_INDEX_PORT);
+		rv[i] = inb(CMOS_DATA_PORT);
+	}
+	
+	return sprintf(buf, "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",
+	rv[0], rv[1], rv[2], rv[3], rv[4], rv[5], rv[6], rv[7], 
+	rv[8], rv[9], rv[10], rv[11], rv[12], rv[13], rv[14], rv[15],
+	rv[16], rv[17], rv[18], rv[19], rv[20], rv[21], rv[22], rv[23], 
+	rv[24], rv[25], rv[26], rv[27], rv[28], rv[29], rv[30], rv[31]);
+}
+static ssize_t device_id_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int i;
+	int len = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if(len != 33){
+		printk("Invalid length: %d\n", (len-1));
+		return count;
+	}
+	
+	if(len == 33){
+		for(i = 0; i <= 31; i++){
+			if((buf[i] < 32) || (buf[i] > 126)){
+				printk("Invalid string\n");
+				return count;
+			}
+		}
+	
+		for(i = 0; i <= 31; i++){
+			outb(device_id_offset[i], CMOS_INDEX_PORT);
+			outb(buf[i], CMOS_DATA_PORT);
+		}
+	}
+
+	return count;
+}
+
+DEVICE_ATTR(device_id, 0644, device_id_show, device_id_store);
+
+/* -------------------------------------------Region attribute---------------------------------------- */
+static ssize_t region_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	outb(REGION_OFFSET, CMOS_INDEX_PORT);
+	
+	return sprintf(buf, "%2x\n", inb(CMOS_DATA_PORT));
+}
+static ssize_t region_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int i, j, tmp, len=0;
+	unsigned char region_orig[2];
+	unsigned char success_flag = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if(len != 3){
+		printk("Invalid length: %d\n", (len-1));
+		return count;
+	}
+	
+	else if(len == 3){
+		for(i=0; i<=1; i++) {
+			for(j=0; j<=21; j++) {
+				if(buf[i] == strtoint_info[j].strg){
+					region_orig[i] = strtoint_info[j].inte;
+					success_flag = 1;
+				}
+				else if (j == 21 && success_flag == 0){
+					printk("Invalid string !\n");
+					return count;
+				}
+			}
+			success_flag = 0;
+		}
+	
+	tmp = (region_orig[0] << 4) + region_orig[1];
+	outb(REGION_OFFSET, CMOS_INDEX_PORT);
+	outb(tmp, CMOS_DATA_PORT);
+	}
+	
+	return count;
+}
+
+DEVICE_ATTR(region, 0644, region_show, region_store);
+/* ------------------------------------------Open the device------------------------------------------ */
+/*
+int cmos_open(struct inode *inode_ptr, struct file *fptr)
+{
+	printk("CMOS driver is opened\n");                    
+	return(0);
+}
+*/
+/* -----------------------------------------Close the device------------------------------------------ */
+/*
+int cmos_close(struct inode *inode_ptr, struct file *fptr)
+{
+	printk("CMOS driver is closed\n");
+	return(0);
+}
+*/
+/* -------------------------------IOCTL interface for user to get and set----------------------------- */
+/*
+int cmos_ioctl(struct file *file, unsigned int cmd, unsigned long para)
+{
+	// struct inode * inode, 
+	unsigned int	write_data=0;
+	unsigned char	read_value=0;
+	unsigned int	ret = 0;
+	int temp1, temp2, temp3, temp4;
+
+	switch(cmd)
+	{
+		// Interface to read WOL status in CMOS
+		case GET_WOL:
+			outb(WOL_OFFSET, CMOS_INDEX_PORT);
+			read_value = inb(CMOS_DATA_PORT);
+			printk("Wake on LAN is %x\n",read_value);
+			ret = read_value;
+			break;
+
+		// Interface to write WOL setting in CMOS
+		case SET_WOL:
+			outb(WOL_OFFSET, CMOS_INDEX_PORT);
+			write_data = (unsigned int)para;
+			outb(write_data, CMOS_DATA_PORT);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(CMOS_CHANGE_ENABLE, CMOS_DATA_PORT);
+			printk("set Wake on LAN to %x\n",write_data);
+			break;
+			
+		// Interface to read AC Power Loss status in CMOS
+		case GET_ACPOWER:
+			outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+			read_value = inb(CMOS_DATA_PORT);
+			printk("AC Power Loss is %x\n",read_value);
+			ret = read_value;
+			break;
+
+		// Interface to write AC Power Loss setting in CMOS
+		case SET_ACPOWER:
+			outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+			write_data = (unsigned int)para;
+			outb(write_data, CMOS_DATA_PORT);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(CMOS_CHANGE_ENABLE, CMOS_DATA_PORT);
+			printk("set AC Power Loss to %x\n",write_data);
+			break;
+			
+		// Interface to read PID value in CMOS
+		case GET_PID:
+			outb(PID_OFFSET_1, CMOS_INDEX_PORT);
+			temp1 = inb(CMOS_DATA_PORT);
+			outb(PID_OFFSET_2, CMOS_INDEX_PORT);
+			temp2 = inb(CMOS_DATA_PORT);
+			outb(PID_OFFSET_3, CMOS_INDEX_PORT);
+			temp3 = inb(CMOS_DATA_PORT);
+			outb(PID_OFFSET_4, CMOS_INDEX_PORT);
+			temp4 = inb(CMOS_DATA_PORT);
+			ret = temp4*256*256*256+temp3*256*256+temp2*256+temp1;
+			break;
+
+		// Interface to write PID value in CMOS
+		case SET_PID:
+			write_data = (unsigned int)para;
+			outb(PID_OFFSET_4, CMOS_INDEX_PORT);
+			outb((write_data >> 24)&0x000000FF, CMOS_DATA_PORT);
+			outb(PID_OFFSET_3, CMOS_INDEX_PORT);
+			outb((write_data >> 16)&0x000000FF, CMOS_DATA_PORT);
+			outb(PID_OFFSET_2, CMOS_INDEX_PORT);
+			outb((write_data >> 8)&0x000000FF, CMOS_DATA_PORT);
+			outb(PID_OFFSET_1, CMOS_INDEX_PORT);
+			outb(write_data&0x000000FF, CMOS_DATA_PORT);
+	
+		// Enable to change CMOS setting
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(CMOS_CHANGE_ENABLE, CMOS_DATA_PORT);
+			break;
+			
+		// Interface to read region in CMOS
+		case GET_REGION:
+			outb(REGION_OFFSET, CMOS_INDEX_PORT);
+			read_value = inb(CMOS_DATA_PORT);
+			ret = read_value;
+			printk("ret:%x\n", ret);
+			break;
+
+		// Interface to write region in CMOS
+		case SET_REGION:
+			write_data = (unsigned int)para;
+			outb(REGION_OFFSET, CMOS_INDEX_PORT);
+			outb(write_data, CMOS_DATA_PORT);
+	
+		// Enable to change CMOS setting
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(CMOS_CHANGE_ENABLE, CMOS_DATA_PORT);
+			break;
+
+		default:
+			printk("wrong command\n");
+			break;
+	}		 
+	return ret;
+}
+*/
+
+/* ----------------------------------------Get PCH information---------------------------------------- */
+static int pch_setting(void)
+{
+	int ret;
+	
+	pdev = pci_get_device(INTEL_PCH_C206_VID, INTEL_PCH_C206_DID, NULL);
+	if(!pdev)
+		return -ENODEV;
+	
+	ret = pci_read_config_dword(pdev, PMBASE, &pch_pm_base_addr);
+	if(ret)
+		return -EINVAL;
+		
+	pch_pm_base_addr &= 0x0000FFD0;
+	
+	return 0;
+}
+
+/* ----------------------------------File operations for this device---------------------------------- */
+/*
+struct file_operations cmos_fops = {
+open: cmos_open,
+unlocked_ioctl: cmos_ioctl,
+release: cmos_close,
+owner: THIS_MODULE,
+};
+*/
+
+/* -----------------------------------------Create kiri Class----------------------------------------- */
+static struct class *kiriClassGet(void)
+{
+	struct class *tmp_cls;
+
+	if(kiri_cls)
+		return kiri_cls;
+
+	tmp_cls = class_create(THIS_MODULE, "kiri");
+	if(IS_ERR(tmp_cls))
+	{
+		printk("%s : class_create failed.", __FUNCTION__);
+		return NULL;
+	}
+
+	kiri_cls = tmp_cls;
+	return kiri_cls;
+}
+
+/* ------------------------------------Initialize and exit module------------------------------------- */
+static int __init kiri_cmos_init(void)
+{
+	int ret;
+  struct class *cls;
+	//printk("Enter %s module init\n", DEVNAME);
+
+	kirit_cmos = MKDEV(kiri_cmos_major, kiri_cmos_minor);
+	//ret = register_chrdev(kiri_cmos_major, DEVNAME, &cmos_fops);
+	ret = register_chrdev_region(kirit_cmos, dev_count, DEVNAME);
+	if(ret<0){
+		printk("%s cannot register\n", DEVNAME);
+		return (ret);
+	}	
+	
+	/* Create /sys/class/kiri */
+	cls = kiriClassGet();
+	if(kiri_cls)
+	{
+		int rv = 0;		
+		/* Create /sys/class/kiri/cmos */
+		cmos_dev = device_create(kiri_cls, NULL, kirit_cmos, NULL, "cmos");
+	
+		/* Create /sys/class/kiri/coms/WOL */
+    rv = device_create_file(cmos_dev, &dev_attr_wol_setting);
+	
+		/* Create /sys/class/kiri/cmos/acpower_setting */
+		rv = device_create_file(cmos_dev, &dev_attr_power_setting);
+		
+		/* Create /sys/class/kiri/coms/device_id */
+    rv = device_create_file(cmos_dev, &dev_attr_device_id);
+    
+    /* Create /sys/class/kiri/coms/region */
+    rv = device_create_file(cmos_dev, &dev_attr_region);
+	}
+	
+	pch_setting();
+	
+	printk("kiri_cmos module has been initialized.\n");
+	return 0;
+}
+
+static void __exit kiri_cmos_exit(void)
+{
+	/* Remove /sys/class/kiri/cmos/wol_setting */	
+	device_remove_file(cmos_dev, &dev_attr_wol_setting);
+	
+	/* Remove /sys/class/kiri/cmos/acpower_setting */
+	device_remove_file(cmos_dev, &dev_attr_power_setting);
+	
+	/* Remove /sys/class/kiri/cmos/device_id */
+	device_remove_file(cmos_dev, &dev_attr_device_id);
+	
+	/* Remove /sys/class/kiri/cmos/region */
+	device_remove_file(cmos_dev, &dev_attr_region);
+	
+	/* Remove /sys/class/kiri/cmos */
+	device_destroy(kiri_cls, kirit_cmos);
+
+	/* Remove /sys/class/kiri */
+	//class_destroy(kiri_cls);
+	
+	unregister_chrdev_region(kirit_cmos, dev_count);
+	printk("kiri_cmos module has been removed.\n");
+}
+
+module_init(kiri_cmos_init);
+module_exit(kiri_cmos_exit);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/kiri_cmos.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_cmos.h
--- linux-3.10.69/arch/x86/plat-kiri/kiri_cmos.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_cmos.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,59 @@
+#if !defined __KIRI_CMOS_H__
+#define __KIRI_CMOS_H__
+
+/* IO index */
+#define	CMOS_INDEX_PORT						0x72
+#define	CMOS_DATA_PORT						0x73
+
+/* Wake on lan setting */
+#define WOL_OFFSET								0x70
+#define WOL_ENABLE								0x00
+#define WOL_DISABLE								0x01
+
+/* AC power loss setting */
+#define	AC_POWER_LOSS_OFFSET			0x71
+#define AC_POWER_LOSS_POWER_OFF 	0x00
+#define AC_POWER_LOSS_POWER_ON  	0x01
+#define AC_POWER_LOSS_LAST_STATE	0x02
+
+/* CMOS setting */
+#define CMOS_CHECKSUM_OFFSET			0x73
+#define CMOS_CHANGE_CHECKSUM			0xBF
+
+/* WOL and ACPOWERLOSS registers of ICH10R */
+#define INTEL_PCH_C206_VID				0x8086
+#define INTEL_PCH_C206_DID				0x1C56
+#define PMBASE										0x40
+#define PM1_STS										0x00
+#define PM1_EN										0x02
+#define GEN_PMCON_3								0xA4
+
+/* Buffalo used */
+#define REGION_OFFSET							0x75
+
+// Reserved offset 0x76~0x7C
+
+/* IOCTL interface command */
+#define GET_WOL										0x1
+#define SET_WOL										0x2
+#define GET_ACPOWER							  0x3
+#define SET_ACPOWER								0x4
+#define GET_PID										0x5
+#define SET_PID										0x6
+#define GET_REGION								0x7
+#define SET_REGION								0x8
+
+
+/* Common section */
+#define kiri_cmos_major						124
+#define kiri_cmos_minor						0
+#define dev_count									1
+#define	DEVNAME										"kiri_cmos"
+
+/* ASCII string strcture */
+struct strtoint_st {
+	unsigned char strg;
+	unsigned char inte;
+};
+
+#endif
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/kiri_common.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_common.c
--- linux-3.10.69/arch/x86/plat-kiri/kiri_common.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_common.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,42 @@
+#include <linux/module.h>
+#include <linux/device.h>
+#include "kiri_common.h"
+
+struct class *kiri_cls;
+static unsigned long ref_count = 0;
+
+/*******************************************************************************
+* function: KiriClassGet
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+struct class *KiriClassGet(void)
+{
+        struct class *tmp_cls;
+
+        if(kiri_cls)
+		goto __return_with_pointer;
+
+        tmp_cls = class_create(THIS_MODULE, "kiri");
+        if(IS_ERR(tmp_cls)) {
+                printk("%s : class_create failed.", __FUNCTION__);
+                return NULL;
+        }
+        kiri_cls = tmp_cls;
+
+__return_with_pointer:
+	ref_count++;
+        return kiri_cls;
+}
+
+void KiriClassDestroy(void)
+{
+	if(ref_count == 0)
+		printk("Warn!!! %s is called instead of ref_count == 0\n", __FUNCTION__);
+	else
+		ref_count--;
+
+	if(ref_count == 0)
+		class_destroy(kiri_cls);
+}
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/kiri_common.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_common.h
--- linux-3.10.69/arch/x86/plat-kiri/kiri_common.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_common.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,10 @@
+#if defined(__KIRI_COMMON_H__)
+#else
+#define __KIRI_COMMON_H__
+#include <linux/device.h>
+
+extern struct class *kiri_cls;
+struct class *KiriClassGet(void);
+void KiriClassDestroy(void);
+
+#endif
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/kiri_fan.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_fan.c
--- linux-3.10.69/arch/x86/plat-kiri/kiri_fan.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_fan.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,605 @@
+/*
+ *	-----------------------------
+ *	Author : Gary Chen
+ *	Date   : 2012/06/18
+ *	-----------------------------
+ */
+
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include "kiri_fan.h"
+
+extern struct class *kiri_cls;
+struct device *fan_dev;
+unsigned int EC_BASE_ADDR, IT87_EC_ADDR_REG, IT87_EC_DATA_REG;
+dev_t kirit_fan;
+
+
+/* I2c relative variables */
+static unsigned short normal_i2c[] ={0x00, I2C_CLIENT_END};
+struct i2c_client *kiri_fan_i2c_client;
+static char i2c_temp;
+struct mutex update_lock;
+
+/* define 4 steps of fan speed */
+static unsigned int fan_threshold = 100;
+static unsigned char fan_stop_speed = 0;
+static unsigned char fan_slow_speed = 150;
+static unsigned char fan_fast_speed = 200;
+static unsigned char fan_full_speed = 255;
+
+struct fan_info_st fan_info[] =
+{
+	{IT87_EC_FAN_TACO1, IT87_EC_FAN_TACO1_EXT, IT87_EC_FAN_SMART_PWM1, IT87_EC_FAN_PWM1, 0x1},
+	{IT87_EC_FAN_TACO2, IT87_EC_FAN_TACO2_EXT, IT87_EC_FAN_SMART_PWM2, IT87_EC_FAN_PWM2, 0x2},
+	{IT87_EC_FAN_TACO3, IT87_EC_FAN_TACO3_EXT, IT87_EC_FAN_SMART_PWM3, IT87_EC_FAN_PWM3, 0x4},
+};
+
+struct temp_info_st temp_info[] =
+{
+	{IT87_EC_TMPIN1},
+	{IT87_EC_TMPIN2},
+	{IT87_EC_TMPIN3},
+};
+
+
+/* ----------------------------------------- kiri_fan i2c driver ------------------------------------- */
+static int kiri_fan_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+
+	strlcpy(info->type, "kiri_fan", I2C_NAME_SIZE);
+	
+	return 0;
+}
+
+static int kiri_fan_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	kiri_fan_i2c_client = client;
+	mutex_init(&update_lock);	
+	return 0;
+}
+
+static int kiri_fan_remove(struct i2c_client *client)
+{
+	normal_i2c[0]= 0x00;
+	return 0;
+}
+
+static const struct i2c_device_id kiri_fan_id[] =
+{
+	{ "kiri_fan", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, kiri_fan_id);
+
+static struct i2c_driver kiri_fan_driver =
+{
+		.driver		= {
+			.name 	= "kiri_fan",
+		},
+		.probe		= kiri_fan_probe,
+		.remove		= kiri_fan_remove,
+		.id_table	= kiri_fan_id,
+
+		.class		= I2C_CLASS_HWMON,
+		.detect		= kiri_fan_detect,
+		.address_list	= normal_i2c, 
+};
+
+/* --------------------------------- fan and temp set/get function ----------------------------------- */
+unsigned int set_fan_speed(unsigned char fan_num, unsigned char set_val)
+{
+	unsigned int	write_data;
+	unsigned char	read_value;
+
+	if(fan_info[fan_num].reg_smart_pwm == 0 ||
+		fan_info[fan_num].reg_pwm == 0)
+	{
+		return -EINVAL;
+	}
+
+	outb(IT87_EC_FAN_MAIN_CTL, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value |= fan_info[fan_num].offset;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	write_data = set_val;
+	outb(fan_info[fan_num].reg_smart_pwm, IT87_EC_ADDR_REG);
+	outb(write_data, IT87_EC_DATA_REG);
+
+	outb(fan_info[fan_num].reg_pwm, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value &= 0x7F;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	//DPRINTK("set FAN%d speed %d\n", fan_num + 1, write_data);
+	return 0;
+}
+
+unsigned int get_fan_speed(unsigned char fan_num)
+{
+	unsigned char	read_value;
+
+	outb(IT87_EC_FAN_MAIN_CTL, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value |= fan_info[fan_num].offset;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	outb(fan_info[fan_num].reg_smart_pwm, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+
+	return read_value;
+}
+
+unsigned int get_fan_rpm(unsigned char fan_num)
+{
+	unsigned int	read_value;
+	unsigned int	read_value_ext;
+	unsigned int	ret = 0;
+	
+
+	outb(fan_info[fan_num].reg, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	outb(fan_info[fan_num].reg_ext, IT87_EC_ADDR_REG);
+	read_value_ext = inb(IT87_EC_DATA_REG);
+	ret = 1350000/(read_value_ext*256+read_value)/2;
+
+	if(ret < fan_threshold)
+		ret = 0;
+	return ret;
+}
+
+unsigned int get_temp(unsigned char temp_num)
+{
+	unsigned char	read_value;
+	unsigned int	ret = 0;
+
+	outb(temp_info[temp_num].reg, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	
+	#if !defined(CONFIG_BUFFALO_PLATFORM)
+		printk("TEMP%d is %d\n", temp_num + 1, read_value);
+	#endif
+		
+	ret = read_value;
+	return ret;
+}
+
+char i2c_get_temp(unsigned short addr)
+{
+	i2c_temp = 0;
+	normal_i2c[0] = addr;
+	i2c_add_driver(&kiri_fan_driver);
+	mutex_lock(&update_lock);
+	i2c_temp = i2c_smbus_read_byte_data(kiri_fan_i2c_client, 0x00);
+	mutex_unlock(&update_lock);
+	i2c_del_driver(&kiri_fan_driver);
+	return i2c_temp;
+}
+
+/* ------------------------------------ string and unsigned long converter --------------------------- */
+static unsigned long fan_speed_str_to_ul(const char *buf)
+{
+	if((strncmp(buf, "stop", strlen("stop")) == 0))
+		return fan_stop_speed;
+	else if((strncmp(buf, "slow", strlen("slow")) == 0))
+		return fan_slow_speed;
+	else if((strncmp(buf, "fast", strlen("fast")) == 0))
+		return fan_fast_speed;
+	else if((strncmp(buf, "full", strlen("full")) == 0))
+		return fan_full_speed;
+
+	return simple_strtoul(buf, NULL, 10);
+}
+
+static void fan_speed_ul_to_str(char *buf, size_t len, unsigned long speed)
+{
+	if(speed <= fan_stop_speed)
+		snprintf(buf, len, "stop");
+	else if(speed > fan_stop_speed && speed <= fan_slow_speed)
+		snprintf(buf, len, "slow");
+	else if(speed > fan_slow_speed && speed <= fan_fast_speed)
+		snprintf(buf, len, "fast");
+	else if(speed > fan_fast_speed)
+		snprintf(buf, len, "full");
+	else
+		snprintf(buf, len, "Unknown");
+}
+
+/* ------------------------------------------fan_rpm attribute---------------------------------------- */
+
+static ssize_t show_fan1_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(0));
+}
+
+static ssize_t show_fan2_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(1));
+}
+
+static ssize_t show_fan3_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(2));
+}
+
+DEVICE_ATTR(fan1_rpm, 0444, show_fan1_rpm, NULL);
+DEVICE_ATTR(fan2_rpm, 0444, show_fan2_rpm, NULL);
+DEVICE_ATTR(fan3_rpm, 0444, show_fan3_rpm, NULL);
+/* ------------------------------------------fan_speed attribute---------------------------------------- */
+
+static ssize_t show_fan1_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	char szSpeed[32];
+	
+	fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(0));
+	return sprintf(buf, "%s\n", szSpeed);
+	//return sprintf(buf, "%d\n", get_fan_speed(0));
+}
+static ssize_t store_fan1_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((const char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(0, (unsigned char)(write_val & 0xff));
+	
+	#if !defined(CONFIG_BUFFALO_PLATFORM)
+		printk("Write value is %lx\n", write_val);
+	#endif
+		
+	return count;
+}
+
+static ssize_t show_fan2_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	char szSpeed[32];
+	
+	fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(1));
+	return sprintf(buf, "%s\n", szSpeed);
+}
+static ssize_t store_fan2_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((const char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(1, (unsigned char)(write_val & 0xff));
+	return count;
+}
+
+static ssize_t show_fan3_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	char szSpeed[32];
+	
+	fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(2));
+	return sprintf(buf, "%s\n", szSpeed);
+}
+static ssize_t store_fan3_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((const char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(2, (unsigned char)(write_val & 0xff));
+	return count;
+}
+
+
+DEVICE_ATTR(fan1_speed, 0644, show_fan1_speed, store_fan1_speed);
+DEVICE_ATTR(fan2_speed, 0644, show_fan2_speed, store_fan2_speed);
+DEVICE_ATTR(fan3_speed, 0644, show_fan3_speed, store_fan3_speed);
+
+/* ------------------------------------ set speed pattern attribute ---------------------------------- */
+
+static ssize_t show_fan_stop_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_stop_speed);
+}
+static ssize_t store_fan_stop_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xff)
+		return -EINVAL;
+
+	fan_stop_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_slow_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_slow_speed);
+}
+static ssize_t store_fan_slow_speed(struct device *dev, struct device_attribute *attr,const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xff)
+		return -EINVAL;
+
+	fan_slow_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_fast_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_fast_speed);
+}
+static ssize_t store_fan_fast_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xff)
+		return -EINVAL;
+
+	fan_fast_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_full_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_full_speed);
+}
+static ssize_t store_fan_full_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xff)
+		return -EINVAL;
+
+	fan_full_speed = tmp_speed;
+	return count;
+}
+
+DEVICE_ATTR(fan_stop_speed, 0644, show_fan_stop_speed, store_fan_stop_speed);
+DEVICE_ATTR(fan_slow_speed, 0644, show_fan_slow_speed, store_fan_slow_speed);
+DEVICE_ATTR(fan_fast_speed, 0644, show_fan_fast_speed, store_fan_fast_speed);
+DEVICE_ATTR(fan_full_speed, 0644, show_fan_full_speed, store_fan_full_speed);
+
+/* -------------------------------------------temp_attribute------------------------------------------ */
+
+
+
+static ssize_t temp1_show(struct device *dev, struct device_attribute *attr, char *buf)
+
+{
+	return sprintf(buf, "%d\n", get_temp(0));
+}
+
+static ssize_t temp2_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_temp(1));
+}
+
+static ssize_t temp3_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_temp(2));
+}
+
+static ssize_t temp4_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", i2c_get_temp(0x48));
+}
+
+static ssize_t temp5_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", i2c_get_temp(0x49));
+}
+
+DEVICE_ATTR(temp1, 0444, temp1_show, NULL);
+DEVICE_ATTR(temp2, 0444, temp2_show, NULL);
+DEVICE_ATTR(temp3, 0444, temp3_show, NULL);
+DEVICE_ATTR(temp4, 0444, temp4_show, NULL);
+DEVICE_ATTR(temp5, 0444, temp5_show, NULL);
+
+/* -----------------------------------------Open the device------------------------------------------- */
+/*
+int fan_open(struct inode *inode_ptr, struct file *fptr)
+{
+	printk("Fan driver is opened\n");                    
+	return(0);
+}
+*/
+/* -----------------------------------------Close the device------------------------------------------ */
+/*
+int fan_close(struct inode *inode_ptr, struct file *fptr)
+{
+	printk("Fan driver is closed\n");
+	return(0);
+}
+*/
+/* -----------------------------IOCTL interface for user to get and set------------------------------- */
+/*
+int fan_ioctl(struct file *file,unsigned int cmd, unsigned long para)
+{
+	int	ret = 0;
+	unsigned char dev_id = (unsigned char)(cmd & ~IOCTL_CMD_MASK);
+
+	switch(cmd & IOCTL_CMD_MASK)
+	{
+		case GET_TEMP_CMD_BASE:
+			if(dev_id > 2){ 
+					if(dev_id==3)
+						ret = i2c_get_temp(0x48);
+					if(dev_id==4)
+						ret = i2c_get_temp(0x49);
+			}
+			else
+				ret = get_temp(dev_id);
+			break;
+		
+		case GET_FAN_CMD_BASE:
+			ret = get_fan_rpm(dev_id);
+			break;
+		
+		case SET_FAN_CMD_BASE:
+			set_fan_speed(dev_id, (unsigned char )para);
+			break;
+		
+		default:
+			break;
+	}		 
+	return ret;
+}
+*/
+/* ----------------------------------File operations for this device-----------------------------------*/
+/*
+struct file_operations fan_fops = {
+	open: fan_open,
+	unlocked_ioctl: fan_ioctl,
+	release: fan_close,
+	owner: THIS_MODULE,
+};
+*/
+/* -----------------------------------------Create kiri Class----------------------------------------- */
+struct class *kiriFanClassGet(void)
+{
+	struct class *tmp_cls;
+
+	if(kiri_cls)
+		return kiri_cls;
+
+	tmp_cls = class_create(THIS_MODULE, "kiri");
+	if(IS_ERR(tmp_cls))
+	{
+		printk("%s : class_create failed.", __FUNCTION__);
+		return NULL;
+	}
+
+	kiri_cls = tmp_cls;
+	return kiri_cls;
+}
+
+/* ----------------------------------------ITE8721 MBPnP Config--------------------------------------- */
+
+void EnterMBPnP(void)
+{
+	outb(0x87, CONFIG_ADDR_PORT);
+	outb(0x01, CONFIG_ADDR_PORT);
+	outb(0x55, CONFIG_ADDR_PORT);
+	outb(0x55, CONFIG_ADDR_PORT);
+}
+
+void SetMBPnP(void)
+{
+	unsigned short BASE_ADDR_EXT;
+	unsigned short BASE_ADDR;	
+	outb(IT87_LDN_ADDR, CONFIG_ADDR_PORT);
+	outb(IT87_EC_LDN, CONFIG_DATA_PORT);
+	outb(0x60,CONFIG_ADDR_PORT);
+	BASE_ADDR_EXT = inb(CONFIG_DATA_PORT)*256;
+	outb(0x61,CONFIG_ADDR_PORT);
+	BASE_ADDR = inb(CONFIG_DATA_PORT);
+    	EC_BASE_ADDR = BASE_ADDR_EXT+BASE_ADDR;
+    	IT87_EC_ADDR_REG = EC_BASE_ADDR+0x05;
+    	IT87_EC_DATA_REG = EC_BASE_ADDR+0x06;
+}
+
+void ExitMBPnP(void)
+{
+	outb(0x02, CONFIG_ADDR_PORT);
+	outb(0x02, CONFIG_DATA_PORT);		
+}
+
+/* ------------------------------------Initialize and exit module------------------------------------- */
+
+static int __init kiri_fan_init(void)
+{  	
+	int ret;
+	int rv = 0;
+	struct class *cls;
+	//printk("Enter kiri_fan module init.\n");
+	
+	kirit_fan = MKDEV(kiri_fan_major, kiri_fan_minor);
+		
+	//ret = register_chrdev(kiri_fan_major, DEVNAME, &fan_fops);	
+	ret = register_chrdev_region(kirit_fan, dev_count, DEVNAME);
+	if(ret<0){
+		printk("%s cannot register\n", DEVNAME);
+		return (ret);
+	}
+
+	/* ITE8721 Config */
+	EnterMBPnP();
+	SetMBPnP();
+	ExitMBPnP();
+	
+	/* Create /sys/class/kiri */
+	cls = kiriFanClassGet();
+	if(kiri_cls)
+	{		
+		/* Create /sys/class/kiri/fan */
+		fan_dev = device_create(kiri_cls, NULL, kirit_fan, NULL, "fan");
+
+		/* Create /sys/class/kiri/fan/fan#rpm */
+		rv = device_create_file(fan_dev, &dev_attr_fan1_rpm);
+		rv = device_create_file(fan_dev, &dev_attr_fan2_rpm);
+		rv = device_create_file(fan_dev, &dev_attr_fan3_rpm);
+	
+		/* Create /sys/class/kiri/fan/fan#_speed */
+    rv = device_create_file(fan_dev, &dev_attr_fan1_speed);
+    rv = device_create_file(fan_dev, &dev_attr_fan2_speed);
+    rv = device_create_file(fan_dev, &dev_attr_fan3_speed);
+    
+    /* Create /sys/class/kiri/fan/fan_pattern_speed */
+    rv = device_create_file(fan_dev, &dev_attr_fan_stop_speed);
+    rv = device_create_file(fan_dev, &dev_attr_fan_slow_speed);
+    rv = device_create_file(fan_dev, &dev_attr_fan_fast_speed);
+    rv = device_create_file(fan_dev, &dev_attr_fan_full_speed);
+
+		/* Create /sys/class/kiri/fan/temp# */
+		rv = device_create_file(fan_dev, &dev_attr_temp1);
+		rv = device_create_file(fan_dev, &dev_attr_temp2);
+		rv = device_create_file(fan_dev, &dev_attr_temp3);
+		rv = device_create_file(fan_dev, &dev_attr_temp4);
+		rv = device_create_file(fan_dev, &dev_attr_temp5);
+	}
+		printk("kiri_fan module has been initialized.\n");
+		return 0;
+}
+
+static void __exit kiri_fan_exit(void)
+{
+	/* Remove /sys/class/kiri/fan/fan#_rpm */	
+	device_remove_file(fan_dev, &dev_attr_fan1_rpm);
+	device_remove_file(fan_dev, &dev_attr_fan2_rpm);
+	device_remove_file(fan_dev, &dev_attr_fan3_rpm);
+
+	/* Remove /sys/class/kiri/fan/fan#_speed */	
+	device_remove_file(fan_dev, &dev_attr_fan1_speed);
+	device_remove_file(fan_dev, &dev_attr_fan2_speed);
+	device_remove_file(fan_dev, &dev_attr_fan3_speed);
+	
+	/* Remove /sys/class/kiri/fan/fan_pattern_speed */	
+	device_remove_file(fan_dev, &dev_attr_fan_stop_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_slow_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_fast_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_full_speed);
+	
+	/* Remove /sys/class/kiri/fan/temp# */
+	device_remove_file(fan_dev, &dev_attr_temp1);
+	device_remove_file(fan_dev, &dev_attr_temp2);
+	device_remove_file(fan_dev, &dev_attr_temp3);
+	device_remove_file(fan_dev, &dev_attr_temp4);
+	device_remove_file(fan_dev, &dev_attr_temp5);
+
+	/* Remove /sys/class/kiri/fan */
+	device_destroy(kiri_cls, kirit_fan);
+
+	/* Remove /sys/class/kiri */
+	//class_destroy(kiri_cls);
+
+  unregister_chrdev_region(kirit_fan, dev_count);
+	//unregister_chrdev(kiri_fan_major, DEVNAME);
+	printk("kiri_fan module has been removed.\n");
+}
+
+module_init(kiri_fan_init);
+module_exit(kiri_fan_exit);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/kiri_fan.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_fan.h
--- linux-3.10.69/arch/x86/plat-kiri/kiri_fan.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_fan.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,72 @@
+#if !defined __KIRI_FAN_H__
+#define __KIRI_FAN_H__
+
+/* IT8721 Registers Section */
+#define CONFIG_ADDR_PORT	       	0x2E
+#define CONFIG_DATA_PORT	       	0x2F
+#define IT87_LDN_ADDR		       		0x07
+#define	IT87_EC_LDN								0x04
+
+/* ITE8721 EC Fan Registers */
+#define IT87_EC_FAN_MAIN_CTL	   	0x13
+#define IT87_EC_FAN_CTL		       	0x14
+
+/* ITE8721 EC Fan Tachometer Registers */
+#define IT87_EC_FAN_TACO1	       	0x0E // SYS1
+#define IT87_EC_FAN_TACO2	       	0x0F // SYS2
+#define IT87_EC_FAN_TACO3	       	0x0D // SYS3(CPU)
+/*
+#define IT87_EC_FAN_TACO4	       	0x80
+#define IT87_EC_FAN_TACO5	       	0x82
+*/
+#define IT87_EC_FAN_TACO1_EXT	   	0x19
+#define IT87_EC_FAN_TACO2_EXT	   	0x1A
+#define IT87_EC_FAN_TACO3_EXT	   	0x18
+/*
+#define IT87_EC_FAN_TACO4_EXT	   	0x81
+#define IT87_EC_FAN_TACO5_EXT	   	0x83
+*/
+
+/* Set the type of PWM control function */
+#define IT87_EC_FAN_PWM1					0x16
+#define IT87_EC_FAN_PWM2					0x17
+#define IT87_EC_FAN_PWM3					0x15
+
+/* set the fan speed value */
+#define IT87_EC_FAN_SMART_PWM1		0x6B
+#define IT87_EC_FAN_SMART_PWM2		0x73
+#define IT87_EC_FAN_SMART_PWM3		0x63
+
+/* ITE8721 EC Temprature Registers */
+#define IT87_EC_TMPIN1						0x29 // CPU
+#define IT87_EC_TMPIN2						0x2A // HDDTIN(Q278)
+#define IT87_EC_TMPIN3						0x2B // SYSTIN(Q276)
+
+
+/* Common Section */
+#define kiri_fan_major						125
+#define kiri_fan_minor						0
+#define dev_count           			1
+#define	DEVNAME										"kiri_fan"
+
+struct fan_info_st
+{
+	unsigned char reg;
+	unsigned char reg_ext;
+	unsigned char reg_smart_pwm;
+	unsigned char reg_pwm;
+	unsigned char offset;
+};
+
+struct temp_info_st
+{
+	unsigned char reg;
+};
+
+/* IOCTL interface command */
+#define GET_TEMP_CMD_BASE					0x100
+#define GET_FAN_CMD_BASE					0x200
+#define SET_FAN_CMD_BASE					0x400
+#define IOCTL_CMD_MASK						0xF00
+
+#endif
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/kiri_rpsu.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_rpsu.c
--- linux-3.10.69/arch/x86/plat-kiri/kiri_rpsu.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_rpsu.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,889 @@
+/*
+ *	-----------------------------
+ *	Author : Gary Chen
+ *	Date   : 2012/08/09
+ *	-----------------------------
+ */
+
+#include <asm/io.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+#include "kiri_rpsu.h"
+
+#if defined(CONFIG_BUFFALO_PLATFORM)
+#include <buffalo/kernevnt.h>
+#endif
+
+/* common global variables */
+struct class *kiri_cls = NULL;
+EXPORT_SYMBOL(kiri_cls);
+struct device *kiri_rpsu;
+dev_t kirit_rpsu;
+unsigned int detect_flag[2] = {0,0};
+
+/* I2c relative variables */
+static unsigned short normal_i2c[] ={RPSU_MOD1_ADDR, RPSU_MOD2_ADDR, I2C_CLIENT_END};
+struct i2c_client *kiri_module_mod1;
+struct i2c_client *kiri_module_mod2;
+
+struct kiri_module_data{
+	struct mutex	update_lock;
+	unsigned int	pmbus_data;
+};
+
+
+static unsigned int pch_c206_gpio_base_addr;
+static unsigned int gp_lvl_data;
+spinlock_t status_lock;
+
+/* APIC rgister access port */
+unsigned char *apic_index;
+unsigned char *data;
+unsigned int value;
+
+/* PSU status flag */
+int status = 1;
+
+/* -------------------------------------------set PSU alarm mute-------------------------------------- */
+void set_mute(void)
+{
+	gp_lvl_data = inl(pch_c206_gpio_base_addr+GP_LVL);
+	outl((gp_lvl_data & 0xFFFFFFF7), (pch_c206_gpio_base_addr+GP_LVL));		
+	mdelay(100);
+	outl((gp_lvl_data | 0x00000008), (pch_c206_gpio_base_addr+GP_LVL));
+}
+
+/* --------------------------------------------alarm attribute---------------------------------------- */
+static ssize_t alarm_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{	
+	int len = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if((strncmp(buf, "mute", strlen("mute"))==0) && ((len-1) == 4)) 
+		set_mute();
+
+	return count;
+}
+DEVICE_ATTR(alarm, 0244, NULL, alarm_store);
+
+/* -------------------------------------------status attribute---------------------------------------- */
+static ssize_t status_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(status==1)
+		return sprintf(buf, "fine\n");
+	else if(status==-1)
+		return sprintf(buf, "broken\n");
+	return sprintf(buf, "unknown\n");
+}
+DEVICE_ATTR(status, 0444, status_show, NULL);
+
+
+/* --------------------------------------------PMBUS attribute---------------------------------------- */
+/* --------- kiri_module i2c driver -------- */
+static int kiri_module_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+
+	strlcpy(info->type, "kiri_module", I2C_NAME_SIZE);
+	
+	return 0;
+}
+
+static int kiri_module_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct kiri_module_data *data;
+	
+	data = kzalloc(sizeof(struct kiri_module_data), GFP_KERNEL);
+	if(!data)
+		return -ENOMEM;
+
+	if( (*client).addr == RPSU_MOD1_ADDR){
+		kiri_module_mod1 = client;
+		i2c_set_clientdata(kiri_module_mod1, data);
+		detect_flag[0] = 1;
+	}
+	
+	if( (*client).addr == RPSU_MOD2_ADDR){
+		kiri_module_mod2 = client;
+		i2c_set_clientdata(kiri_module_mod2, data);
+		detect_flag[1] = 1;
+	}
+	
+	mutex_init(&data -> update_lock);
+	
+	return 0;
+}
+
+static int kiri_module_remove(struct i2c_client *client)
+{
+	kfree(i2c_get_clientdata(client));
+	
+	return 0;
+}
+
+static const struct i2c_device_id kiri_module_id[] =
+{
+	{ "kiri_module", 0},
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, kiri_module_id);
+
+static struct i2c_driver kiri_module_driver =
+{
+		.driver		= {
+			.name 	= "kiri_module",
+		},
+		.probe		= kiri_module_probe,
+		.remove		= kiri_module_remove,
+		.id_table	= kiri_module_id,
+		.class		= I2C_CLASS_HWMON,
+		.detect		= kiri_module_detect,
+		.address_list	= normal_i2c, 
+};
+
+/* ------ get RPSU status from PMBUS ----- */
+int pmbus_get_function(int flag, unsigned char command_code)
+{
+	int read_value = 0;
+	int N =0, Y = 0, signN = 0, signY = 0;
+	
+	struct kiri_module_data *pmbus_data;
+	
+	if(flag == 1){
+		pmbus_data = i2c_get_clientdata(kiri_module_mod1);
+		mutex_lock(&pmbus_data->update_lock);
+		read_value = i2c_smbus_read_word_data(kiri_module_mod1, command_code);
+		mutex_unlock(&pmbus_data->update_lock);
+	}
+	
+	if(flag == 2){
+		pmbus_data = i2c_get_clientdata(kiri_module_mod2);
+		mutex_lock(&pmbus_data->update_lock);
+		read_value = i2c_smbus_read_word_data(kiri_module_mod2, command_code);
+		mutex_unlock(&pmbus_data->update_lock);
+	}
+	
+	if(read_value < 0)
+		return -1;
+	
+	if(command_code == 0xB0)
+		read_value &= 0x01;
+	
+	if((command_code == 0x8D) || (command_code == 0x90) || (command_code == 0x91)){
+		signN = (read_value & 0x8000) >> 15;
+		signY = (read_value & 0x0400) >> 10;
+		N = (read_value & 0xF800) >> 11;
+		Y = read_value & 0x07FF;
+		
+		if((signN == 0) && (signY == 0))
+			read_value = Y * (0x1 << N);
+			
+		if((signN == 0) && (signY == 1)){
+			Y = ~(Y - 1);
+			Y &= 0x07FF;
+			read_value = -(Y * (0x1 << N));
+		}
+		
+		if((signN == 1) && (signY == 0)){
+			N = ~(N - 1);
+			N &= 0x001F;
+			read_value = Y / (0x1 << N);
+		}
+		
+		if((signN == 1) && (signY == 1)){
+			N = ~(N - 1);
+			Y = ~(Y - 1);
+			N &= 0x001F;
+			Y &= 0x07FF;
+			read_value = -(Y / (0x1 << N));
+		}		  
+	}
+	return read_value;
+}
+
+/* -------------- modules 1 -------------- */
+static ssize_t show_mod1_vout(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int read_value;
+	int N = 0, Y = 0, signN = 0, signY = 0, rv;
+	int ret = 0;
+	struct kiri_module_data *pmbus_data;
+	
+	if(detect_flag[0] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+		
+	if(detect_flag[0] == 1){
+		pmbus_data = i2c_get_clientdata(kiri_module_mod1);
+		mutex_lock(&pmbus_data->update_lock);
+		read_value = i2c_smbus_read_word_data(kiri_module_mod1, 0x8B);
+		mutex_unlock(&pmbus_data->update_lock);
+	
+		if(read_value < 0)
+			return sprintf(buf, "unknown\n");
+	
+		signN = (read_value & 0x8000) >> 15;
+		signY = (read_value & 0x0400) >> 10;
+		N = (read_value & 0xF800) >> 11;
+		Y = read_value & 0x07FF;
+		
+		if((signN == 0) && (signY == 0)){
+			rv = Y*(0x01 << N);
+			return sprintf(buf, "%d\n", rv);
+		}
+		
+		if((signN == 0) && (signY == 1)){
+			Y = ~(Y - 1);
+			Y &= 0x07FF;
+			rv = -Y*(0x01 << N);
+			return sprintf(buf, "%d\n", rv);
+		}
+			
+		if((signN == 1) && (signY == 0)){
+			N = ~(N - 1);
+			N &= 0x001F;
+			rv = (Y*100)/(0x01 << N);
+			return sprintf(buf, "%d.%02d\n", (rv/100), (rv%100));
+		}
+		
+		if((signN == 1) && (signY == 1)){
+			N = ~(N - 1);
+			N &= 0x001F;
+			Y = ~(Y - 1);
+			Y &= 0x07FF;
+			rv = -(Y*100)/(0x01 << N);
+			return sprintf(buf, "%d.%02d\n", (rv/100), (rv%100));
+		}
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t show_mod1_iout(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int read_value;
+	int N = 0, Y = 0, signN = 0, signY = 0, rv;
+	int ret = 0;
+	struct kiri_module_data *pmbus_data;
+	
+	if(detect_flag[0] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+		
+	if(detect_flag[0] == 1){
+		pmbus_data = i2c_get_clientdata(kiri_module_mod1);
+		mutex_lock(&pmbus_data->update_lock);
+		read_value = i2c_smbus_read_word_data(kiri_module_mod1, 0x8C);
+		mutex_unlock(&pmbus_data->update_lock);
+	
+		if(read_value < 0)
+			return sprintf(buf, "unknown\n");
+	
+		signN = (read_value & 0x8000) >> 15;
+		signY = (read_value & 0x0400) >> 10;
+		N = (read_value & 0xF800) >> 11;
+		Y = read_value & 0x07FF;
+		
+		if((signN == 0) && (signY == 0)){
+			rv = Y*(0x01 << N);
+			return sprintf(buf, "%d\n", rv);
+		}
+		
+		if((signN == 0) && (signY == 1)){
+			Y = ~(Y - 1);
+			Y &= 0x07FF;
+			rv = -Y*(0x01 << N);
+			return sprintf(buf, "%d\n", rv);
+		}
+			
+		if((signN == 1) && (signY == 0)){
+			N = ~(N - 1);
+			N &= 0x001F;
+			rv = (Y*100)/(0x01 << N);
+			return sprintf(buf, "%d.%02d\n", (rv/100), (rv%100));
+		}
+		
+		if((signN == 1) && (signY == 1)){
+			N = ~(N - 1);
+			N &= 0x001F;
+			Y = ~(Y - 1);
+			Y &= 0x07FF;
+			rv = -(Y*100)/(0x01 << N);
+			return sprintf(buf, "%d.%02d\n", (rv/100), (rv%100));
+		}
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t show_mod1_temp(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rv = 0;
+	int ret = 0;
+
+	if(detect_flag[0] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+	
+	if(detect_flag[0] == 1){
+		rv = pmbus_get_function(1, READ_TEMPERATURE1);
+		if(rv == -1)
+			return sprintf(buf, "unknown\n");
+		return sprintf(buf, "%d\n", rv);
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t show_mod1_fan1_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rv = 0;
+	int ret = 0;
+	
+	if(detect_flag[0] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+	
+	if(detect_flag[0] == 1){
+		rv = pmbus_get_function(1, READ_FAN_SPEED1);
+		if(rv == -1)
+			return sprintf(buf, "unknown\n");
+		return sprintf(buf, "%d\n", rv);
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t show_mod1_fan2_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rv = 0;
+	int ret = 0;
+	
+	if(detect_flag[0] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+	
+	if(detect_flag[0] == 1){
+		rv = pmbus_get_function(1, READ_FAN_SPEED2);
+		if(rv == -1)
+			return sprintf(buf, "unknown\n");
+		return sprintf(buf, "%d\n", rv);
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t show_mod1_ac_input(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rv = 0;
+	int ret = 0;
+	
+	if(detect_flag[0] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+	
+	if(detect_flag[0] == 1){
+		rv = pmbus_get_function(1, USER_DATA_00);
+		if(rv == -1)
+			return sprintf(buf, "unknown\n");
+		if(rv == 1)
+			return sprintf(buf,"none\n");
+		else if(rv == 0)
+			return sprintf(buf, "fine\n");
+		return sprintf(buf, "unknown\n");
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+DEVICE_ATTR(mod1_vout, 0444, show_mod1_vout, NULL);
+DEVICE_ATTR(mod1_iout, 0444, show_mod1_iout, NULL);
+DEVICE_ATTR(mod1_temp, 0444, show_mod1_temp, NULL);
+DEVICE_ATTR(mod1_fan1_rpm, 0444, show_mod1_fan1_rpm, NULL);
+DEVICE_ATTR(mod1_fan2_rpm, 0444, show_mod1_fan2_rpm, NULL);
+DEVICE_ATTR(mod1_ac_input, 0444, show_mod1_ac_input, NULL);
+
+/* -------------- modules 2 -------------- */
+static ssize_t show_mod2_vout(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int read_value;
+	int N = 0, Y = 0, signN = 0, signY = 0, rv;
+	int ret = 0;
+	struct kiri_module_data *pmbus_data;
+	
+	if(detect_flag[1] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+	
+	if(detect_flag[1] == 1){
+		pmbus_data = i2c_get_clientdata(kiri_module_mod2);
+		mutex_lock(&pmbus_data->update_lock);
+		read_value = i2c_smbus_read_word_data(kiri_module_mod2, 0x8B);
+		mutex_unlock(&pmbus_data->update_lock);
+	
+		if(read_value < 0)
+			return sprintf(buf, "unknown\n");
+	
+		signN = (read_value & 0x8000) >> 15;
+		signY = (read_value &0x0400) >> 10;
+		N = (read_value & 0xF800) >> 11;
+		Y = read_value & 0x07FF;
+		
+		if((signN == 0) && (signY == 0)){
+			rv = Y*(0x01 << N);
+			return sprintf(buf, "%d\n", rv);
+		}
+		
+		if((signN == 0) && (signY == 1)){
+			Y = ~(Y - 1);
+			Y &= 0x07FF;
+			rv = -Y*(0x01 << N);
+			return sprintf(buf, "%d\n", rv);
+		}
+			
+		if((signN == 1) && (signY == 0)){
+			N = ~(N - 1);
+			N &= 0x001F;
+			rv = (Y*100)/(0x01 << N);
+			return sprintf(buf, "%d.%02d\n", (rv/100), (rv%100));
+		}
+		
+		if((signN == 1) && (signY == 1)){
+			N = ~(N - 1);
+			N &= 0x001F;
+			Y = ~(Y - 1);
+			Y &= 0x07FF;
+			rv = -(Y*100)/(0x01 << N);
+			return sprintf(buf, "%d.%02d\n", (rv/100), (rv%100));
+		}
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t show_mod2_iout(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int read_value;
+	int N = 0, Y = 0, signN = 0, signY = 0, rv;
+	int ret = 0;
+	struct kiri_module_data *pmbus_data;
+	
+	if(detect_flag[1] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+	
+	if(detect_flag[1] == 1){
+		pmbus_data = i2c_get_clientdata(kiri_module_mod2);
+		mutex_lock(&pmbus_data->update_lock);
+		read_value = i2c_smbus_read_word_data(kiri_module_mod2, 0x8C);
+		mutex_unlock(&pmbus_data->update_lock);
+		
+		if(read_value < 0)
+			return sprintf(buf, "unknown\n");
+		
+		signN = (read_value & 0x8000) >> 15;
+		signY = (read_value & 0x0400) >> 10;
+		N = (read_value & 0xF800) >> 11;
+		Y = read_value & 0x07FF;
+		
+		if((signN == 0) && (signY == 0)){
+			rv = Y*(0x01 << N);
+			return sprintf(buf, "%d\n", rv);
+		}
+		
+		if((signN == 0) && (signY == 1)){
+			Y = ~(Y - 1);
+			Y &= 0x07FF;
+			rv = -Y*(0x01 << N);
+			return sprintf(buf, "%d\n", rv);
+		}
+			
+		if((signN == 1) && (signY == 0)){
+			N = ~(N - 1);
+			N &= 0x001F;
+			rv = (Y*100)/(0x01 << N);
+			return sprintf(buf, "%d.%02d\n", (rv/100), (rv%100));
+		}
+		
+		if((signN == 1) && (signY == 1)){
+			N = ~(N - 1);
+			N &= 0x001F;
+			Y = ~(Y - 1);
+			Y &= 0x07FF;
+			rv = -(Y*100)/(0x01 << N);
+			return sprintf(buf, "%d.%02d\n", (rv/100), (rv%100));
+		}
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t show_mod2_temp(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rv = 0;
+	int ret = 0;
+	
+	if(detect_flag[1] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+	
+	if(detect_flag[1] == 1){
+		rv = pmbus_get_function(2, READ_TEMPERATURE1);
+		if(rv == -1)
+			return sprintf(buf, "unknown\n");
+		return sprintf(buf, "%d\n", rv);
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t show_mod2_fan1_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rv = 0;
+	int ret = 0;
+	
+	if(detect_flag[1] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+	
+	if(detect_flag[1] == 1){
+		rv = pmbus_get_function(2, READ_FAN_SPEED1);
+		if(rv == -1)
+			return sprintf(buf, "unknown\n");
+		return sprintf(buf, "%d\n", rv);
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t show_mod2_fan2_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rv = 0;
+	int ret = 0;
+	
+	if(detect_flag[1] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+	
+	if(detect_flag[1] == 1){
+		rv = pmbus_get_function(2, READ_FAN_SPEED2);
+		if(rv == -1)
+			return sprintf(buf, "unknown\n");
+		return sprintf(buf, "%d\n", rv);
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+static ssize_t show_mod2_ac_input(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int rv = 0;
+	int ret = 0;
+	
+	if(detect_flag[1] == 0){
+		i2c_del_driver(&kiri_module_driver);
+		detect_flag[0] = 0;
+		detect_flag[1] = 0;
+		ret = i2c_add_driver(&kiri_module_driver);
+	}
+	
+	if(detect_flag[1] ==1){
+		rv = pmbus_get_function(2, USER_DATA_00);
+		if(rv == -1)
+			return sprintf(buf, "unknown\n");
+		if(rv == 1)
+			return sprintf(buf,"none\n");
+		else if(rv == 0)
+			return sprintf(buf, "fine\n");
+		return sprintf(buf, "unknown\n");
+	}
+	return sprintf(buf, "unknown\n");
+}
+
+DEVICE_ATTR(mod2_vout, 0444, show_mod2_vout, NULL);
+DEVICE_ATTR(mod2_iout, 0444, show_mod2_iout, NULL);
+DEVICE_ATTR(mod2_temp, 0444, show_mod2_temp, NULL);
+DEVICE_ATTR(mod2_fan1_rpm, 0444, show_mod2_fan1_rpm, NULL);
+DEVICE_ATTR(mod2_fan2_rpm, 0444, show_mod2_fan2_rpm, NULL);
+DEVICE_ATTR(mod2_ac_input, 0444, show_mod2_ac_input, NULL);
+
+/* ---------------------------------Kiri rpsu alarm interrupt handler----------------------------------*/
+static irqreturn_t kiri_interrupt(int irq, void *dev_id)
+{
+	unsigned long flags;
+	
+	#if defined(CONFIG_BUFFALO_PLATFORM)
+		char msg[32];
+		memset(msg, 0, sizeof(msg));
+	#endif
+
+	//printk("interrupt service\n");
+	mdelay(100);
+	status = -(status);
+	//printk("status: %d\n",status);
+	spin_lock_init(&status_lock);	
+	spin_lock_irqsave(&status_lock, flags);
+	iowrite8(0x3c, apic_index);
+	
+	if(status==-1){
+		/* mask interrupt */
+		value = ioread32(data);
+		iowrite32((value|0x00010000), data);	
+		
+		/* set as active-high */
+		value = ioread32(data);
+		iowrite32((value&0xFFFFDFFF), data);
+		
+		/* unmask */	
+		value = ioread32(data);
+		iowrite32((value&0xFFFEFFFF), data);
+		
+		#if defined(CONFIG_BUFFALO_PLATFORM)
+			sprintf(msg, "psu_broken");
+		#endif
+		
+		printk("PSU is broken\n");
+	}
+	else if(status==1){
+		/* mask */
+		value = ioread32(data);
+		iowrite32((value|0x00010000), data);
+		
+		/* set as active-low */
+		value = ioread32(data);
+		iowrite32((value|0x00002000), data);
+			
+		/* unmask */
+		value = ioread32(data);
+		iowrite32((value&0xFFFEFFFF), data);
+		
+		#if defined(CONFIG_BUFFALO_PLATFORM)
+			sprintf(msg, "psu_fine");
+		#endif
+		
+		printk("PSU is fine\n");
+	}
+	
+	spin_unlock_irqrestore(&status_lock, flags);
+	
+	#if defined(CONFIG_BUFFALO_PLATFORM)
+		if(msg[0] != '\0')
+		buffalo_kernevnt_queuein(msg);
+	#endif
+	
+	return IRQ_HANDLED;
+}
+
+/* -----------------------------------GPIO and APIC registers setting--------------------------------- */
+static int pch_c206_gpio_apic_setting(void)
+{
+	struct pci_dev *pdev = NULL;
+	int ret;
+	
+	pdev = pci_get_device(INTEL_PCH_C206_VID, INTEL_PCH_C206_DID, NULL);
+	if(!pdev)
+		return -ENODEV;
+	
+	/* get GPIOBASE */
+	ret = pci_read_config_dword(pdev, GPIOBASE, &pch_c206_gpio_base_addr);
+	
+	if(ret){
+		printk("pci_read_config_dword is failed\n");
+		return 0;
+	}
+	
+	pch_c206_gpio_base_addr &= 0x0000FFD0;
+		
+	/* set gpio4 as native function */	
+	outl(inl(pch_c206_gpio_base_addr+GP_USE_SEL)&0xFFFFFFEF, pch_c206_gpio_base_addr+GP_USE_SEL);
+	
+	/* set gpio3 as gpio function */
+	outl(inl(pch_c206_gpio_base_addr+GP_USE_SEL)|0x00000008, pch_c206_gpio_base_addr+GP_USE_SEL);
+
+	/* set gpio3 as output */
+	outl(inl(pch_c206_gpio_base_addr+GP_IO_SEL)&0xFFFFFFF7, pch_c206_gpio_base_addr+GP_IO_SEL);
+	
+	/* APIC indirect register setting */
+	apic_index = ioremap(APIC_index, 1);
+	data = ioremap(APIC_data, 4);
+	
+	/* set interrupt as level triggered */
+	iowrite8(0x3c, apic_index);
+	value = ioread32(data);
+	iowrite32((value|0x00008000), data);
+	
+	/* set active-low */
+	value = ioread32(data);
+	iowrite32((value|0x00002000), data);
+		
+	return 0;
+}
+
+/* -----------------------------------------Create kiri Class----------------------------------------- */
+struct class *kiriClassGet(void)
+{
+	struct class *tmp_cls;
+
+	if(kiri_cls)
+		return kiri_cls;
+
+	tmp_cls = class_create(THIS_MODULE, "kiri");
+	if(IS_ERR(tmp_cls))
+	{
+		printk("%s : class_create failed.", __FUNCTION__);
+		return NULL;
+	}
+
+	kiri_cls = tmp_cls;
+
+	return kiri_cls;
+}
+
+/* ------------------------------------Initialize and exit module------------------------------------- */
+static int __init kiri_rpsu_init(void)
+{  	
+	int ret;
+	struct class *cls;
+	
+	/* use PMBUS to get RPSU status */
+	ret = i2c_add_driver(&kiri_module_driver);
+		
+	if(ret){
+		printk("RPSU modules are error\n");
+		return -ENODEV;
+	}
+		
+	kirit_rpsu = MKDEV(kiri_rpsu_major, kiri_rpsu_minor);
+	
+	ret = register_chrdev_region(kirit_rpsu, dev_count, DEVNAME);
+	if(ret<0){
+		printk("%s cannot register\n", DEVNAME);
+		return (ret);
+	}	
+
+	/* create /sys/class/kiri */
+	cls = kiriClassGet();
+	if(cls){
+		
+		int rv = 0;		
+		/* create /sys/class/kiri/rpsu */
+		kiri_rpsu = device_create(kiri_cls, NULL, kirit_rpsu, NULL, "rpsu");
+		
+		/* create /sys/class/kiri/rpsu/id */
+    rv = device_create_file(kiri_rpsu, &dev_attr_alarm);
+		rv = device_create_file(kiri_rpsu, &dev_attr_status);
+		
+		/* create /sys/class/kiri/rpsu/pmbus nodes */
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod1_vout);
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod1_iout);
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod1_temp);
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod1_fan1_rpm);
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod1_fan2_rpm);
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod1_ac_input);
+		
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod2_vout);
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod2_iout);
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod2_temp);
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod2_fan1_rpm);
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod2_fan2_rpm);
+		rv = device_create_file(kiri_rpsu, &dev_attr_mod2_ac_input);
+	}
+		
+	/* find GPIO base adderss, and set registers relatvie to interrupt */
+	ret = pch_c206_gpio_apic_setting();
+	ret = request_irq(22, kiri_interrupt, IRQF_SHARED, DEVNAME, kiri_interrupt);
+	if(ret){
+  	printk (KERN_ALERT "!!!!! Error requesting irq 3: returned %d\n", ret);
+		free_irq(22, 0);
+    return -EBUSY;
+  }
+	
+	printk("Kiri Linux API Driver Version : %s\n", DRIVER_VERSION);
+	printk("kiri_rpsu module has been initialized.\n");
+
+	return 0;
+}
+
+static void __exit kiri_rpsu_exit(void)
+{
+	/* release IRQ source */
+	disable_irq(22);
+	free_irq(22, kiri_interrupt);
+	
+	/* release remapping memory */
+	iounmap(apic_index);
+	iounmap(data);
+	
+	/* remove /sys/class/kiri/fan/fan# */	
+	device_remove_file(kiri_rpsu, &dev_attr_alarm);
+	device_remove_file(kiri_rpsu, &dev_attr_status);
+	
+	/* release i2c driver */
+	i2c_del_driver(&kiri_module_driver);
+
+		/* remove /sys/class/kiri/rpsu/pmbus nodes */
+	device_remove_file(kiri_rpsu, &dev_attr_mod1_vout);
+	device_remove_file(kiri_rpsu, &dev_attr_mod1_iout);
+	device_remove_file(kiri_rpsu, &dev_attr_mod1_temp);
+	device_remove_file(kiri_rpsu, &dev_attr_mod1_fan1_rpm);
+	device_remove_file(kiri_rpsu, &dev_attr_mod1_fan2_rpm);
+	device_remove_file(kiri_rpsu, &dev_attr_mod1_ac_input);
+	
+	device_remove_file(kiri_rpsu, &dev_attr_mod2_vout);
+	device_remove_file(kiri_rpsu, &dev_attr_mod2_iout);
+	device_remove_file(kiri_rpsu, &dev_attr_mod2_temp);
+	device_remove_file(kiri_rpsu, &dev_attr_mod2_fan1_rpm);
+	device_remove_file(kiri_rpsu, &dev_attr_mod2_fan2_rpm);
+	device_remove_file(kiri_rpsu, &dev_attr_mod2_ac_input);
+	
+	/* remove /sys/class/kiri/rpsu */
+	device_destroy(kiri_cls, kirit_rpsu);
+
+	/* remove /sys/class/kiri */
+	class_destroy(kiri_cls);
+	
+	unregister_chrdev_region(kirit_rpsu, dev_count);
+	
+	printk("kiri_rpsu module has been removed.\n");
+
+}
+
+module_init(kiri_rpsu_init);
+module_exit(kiri_rpsu_exit);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/kiri_rpsu.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_rpsu.h
--- linux-3.10.69/arch/x86/plat-kiri/kiri_rpsu.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/kiri_rpsu.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,46 @@
+#if !defined __KIRI_RPSU_H__
+#define __KIRI_RPSU_H__
+
+/* Define Kiri Linux API Driver Version */
+#define DRIVER_VERSION				"V0.91"
+
+/* Define Vendor and Device ID for Intel PCH C206 */
+#define INTEL_PCH_C206_VID		0x8086
+#define INTEL_PCH_C206_DID		0x1C56
+
+#define GPIOBASE							0x48
+//#define PMBASE								0x40
+
+/* Registers to Control GPIO Address Map */
+#define GP_USE_SEL						0x00
+#define GP_IO_SEL							0x04
+#define GP_LVL								0x0C
+//#define GPI_INV								0x2C
+
+/* APIC register */
+#define APIC_index						0xfec00000
+#define APIC_data							0xfec00010
+
+/* Common Section */
+#define kiri_rpsu_major				122
+#define kiri_rpsu_minor       0
+#define dev_count             1
+#define	DEVNAME								"kiri_rpsu"
+
+/* PMBUS command codes */
+#define	READ_VOUT							0x8B
+#define	READ_IOUT							0x8C
+#define	READ_TEMPERATURE1			0x8D
+#define READ_FAN_SPEED1				0x90
+#define READ_FAN_SPEED2				0x91
+#define USER_DATA_00					0xB0
+
+/* RPSU slave address */
+/* hardware slave address: 0x58, software device address: 0xB0 */
+#define RPSU_MOD1_ADDR				0x58
+/* hardware slave address: 0x59, software device address: 0xB2 */
+#define RPSU_MOD2_ADDR				0x59
+
+
+
+#endif
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/led_ctrl.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/led_ctrl.c
--- linux-3.10.69/arch/x86/plat-kiri/led_ctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/led_ctrl.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,1334 @@
+/*
+ *	-----------------------------
+ *	Author : Gary Chen
+ *	Date   : 2012/06/12
+ *	-----------------------------
+ *	Original Author : Simon Chang
+ */
+#include <asm/io.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <asm/delay.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/cdev.h>
+#include <linux/timer.h>
+#include <asm/param.h>
+#include <linux/i2c.h>
+#include <linux/mutex.h>
+
+
+#define ALARM_LED_STATIC_OFF	0xf0
+#define ALARM_LED_STATIC_ON		0xf1
+#define ALARM_LED_HW_BLINK		0xf2
+#define ALARM_LED_SW_BLINK_MSK	0xf0
+
+
+/* Define Vendor and Device ID for Intel PCH C206 */
+#define INTEL_PCH_C206_VID	0x8086
+#define INTEL_PCH_C206_DID	0x1c56
+#define GPIO_BAR_OFFSET		0x48
+#define GP_LVL				0x0c
+#define GPO_BLINK			0x18
+#define POWER_LED_BIT		(1 << 27)
+#define ALARM_LED_BIT		(1 << 21)
+#define POWER_LED_MASK		(~POWER_LED_BIT)
+#define ALARM_LED_MASK		(~ALARM_LED_BIT)
+
+
+//#define DEVNO			126			//device number
+#define kiri_led_major	126
+#define kiri_led_minor	0
+#define dev_count 			1
+#define	DEVNAME			"kiri_led"	//device name
+//int led_major = DEVNO;
+//char *led_devname = DEVNAME;
+
+
+
+#define TIME_1_0			(HZ)			// 1 sec
+#define TIME_0_5			(HZ/2)			// 0.5 sec
+#define TIME_0_3			((HZ*3)/10)		// 0.3 sec
+#define TIME_TEN_ON			TIME_1_0
+#define TIME_TEN_OFF		TIME_0_3
+#define TIME_ONE_ON			TIME_0_5
+#define TIME_ONE_OFF		TIME_0_3
+#define TIME_INTERVAL_OFF	TIME_1_0
+
+#define BLINK_TEN_OFF			0x10
+#define BLINK_TEN_ON			0x11
+#define BLINK_ONE_OFF			0x20
+#define BLINK_ONE_ON			0x21
+#define BLINK_INTERVAL_OFF		0x30
+#define BLINK_END				0xff
+
+
+/* Define for ioctl */
+#define IOCTL_GET_ALARM_LED		0x00
+#define IOCTL_SET_ALARM_LED		0x01
+#define IOCTL_SET_ALARM_LED_SW_BLINK		0x02
+#define IOCTL_GET_POWER_LED		0x03
+#define IOCTL_SET_POWER_LED		0x04
+
+/*
+#define IOCTL_SET_HDD_LEDERR0	0x10
+#define IOCTL_SET_HDD_LEDERR1	0x11
+#define IOCTL_SET_HDD_LEDERR2	0x12
+#define IOCTL_SET_HDD_LEDERR3	0x13
+#define IOCTL_SET_HDD_LEDERR4	0x14
+#define IOCTL_SET_HDD_LEDERR5	0x15
+#define IOCTL_SET_HDD_LEDERR6	0x16
+#define IOCTL_SET_HDD_LEDERR7	0x17
+#define IOCTL_SET_HDD_LEDERR8	0x18
+#define IOCTL_SET_HDD_LEDERR9	0x19
+#define IOCTL_SET_HDD_LEDERR10	0x1a
+#define IOCTL_SET_HDD_LEDERR11	0x1b
+
+#define IOCTL_GET_HDD_LEDERR0	0x20
+#define IOCTL_GET_HDD_LEDERR1	0x21
+#define IOCTL_GET_HDD_LEDERR2	0x22
+#define IOCTL_GET_HDD_LEDERR3	0x23
+#define IOCTL_GET_HDD_LEDERR4	0x24
+#define IOCTL_GET_HDD_LEDERR5	0x25
+#define IOCTL_GET_HDD_LEDERR6	0x26
+#define IOCTL_GET_HDD_LEDERR7	0x27
+#define IOCTL_GET_HDD_LEDERR8	0x28
+#define IOCTL_GET_HDD_LEDERR9	0x29
+#define IOCTL_GET_HDD_LEDERR10	0x2a
+#define IOCTL_GET_HDD_LEDERR11	0x2b
+*/
+
+/* Define for PCA9505 GPIO expander */
+/*
+#define GPI_PORT3		0x03
+#define GPI_PORT4		0x04
+#define GPO_PORT3		0x0b
+#define GPO_PORT4		0x0c
+
+#define HDD_ERRLED0_BIT		(1 << 0)
+#define HDD_ERRLED1_BIT		(1 << 1)
+#define HDD_ERRLED2_BIT		(1 << 2)
+#define HDD_ERRLED3_BIT		(1 << 3)
+#define HDD_ERRLED4_BIT		(1 << 4)
+#define HDD_ERRLED5_BIT		(1 << 5)
+#define HDD_ERRLED6_BIT		(1 << 6)
+#define HDD_ERRLED7_BIT		(1 << 7)
+#define HDD_ERRLED8_BIT		(1 << 0)
+#define HDD_ERRLED9_BIT		(1 << 1)
+#define HDD_ERRLED10_BIT	(1 << 2)
+#define HDD_ERRLED11_BIT	(1 << 3)
+
+#define HDD_ERRLED0_MASK	(~HDD_ERRLED0_BIT)
+#define HDD_ERRLED1_MASK	(~HDD_ERRLED1_BIT)
+#define HDD_ERRLED2_MASK	(~HDD_ERRLED2_BIT)
+#define HDD_ERRLED3_MASK	(~HDD_ERRLED3_BIT)
+#define HDD_ERRLED4_MASK	(~HDD_ERRLED4_BIT)
+#define HDD_ERRLED5_MASK	(~HDD_ERRLED5_BIT)
+#define HDD_ERRLED6_MASK	(~HDD_ERRLED6_BIT)
+#define HDD_ERRLED7_MASK	(~HDD_ERRLED7_BIT)
+#define HDD_ERRLED8_MASK	(~HDD_ERRLED8_BIT)
+#define HDD_ERRLED9_MASK	(~HDD_ERRLED9_BIT)
+#define HDD_ERRLED10_MASK	(~HDD_ERRLED10_BIT)
+#define HDD_ERRLED11_MASK	(~HDD_ERRLED11_BIT)
+*/
+
+/* Define for LED Command */
+#define LED_CMD_ERR		0
+#define LED_CMD_ON		1
+#define LED_CMD_OFF		2
+#define LED_CMD_BLINK	3
+
+/*
+#define PCA9505_SLAVE_ADDR	0x20
+*/
+
+/* Addresses to scan */
+/*
+static const unsigned short hdd_lederr_i2c[] = { PCA9505_SLAVE_ADDR, I2C_CLIENT_END };
+struct i2c_client *kiri_hdd_lederr_client;
+struct kiri_hdderr_data {
+	struct mutex update_lock;
+	u8 gpio_port_data;
+};
+*/
+
+extern struct class *kiri_cls;
+/* EXPORT_SYMBOL(kiri_cls); */
+struct device *led_dev = NULL;
+EXPORT_SYMBOL(led_dev);
+dev_t kirit_led;
+EXPORT_SYMBOL(kirit_led);
+static unsigned int pch_c206_gpio_base_addr;
+
+struct alm_led {
+	unsigned char pattern;			// the blink pattern under running
+	unsigned char action;			// command from user space
+	struct timer_list blink_timer;
+	unsigned char blink_schedule[40];
+	int sche_index;
+};
+struct alm_led alarm_led;
+
+//unsigned char pwr_led_pattern;
+
+/*******************************************************************************
+* function: find_c206_gpio_base_addr
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static int find_c206_gpio_base_addr(void)
+{
+	struct pci_dev *pdev = NULL;
+
+	pdev = pci_get_device(INTEL_PCH_C206_VID, INTEL_PCH_C206_DID, NULL);
+	if (!pdev) return -ENODEV;
+	pci_read_config_dword(pdev, GPIO_BAR_OFFSET, &pch_c206_gpio_base_addr);
+	pch_c206_gpio_base_addr &= 0x0000ff80;
+
+	return 0;
+}
+
+/*******************************************************************************
+* function: set_pwr_led_on
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+void set_pwr_led_on(void)
+{
+	unsigned int tmpgpioval;
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GP_LVL);
+	tmpgpioval |= POWER_LED_BIT;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GP_LVL);
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GPO_BLINK);
+	tmpgpioval &= POWER_LED_MASK;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GPO_BLINK);
+}
+
+/*******************************************************************************
+* function: set_pwr_led_off
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+void set_pwr_led_off(void)
+{
+	unsigned int tmpgpioval;
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GP_LVL);
+	tmpgpioval &= POWER_LED_MASK;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GP_LVL);
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GPO_BLINK);
+	tmpgpioval &= POWER_LED_MASK;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GPO_BLINK);
+}
+
+/*******************************************************************************
+* function: set_pwr_led_hw_blink
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+void set_pwr_led_hw_blink(void)
+{
+	unsigned int tmpgpioval;
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GP_LVL);
+	tmpgpioval |= POWER_LED_BIT;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GP_LVL);
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GPO_BLINK);
+	tmpgpioval |= POWER_LED_BIT;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GPO_BLINK);
+}
+
+/*******************************************************************************
+* function: set_alarm_led_on
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+void set_alarm_led_on(void)
+{
+	unsigned int tmpgpioval;
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GP_LVL);
+	tmpgpioval &= ALARM_LED_MASK;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GP_LVL);
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GPO_BLINK);
+	tmpgpioval &= ALARM_LED_MASK;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GPO_BLINK);
+}
+
+/*******************************************************************************
+* function: set_alarm_led_off
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+void set_alarm_led_off(void)
+{
+	unsigned int tmpgpioval;
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GP_LVL);
+	tmpgpioval |= ALARM_LED_BIT;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GP_LVL);
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GPO_BLINK);
+	tmpgpioval &= ALARM_LED_MASK;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GPO_BLINK);
+}
+
+/*******************************************************************************
+* function: set_alarm_led_hw_blink
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+void set_alarm_led_hw_blink(void)
+{
+	unsigned int tmpgpioval;
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GP_LVL);
+	tmpgpioval &= ALARM_LED_MASK;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GP_LVL);
+
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GPO_BLINK);
+	tmpgpioval |= ALARM_LED_BIT;
+	outl(tmpgpioval, pch_c206_gpio_base_addr + GPO_BLINK);
+}
+
+
+/*******************************************************************************
+* function: KiriClassGet
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static struct class *KiriClassGet(void)
+{
+	struct class *tmp_cls;
+
+	if(kiri_cls)
+		return kiri_cls;
+
+	tmp_cls = class_create(THIS_MODULE, "kiri");
+	if(IS_ERR(tmp_cls)) {
+		printk("%s : class_create failed.", __FUNCTION__);
+		return NULL;
+	}
+
+	kiri_cls = tmp_cls;
+	return kiri_cls;
+}
+
+/*******************************************************************************
+* function: alarm_led_check_param
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+int alarm_led_check_param(char * str, size_t count)
+{
+	if ((count == 3) && (str[2] == '\n')) count--;
+	else if ((count == 4) && (str[3] == '\n')) count--;
+	else if ((count == 6) && (str[5] == '\n')) count--;
+
+	// Check for "on", "00" ~ "99"
+	if (count == 2) {
+		if(strncmp(str, "on", 2) == 0) {
+			alarm_led.action = ALARM_LED_STATIC_ON;
+			return 0;
+		}
+		else if ((str[0] >= 0x30) && (str[0] <= 0x39) && (str[1] >= 0x30) && (str[1] <= 0x39)){
+			if ((str[0] == 0x30) && (str[1] == 0x30)) return -EINVAL;
+			alarm_led.action = ((str[0] & 0x0f) << 4) + (str[1] & 0x0f);
+			return 0;
+		}
+		else return -EINVAL;
+	}
+	// Check for "off"
+	else if (count == 3) {
+		if(strncmp(str, "off", 3) == 0) {
+			alarm_led.action = ALARM_LED_STATIC_OFF;
+			return 0;
+		}
+		else return -EINVAL;
+	}
+	// Check for "blink"
+	else if (count == 5) {
+		if(strncmp(str, "blink", 5) == 0) {
+			alarm_led.action = ALARM_LED_HW_BLINK;
+			return 0;
+		}
+		else return -EINVAL;
+	}
+	else return -EINVAL;
+}
+
+/*******************************************************************************
+* function: timer_function
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static void timer_function(unsigned long data)
+{
+
+	alarm_led.sche_index++;
+	switch (alarm_led.blink_schedule[alarm_led.sche_index]) {
+		case BLINK_TEN_ON:
+			mod_timer(&alarm_led.blink_timer, jiffies + TIME_TEN_ON);
+			//printk("  On\n");
+			set_alarm_led_on();
+			break;
+
+		case BLINK_TEN_OFF:
+			mod_timer(&alarm_led.blink_timer, jiffies + TIME_TEN_OFF);
+			//printk("  Off\n");
+			set_alarm_led_off();
+			break;
+
+		case BLINK_ONE_ON:
+			mod_timer(&alarm_led.blink_timer, jiffies + TIME_ONE_ON);
+			//printk("  On\n");
+			set_alarm_led_on();
+			break;
+
+		case BLINK_ONE_OFF:
+			mod_timer(&alarm_led.blink_timer, jiffies + TIME_ONE_OFF);
+			//printk("  Off\n");
+			set_alarm_led_off();
+			break;
+
+		case BLINK_INTERVAL_OFF:
+			mod_timer(&alarm_led.blink_timer, jiffies + TIME_INTERVAL_OFF);
+			break;
+
+		case BLINK_END:
+			alarm_led.sche_index = 0;
+			if (alarm_led.blink_schedule[0] == BLINK_TEN_ON)
+				alarm_led.blink_timer.expires = jiffies + TIME_TEN_ON;
+			else alarm_led.blink_timer.expires = jiffies + TIME_ONE_ON;
+			mod_timer(&alarm_led.blink_timer, jiffies + TIME_TEN_ON);
+			//printk("=======================\n");
+			//printk("  On\n");
+			set_alarm_led_on();
+			break;
+
+	}
+}
+
+/*******************************************************************************
+* function: alarm_led_sw_blink_start
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+void alarm_led_sw_blink_start(void)
+{
+	int i, j, ten_times, one_times;
+
+	// prepare blinking schedule
+	alarm_led.sche_index = 0;
+	ten_times = (alarm_led.pattern >> 4) & 0x0f;
+	one_times = alarm_led.pattern & 0x0f;
+	//printk("ten_times=%d, one_times=%d\n", ten_times, one_times);
+	for (i = 0, j = 0 ; i < ten_times ; i++) {
+		alarm_led.blink_schedule[j++] = BLINK_TEN_ON;
+		alarm_led.blink_schedule[j++] = BLINK_TEN_OFF;
+	}
+	for (i = 0 ; i < one_times ; i++) {
+		alarm_led.blink_schedule[j++] = BLINK_ONE_ON;
+		alarm_led.blink_schedule[j++] = BLINK_ONE_OFF;
+	}
+	alarm_led.blink_schedule[j++] = BLINK_INTERVAL_OFF;
+	alarm_led.blink_schedule[j] = BLINK_END;
+
+	//Setup timer for blinking schedule
+	init_timer(&alarm_led.blink_timer);
+	if (alarm_led.blink_schedule[0] == BLINK_TEN_ON)
+		alarm_led.blink_timer.expires = jiffies + TIME_TEN_ON;
+	else alarm_led.blink_timer.expires = jiffies + TIME_ONE_ON;
+	//printk("=======================\n");
+	//printk("  On\n");
+	set_alarm_led_on();
+	//alarm_led.blink_timer.data = 0;
+	alarm_led.blink_timer.function = timer_function;
+	add_timer(&alarm_led.blink_timer);
+}
+
+/*******************************************************************************
+* function: alarm_led_proc
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+void alarm_led_proc(void)
+{
+	if ((alarm_led.pattern & ALARM_LED_SW_BLINK_MSK) != ALARM_LED_SW_BLINK_MSK) {
+		// stop timer here
+		del_timer(&alarm_led.blink_timer);
+	}
+
+	alarm_led.pattern = alarm_led.action;
+	if ((alarm_led.action & ALARM_LED_SW_BLINK_MSK) == ALARM_LED_SW_BLINK_MSK) {
+		// set led to on or off or hw blink
+		switch(alarm_led.action) {
+			case ALARM_LED_STATIC_ON:
+				set_alarm_led_on();
+			break;
+
+			case ALARM_LED_STATIC_OFF:
+				set_alarm_led_off();
+			break;
+
+			case ALARM_LED_HW_BLINK:
+				set_alarm_led_hw_blink();
+			break;
+		}
+	}
+	else {
+		// set led to sw blink
+		printk("sw blink start...\n");
+		alarm_led_sw_blink_start();
+	}
+}
+
+/*******************************************************************************
+* function: set_hdd_lederr_on
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+void set_hdd_lederr_on(int hddno)
+{
+	struct kiri_hdderr_data *gpio_data = i2c_get_clientdata(kiri_hdd_lederr_client);
+	u8 temp = 0x01;
+	u8 port;
+
+	if (hddno < 8) {
+		temp <<= hddno;
+		port = GPO_PORT3;
+	}
+	else if (hddno < 12) {
+		hddno -= 8;
+		temp <<= hddno;
+		port = GPO_PORT4;
+	}
+	else return;
+
+	mutex_lock(&gpio_data->update_lock);
+	gpio_data->gpio_port_data = (u8)i2c_smbus_read_byte_data(kiri_hdd_lederr_client, port);
+	gpio_data->gpio_port_data &= ~temp;
+	i2c_smbus_write_byte_data(kiri_hdd_lederr_client, port, gpio_data->gpio_port_data);
+	mutex_unlock(&gpio_data->update_lock);
+}
+*/
+/*******************************************************************************
+* function: set_hdd_lederr_off
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+void set_hdd_lederr_off(int hddno)
+{
+	struct kiri_hdderr_data *gpio_data = i2c_get_clientdata(kiri_hdd_lederr_client);
+	u8 temp = 0x01;
+	u8 port;
+
+	if (hddno < 8) {
+		temp <<= hddno;
+		port = GPO_PORT3;
+	}
+	else if (hddno < 12) {
+		hddno -= 8;
+		temp <<= hddno;
+		port = GPO_PORT4;
+	}
+	else return;
+
+	mutex_lock(&gpio_data->update_lock);
+	gpio_data->gpio_port_data = (u8)i2c_smbus_read_byte_data(kiri_hdd_lederr_client, port);
+	gpio_data->gpio_port_data |= temp;
+	i2c_smbus_write_byte_data(kiri_hdd_lederr_client, port, gpio_data->gpio_port_data);
+	mutex_unlock(&gpio_data->update_lock);
+}
+*/
+
+/*******************************************************************************
+* function: get_hdd_lederr_status
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+int get_hdd_lederr_status(int hddno)
+{
+	struct kiri_hdderr_data *gpio_data = i2c_get_clientdata(kiri_hdd_lederr_client);
+	u8 temp = 0x01;
+	u8 port;
+
+	if (hddno < 8) {
+		temp <<= hddno;
+		port = GPO_PORT3;
+	}
+	else if (hddno < 12) {
+		hddno -= 8;
+		temp <<= hddno;
+		port = GPO_PORT4;
+	}
+	else return -EINVAL;
+
+	mutex_lock(&gpio_data->update_lock);
+	gpio_data->gpio_port_data = (u8)i2c_smbus_read_byte_data(kiri_hdd_lederr_client, port);
+	mutex_unlock(&gpio_data->update_lock);
+
+	return (gpio_data->gpio_port_data & temp);
+}
+*/
+
+/*******************************************************************************
+* function: check_led_cmd_param
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static int check_led_cmd_param(char *buf, size_t count)
+{
+	if (strncmp(buf, "on", 2) == 0) {
+		if (count == 2) {
+			return LED_CMD_ON;
+		}
+		else if (count == 3) {
+			if (buf[2] == '\n') return LED_CMD_ON;
+			else return LED_CMD_ERR;
+		}
+		else return LED_CMD_ERR;
+	}
+	else if (strncmp(buf, "off", 3) == 0) {
+		if (count == 3) {
+			return LED_CMD_OFF;
+		}
+		else if (count == 4) {
+			if (buf[3] == '\n') return LED_CMD_OFF;
+			else return LED_CMD_ERR;
+		}
+		else return LED_CMD_ERR;
+	}
+	else if (strncmp(buf, "blink", 5) == 0) {
+		if (count == 5) {
+			return LED_CMD_BLINK;
+		}
+		else if (count == 6) {
+			if (buf[5] == '\n') return LED_CMD_BLINK;
+			else return LED_CMD_ERR;
+		}
+		else return LED_CMD_ERR;
+	}
+	else return LED_CMD_ERR;
+
+}
+
+/*******************************************************************************
+* function: show_alarm_led_pattern
+* function: store_alarm_led_pattern
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_alarm_led_pattern(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if ((alarm_led.pattern & ALARM_LED_SW_BLINK_MSK) == ALARM_LED_SW_BLINK_MSK) {
+		switch (alarm_led.pattern) {
+			case ALARM_LED_STATIC_ON:	return sprintf(buf, "on\n");	break;
+			case ALARM_LED_STATIC_OFF:	return sprintf(buf, "off\n");	break;
+			case ALARM_LED_HW_BLINK:	return sprintf(buf, "blink\n");	break;
+		}
+	}
+	else {
+		return sprintf(buf, "%02x\n", alarm_led.pattern);
+	}
+	return 0;
+}
+static ssize_t store_alarm_led_pattern(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+
+	retval = alarm_led_check_param((char *)buf, count);
+	if (retval) return retval;
+	//printk("New alert led command: 0x%02x\n", alarm_led.action);
+	alarm_led_proc();
+
+	return count;
+}
+DEVICE_ATTR(Alarm, 0644, show_alarm_led_pattern, store_alarm_led_pattern);
+
+/*******************************************************************************
+* function: show_power_led
+* function: store_power_led
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static ssize_t show_power_led(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	unsigned int tmpgpioval;
+		
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GPO_BLINK);
+	if (tmpgpioval & POWER_LED_BIT) return sprintf(buf, "blink\n");
+		else{
+			tmpgpioval = inl(pch_c206_gpio_base_addr + GP_LVL);
+				if (tmpgpioval & POWER_LED_BIT) return sprintf(buf, "on\n");
+				else return sprintf(buf, "off\n");
+				}
+	
+	
+	/*
+	tmpgpioval = inl(pch_c206_gpio_base_addr + GP_LVL);
+	if (tmpgpioval & POWER_LED_BIT) {
+		tmpgpioval = inl(pch_c206_gpio_base_addr + GPO_BLINK);
+		if (tmpgpioval & POWER_LED_BIT) return sprintf(buf, "blink\n");
+		else return sprintf(buf, "on\n");
+	}
+	else return sprintf(buf, "off\n");
+	*/	
+}
+static ssize_t store_power_led(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	switch (check_led_cmd_param((char *)buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_pwr_led_on();		break;
+		case LED_CMD_OFF:	set_pwr_led_off();		break;
+		case LED_CMD_BLINK:	set_pwr_led_hw_blink();	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Power, 0644, show_power_led, store_power_led);
+
+/*******************************************************************************
+* function: show_Lederr0
+* function: store_Lederr0
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr0(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(0))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr0(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(0);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(0);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr0, 0644, show_Lederr0, store_Lederr0);
+*/
+
+/*******************************************************************************
+* function: show_Lederr1
+* function: store_Lederr1
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr1(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(1))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr1(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(1);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(1);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr1, 0644, show_Lederr1, store_Lederr1);
+*/
+
+/*******************************************************************************
+* function: show_Lederr2
+* function: store_Lederr2
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr2(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(2))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr2(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(2);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(2);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr2, 0644, show_Lederr2, store_Lederr2);
+*/
+
+/*******************************************************************************
+* function: show_Lederr3
+* function: store_Lederr3
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr3(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(3))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr3(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(3);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(3);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr3, 0644, show_Lederr3, store_Lederr3);
+*/
+
+/*******************************************************************************
+* function: show_Lederr4
+* function: store_Lederr4
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr4(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(4))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr4(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(4);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(4);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr4, 0644, show_Lederr4, store_Lederr4);
+*/
+
+/*******************************************************************************
+* function: show_Lederr5
+* function: store_Lederr5
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr5(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(5))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr5(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(5);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(5);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr5, 0644, show_Lederr5, store_Lederr5);
+*/
+
+/*******************************************************************************
+* function: show_Lederr6
+* function: store_Lederr6
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr6(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(6))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr6(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(6);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(6);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr6, 0644, show_Lederr6, store_Lederr6);
+*/
+
+/*******************************************************************************
+* function: show_Lederr7
+* function: store_Lederr7
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr7(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(7))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr7(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(7);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(7);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr7, 0644, show_Lederr7, store_Lederr7);
+*/
+
+/*******************************************************************************
+* function: show_Lederr8
+* function: store_Lederr8
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr8(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(8))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr8(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(8);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(8);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr8, 0644, show_Lederr8, store_Lederr8);
+*/
+
+/*******************************************************************************
+* function: show_Lederr9
+* function: store_Lederr9
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr9(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(9))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr9(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(9);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(9);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr9, 0644, show_Lederr9, store_Lederr9);
+*/
+
+/*******************************************************************************
+* function: show_Lederr10
+* function: store_Lederr10
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr10(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(10))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr10(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(10);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(10);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr10, 0644, show_Lederr10, store_Lederr10);
+*/
+
+/*******************************************************************************
+* function: show_Lederr11
+* function: store_Lederr11
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static ssize_t show_Lederr11(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if (get_hdd_lederr_status(11))
+		return sprintf(buf, "off\n");
+	else
+		return sprintf(buf, "on\n");
+}
+static ssize_t store_Lederr11(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	switch (check_led_cmd_param(buf, count)) {
+		case LED_CMD_ERR:	return -EINVAL;			break;
+		case LED_CMD_ON:	set_hdd_lederr_on(11);	break;
+		case LED_CMD_OFF:	set_hdd_lederr_off(11);	break;
+		default: 			return -EINVAL;			break;
+	}
+	return count;
+}
+DEVICE_ATTR(Lederr11, 0644, show_Lederr11, store_Lederr11);
+*/
+
+/*******************************************************************************
+* function: led_ioctl
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+int led_ioctl(struct file *file,unsigned int cmd, unsigned long para)
+{
+	int ret = 0;
+
+	switch (cmd) {
+		case IOCTL_GET_ALARM_LED:
+			if ((alarm_led.pattern & ALARM_LED_SW_BLINK_MSK) == ALARM_LED_SW_BLINK_MSK) {
+				switch (para) {
+					case ALARM_LED_STATIC_ON:	printk("on\n");	break;
+					case ALARM_LED_STATIC_OFF:	printk("off\n");	break;
+					case ALARM_LED_HW_BLINK:	printk("blink\n");	break;
+				}
+			}
+			else {
+				printk("%02x\n", alarm_led.pattern);
+			}
+		break;
+
+		case IOCTL_SET_ALARM_LED_SW_BLINK:
+			alarm_led.action = (u8)para;
+			alarm_led_proc();
+		break;
+
+		case IOCTL_SET_ALARM_LED:
+			switch (para) {
+				case 0:	alarm_led.action = ALARM_LED_STATIC_OFF;	break;
+				case 1:	alarm_led.action = ALARM_LED_STATIC_ON;		break;
+				case 2:	alarm_led.action = ALARM_LED_HW_BLINK;	break;
+			}
+			alarm_led_proc();
+		break;
+
+		case IOCTL_GET_POWER_LED:
+			if (inl(pch_c206_gpio_base_addr + GP_LVL) & POWER_LED_BIT) {
+				if (inl(pch_c206_gpio_base_addr + GPO_BLINK) & POWER_LED_BIT) printk("blink\n");
+				else printk("on\n");
+			}
+			else printk("off\n");
+		break;
+
+		case IOCTL_SET_POWER_LED:
+			switch (para) {
+				case 0:	set_pwr_led_off();		break;
+				case 1:	set_pwr_led_on();		break;
+				case 2:	set_pwr_led_hw_blink();	break;
+			}
+		break;
+/*
+		case IOCTL_SET_HDD_LEDERR0:
+		case IOCTL_SET_HDD_LEDERR1:
+		case IOCTL_SET_HDD_LEDERR2:
+		case IOCTL_SET_HDD_LEDERR3:
+		case IOCTL_SET_HDD_LEDERR4:
+		case IOCTL_SET_HDD_LEDERR5:
+		case IOCTL_SET_HDD_LEDERR6:
+		case IOCTL_SET_HDD_LEDERR7:
+		case IOCTL_SET_HDD_LEDERR8:
+		case IOCTL_SET_HDD_LEDERR9:
+		case IOCTL_SET_HDD_LEDERR10:
+		case IOCTL_SET_HDD_LEDERR11:
+			switch (para) {
+				case 0:	set_hdd_lederr_off(cmd-IOCTL_SET_HDD_LEDERR0);		break;
+				case 1:	set_hdd_lederr_on(cmd-IOCTL_SET_HDD_LEDERR0);		break;
+			}
+		break;
+
+		case IOCTL_GET_HDD_LEDERR0:
+		case IOCTL_GET_HDD_LEDERR1:
+		case IOCTL_GET_HDD_LEDERR2:
+		case IOCTL_GET_HDD_LEDERR3:
+		case IOCTL_GET_HDD_LEDERR4:
+		case IOCTL_GET_HDD_LEDERR5:
+		case IOCTL_GET_HDD_LEDERR6:
+		case IOCTL_GET_HDD_LEDERR7:
+		case IOCTL_GET_HDD_LEDERR8:
+		case IOCTL_GET_HDD_LEDERR9:
+		case IOCTL_GET_HDD_LEDERR10:
+		case IOCTL_GET_HDD_LEDERR11:
+			if (get_hdd_lederr_status(cmd-IOCTL_GET_HDD_LEDERR0)) {
+				ret = 0;
+				printk("off\n");
+			}
+			else {
+				ret = 1;
+				printk("on\n");
+			}
+		break;
+*/
+		default:
+			goto IOCTL_WRONG_CMD;
+		break;
+	}
+	return ret;
+
+IOCTL_WRONG_CMD:
+	printk("wrong command\n");
+	return ret;
+}
+
+struct file_operations led_fops = {
+	//open: led_open,
+	//unlocked_ioctl: led_ioctl,
+	//release: led_close,
+	//owner: THIS_MODULE,
+};
+
+/*******************************************************************************
+* function: kiri_hdd_lederr_detect
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static int kiri_hdd_lederr_detect(struct i2c_client *client, struct i2c_board_info *info)
+{
+	strlcpy(info->type, "kiri_hdd_ederr", I2C_NAME_SIZE);
+
+	return 0;
+}
+*/
+
+/*******************************************************************************
+* function: kiri_hdd_lederr_probe
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static int kiri_hdd_lederr_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct kiri_hdderr_data *data;
+
+	if (!(data = kzalloc(sizeof(struct kiri_hdderr_data), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+
+	kiri_hdd_lederr_client = client;
+	data->gpio_port_data = 0;
+	i2c_set_clientdata(kiri_hdd_lederr_client, data);
+	mutex_init(&data->update_lock);
+
+	// for init PCA9505, because BIOS is not ready.
+	struct kiri_hdderr_data *gpio_data = i2c_get_clientdata(kiri_hdd_lederr_client);
+	mutex_lock(&gpio_data->update_lock);
+	i2c_smbus_write_byte_data(kiri_hdd_lederr_client, 0x1b, 0x00);
+	i2c_smbus_write_byte_data(kiri_hdd_lederr_client, 0x1c, 0x00);
+	i2c_smbus_write_byte_data(kiri_hdd_lederr_client, 0x0b, 0xff);
+	i2c_smbus_write_byte_data(kiri_hdd_lederr_client, 0x0c, 0xff);
+	mutex_unlock(&gpio_data->update_lock);
+
+
+
+	return 0;
+}
+*/
+
+/*******************************************************************************
+* function: kiri_hdd_lederr_remove
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+/*
+static int kiri_hdd_lederr_remove(struct i2c_client *client)
+{
+	kfree(i2c_get_clientdata(client));
+	return 0;
+}
+
+static const struct i2c_device_id kiri_hdd_lederr_id[] = {
+	{ "kiri_hdd_ederr", 0 },
+	{ }
+};
+
+static struct i2c_driver kiri_hdd_lederr_driver = {
+	.driver = {
+		.name	= "kiri_hdd_ederr",
+	},
+	.probe		= kiri_hdd_lederr_probe,
+	.remove		= kiri_hdd_lederr_remove,
+	.id_table	= kiri_hdd_lederr_id,
+	.class		= I2C_CLASS_SPD,
+	.detect		= kiri_hdd_lederr_detect,
+	.address_list	= hdd_lederr_i2c,
+};
+*/
+
+/*******************************************************************************
+* function: kiri_led_ctrl_init
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static int __init kiri_led_ctrl_init(void)
+{
+	int ret;
+	int rv = 0;
+	struct class *cls;
+
+	//printk(KERN_ALERT "led control module init...\n");
+	
+/*
+	if (i2c_add_driver(&kiri_hdd_lederr_driver)) return -ENODEV;
+*/
+
+	if (find_c206_gpio_base_addr()) return -ENODEV;
+
+	kirit_led = MKDEV(kiri_led_major, kiri_led_minor);
+
+	/* Register device, and may be allocating major# */
+	//ret = register_chrdev(led_major, led_devname, &led_fops);
+	ret = register_chrdev_region(kirit_led, dev_count, DEVNAME);
+	if(ret<0){
+		printk("%s cannot register\n", DEVNAME);
+		return (ret);
+	}
+
+	cls = KiriClassGet();
+	if(kiri_cls){
+		led_dev = device_create(kiri_cls, NULL, kirit_led, NULL, "led");
+		rv = device_create_file(led_dev, &dev_attr_Alarm);
+		rv = device_create_file(led_dev, &dev_attr_Power);
+/*
+		ret = device_create_file(dev, &dev_attr_Lederr0);
+		ret = device_create_file(dev, &dev_attr_Lederr1);
+		ret = device_create_file(dev, &dev_attr_Lederr2);
+		ret = device_create_file(dev, &dev_attr_Lederr3);
+		ret = device_create_file(dev, &dev_attr_Lederr4);
+		ret = device_create_file(dev, &dev_attr_Lederr5);
+		ret = device_create_file(dev, &dev_attr_Lederr6);
+		ret = device_create_file(dev, &dev_attr_Lederr7);
+		ret = device_create_file(dev, &dev_attr_Lederr8);
+		ret = device_create_file(dev, &dev_attr_Lederr9);
+		ret = device_create_file(dev, &dev_attr_Lederr10);
+		ret = device_create_file(dev, &dev_attr_Lederr11);
+*/
+	}
+	alarm_led.pattern = ALARM_LED_STATIC_OFF;
+	alarm_led.action = 0x00;
+
+	printk("led_ctrl module has been initialized. \n");
+	return 0;
+}
+
+/*******************************************************************************
+* function: kiri_led_ctrl_exit_cleanup
+* argument:
+* retvalue:
+* description:
+*******************************************************************************/
+static void __exit kiri_led_ctrl_exit_cleanup(void)
+{
+	//int ret;
+
+	//printk(KERN_ALERT "led control module exit...\n");
+
+	device_remove_file(led_dev, &dev_attr_Alarm);
+	device_remove_file(led_dev, &dev_attr_Power);
+	device_destroy(kiri_cls, kirit_led);
+	
+	/* class_destroy(kiri_cls); */
+	//unregister_chrdev(led_major, led_devname);
+	unregister_chrdev_region(kirit_led, dev_count);
+	/*
+	i2c_del_driver(&kiri_hdd_lederr_driver);
+	*/
+	printk("led_ctrl module has been removed. \n");
+}
+
+module_init(kiri_led_ctrl_init);
+module_exit(kiri_led_ctrl_exit_cleanup);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-kiri/Makefile F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/Makefile
--- linux-3.10.69/arch/x86/plat-kiri/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-kiri/Makefile	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,6 @@
+obj-$(CONFIG_BUFFALO_KIRI_PLATFORM)	+= kiri_rpsu.o
+obj-$(CONFIG_BUFFALO_KIRI_PLATFORM)	+= kiri_cmos.o
+obj-$(CONFIG_BUFFALO_KIRI_PLATFORM)	+= kiri_fan.o
+obj-$(CONFIG_BUFFALO_KIRI_PLATFORM)	+= led_ctrl.o
+obj-$(CONFIG_BUFFALO_KIRI_PLATFORM)	+= hdd_ctrl.o
+obj-$(CONFIG_BUFFALO_KIRI_PLATFORM)	+= bz_ctrl.o
diff -rubB --new-file linux-3.10.69/arch/x86/plat-matsu/boardid_ctrl.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/boardid_ctrl.c
--- linux-3.10.69/arch/x86/plat-matsu/boardid_ctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/boardid_ctrl.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,191 @@
+/*****************************************************************************+
+ DESCRIPTION:  Matsu ID driver (sample)
+ AUTHOR:       Wayne Lai
+ DATE STARTED: August, 2010
+ PROJECT:      WS-QX2(Matsu)
+
+ Rev 0.1   August 18 2010
+ *******************************************************************************/
+#include <asm/io.h>
+#include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <asm/delay.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/cdev.h>
+
+/* Define Vendor and product id for ich9r */
+#define INTEL_ICH9R_VENDOR_ID	0x8086
+#define INTEL_ICH9R_DEVICE_ID	0x2916
+
+#define GPIO_BAR_OFFSET		0x48
+#define GP_LVL			0x0c
+
+/* Define GPIO
+      GPIO31   GPIO30   GPIO29        SKU
+      ------   ------   ------     ------------
+(1)      0       0        0         2HDD box
+(2)      0       0        1         4HDD box
+(3)      0       1        0         6HDD box
+(4)      0       1        1         8HDD box
+(5)      1       0        0         1U
+
+*/
+#define GPIO29			0x20000000	/*GPIO29*/
+#define GPIO30			0x40000000	/*GPIO30*/
+#define GPIO31			0x80000000	/*GPIO31*/
+#define BOARD_ID_MASK		(GPIO29 | GPIO30 | GPIO31)
+#define BOARD_ID_OFFSET		29
+
+#define	GET_ID			1
+
+//Common section
+#define DRVVER			123		//device number
+#define	DRVNAME			"matsu_id"	//device name
+
+//#define DEBUG
+#if defined(DEBUG)
+	#define debug(fmt, args...)	printk(fmt, ##args)
+#else
+	#define debug(fmt, args...)
+#endif
+
+int id_major = DRVVER;
+char *id_devname = DRVNAME;
+
+extern struct class *matsu_cls;
+extern struct class *MatsuClassGet(void);
+
+static unsigned int ich9r_gpio_base_addr;
+
+static int find_ich9_gpio_base_addr(void)
+{
+	struct pci_dev *pdev = NULL;
+
+	pdev = pci_get_device(INTEL_ICH9R_VENDOR_ID, INTEL_ICH9R_DEVICE_ID, NULL);
+	if (!pdev) return -ENODEV;
+	pci_read_config_dword(pdev, GPIO_BAR_OFFSET, &ich9r_gpio_base_addr);
+	ich9r_gpio_base_addr &= 0x0000ff80;
+
+	return 0;
+}
+
+/* Open the device */
+int id_open(struct inode *inode_ptr, struct file *fptr)
+{
+	printk("id driver is opened\n");                    
+	return(0);
+}
+
+/* Close the device */
+int id_close(struct inode *inode_ptr, struct file *fptr)
+{
+	printk("id driver is closed\n");
+	return(0);
+}
+
+unsigned int
+GetBoardId(void)
+{
+	unsigned int	read_value;
+	read_value = (inl(ich9r_gpio_base_addr + GP_LVL) & BOARD_ID_MASK) >> BOARD_ID_OFFSET;
+
+	debug("gpio31 is %d \n", (inl(ich9r_gpio_base_addr + GP_LVL)&GPIO31)>>31 );
+	debug("gpio30 is %d \n", (inl(ich9r_gpio_base_addr + GP_LVL)&GPIO30)>>30 );
+	debug("gpio29 is %d \n", (inl(ich9r_gpio_base_addr + GP_LVL)&GPIO29)>>29 );
+	debug("id is %d \n",read_value);
+
+	return read_value;
+}
+
+// IOCTL interface for user to get
+int id_ioctl(struct inode * inode,struct file *file,unsigned int cmd, unsigned long para)
+{
+	unsigned int	ret = -1;
+
+	switch(cmd)
+	{
+		//interface to read id
+		case GET_ID:
+			ret = GetBoardId();
+			break;
+
+		default:
+			printk("wrong command");
+			ret = -1;
+			break;
+	}		 
+	return ret;
+}
+
+//file operations for this device.
+struct file_operations id_fops = {
+open: id_open,
+compat_ioctl: id_ioctl,
+release: id_close,
+owner: THIS_MODULE,
+};
+
+static ssize_t show_dev_number(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d:%d\n", id_major, 0);
+}
+DEVICE_ATTR(matsu_board_dev, 0444, show_dev_number, NULL);
+
+static ssize_t show_matsu_board_id(struct device *dev, struct device_attribute *attr, char *buf)
+{
+        return sprintf(buf, "%d\n", GetBoardId());
+}
+DEVICE_ATTR(id, 0444, show_matsu_board_id, NULL);
+
+//register the device to kernel.
+static int __init matsuid_init(void)
+{
+	int ret = -1;
+	struct class *cls;
+
+	debug("enter id module init\n");
+
+	/* find intel ich9 device */
+	if (find_ich9_gpio_base_addr()) return -ENODEV;
+
+	/* Register device, and may be allocating major# */
+	ret = register_chrdev(id_major, id_devname, &id_fops);
+	if(ret <0)
+	{
+		printk("%s cannot register\n", id_devname);
+		return(ret);
+	}
+	else
+	{
+		if(id_major==0)
+			id_major = ret;
+	}
+
+	cls = MatsuClassGet();
+	if(cls)
+	{
+		struct device *dev = device_create(cls, NULL, 0, NULL, "board");
+		int rv = 0;
+		rv = device_create_file(dev, &dev_attr_matsu_board_dev);
+		rv = device_create_file(dev, &dev_attr_id);
+	}
+
+	return 0;
+}
+
+//unregister the device from kernel.
+static void __exit matsuid_exit_cleanup(void)
+{
+	
+	printk(DRVNAME " ID MODULE HAS BEEN REMOVED!\n");
+	unregister_chrdev(id_major, id_devname);
+}
+
+module_init(matsuid_init);
+module_exit(matsuid_exit_cleanup);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-matsu/btn_ctrl.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/btn_ctrl.c
--- linux-3.10.69/arch/x86/plat-matsu/btn_ctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/btn_ctrl.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,363 @@
+/*****************************************************************************+
+ DESCRIPTION:  Matsu button driver (sample)
+ AUTHOR:       Ian Juang
+ DATE STARTED: July, 2010
+ PROJECT:      WS-QX2(Matsu)
+
+ Rev 0.3   Aug  05 2010
+ - Adding an "if" clause in the interrupt handler to check for the interrupt 
+   source(PBD's IRQ).
+ - Indicate the timer source.
+*******************************************************************************
+ Rev 0.2   Aug  04 2010
+ - Modify button interrupt event to become triggered by IT87 de-bounce IRQ.
+ Rev 0.1   July 26 2010
+ - Initial revision.
+--------------------------------------------------------------------------------
+ CONVENTIONS:
+
++----------------------------------------------------------------------------+*/
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+
+#include <linux/timer.h>
+#include <asm/param.h>
+
+//Common section
+#define DRVVER			"0.3"
+#define	DRVNAME			"matsu_btn"
+
+#if defined(CONFIG_BUFFALO_PLATFORM)
+#include "buffalo/kernevnt.h"
+#endif
+
+//IT8721 registers section
+#define CONFIG_ADDR_PORT	0x2E
+#define CONFIG_DATA_PORT	0x2F
+
+#define IT87_LDN_ADDR		0x07
+#define	IT87_GPIO_LDN		0x07
+
+#define IT87_GP34_LOC		0x1C
+#define IT87_GP35_LOC		0x1D
+#define	IT87_IRQEN		0x40
+
+#define IT87_REG_PNL_DBOUNCE0	0xE0
+#define IT87_REG_PNL_DBOUNCE1	0xE1
+#define IT87_REG_PNL_IRQ_SEL	0x70
+#define IT87_PNL_IRQ3		0x03	//IRQ level 3
+#define IT87_REG_SMI_STS2	0xF3
+
+#define IT87_SMI_DEB_MASK	0xC0
+#define IT87_DEB0		0x80	//bit7
+#define IT87_DEB1		0x40	//bit6
+#define IT87_DEB0DEB1		0xC0	//bits[6-7]
+#define IT87_SMI_STS2_PBD	0x01	//bit0 PBD's IRQ
+
+#define IT87_GP34_BIT4		0x10
+#define IT87_GP35_BIT5		0x20
+//Simple I/O base addr(Index62h and 63h)+ GPIO Set2
+#define IT87_SIMPLE_IO_SET2	0xA22
+
+//Buttons section
+#define BTN_DISP	    	   1
+#define BTN_FUNC	 	   2
+      
+#define TIMER_DELAY		(HZ/500)//this value can be adjusted
+static struct timer_list btn_timer;
+
+#define MODULE_DIR		"buffalo/gpio"
+#define SWITCH_DIR		"buffalo/gpio/switch"
+
+static struct button_info_st {
+	char name[32];
+	unsigned char reg_stat;
+} button_info[] = {
+	{"func", IT87_DEB1},
+	{"display", IT87_DEB0},
+};
+#define NUM_SUPPORTED_BUTTON_NUM	(sizeof(button_info) / sizeof(button_info[0]))
+
+/*+--------------------------------------------+
+This procedure is for program LPC configuration 
+registers. Entering and exiting MBPnP mode.
++--------------------------------------------+*/
+void EnterMBPnP(void)
+{
+	outb(0x87, CONFIG_ADDR_PORT);
+	outb(0x01, CONFIG_ADDR_PORT);
+	outb(0x55, CONFIG_ADDR_PORT);
+	outb(0x55, CONFIG_ADDR_PORT);
+}
+void ExitMBPnP(void)
+{
+	outb(0x02, CONFIG_ADDR_PORT);
+	outb(0x02, CONFIG_DATA_PORT);		
+}
+
+/*+--------------------------------------------+
+This procedure is for getting the GPIO status of
+buttons.
+
+Returns:
++--------------------------------------------+*/
+static int it87_gpio_getsts(int pin)
+{
+	int	off;
+	if(pin == BTN_DISP){
+		off = IT87_GP35_BIT5;	//pin number of DISP button
+	}else{
+		off = IT87_GP34_BIT4;	//pin number of FUNC button
+	}		
+
+	return inb(IT87_SIMPLE_IO_SET2) & off;
+}
+
+/*+--------------------------------------------+
+A timer for checking if the de-bounce gpio pin
+has been released. This interrupt won't be 
+triggered again until the IT87_REG_SMI_STS2 is
+cleared by software.
+
+Returns: 
++--------------------------------------------+*/
+static void timer_function(unsigned long data)
+{
+	int	pin_sts;
+
+	pin_sts=it87_gpio_getsts(data);
+	
+	if(pin_sts){
+	//Clear de-bounce ping SMI status
+		EnterMBPnP();
+		outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+		outb(IT87_DEB0DEB1 | IT87_SMI_STS2_PBD, CONFIG_DATA_PORT);		
+		ExitMBPnP();
+	//Delete timer
+		del_timer(&btn_timer);
+		printk(KERN_ALERT "Timer %ld is cleared!\n",data);
+	}else{
+        	mod_timer(&btn_timer, jiffies + TIMER_DELAY);
+	}
+}
+
+/*+--------------------------------------------+
+Matsu button interrupt handler
+
+Handling display and funcion button irq demand. 
+Check IT8721 SMI# Status Register2 to determine 
+which button was pressed.
+
+Returns: 
++--------------------------------------------+*/
+static irqreturn_t matsu_interrupt(int irq, void *dev_id)
+{
+	int	pin=0;
+	unsigned char smi_sts;
+#if defined(CONFIG_BUFFALO_PLATFORM)
+	char msg[32];
+	memset(msg, 0, sizeof(msg));
+#endif
+	//Get SMI status of two de-bounce pin
+	EnterMBPnP();	
+	outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+
+	smi_sts = inb(CONFIG_DATA_PORT);
+	ExitMBPnP();
+	//Check if the interrupt source is PBD's IRQ
+	if(smi_sts & IT87_SMI_STS2_PBD)
+	{
+		smi_sts &= IT87_SMI_DEB_MASK;
+		//Check which button was pressed
+		if (smi_sts == IT87_DEB0){
+#if defined(CONFIG_BUFFALO_PLATFORM)
+			sprintf(msg, "micon_interrupts");
+#else
+			printk(KERN_ALERT "(1)The DISPLAY button was pressed\n");
+#endif
+			pin = BTN_DISP;
+		}
+		else if (smi_sts == IT87_DEB1){
+#if defined(CONFIG_BUFFALO_PLATFORM)
+			sprintf(msg, "micon_interrupts");
+#else
+			printk(KERN_ALERT "(2)The FUNCTION button was pressed\n");
+#endif
+			pin = BTN_FUNC;
+		}
+		//Setup timer for checking button gpio state
+ 		init_timer(&btn_timer);
+
+		btn_timer.expires = jiffies + TIMER_DELAY;
+		btn_timer.data = pin;
+		btn_timer.function = timer_function;
+	
+		add_timer(&btn_timer);
+#if defined(CONFIG_BUFFALO_PLATFORM)
+		if(msg[0] != '\0')
+			buffalo_kernevnt_queuein(msg);
+#endif
+	}
+	return IRQ_HANDLED;
+}
+
+static int
+read_button_status(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+	struct button_info_st *button_info = (struct button_info_st *)data;
+	unsigned char smi_sts;
+
+	EnterMBPnP();
+
+	//Get SMI status of two de-bounce pin
+	outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+	smi_sts = inb(CONFIG_DATA_PORT);
+	smi_sts &= IT87_SMI_DEB_MASK;
+
+	ExitMBPnP();
+
+	//Check which button was pressed
+	if ((smi_sts & button_info->reg_stat))
+		len = sprintf(page, "on\n");
+	else
+		len = sprintf(page, "off\n");
+
+	if(off > 0){
+		*eof = 1;
+		return 0;
+	}
+
+	*eof = 1;
+	return len;
+}
+
+/*+--------------------------------------------+
+Initial procedure, device driver interrupt 
+handler register IRQ3 and initialize the SIO(IT 
+8721) GPIO34/35.
+
+Returns:
++--------------------------------------------+*/
+static int __init matsubtn_init(void)
+{
+	int ret;
+
+        ret = request_irq(3, matsu_interrupt, IRQF_SHARED, DRVNAME, matsu_interrupt);
+    	if (ret){
+    		printk (KERN_ALERT "!!!!! Error requesting irq 3: returned %d\n", ret);
+		free_irq(3, 0);
+        	return -EBUSY;
+    	}
+ 
+	//Enter ITE config
+	EnterMBPnP();
+	
+	//Select LDN 07h	
+	outb(IT87_LDN_ADDR, CONFIG_ADDR_PORT);
+	outb(IT87_GPIO_LDN, CONFIG_DATA_PORT);
+	
+	//Set GPIO34/35 as De-bounce GPIO
+	outb(IT87_REG_PNL_DBOUNCE0, CONFIG_ADDR_PORT);
+	outb(IT87_GP34_LOC | IT87_IRQEN, CONFIG_DATA_PORT);
+	outb(IT87_REG_PNL_DBOUNCE1, CONFIG_ADDR_PORT);
+	outb(IT87_GP35_LOC, CONFIG_DATA_PORT);
+	
+	outb(IT87_REG_PNL_IRQ_SEL, CONFIG_ADDR_PORT);
+	outb(IT87_PNL_IRQ3, CONFIG_DATA_PORT);
+	//Exit ITE config
+	ExitMBPnP();
+
+#if defined(CONFIG_BUFFALO_PLATFORM)
+	//static struct proc_dir_entry *btn_ctrl_dir;
+	static struct proc_dir_entry *switch_dir;
+	static struct proc_dir_entry *switch_entry;
+	int i = 0;
+
+/*
+	btn_ctrl_dir = proc_mkdir(MODULE_DIR, NULL);
+	if(btn_ctrl_dir == NULL)
+	{
+		printk(KERN_ALERT "%s directory create failed.....\n", MODULE_DIR);
+		goto MODULE_DIR_FAIL;
+	}
+	printk(KERN_ALERT "%s directory create successful.....\n", MODULE_DIR);
+*/
+	switch_dir = proc_mkdir(SWITCH_DIR, NULL);
+	if(switch_dir == NULL)
+	{
+		printk(KERN_ALERT "%s directory create failed.....\n", SWITCH_DIR);
+		goto SWITCH_DIR_FAIL;
+	}
+	printk(KERN_ALERT "%s directory create successful.....\n", SWITCH_DIR);
+
+	for(i = 0; i < NUM_SUPPORTED_BUTTON_NUM; i++)
+	{
+		switch_entry = create_proc_read_entry(button_info[i].name, 0, switch_dir, read_button_status, NULL);
+		if(switch_entry == NULL)
+		{
+			printk(KERN_ALERT "%s/%s create failed.....\n", SWITCH_DIR, button_info[i].name);
+			goto SWITCH_FILE_FAIL;
+		}
+		printk(KERN_ALERT "%s/%s create successful.....\n", SWITCH_DIR, button_info[i].name);
+		switch_entry->data = (void *)&button_info[i];
+	}
+#endif
+
+	return 0;
+
+#if defined(CONFIG_BUFFALO_PLATFORM)
+SWITCH_FILE_FAIL:
+	for (i = 0; i < NUM_SUPPORTED_BUTTON_NUM; i++)
+	{
+		remove_proc_entry(button_info[i].name, switch_dir);
+	}
+
+SWITCH_DIR_FAIL:
+	remove_proc_entry(SWITCH_DIR, NULL);
+MODULE_DIR_FAIL:
+	return -1;
+#endif
+}
+
+/*+--------------------------------------------+
+Cleanup procedure, unregister IRQ3 and restore 
+system BIOS IT8721 GPIO34/35 settings.
+
+Returns:
++--------------------------------------------+*/
+
+static void __exit matsubtn_exit_cleanup(void)
+{
+	disable_irq(3);
+	free_irq(3, matsu_interrupt);
+	//Restore GPIO34/35 settings
+	EnterMBPnP();
+
+	outb(IT87_LDN_ADDR, CONFIG_ADDR_PORT);
+	outb(IT87_GPIO_LDN, CONFIG_DATA_PORT);
+	
+	outb(IT87_REG_PNL_DBOUNCE0, CONFIG_ADDR_PORT);
+	outb(0x00, CONFIG_DATA_PORT);
+	outb(IT87_REG_PNL_DBOUNCE1, CONFIG_ADDR_PORT);
+	outb(0x00, CONFIG_DATA_PORT);
+	
+	outb(IT87_REG_PNL_IRQ_SEL, CONFIG_ADDR_PORT);
+	outb(0x00, CONFIG_DATA_PORT);
+	
+	ExitMBPnP();
+
+	printk(KERN_INFO "MODULE %s %s HAS BEEN REMOVED!\n", DRVNAME, DRVVER);
+}
+
+module_init(matsubtn_init);
+module_exit(matsubtn_exit_cleanup);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-matsu/cmos_ctrl.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/cmos_ctrl.c
--- linux-3.10.69/arch/x86/plat-matsu/cmos_ctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/cmos_ctrl.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,335 @@
+/*****************************************************************************+
+ DESCRIPTION:  Matsu CMOS driver (sample)
+ AUTHOR:       Wayne Lai
+ DATE STARTED: August, 2010
+ PROJECT:      WS-QX2(Matsu)
+
+ Rev 0.2   August 12 2010
+ *******************************************************************************/
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <asm/delay.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+
+//I/O index
+#define	CMOS_INDEX_PORT		0x72
+#define	CMOS_DATA_PORT		0x73
+#define	POWER_OFFSET		0xAA
+#define	POWER_MASK		0xC0
+#define	WOL_OFFSET		0xC2
+#define	WOL_MASK		0x80
+
+//IOCTL interface command
+#define GET_POWER		1
+#define SET_POWER		2
+#define GET_WOL			3
+#define SET_WOL			4
+
+//Common section
+#define DRVVER			124		//device number
+#define	DRVNAME			"matsu_cmos"	//device name
+
+int cmos_major = DRVVER;
+char *cmos_devname = DRVNAME;
+
+extern struct class *matsu_cls;
+extern struct class *MatsuClassGet(void);
+
+#define AC_POWER_LOSS_POWER_OFF		0
+#define AC_POWER_LOSS_POWER_ON		1
+#define AC_POWER_LOSS_LAST_STATE	2
+
+#define WOL_ENABLE		0
+#define WOL_DISABLE		1
+
+struct matsu_cmos_power_value_to_str_st {
+	unsigned char value;
+	char str_value[16];
+} matsu_cmos_power_value_to_str[] = {
+	{AC_POWER_LOSS_POWER_OFF,	"off"},
+	{AC_POWER_LOSS_POWER_ON,	"on"},
+	{AC_POWER_LOSS_LAST_STATE,	"last_state"},
+};
+#define MAX_MATSU_CMOS_POWER_VALUE_TO_STR	(sizeof(matsu_cmos_power_value_to_str) / sizeof(matsu_cmos_power_value_to_str[0]))
+
+struct matsu_cmos_wol_value_to_str_st {
+	unsigned char value;
+	char str_value[16];
+} matsu_cmos_wol_value_to_str[] = {
+	{WOL_ENABLE,	"enable"},
+	{WOL_DISABLE,	"disable"},
+};
+#define MAX_MATSU_CMOS_WOL_VALUE_TO_STR		(sizeof(matsu_cmos_wol_value_to_str) / sizeof(matsu_cmos_wol_value_to_str[0]))
+
+/* Open the device */
+int cmos_open(struct inode *inode_ptr, struct file *fptr)
+{
+	printk("CMOS driver is opened\n");                    
+	return(0);
+}
+
+/* Close the device */
+int cmos_close(struct inode *inode_ptr, struct file *fptr)
+{
+	printk("CMOS driver is closed\n");
+	return(0);
+}
+
+static unsigned int
+matsu_cmos_get_power_setting(void)
+{
+	unsigned char	read_value;
+
+	outb(POWER_OFFSET, CMOS_INDEX_PORT);
+	read_value = inb(CMOS_DATA_PORT);
+	read_value&= POWER_MASK;
+	read_value = read_value >> 6;
+	printk("AC Power Loss is %d\n",read_value);
+	return (unsigned int)read_value;
+}
+
+static unsigned int
+matsu_cmos_set_power_setting(unsigned long set_value)
+{
+	unsigned int	write_data;
+
+	outb(POWER_OFFSET, CMOS_INDEX_PORT);
+	write_data = (unsigned int)set_value;
+	write_data = write_data << 6;
+	outb(write_data, CMOS_DATA_PORT);
+	write_data = write_data >> 6;
+	printk("set AC Power Loss to %d\n",write_data);
+	return 0;
+}
+
+static unsigned int
+matsu_cmos_get_wol_setting(void)
+{
+	unsigned char	read_value;
+
+	outb(WOL_OFFSET, CMOS_INDEX_PORT);
+	read_value = inb(CMOS_DATA_PORT);
+	read_value &= WOL_MASK;
+	read_value = read_value >> 7;
+	printk("Wake on LAN is %d\n",read_value);
+	return (unsigned int)read_value;
+}
+
+static unsigned int
+matsu_cmos_set_wol_setting(unsigned long set_value)
+{
+	unsigned int	write_data;
+
+	outb(WOL_OFFSET, CMOS_INDEX_PORT);
+	write_data = (unsigned int)set_value;
+	write_data = write_data << 7;
+	outb(write_data, CMOS_DATA_PORT);
+	write_data = write_data >> 7;
+	printk("set Wake on LAN to %d\n",write_data);
+	return 0;
+}
+
+// IOCTL interface for user to get and set
+int cmos_ioctl(struct inode * inode,struct file *file,unsigned int cmd, unsigned long para)
+{
+	unsigned int	ret = 0;
+
+	switch(cmd)
+	{
+		//interface to read AC Power Loss in CMOS
+		case GET_POWER:
+			ret = matsu_cmos_get_power_setting();
+			break;
+
+		//interface to write AC Power Loss in CMOS
+		case SET_POWER:
+			ret = matsu_cmos_set_power_setting(para);
+			break;
+
+		//interface to read wake on LAN in CMOS
+		case GET_WOL:
+			ret = matsu_cmos_get_wol_setting();
+			break;
+
+		//interface to write wake on LAN in CMOS
+		case SET_WOL:
+			ret = matsu_cmos_set_wol_setting(para);
+			break;
+
+		default:
+			printk("wrong command");
+			break;
+	}		 
+	return ret;
+}
+
+//file operations for this device.
+struct file_operations cmos_fops = {
+open: cmos_open,
+compat_ioctl: cmos_ioctl,
+release: cmos_close,
+owner: THIS_MODULE,
+};
+
+static ssize_t show_dev_number(struct device *dev, struct device_attribute *attr, char *buf)
+{
+        return sprintf(buf, "%d:%d\n", cmos_major, 0);
+}
+DEVICE_ATTR(matsu_cmos_dev, 0444, show_dev_number, NULL);
+
+static ssize_t show_power_setting(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	unsigned int value = matsu_cmos_get_power_setting();
+	char *str_value = NULL;
+	int i = 0;
+
+	for(i = 0; i < MAX_MATSU_CMOS_POWER_VALUE_TO_STR; i++)
+	{
+		if(value == matsu_cmos_power_value_to_str[i].value)
+		{
+			str_value = matsu_cmos_power_value_to_str[i].str_value;
+			break;
+		}
+	}
+	if(str_value == NULL)
+	{
+		printk("CMOS setting is broken\n");
+		return 0;
+	}
+
+        return sprintf(buf, "%s\n", str_value);
+}
+
+static ssize_t store_power_setting(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned int i = 0;
+        unsigned long tmp_value = (unsigned long)-1;
+
+	for(i = 0; i < strlen(buf); i++)
+	{
+		if(buf[i] == '\n')
+		{
+			buf[i] = 0;
+			break;
+		}
+	}
+
+	for(i = 0; i < MAX_MATSU_CMOS_POWER_VALUE_TO_STR; i++)
+	{
+		if((strlen(buf) == strlen(matsu_cmos_power_value_to_str[i].str_value)) && (strncmp(buf, matsu_cmos_power_value_to_str[i].str_value, strlen(matsu_cmos_power_value_to_str[i].str_value)) == 0))
+		{
+			tmp_value = matsu_cmos_power_value_to_str[i].value;
+			break;
+		}
+	}
+        if(tmp_value  == (unsigned long)-1)
+                return -EINVAL;
+
+	matsu_cmos_set_power_setting(tmp_value);
+        return count;
+}
+DEVICE_ATTR(power_setting, 0644, show_power_setting, store_power_setting);
+
+static ssize_t show_wol_setting(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	unsigned int value = matsu_cmos_get_wol_setting();
+	char *str_value = NULL;
+	int i = 0;
+
+	for(i = 0; i < MAX_MATSU_CMOS_WOL_VALUE_TO_STR; i++)
+	{
+		if(value == matsu_cmos_wol_value_to_str[i].value)
+		{
+			str_value = matsu_cmos_wol_value_to_str[i].str_value;
+		}
+	}
+	if(str_value == NULL)
+	{
+		printk("CMOS setting is broken\n");
+		return 0;
+	}
+        return sprintf(buf, "%s\n", str_value);
+}
+
+static ssize_t store_wol_setting(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned int i = 0;
+        unsigned long tmp_value = (unsigned long)-1;
+
+	for(i = 0; i < strlen(buf); i++)
+	{
+		if(buf[i] == '\n')
+		{
+			buf[i] = 0;
+			break;
+		}
+	}
+
+	for(i = 0; i < MAX_MATSU_CMOS_WOL_VALUE_TO_STR; i++)
+	{
+		if((strlen(buf) == strlen(matsu_cmos_wol_value_to_str[i].str_value)) && (strncmp(buf, matsu_cmos_wol_value_to_str[i].str_value, strlen(matsu_cmos_wol_value_to_str[i].str_value)) == 0))
+		{
+			tmp_value = matsu_cmos_wol_value_to_str[i].value;
+			break;
+		}
+	}
+        if(tmp_value == (unsigned long)-1)
+                return -EINVAL;
+
+	matsu_cmos_set_wol_setting(tmp_value);
+        return count;
+}
+DEVICE_ATTR(wol_setting, 0644, show_wol_setting, store_wol_setting);
+
+//register the device to kernel.
+static int __init matsucmos_init(void)
+{
+	int ret;
+	struct class *cls;
+
+	printk("enter cmos module init\n");
+
+	/* Register device, and may be allocating major# */
+	ret = register_chrdev(cmos_major, cmos_devname, &cmos_fops);
+	if(ret <0)
+	{
+		printk("%s cannot register\n", cmos_devname);
+		return(ret);
+	}
+	else
+	{
+		if(cmos_major==0)
+			cmos_major = ret;
+	}
+
+	cls = MatsuClassGet();
+	if(cls)
+	{
+		struct device *dev = device_create(cls, NULL, 0, NULL, "cmos");
+		int rv = 0;
+		rv = device_create_file(dev, &dev_attr_matsu_cmos_dev);
+		rv = device_create_file(dev, &dev_attr_power_setting);
+		rv = device_create_file(dev, &dev_attr_wol_setting);
+	}
+
+	return 0;
+}
+
+//unregister the device from kernel.
+static void __exit matsucmos_exit_cleanup(void)
+{
+	
+	printk(DRVNAME " CMOS MODULE HAS BEEN REMOVED!\n");
+	unregister_chrdev(cmos_major, cmos_devname);
+}
+
+module_init(matsucmos_init);
+module_exit(matsucmos_exit_cleanup);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-matsu/fan_ctrl.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/fan_ctrl.c
--- linux-3.10.69/arch/x86/plat-matsu/fan_ctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/fan_ctrl.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,591 @@
+/*****************************************************************************+
+ DESCRIPTION:  Matsu Fan driver (sample)
+ AUTHOR:       Wayne Lai
+ DATE STARTED: July, 2010
+ PROJECT:      WS-QX2(Matsu)
+
+ Rev 0.2   July 28 2010
+ - Initial revision.
+*******************************************************************************/
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+
+#include "fan_ctrl.h"
+
+//IT8721 registers section
+#define	IT87_EC_ADD_REG		0xA15
+#define	IT87_EC_DATA_REG	0xA16
+// ITE8721 EC FAN REGISTERS
+#define IT87_EC_FAN_MAIN_CTL	0x13
+#define IT87_EC_FAN_CTL		0x14
+#define IT87_EC_FAN_PWM1	0x15
+#define IT87_EC_FAN_PWM2	0x16
+#define IT87_EC_FAN_PWM3	0x17
+
+#define IT87_EC_FAN_SMART_PWM1	0x63
+#define IT87_EC_FAN_SMART_PWM2	0x6B
+#define IT87_EC_FAN_SMART_PWM3	0x73
+
+// ITE8721 EC FAN TACO REGISTERS
+#define IT87_EC_FAN_TACO1	0x0D
+#define IT87_EC_FAN_TACO2	0x0E
+#define IT87_EC_FAN_TACO3	0x0F
+#define IT87_EC_FAN_TACO4	0x80
+#define IT87_EC_FAN_TACO1_EXT	0x18
+#define IT87_EC_FAN_TACO2_EXT	0x19
+#define IT87_EC_FAN_TACO3_EXT	0x1A
+#define IT87_EC_FAN_TACO4_EXT	0x81
+
+// ITE8721 EC TEMPERATURE SENSOR
+#define IT87_EC_TMPIN1		0x29
+#define IT87_EC_TMPIN2		0x2A
+#define IT87_EC_TMPIN3		0x2B
+
+//Common section
+#define DRVVER			125		//device number
+#define	DRVNAME			"matsu_fan"	//device name
+
+//#define DEBUG
+#if defined(DEBUG)
+#define DPRINTK(fmt, args...)	printk(fmt, ##args)
+#else
+#define DPRINTK(fmt, atgs...)
+#endif
+
+int fan_major = DRVVER;
+char *fan_devname = DRVNAME;
+static unsigned int fan_threshold = 100;
+static unsigned char fan_stop_speed = 0;
+static unsigned char fan_slow_speed = 150;
+static unsigned char fan_fast_speed = 200;
+static unsigned char fan_full_speed = 255;
+static unsigned int flag_show_speed_by_string = 1;
+
+struct class *matsu_cls;
+
+struct fan_info_st {
+	uint8_t reg;
+	uint8_t reg_ext;
+	uint8_t reg_smart_pwm;
+	uint8_t reg_pwm;
+	uint8_t offset;
+} fan_info[] = {
+	{IT87_EC_FAN_TACO1, IT87_EC_FAN_TACO1_EXT, IT87_EC_FAN_SMART_PWM1, IT87_EC_FAN_PWM1, 0x1},
+	{IT87_EC_FAN_TACO2, IT87_EC_FAN_TACO2_EXT, IT87_EC_FAN_SMART_PWM2, IT87_EC_FAN_PWM2, 0x2},
+	{IT87_EC_FAN_TACO3, IT87_EC_FAN_TACO3_EXT, IT87_EC_FAN_SMART_PWM3, IT87_EC_FAN_PWM3, 0x4},
+	{IT87_EC_FAN_TACO4, IT87_EC_FAN_TACO4_EXT, 0, 0, 0},
+};
+
+struct temp_info_st {
+	uint8_t reg;
+} temp_info[] = {
+	{IT87_EC_TMPIN1},
+	{IT87_EC_TMPIN2},
+	{IT87_EC_TMPIN3},
+};
+
+/* Open the device */
+int fan_open(struct inode *inode_ptr, struct file *fptr)
+{
+	DPRINTK("Fan driver is opened\n");                    
+	return(0);
+}
+
+/* Close the device */
+int fan_close(struct inode *inode_ptr, struct file *fptr)
+{
+	DPRINTK("Fan driver is closed\n");
+	return(0);
+}
+
+unsigned int get_fan_rpm(unsigned char fan_num)
+{
+	unsigned char	read_value, read_value_ext;
+	unsigned int	ret = 0;
+	unsigned int	retry_max = 5;
+
+	for(retry_max = 5; retry_max > 0; retry_max--)
+	{
+		outb(fan_info[fan_num].reg, IT87_EC_ADD_REG);
+		read_value = inb(IT87_EC_DATA_REG);
+		outb(fan_info[fan_num].reg_ext, IT87_EC_ADD_REG);
+		read_value_ext = inb(IT87_EC_DATA_REG);
+		if(read_value_ext != 0 || read_value != 0)
+			ret = 1350000/(read_value_ext*256+read_value)/2;
+		else
+			ret = 0;
+
+		if(ret <= 16500 && ret > 0)
+			break;
+		else
+			printk("read_value_ext=%d : read_value=%d\n", read_value_ext, read_value);
+		mdelay(100);
+	}
+
+	DPRINTK("FAN%d speed is %d\n", fan_num + 1, ret);
+	if(ret < fan_threshold)
+		ret = 0;
+	return ret;
+}
+
+unsigned int get_temp(unsigned char temp_num)
+{
+	unsigned char	read_value;
+	unsigned int	ret = 0;
+
+	outb(temp_info[temp_num].reg, IT87_EC_ADD_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	DPRINTK("TEMP%d is %d\n", temp_num + 1, read_value);
+	ret = read_value;
+	return ret;
+}
+
+unsigned int set_fan_speed(unsigned char fan_num, unsigned char set_val)
+{
+	unsigned int	write_data;
+	unsigned char	read_value;
+
+	if(fan_info[fan_num].reg_smart_pwm == 0 ||
+		fan_info[fan_num].reg_pwm == 0)
+	{
+		return -EINVAL;
+	}
+
+	outb(IT87_EC_FAN_MAIN_CTL, IT87_EC_ADD_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value |= fan_info[fan_num].offset;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	write_data = set_val;
+	outb(fan_info[fan_num].reg_smart_pwm, IT87_EC_ADD_REG);
+	outb(write_data, IT87_EC_DATA_REG);
+
+	outb(fan_info[fan_num].reg_pwm, IT87_EC_ADD_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value &= 0x7F;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	DPRINTK("set FAN%d speed %d\n", fan_num + 1, write_data);
+	return 0;
+}
+
+unsigned int get_fan_speed(unsigned char fan_num)
+{
+	unsigned char	read_value;
+
+	outb(IT87_EC_FAN_MAIN_CTL, IT87_EC_ADD_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value |= fan_info[fan_num].offset;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	outb(fan_info[fan_num].reg_smart_pwm, IT87_EC_ADD_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+
+	return read_value;
+}
+
+// IOCTL interface for user to get and set
+int fan_ioctl(struct inode * inode,struct file *file,unsigned int cmd, unsigned long para)
+{
+	unsigned int	ret = 0;
+	unsigned char dev_id = (unsigned char)(cmd & ~IOCTL_CMD_MASK);
+
+	switch(cmd & IOCTL_CMD_MASK)
+	{
+		case GET_TEMP_CMD_BASE:
+			//interface to read temperature sensor 1
+			//interface to read temperature sensor 2
+			//interface to read temperature sensor 3
+			if(dev_id > MAX_GET_TEMP)
+				goto IOCTL_WRONG_CMD;
+
+			ret = get_temp(dev_id);
+			break;
+		case GET_FAN_CMD_BASE:
+			//interface to read FAN1 speed.(In 1U)
+			//interface to read FAN2 speed.(In 1U)
+			//interface to read FAN3 speed.(In Box)
+			if(dev_id > MAX_GET_FAN)
+				goto IOCTL_WRONG_CMD;
+
+			ret = get_fan_rpm(dev_id);
+			break;
+		case SET_FAN_CMD_BASE:
+			//interface to set FAN1 speed.(In 1U)
+			//interface to set FAN2 speed.(In 1U)
+			//interface to set FAN3 speed.(In Box)
+			//interface to read FAN4 speed.(In Box)
+			if(dev_id > MAX_SET_FAN)
+				goto IOCTL_WRONG_CMD;
+
+			ret = set_fan_speed(dev_id, (unsigned char )para);
+			break;
+		default:
+			goto IOCTL_WRONG_CMD;
+			break;
+	}		 
+	return ret;
+
+IOCTL_WRONG_CMD:
+	printk("wrong command");
+	return ret;
+}
+
+//file operations for this device.
+struct file_operations fan_fops = {
+	.open = fan_open,
+	.compat_ioctl = fan_ioctl,
+	.release = fan_close,
+	.owner = THIS_MODULE,
+};
+
+struct class *MatsuClassGet(void)
+{
+	struct class *tmp_cls;
+
+	if(matsu_cls)
+		return matsu_cls;
+
+	tmp_cls = class_create(THIS_MODULE, "matsu");
+	if(IS_ERR(tmp_cls))
+	{
+		printk("%s : class_create failed.", __FUNCTION__);
+		return NULL;
+	}
+
+	matsu_cls = tmp_cls;
+	return matsu_cls;
+}
+
+static ssize_t show_dev_number(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d:%d\n", fan_major, 0);
+}
+DEVICE_ATTR(matsu_fan_dev, 0444, show_dev_number, NULL);
+
+static ssize_t show_fan1_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(0));
+}
+
+static ssize_t show_fan2_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(1));
+}
+
+static ssize_t show_fan3_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(2));
+}
+
+static ssize_t show_fan4_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(3));
+}
+DEVICE_ATTR(fan1_rpm, 0444, show_fan1_rpm, NULL);
+DEVICE_ATTR(fan2_rpm, 0444, show_fan2_rpm, NULL);
+DEVICE_ATTR(fan3_rpm, 0444, show_fan3_rpm, NULL);
+DEVICE_ATTR(fan4_rpm, 0444, show_fan4_rpm, NULL);
+
+static ssize_t show_temp1(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_temp(0));
+}
+
+static ssize_t show_temp2(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_temp(1));
+}
+
+static ssize_t show_temp3(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_temp(2));
+}
+DEVICE_ATTR(temp1, 0444, show_temp1, NULL);
+DEVICE_ATTR(temp2, 0444, show_temp2, NULL);
+DEVICE_ATTR(temp3, 0444, show_temp3, NULL);
+
+static unsigned long fan_speed_str_to_ul(const char *buf)
+{
+	if((strncmp(buf, "stop", strlen("stop")) == 0))
+		return fan_stop_speed;
+	else if((strncmp(buf, "slow", strlen("slow")) == 0))
+		return fan_slow_speed;
+	else if((strncmp(buf, "fast", strlen("fast")) == 0))
+		return fan_fast_speed;
+	else if((strncmp(buf, "full", strlen("full")) == 0))
+		return fan_full_speed;
+
+	return simple_strtoul(buf, NULL, 10);
+}
+
+static unsigned long fan_speed_ul_to_str(const char *buf, size_t len, unsigned long speed)
+{
+	if(speed <= fan_stop_speed)
+		snprintf(buf, len, "stop");
+	else if(speed > fan_stop_speed && speed <= fan_slow_speed)
+		snprintf(buf, len, "slow");
+	else if(speed > fan_slow_speed && speed <= fan_fast_speed)
+		snprintf(buf, len, "fast");
+	else if(speed > fan_fast_speed)
+		snprintf(buf, len, "full");
+	else
+		snprintf(buf, len, "Unknown");
+}
+
+static ssize_t show_fan1_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(flag_show_speed_by_string == 1)
+	{
+		char szSpeed[32];
+		fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(0));
+		sprintf(buf, "%s\n", szSpeed);
+	}
+	else
+		return sprintf(buf, "%d\n", get_fan_speed(0));
+}
+
+static ssize_t store_fan1_speed(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((const char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(0, (unsigned char)(write_val & 0xff));
+	return count;
+}
+
+static ssize_t show_fan2_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(flag_show_speed_by_string == 1)
+	{
+		char szSpeed[32];
+		fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(1));
+		sprintf(buf, "%s\n", szSpeed);
+	}
+	else
+		return sprintf(buf, "%d\n", get_fan_speed(1));
+}
+
+static ssize_t store_fan2_speed(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((const char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(1, (unsigned char)(write_val & 0xff));
+	return count;
+}
+
+static ssize_t show_fan3_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(flag_show_speed_by_string == 1)
+	{
+		char szSpeed[32];
+		fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(2));
+		sprintf(buf, "%s\n", szSpeed);
+	}
+	else
+		return sprintf(buf, "%d\n", get_fan_speed(2));
+}
+
+static ssize_t store_fan3_speed(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((const char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(2, (unsigned char)(write_val & 0xff));
+	return count;
+}
+
+static ssize_t show_fan4_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(flag_show_speed_by_string == 1)
+	{
+		char szSpeed[32];
+		fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(3));
+		sprintf(buf, "%s\n", szSpeed);
+	}
+	else
+		return sprintf(buf, "%d\n", get_fan_speed(3));
+}
+
+static ssize_t store_fan4_speed(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((const char*) buf );
+	
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(3, (unsigned char)(write_val & 0xff));
+	return count;
+}
+
+static ssize_t show_show_speed_by_string(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", flag_show_speed_by_string);
+}
+
+static ssize_t store_show_speed_by_string(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned long value = simple_strtoul(buf, NULL, 10);
+	
+	if(value != 0 && value != 1)
+		return -EINVAL;
+
+	flag_show_speed_by_string = value;
+
+	return count;
+}
+
+DEVICE_ATTR(fan1_speed, 0644, show_fan1_speed, store_fan1_speed);
+DEVICE_ATTR(fan2_speed, 0644, show_fan2_speed, store_fan2_speed);
+DEVICE_ATTR(fan3_speed, 0644, show_fan3_speed, store_fan3_speed);
+DEVICE_ATTR(fan4_speed, 0644, show_fan4_speed, store_fan4_speed);
+DEVICE_ATTR(show_speed_by_string, 0644, show_show_speed_by_string, store_show_speed_by_string);
+
+static ssize_t show_fan_threshold(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_threshold);
+}
+
+static ssize_t store_fan_threshold(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	fan_threshold = simple_strtoul(buf, NULL, 10);
+	return count;
+}
+DEVICE_ATTR(fan_threshold, 0644, show_fan_threshold, store_fan_threshold);
+
+static ssize_t show_fan_stop_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_stop_speed);
+}
+
+static ssize_t store_fan_stop_speed(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xff)
+		return -EINVAL;
+
+	fan_stop_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_slow_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_slow_speed);
+}
+
+static ssize_t store_fan_slow_speed(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xff)
+		return -EINVAL;
+
+	fan_slow_speed = tmp_speed;
+	return count;
+}
+static ssize_t show_fan_fast_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_fast_speed);
+}
+
+static ssize_t store_fan_fast_speed(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xff)
+		return -EINVAL;
+
+	fan_fast_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_full_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_full_speed);
+}
+
+static ssize_t store_fan_full_speed(struct device *dev, struct device_attribute *attr, char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xff)
+		return -EINVAL;
+
+	fan_full_speed = tmp_speed;
+	return count;
+}
+DEVICE_ATTR(fan_stop_speed, 0644, show_fan_stop_speed, store_fan_stop_speed);
+DEVICE_ATTR(fan_slow_speed, 0644, show_fan_slow_speed, store_fan_slow_speed);
+DEVICE_ATTR(fan_fast_speed, 0644, show_fan_fast_speed, store_fan_fast_speed);
+DEVICE_ATTR(fan_full_speed, 0644, show_fan_full_speed, store_fan_full_speed);
+
+//register the device to kernel.
+static int __init matsufan_init(void)
+{
+	int ret;
+	struct class *cls;
+
+	printk("enter fan module init\n");
+
+	/* Register device, and may be allocating major# */
+	ret = register_chrdev(fan_major, fan_devname, &fan_fops);
+	if(ret <0)
+	{
+		printk("%s cannot register\n", fan_devname);
+		return(ret);
+	}
+	else
+	{
+		if(fan_major==0)
+			fan_major = ret;
+	}
+
+	cls = MatsuClassGet();
+	if(cls)
+	{
+		struct device *dev = device_create(cls, NULL, 0, NULL, "fan");
+		int rv = 0;
+		rv = device_create_file(dev, &dev_attr_matsu_fan_dev);
+		rv = device_create_file(dev, &dev_attr_fan1_rpm);
+		rv = device_create_file(dev, &dev_attr_fan2_rpm);
+		rv = device_create_file(dev, &dev_attr_fan3_rpm);
+		rv = device_create_file(dev, &dev_attr_fan4_rpm);
+		rv = device_create_file(dev, &dev_attr_temp1);
+		rv = device_create_file(dev, &dev_attr_temp2);
+		rv = device_create_file(dev, &dev_attr_temp3);
+		rv = device_create_file(dev, &dev_attr_fan1_speed);
+		rv = device_create_file(dev, &dev_attr_fan2_speed);
+		rv = device_create_file(dev, &dev_attr_fan3_speed);
+		rv = device_create_file(dev, &dev_attr_fan4_speed);
+		rv = device_create_file(dev, &dev_attr_fan_threshold);
+		rv = device_create_file(dev, &dev_attr_fan_stop_speed);
+		rv = device_create_file(dev, &dev_attr_fan_slow_speed);
+		rv = device_create_file(dev, &dev_attr_fan_fast_speed);
+		rv = device_create_file(dev, &dev_attr_fan_full_speed);
+		rv = device_create_file(dev, &dev_attr_show_speed_by_string);
+	}
+
+	return 0;
+}
+
+//unregister the device from kernel.
+static void __exit matsufan_exit_cleanup(void)
+{
+	
+	printk(DRVNAME " MODULE HAS BEEN REMOVED!\n");
+	unregister_chrdev(fan_major, fan_devname);
+}
+
+module_init(matsufan_init);
+module_exit(matsufan_exit_cleanup);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-matsu/fan_ctrl.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/fan_ctrl.h
--- linux-3.10.69/arch/x86/plat-matsu/fan_ctrl.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/fan_ctrl.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,19 @@
+#if defined(__FAN_CTRL_H__)
+#else
+
+#define __FAN_CTRL_H__
+
+//IOCTL interface command
+#define GET_TEMP_CMD_BASE		0x100
+#define MAX_GET_TEMP			3
+#define GET_FAN_CMD_BASE		0x200
+#define MAX_GET_FAN			4
+#define SET_FAN_CMD_BASE		0x400
+#define MAX_SET_FAN			3
+#define IOCTL_CMD_MASK			0xFFFFFF00
+
+#define GET_TEMP(x)		((x >= 0 && x < MAX_GET_TEMP)? (GET_TEMP_CMD_BASE + x):-1)
+#define GET_FAN(x)		((x >= 0 && x < MAX_GET_FAN)? (GET_FAN_CMD_BASE + x):-1)
+#define SET_FAN(x)		((x >= 0 && x < MAX_SET_FAN)? (SET_FAN_CMD_BASE + x):-1)
+
+#endif
diff -rubB --new-file linux-3.10.69/arch/x86/plat-matsu/hdd_ctrl.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/hdd_ctrl.c
--- linux-3.10.69/arch/x86/plat-matsu/hdd_ctrl.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/hdd_ctrl.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,405 @@
+/*
+ * HDD control driver - 0.1
+ * 1. Detect if HDD is presented or not.
+ * 2. Get the power status of HDD.
+ * 3. Set the power status of HDD.
+ *
+ * Author: Simon Chang, USI.
+ *
+ * HDD control driver - 0.2
+ * Extented to support 8 HDD
+ *
+ * Author: Wayne Lai, USI.
+ *
+ * History:
+ * 0.1 Initial version for 4 HDDs.
+ * 0.2 Extented to support 8 HDDs.
+ */
+
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/proc_fs.h>
+#include <linux/timer.h>
+#include <asm/uaccess.h>
+#include "hdd_ctrl.h"
+#include "buffalo/kernevnt.h"
+
+#define HDD_CTRL_MODULE_VERSION "0.2"
+#define HDD_CTRL_MODULE_NAME "hdd control module"
+
+static unsigned int ich9r_gpio_base_addr;
+
+struct matsu_hdd_info_st {
+	uint32_t HDD_GPIO_PRESENT_REG;
+	uint32_t HDD_PRESENT_BIT;
+	uint32_t HDD_GPIO_POWER_REG;
+	uint32_t HDD_POWER_BIT;
+	uint32_t HDD_POWER_MASK;
+};
+
+static struct matsu_hdd_info_st matsu_hdd_info[] = {
+	{GP_LVL,	HDD0_PRESENT_BIT,	GP_LVL,		HDD0_POWER_BIT,	HDD0_POWER_MASK},
+	{GP_LVL,	HDD1_PRESENT_BIT,	GP_LVL,		HDD1_POWER_BIT,	HDD1_POWER_MASK},
+	{GP_LVL,	HDD2_PRESENT_BIT,	GP_LVL,		HDD2_POWER_BIT,	HDD2_POWER_MASK},
+	{GP_LVL,	HDD3_PRESENT_BIT,	GP_LVL,		HDD3_POWER_BIT,	HDD3_POWER_MASK},
+	{GP_LVL,	HDD4_PRESENT_BIT,	GP_LVL,		HDD4_POWER_BIT,	HDD4_POWER_MASK},
+	{GP_LVL,	HDD5_PRESENT_BIT,	GP_LVL2,	HDD5_POWER_BIT,	HDD5_POWER_MASK},
+	{GP_LVL,	HDD6_PRESENT_BIT,	GP_LVL2,	HDD6_POWER_BIT,	HDD6_POWER_MASK},
+	{GP_LVL,	HDD7_PRESENT_BIT,	GP_LVL2,	HDD7_POWER_BIT,	HDD7_POWER_MASK},
+};
+
+static struct proc_dir_entry *hdd_power_dir;
+static struct proc_dir_entry *hdd_present_dir;
+
+#define PLUGGED_EVENT_MSG       "SATA %d plugged"
+#define UNPLUGGED_EVENT_MSG     "SATA %d unplugged"
+
+// for polling timer
+#define SATA_POL_INTERVAL       HZ/100
+//#define SATA_POL_INTERVAL       HZ/1
+#define SATA_POL_LOOPS          10
+
+struct timer_list sata_hotplug_polling_timer;
+struct sata_hotplug_data_st sata_hotplug_data[MAX_SUPPORTED_DISKS];
+
+/*******************************************************************************
+* function: find_ich9_gpio_base_addr
+* argument:
+* retvalue:
+*******************************************************************************/
+static int find_ich9_gpio_base_addr(void)
+{
+	struct pci_dev *pdev = NULL;
+
+	pdev = pci_get_device(INTEL_ICH9R_VENDOR_ID, INTEL_ICH9R_DEVICE_ID, NULL);
+	if (!pdev) return -ENODEV;
+	pci_read_config_dword(pdev, GPIO_BAR_OFFSET, &ich9r_gpio_base_addr);
+	ich9r_gpio_base_addr &= 0x0000ff80;
+
+	return 0;
+}
+
+/*******************************************************************************
+* function: read_hdd_present_status
+* argument:
+* retvalue:
+*******************************************************************************/
+static int read_hdd_present_status(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+	struct matsu_hdd_info_st *hdd_info = (struct matsu_hdd_info_st *)data;
+	if (off > 0) {
+		*eof = 1;
+		return 0;
+	}
+
+	if (inl(ich9r_gpio_base_addr + hdd_info->HDD_GPIO_PRESENT_REG) & hdd_info->HDD_PRESENT_BIT)
+		len = sprintf(page, "unplugged\n");
+	else
+		len = sprintf(page, "plugged\n");
+
+	*eof = 1;
+	return len;
+}
+
+/*******************************************************************************
+* function: read_hdd_power_status
+* argument:
+* retvalue:
+*******************************************************************************/
+static int read_hdd_power_status(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+	struct matsu_hdd_info_st *hdd_info = (struct matsu_hdd_info_st *)data;
+
+	if (off > 0) {
+		*eof = 1;
+		return 0;
+	}
+
+	if (inl(ich9r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG) & hdd_info->HDD_POWER_BIT)
+		len = sprintf(page, "on\n");
+	else
+		len = sprintf(page, "off\n");
+
+	*eof = 1;
+	return len;
+
+}
+
+/*******************************************************************************
+* function: set_hdd_power
+* argument:
+* retvalue:
+*******************************************************************************/
+static int set_hdd_power(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	int tmpgpioval;
+	struct matsu_hdd_info_st *hdd_info = (struct matsu_hdd_info_st *)data;
+
+	tmpgpioval = inl(ich9r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG);
+
+	if (strncmp(buffer, "off", 3) == 0) {
+		if (tmpgpioval & hdd_info->HDD_POWER_BIT) {
+			tmpgpioval &= hdd_info->HDD_POWER_MASK;
+			outl(tmpgpioval, ich9r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG);
+		}
+	}
+	else if (strncmp(buffer, "on", 2) == 0) {
+		if ((tmpgpioval & hdd_info->HDD_POWER_BIT) != hdd_info->HDD_POWER_BIT) {
+			tmpgpioval |= hdd_info->HDD_POWER_BIT;
+			outl(tmpgpioval, ich9r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG);
+		}
+	}
+	else {
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+/*******************************************************************************
+* function: init_proc_files
+* argument:
+* retvalue:
+* description: create procfs for hdd control:
+/ --- proc --- buffalo --- gpio -+- hotplug -+- sata0
+                                 |           +- sata1
+                                 |           +- sata2
+                                 |           +- sata3
+                                 |           +- sata4
+                                 |           +- sata5
+                                 |           +- sata6
+                                 |           +- sata7
+                                 |
+                                 +- power_control -+- hdd0
+                                                   +- hdd1
+                                                   +- hdd2
+                                                   +- hdd3
+                                                   +- hdd4
+                                                   +- hdd5
+                                                   +- hdd6
+                                                   +- hdd7
+*******************************************************************************/
+static int init_proc_files(void)
+{
+	int retval = 0;
+	int i = 0;
+	char buf[32];
+
+	/* declare for file and directory of procfs */
+	static struct proc_dir_entry *hdd_ctrl_dir;
+
+	static struct proc_dir_entry *hdd_present_status_file[MAX_SUPPORTED_DISKS];
+	static struct proc_dir_entry *hdd_power_status_file[MAX_SUPPORTED_DISKS];
+
+	// Create /proc/buffalo/gpio directory
+	hdd_ctrl_dir = proc_mkdir(MODULE_DIR, NULL);
+	if(hdd_ctrl_dir == NULL) {
+		printk(KERN_ALERT "buffalo/gpio directory create fail.....\n");
+		goto MODULE_DIR_FAIL;
+	}
+	printk(KERN_ALERT "buffalo/gpio directory create successful.....\n");
+
+	// Create /proc/buffalo/gpio/hotplug directory
+	hdd_present_dir = proc_mkdir(HDD_PRESENT_DIR, NULL);
+	if(hdd_present_dir == NULL) {
+		printk(KERN_ALERT "hotplug directory create fail.....\n");
+		goto PRESENT_DIR_FAIL;
+	}
+	printk(KERN_ALERT "hotplug directory create successful.....\n");
+
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		hdd_present_status_file[i] = create_proc_read_entry(buf, 0, hdd_present_dir, read_hdd_present_status, NULL);
+		if(hdd_present_status_file[i] == NULL)
+		{
+			printk(KERN_ALERT "HDD%d_PRESENT_STATUS_FILE create fail.....\n", i);
+			goto HDD_PRESENT_STATUS_FILE_FAIL;
+		}
+		printk(KERN_ALERT "HDD%d_PRESENT_STATUS_FILE create successful.....\n", i);
+		hdd_present_status_file[i]->data = (void *)&matsu_hdd_info[i];
+	}
+
+	// Create /proc/buffalo/gpio/power_control directory
+	hdd_power_dir = proc_mkdir(HDD_POWER_DIR, NULL);
+	if(hdd_power_dir == NULL) {
+		printk(KERN_ALERT "power_control directory create fail.....\n");
+		goto HDD_POWER_DIR_FAIL;
+	}
+	printk(KERN_ALERT "power_control directory create successful.....\n");
+
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		hdd_power_status_file[i] = create_proc_entry(buf, 0644, hdd_power_dir);
+		if(hdd_power_status_file[i] == NULL)
+		{
+			printk(KERN_ALERT "HDD%d_POWER_STATUS_FILE create fail.....\n", i);
+			goto HDD_POWER_STATUS_FILE_FAIL;
+		}
+		printk(KERN_ALERT "HDD%d_POWER_STATUS_FILE create successful.....\n", i);
+		hdd_power_status_file[i]->read_proc = &read_hdd_power_status;
+		hdd_power_status_file[i]->write_proc = &set_hdd_power;
+		hdd_power_status_file[i]->data = (void *)&matsu_hdd_info[i];
+	}
+
+	goto INIT_OK;
+
+HDD_POWER_STATUS_FILE_FAIL:
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		remove_proc_entry(buf, hdd_power_dir);
+	}
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+
+HDD_POWER_DIR_FAIL:
+HDD_PRESENT_STATUS_FILE_FAIL:
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		remove_proc_entry(buf, hdd_present_dir);
+	}
+
+	remove_proc_entry(HDD_PRESENT_DIR, NULL);
+
+PRESENT_DIR_FAIL:
+	remove_proc_entry(MODULE_DIR, NULL);
+
+MODULE_DIR_FAIL:
+	retval = -ENOMEM;
+
+INIT_OK:
+	return retval;
+}
+
+///////////////// for hotplug /////////////
+static void SataHotplugPollingUpdatePinstat(void)
+{
+	unsigned int i = 0;
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sata_hotplug_data[i].presentpinstat = (inl(ich9r_gpio_base_addr + matsu_hdd_info[i].HDD_GPIO_PRESENT_REG) & matsu_hdd_info[i].HDD_PRESENT_BIT)? SATA_STAT_UNPLUGGED:SATA_STAT_PLUGGED;
+	}
+
+}
+
+static void SataHotplugPolling(void)
+{
+	//printk("%s : entered\n", __FUNCTION__);
+	unsigned int i = 0;
+	char buf[32];
+
+	SataHotplugPollingUpdatePinstat();
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		//printk("sata_hotplug_data[%d].prevplugstat=%d : sata_hotplug_data[%d].presentpinstat=%d\n", i, sata_hotplug_data[i].prevplugstat, i, sata_hotplug_data[i].presentpinstat);
+		if(sata_hotplug_data[i].prevplugstat == sata_hotplug_data[i].presentpinstat)
+		{
+			sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+			continue;
+		}
+		--sata_hotplug_data[i].loops;
+		//printk("sata_hotplug_data[%d].loops=%d\n", i, sata_hotplug_data[i].loops);
+
+		if(sata_hotplug_data[i].loops == 0)
+		{
+			if(sata_hotplug_data[i].presentpinstat == SATA_STAT_PLUGGED)
+				sprintf(buf, PLUGGED_EVENT_MSG, i);
+			else
+				sprintf(buf, UNPLUGGED_EVENT_MSG, i);
+
+			buffalo_kernevnt_queuein(buf);
+			sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+			sata_hotplug_data[i].prevplugstat = sata_hotplug_data[i].presentpinstat;
+		}
+	}
+	sata_hotplug_polling_timer.expires += SATA_POL_INTERVAL;
+	add_timer(&sata_hotplug_polling_timer);
+}
+
+static unsigned long
+SataHotplugPollingStart(void)
+{
+	unsigned int i = 0;
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sata_hotplug_data[i].prevplugstat = SATA_STAT_UNKNOWN;
+		sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+	}
+
+        init_timer(&sata_hotplug_polling_timer);
+        sata_hotplug_polling_timer.expires = jiffies + SATA_POL_INTERVAL;
+        sata_hotplug_polling_timer.function = SataHotplugPolling;
+        sata_hotplug_polling_timer.data = NULL;
+        add_timer(&sata_hotplug_polling_timer);
+
+        return 0;
+}
+
+
+///////////////// for hotplug /////////////
+
+/*******************************************************************************
+* function: hdd_ctrl_init
+* argument:
+* retvalue:
+*******************************************************************************/
+static int __init hdd_ctrl_init(void)
+{
+	printk(KERN_ALERT "[%s init proc]\n", HDD_CTRL_MODULE_NAME);
+
+	/* find intel ich9 device */
+	if (find_ich9_gpio_base_addr()) return -ENODEV;
+
+	/* create files within proc filesystem */
+	if (init_proc_files()) return -ENOMEM;
+
+#if defined(CONFIG_BUFFALO_MATSU_USE_EVT_BOARD)
+	printk(KERN_INFO "*****\n\nCaution! This kernel working as EVT board mode.\n\n*****\n");
+#endif
+	SataHotplugPollingStart();
+
+	/* everything initialized */
+	printk(KERN_INFO "%s %s initialized...\n",HDD_CTRL_MODULE_NAME, HDD_CTRL_MODULE_VERSION);
+	return 0;
+}
+/*******************************************************************************
+* function: hdd_ctrl_exit
+* argument:
+* retvalue:
+*******************************************************************************/
+static void __exit hdd_ctrl_exit(void)
+{
+	printk(KERN_ALERT "[%s exit proc]\n", HDD_CTRL_MODULE_NAME);
+	int i = 0;
+	char buf[32];
+
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		remove_proc_entry(buf, hdd_power_dir);
+	}
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		remove_proc_entry(buf, hdd_present_dir);
+	}
+	remove_proc_entry(HDD_PRESENT_DIR, NULL);
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+	remove_proc_entry(MODULE_DIR, NULL);
+	printk(KERN_ALERT "hdd ctrl exit successfully....\n");
+}
+
+module_init (hdd_ctrl_init);
+module_exit (hdd_ctrl_exit);
+
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-matsu/hdd_ctrl.c.head F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/hdd_ctrl.c.head
--- linux-3.10.69/arch/x86/plat-matsu/hdd_ctrl.c.head	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/hdd_ctrl.c.head	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,392 @@
+/*
+ * USB to SATA Box driver - 1.0
+ *
+ * This driver is based on the 2.6.3 version of drivers/usb/usb-skeleton.c
+ * but has been rewritten to be easy to read and use, as no locks are now
+ * needed anymore.
+ *
+ * Author: Simon Chang, USI.
+ *
+ */
+
+//#include <linux/config.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kref.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/irq.h>
+#include <asm/uaccess.h>
+#include "hdd_ctrl.h"
+
+#define HDD_CTRL_MODULE_VERSION "0.1"
+#define HDD_CTRL_MODULE_NAME "matsu_hdd_ctl"
+
+#define PLUGGED_EVENT_MSG       "SATA %d plugged"
+#define UNPLUGGED_EVENT_MSG     "SATA %d unplugged"
+
+// for polling timer
+#define SATA_POL_INTERVAL       HZ/100
+#define SATA_POL_LOOPS          10
+
+#define SATAHOT_IRQ_BASE	80
+
+unsigned int ich9r_gpio_base_addr;
+
+typedef enum _sata_plug_state {
+	SATA_STAT_UNKNOWN,
+	SATA_STAT_PLUGGED,
+	SATA_STAT_UNPLUGGED,
+}SATA_PLUG_STATE;
+
+struct sata_hotplug_data {
+	struct timer_list timer;
+	uint32_t pin;
+	uint8_t prevpinstat;
+	SATA_PLUG_STATE prevplugstat;
+	unsigned int loops;
+	void *dev_id;
+};
+
+struct matsu_hdd_info_st {
+	uint32_t HDD_PRESENT_BIT;
+	uint32_t HDD_POWER_BIT;
+	uint32_t HDD_POWER_MASK;
+};
+
+static struct matsu_hdd_info_st matsu_hdd_info[] = {
+	{HDD0_PRESENT_BIT,	HDD0_POWER_BIT,	HDD0_POWER_MASK},
+	{HDD1_PRESENT_BIT,	HDD1_POWER_BIT,	HDD1_POWER_MASK},
+	{HDD2_PRESENT_BIT,	HDD2_POWER_BIT,	HDD2_POWER_MASK},
+	{HDD3_PRESENT_BIT,	HDD3_POWER_BIT,	HDD3_POWER_MASK},
+};
+
+static void PollingSATAHotplug(unsigned long arg)
+{
+	struct sata_hotplug_data *data = (struct sata_hotplug_data *)arg;
+	uint8_t pinstat = inl(ich9r_gpio_base_addr + GP_LVL) & data->pin;
+	SATA_PLUG_STATE plugstat;
+
+	char buf[32];
+
+	if (data->prevpinstat == pinstat)
+		--data->loops;
+	else
+		data->loops = SATA_POL_LOOPS;
+
+	if (data->loops) {
+		data->timer.expires += SATA_POL_INTERVAL;
+		data->prevpinstat = pinstat;
+		add_timer(&data->timer);
+        }
+	else {
+/*
+		if (pinstat & bfGppPolarityRegBitTest(data->pin))
+			plugstat = SATA_STAT_PLUGGED;
+		else if (!pinstat & bfGppPolarityRegBitTest(data->pin))
+			plugstat = SATA_STAT_UNPLUGGED;
+		else if (pinstat & !bfGppPolarityRegBitTest(data->pin))
+			plugstat = SATA_STAT_UNPLUGGED;
+		else
+			plugstat = SATA_STAT_PLUGGED;
+
+		if (plugstat == SATA_STAT_PLUGGED)
+			sprintf(buf, PLUGGED_EVENT_MSG, (int)data->dev_id);
+		else
+			sprintf(buf, UNPLUGGED_EVENT_MSG, (int)data->dev_id);
+
+		if (plugstat == SATA_STAT_UNPLUGGED) {
+			mvGppPolaritySet(0, BIT(data->pin), initial_polarity_val);
+		}
+		else {
+			mvGppPolaritySet(0, BIT(data->pin), ~initial_polarity_val);
+		}
+
+		data->prevplugstat = plugstat;
+		buffalo_kernevnt_queuein(buf);
+*/
+		enable_irq(SATAHOT_IRQ_BASE + data->pin);
+	}
+}
+
+static irqreturn_t
+SataHotplugInterrupts(int irq, void *dev_id)
+{
+	struct sata_hotplug_data *data = (struct sata_hotplug_data *)dev_id;
+
+	disable_irq(irq);
+
+	init_timer(&data->timer);
+	data->timer.expires = jiffies + SATA_POL_INTERVAL;
+	data->timer.function = PollingSATAHotplug;
+	data->timer.data = (unsigned long)data;
+	data->loops = SATA_POL_LOOPS;
+	data->prevpinstat = inl(ich9r_gpio_base_addr + GP_LVL) & data->pin;
+	add_timer(&data->timer);
+
+	return IRQ_HANDLED;
+}
+
+static struct proc_dir_entry *hdd_power_dir;
+static struct proc_dir_entry *hdd_present_dir;
+
+/*******************************************************************************
+* function: find_ich9_gpio_base_addr
+* argument:
+* retvalue:
+*******************************************************************************/
+static int find_ich9_gpio_base_addr(void)
+{
+	struct pci_dev *pdev = NULL;
+
+	pdev = pci_get_device(INTEL_ICH9R_VENDOR_ID, INTEL_ICH9R_DEVICE_ID, NULL);
+	if (!pdev) return -ENODEV;
+	pci_read_config_dword(pdev, GPIO_BAR_OFFSET, &ich9r_gpio_base_addr);
+	ich9r_gpio_base_addr &= 0x0000ff80;
+
+	return 0;
+}
+
+/*******************************************************************************
+* function: read_hdd_present_status
+* argument:
+* retvalue:
+*******************************************************************************/
+static int read_hdd_present_status(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+	struct matsu_hdd_info_st *hdd_info = (struct matsu_hdd_info_st *)data;
+	if (off > 0) {
+		*eof = 1;
+		return 0;
+	}
+
+	if (inl(ich9r_gpio_base_addr + GP_LVL) & hdd_info->HDD_PRESENT_BIT)
+		len = sprintf(page, "unplugged\n");
+	else
+		len = sprintf(page, "plugged\n");
+
+	*eof = 1;
+	return len;
+}
+
+/*******************************************************************************
+* function: read_hdd_power_status
+* argument:
+* retvalue:
+*******************************************************************************/
+static int read_hdd_power_status(char *page, char **start, off_t off, int count, int *eof, void *data)
+{
+	int len;
+	struct matsu_hdd_info_st *hdd_info = (struct matsu_hdd_info_st *)data;
+
+	if (off > 0) {
+		*eof = 1;
+		return 0;
+	}
+
+	if (inl(ich9r_gpio_base_addr + GP_LVL) & hdd_info->HDD_POWER_BIT)
+		len = sprintf(page, "on\n");
+	else
+		len = sprintf(page, "off\n");
+
+	*eof = 1;
+	return len;
+
+}
+
+/*******************************************************************************
+* function: set_hdd_power
+* argument:
+* retvalue:
+*******************************************************************************/
+static int set_hdd_power(struct file *file, const char *buffer, unsigned long count, void *data)
+{
+	int tmpgpioval;
+	struct matsu_hdd_info_st *hdd_info = (struct matsu_hdd_info_st *)data;
+
+	tmpgpioval = inl(ich9r_gpio_base_addr + GP_LVL);
+
+	if (strncmp(buffer, "off", 3) == 0) {
+		if (tmpgpioval & hdd_info->HDD_POWER_BIT) {
+			tmpgpioval &= hdd_info->HDD_POWER_MASK;
+			outl(tmpgpioval, ich9r_gpio_base_addr + GP_LVL);
+		}
+	}
+	else if (strncmp(buffer, "on", 2) == 0) {
+		if ((tmpgpioval & hdd_info->HDD_POWER_BIT) != hdd_info->HDD_POWER_BIT) {
+			tmpgpioval |= hdd_info->HDD_POWER_BIT;
+			outl(tmpgpioval, ich9r_gpio_base_addr + GP_LVL);
+		}
+	}
+	else {
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+/*******************************************************************************
+* function: init_proc_files
+* argument:
+* retvalue:
+* description: create procfs for hdd control:
+/ --- proc --- buffalo --- gpio -+- hotplug -+- sata0
+                                 |           +- sata1
+                                 |           +- sata2
+                                 |           +- sata3
+                                 |
+                                 +- power_control -+- hdd0
+                                                   +- hdd1
+                                                   +- hdd2
+                                                   +- hdd3
+*******************************************************************************/
+static int init_proc_files(void)
+{
+	int retval = 0;
+	int i = 0;
+	char buf[32];
+
+	/* declare for file and directory of procfs */
+	static struct proc_dir_entry *hdd_ctrl_dir;
+
+	static struct proc_dir_entry *hdd_present_status_file[MAX_SUPPORTED_DISKS];
+	static struct proc_dir_entry *hdd_power_status_file[MAX_SUPPORTED_DISKS];
+
+	// Create /proc/buffalo/gpio directory
+	hdd_ctrl_dir = proc_mkdir(MODULE_DIR, NULL);
+	if(hdd_ctrl_dir == NULL) {
+		printk(KERN_ALERT "buffalo/gpio directory create fail.....\n");
+		goto MODULE_DIR_FAIL;
+	}
+	printk(KERN_ALERT "buffalo/gpio directory create successful.....\n");
+
+	// Create /proc/buffalo/gpio/hotplug directory
+	hdd_present_dir = proc_mkdir(HDD_PRESENT_DIR, NULL);
+	if(hdd_present_dir == NULL) {
+		printk(KERN_ALERT "hotplug directory create fail.....\n");
+		goto PRESENT_DIR_FAIL;
+	}
+	printk(KERN_ALERT "hotplug directory create successful.....\n");
+
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		hdd_present_status_file[i] = create_proc_read_entry(buf, 0, hdd_present_dir, read_hdd_present_status, NULL);
+		if(hdd_present_status_file[i] == NULL)
+		{
+			printk(KERN_ALERT "HDD%d_PRESENT_STATUS_FILE create fail.....\n", i);
+			goto HDD_PRESENT_STATUS_FILE_FAIL;
+		}
+		printk(KERN_ALERT "HDD%d_PRESENT_STATUS_FILE create successful.....\n", i);
+		hdd_present_status_file[i]->data = (void *)&matsu_hdd_info[i];
+	}
+
+	// Create /proc/buffalo/gpio/power_control directory
+	hdd_power_dir = proc_mkdir(HDD_POWER_DIR, NULL);
+	if(hdd_power_dir == NULL) {
+		printk(KERN_ALERT "power_control directory create fail.....\n");
+		goto HDD_POWER_DIR_FAIL;
+	}
+	printk(KERN_ALERT "power_control directory create successful.....\n");
+
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		hdd_power_status_file[i] = create_proc_entry(buf, 0644, hdd_power_dir);
+		if(hdd_power_status_file[i] == NULL)
+		{
+			printk(KERN_ALERT "HDD%d_POWER_STATUS_FILE create fail.....\n", i);
+			goto HDD_POWER_STATUS_FILE_FAIL;
+		}
+		printk(KERN_ALERT "HDD%d_POWER_STATUS_FILE create successful.....\n", i);
+		hdd_power_status_file[i]->read_proc = &read_hdd_power_status;
+		hdd_power_status_file[i]->write_proc = &set_hdd_power;
+		hdd_power_status_file[i]->data = (void *)&matsu_hdd_info[i];
+	}
+
+	goto INIT_OK;
+
+HDD_POWER_STATUS_FILE_FAIL:
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		remove_proc_entry(buf, hdd_power_dir);
+	}
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+
+HDD_POWER_DIR_FAIL:
+HDD_PRESENT_STATUS_FILE_FAIL:
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		remove_proc_entry(buf, hdd_present_dir);
+	}
+
+	remove_proc_entry(HDD_PRESENT_DIR, NULL);
+
+PRESENT_DIR_FAIL:
+	remove_proc_entry(MODULE_DIR, NULL);
+
+MODULE_DIR_FAIL:
+	retval = -ENOMEM;
+
+INIT_OK:
+	return retval;
+}
+/*******************************************************************************
+* function: hdd_ctrl_init
+* argument:
+* retvalue:
+*******************************************************************************/
+static int __init hdd_ctrl_init(void)
+{
+	printk(KERN_ALERT "[%s init proc]\n", HDD_CTRL_MODULE_NAME);
+
+	/* find intel ich9 device */
+	if (find_ich9_gpio_base_addr()) return -ENODEV;
+
+	/* create files within proc filesystem */
+	if (init_proc_files()) return -ENOMEM;
+
+	/* everything initialized */
+	printk(KERN_INFO "%s %s initialized...\n",HDD_CTRL_MODULE_NAME, HDD_CTRL_MODULE_VERSION);
+	return 0;
+}
+/*******************************************************************************
+* function: hdd_ctrl_exit
+* argument:
+* retvalue:
+*******************************************************************************/
+static void __exit hdd_ctrl_exit(void)
+{
+	printk(KERN_ALERT "[%s exit proc]\n", HDD_CTRL_MODULE_NAME);
+	int i = 0;
+	char buf[32];
+
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "hdd%d", i);
+		remove_proc_entry(buf, hdd_power_dir);
+	}
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sprintf(buf, "sata%d", i);
+		remove_proc_entry(buf, hdd_present_dir);
+	}
+	remove_proc_entry(HDD_PRESENT_DIR, NULL);
+	remove_proc_entry(HDD_POWER_DIR, NULL);
+	remove_proc_entry(MODULE_DIR, NULL);
+	printk(KERN_ALERT "hdd ctrl exit successfully....\n");
+}
+
+module_init (hdd_ctrl_init);
+module_exit (hdd_ctrl_exit);
+
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-matsu/hdd_ctrl.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/hdd_ctrl.h
--- linux-3.10.69/arch/x86/plat-matsu/hdd_ctrl.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/hdd_ctrl.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,132 @@
+#if defined(_HDD_CTRL_H__)
+#else
+#define _HDD_CTRL_H
+
+/* Define Vendor and product id for ich9r */
+#define INTEL_ICH9R_VENDOR_ID	0x8086
+#define INTEL_ICH9R_DEVICE_ID	0x2916
+
+#define GPIO_BAR_OFFSET		0x48
+#define GPIO_USE_SEL		0x00
+#define GP_IO_SEL		0x04
+#define GP_LVL			0x0c
+#define GP_LVL2			0x38
+#define GPO_BLINK		0x18
+#define GPI_INV			0x2c
+
+/* Define GPIO
+EVT board:
+SATA Hot 0 --> GPIO2
+SATA Hot 1 --> GPIO3
+SATA Hot 2 --> GPIO4
+SATA Hot 3 --> GPIO5
+SATA Hot 4 --> GPIO15
+SATA Hot 5 --> GPIO16
+SATA Hot 6 --> GPIO18
+SATA Hot 7 --> GPIO20
+
+HDD_Power0 --> GPIO17
+HDD_Power1 --> GPIO1
+HDD_Power2 --> GPIO6
+HDD_Power3 --> GPIO7
+HDD_Power4 --> GPIO25
+HDD_Power5 --> GPIO32
+HDD_Power6 --> GPIO33
+HDD_Power7 --> GPIO34
+
+DVT board:
+SATA Hot 0 --> GPIO2
+SATA Hot 1 --> GPIO3
+SATA Hot 2 --> GPIO4
+SATA Hot 3 --> GPIO5
+SATA Hot 4 --> GPIO15
+SATA Hot 5 --> GPIO9
+SATA Hot 6 --> GPIO13
+SATA Hot 7 --> GPIO11
+
+HDD_Power0 --> GPIO17
+HDD_Power1 --> GPIO1
+HDD_Power2 --> GPIO6
+HDD_Power3 --> GPIO7
+HDD_Power4 --> GPIO25
+HDD_Power5 --> GPIO32
+HDD_Power6 --> GPIO33
+HDD_Power7 --> GPIO34
+*/
+/* for EVT and DVT (common) */
+#define HDD0_PRESENT_BIT		0x00000004	/*GPIO2*/
+#define HDD1_PRESENT_BIT		0x00000008	/*GPIO3*/
+#define HDD2_PRESENT_BIT		0x00000010	/*GPIO4*/
+#define HDD3_PRESENT_BIT		0x00000020	/*GPIO5*/
+#define HDD4_PRESENT_BIT		0x00008000	/*GPIO15*/
+#if defined(CONFIG_BUFFALO_MATSU_USE_EVT_BOARD)
+/* for EVT */
+  #define HDD5_PRESENT_BIT		0x00010000	/*GPIO16*/
+  #define HDD6_PRESENT_BIT		0x00040000	/*GPIO18*/
+  #define HDD7_PRESENT_BIT		0x00100000	/*GPIO20*/
+#else
+/* for DVT */
+  #define HDD5_PRESENT_BIT		0x00000200	/*GPIO9*/
+  #define HDD6_PRESENT_BIT		0x00002000	/*GPIO13*/
+  #define HDD7_PRESENT_BIT		0x00000400	/*GPIO10, DVT2 board changed from GPI11 to GPI10*/
+#endif
+
+#define HDD0_POWER_BIT			0x00020000	/*GPIO17*/
+#define HDD1_POWER_BIT			0x00000002	/*GPIO1*/
+#define HDD2_POWER_BIT			0x00000040	/*GPIO6*/
+#define HDD3_POWER_BIT			0x00000080	/*GPIO7*/
+#define HDD4_POWER_BIT			0x02000000	/*GPIO25*/
+#define HDD5_POWER_BIT			0x00000001	/*GPIO32*/
+#define HDD6_POWER_BIT			0x00000002	/*GPIO33*/
+#define HDD7_POWER_BIT			0x00000004	/*GPIO34*/
+
+#define HDD0_PRESENT_MASK		0xfffffffb
+#define HDD1_PRESENT_MASK		0xfffffff7
+#define HDD2_PRESENT_MASK		0xffffffef
+#define HDD3_PRESENT_MASK		0xffffffdf
+#define HDD4_PRESENT_MASK		0xffff7fff
+#if defined(CONFIG_BUFFALO_MATSU_USE_EVT_BOARD)
+/* for EVT */
+  #define HDD5_PRESENT_MASK		0xfffeffff
+  #define HDD6_PRESENT_MASK		0xfffbffff
+  #define HDD7_PRESENT_MASK		0xffefffff
+#else
+/* for DVT */
+  #define HDD5_PRESENT_MASK		0xfffffdff
+  #define HDD6_PRESENT_MASK		0xffffdfff
+  #define HDD7_PRESENT_MASK		0xfffff7ff
+#endif
+
+#define HDD0_POWER_MASK			0xfffdffff
+#define HDD1_POWER_MASK			0xfffffffd
+#define HDD2_POWER_MASK			0xffffffbf
+#define HDD3_POWER_MASK			0xffffff7f
+#define HDD4_POWER_MASK			0xfdffffff
+#define HDD5_POWER_MASK			0xfffffffe
+#define HDD6_POWER_MASK			0xfffffffd
+#define HDD7_POWER_MASK			0xfffffffb
+
+/* Define for procfs directory and file */
+#define MODULE_DIR			"buffalo/gpio"
+#define HDD_PRESENT_DIR			"buffalo/gpio/hotplug"
+#define HDD_POWER_DIR			"buffalo/gpio/power_control"
+
+#define MAX_SUPPORTED_DISKS	8
+
+///////////////// for hotplug /////////////
+typedef enum _sata_plug_state {
+	SATA_STAT_UNKNOWN,
+	SATA_STAT_PLUGGED,
+	SATA_STAT_UNPLUGGED,
+}SATA_PLUG_STATE;
+
+struct sata_hotplug_data_st {
+	SATA_PLUG_STATE presentpinstat;
+	SATA_PLUG_STATE prevplugstat;
+	unsigned int loops;
+};
+
+
+///////////////// for hotplug /////////////
+#endif  /* _HDD_CTRL_H */
+
diff -rubB --new-file linux-3.10.69/arch/x86/plat-matsu/Makefile F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/Makefile
--- linux-3.10.69/arch/x86/plat-matsu/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/Makefile	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,5 @@
+obj-$(CONFIG_BUFFALO_MATSU_PLATFORM)	+= hdd_ctrl.o
+obj-$(CONFIG_BUFFALO_MATSU_PLATFORM)	+= btn_ctrl.o
+obj-$(CONFIG_BUFFALO_MATSU_PLATFORM)	+= fan_ctrl.o
+obj-$(CONFIG_BUFFALO_MATSU_PLATFORM)	+= cmos_ctrl.o
+obj-$(CONFIG_BUFFALO_MATSU_PLATFORM)	+= boardid_ctrl.o
diff -rubB --new-file linux-3.10.69/arch/x86/plat-matsu/matsu_btn.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/matsu_btn.c
--- linux-3.10.69/arch/x86/plat-matsu/matsu_btn.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-matsu/matsu_btn.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,253 @@
+/*****************************************************************************+
+ DESCRIPTION:  Matsu button driver (sample)
+ AUTHOR:       Ian Juang
+ DATE STARTED: July, 2010
+ PROJECT:      WS-QX2(Matsu)
+
+ Rev 0.3   Aug  05 2010
+ - Adding an "if" clause in the interrupt handler to check for the interrupt 
+   source(PBD's IRQ).
+ - Indicate the timer source.
+*******************************************************************************
+ Rev 0.2   Aug  04 2010
+ - Modify button interrupt event to become triggered by IT87 de-bounce IRQ.
+ Rev 0.1   July 26 2010
+ - Initial revision.
+--------------------------------------------------------------------------------
+ CONVENTIONS:
+
++----------------------------------------------------------------------------+*/
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/poll.h>
+#include <linux/irq.h>
+#include <asm/io.h>
+
+#include <linux/timer.h>
+#include <asm/param.h>
+
+//Common section
+#define DRVVER			"0.3"
+#define	DRVNAME			"matsu_btn"
+
+//IT8721 registers section
+#define CONFIG_ADDR_PORT	0x2E
+#define CONFIG_DATA_PORT	0x2F
+
+#define IT87_LDN_ADDR		0x07
+#define	IT87_GPIO_LDN		0x07
+
+#define IT87_GP34_LOC		0x1C
+#define IT87_GP35_LOC		0x1D
+#define	IT87_IRQEN		0x40
+
+#define IT87_REG_PNL_DBOUNCE0	0xE0
+#define IT87_REG_PNL_DBOUNCE1	0xE1
+#define IT87_REG_PNL_IRQ_SEL	0x70
+#define IT87_PNL_IRQ3		0x03	//IRQ level 3
+#define IT87_REG_SMI_STS2	0xF3
+
+#define IT87_SMI_DEB_MASK	0xC0
+#define IT87_DEB0		0x80	//bit7
+#define IT87_DEB1		0x40	//bit6
+#define IT87_DEB0DEB1		0xC0	//bits[6-7]
+#define IT87_SMI_STS2_PBD	0x01	//bit0 PBD's IRQ
+
+#define IT87_GP34_BIT4		0x10
+#define IT87_GP35_BIT5		0x20
+//Simple I/O base addr(Index62h and 63h)+ GPIO Set2
+#define IT87_SIMPLE_IO_SET2	0xA22
+
+//Buttons section
+#define BTN_DISP	    	   1
+#define BTN_FUNC	 	   2
+      
+#define TIMER_DELAY		(HZ/500)//this value can be adjusted
+static struct timer_list btn_timer;
+
+/*+--------------------------------------------+
+This procedure is for program LPC configuration 
+registers. Entering and exiting MBPnP mode.
++--------------------------------------------+*/
+void EnterMBPnP(void)
+{
+	outb(0x87, CONFIG_ADDR_PORT);
+	outb(0x01, CONFIG_ADDR_PORT);
+	outb(0x55, CONFIG_ADDR_PORT);
+	outb(0x55, CONFIG_ADDR_PORT);
+}
+void ExitMBPnP(void)
+{
+	outb(0x02, CONFIG_ADDR_PORT);
+	outb(0x02, CONFIG_DATA_PORT);		
+}
+
+/*+--------------------------------------------+
+This procedure is for getting the GPIO status of
+buttons.
+
+Returns:
++--------------------------------------------+*/
+static int it87_gpio_getsts(int pin)
+{
+	int	off;
+	if(pin == BTN_DISP){
+		off = IT87_GP35_BIT5;	//pin number of DISP button
+	}else{
+		off = IT87_GP34_BIT4;	//pin number of FUNC button
+	}		
+
+	return inb(IT87_SIMPLE_IO_SET2) & off;
+}
+
+/*+--------------------------------------------+
+A timer for checking if the de-bounce gpio pin
+has been released. This interrupt won't be 
+triggered again until the IT87_REG_SMI_STS2 is
+cleared by software.
+
+Returns: 
++--------------------------------------------+*/
+static void timer_function(unsigned long data)
+{
+	int	pin_sts;
+
+	pin_sts=it87_gpio_getsts(data);
+	
+	if(pin_sts){
+	//Clear de-bounce ping SMI status
+		EnterMBPnP();
+		outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+		outb(IT87_DEB0DEB1 | IT87_SMI_STS2_PBD, CONFIG_DATA_PORT);		
+		ExitMBPnP();
+	//Delete timer
+		del_timer(&btn_timer);
+		printk(KERN_ALERT "Timer %ld is cleared!\n",data);
+	}else{
+        	mod_timer(&btn_timer, jiffies + TIMER_DELAY);
+	}
+}
+
+/*+--------------------------------------------+
+Matsu button interrupt handler
+
+Handling display and funcion button irq demand. 
+Check IT8721 SMI# Status Register2 to determine 
+which button was pressed.
+
+Returns: 
++--------------------------------------------+*/
+static irqreturn_t matsu_interrupt(int irq, void *dev_id)
+{
+	int	pin=0;
+	unsigned char smi_sts;
+
+	//Get SMI status of two de-bounce pin
+	EnterMBPnP();	
+	outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+
+	smi_sts = inb(CONFIG_DATA_PORT);
+	ExitMBPnP();
+	//Check if the interrupt source is PBD's IRQ
+	if(smi_sts & IT87_SMI_STS2_PBD)
+	{
+		smi_sts &= IT87_SMI_DEB_MASK;
+		//Check which button was pressed
+		if (smi_sts == IT87_DEB0){
+			printk(KERN_ALERT "(1)The DISPLAY button was pressed\n");
+			pin = BTN_DISP;
+		}
+		else if (smi_sts == IT87_DEB1){
+			printk(KERN_ALERT "(2)The FUNCTION button was pressed\n");
+			pin = BTN_FUNC;
+		}
+		//Setup timer for checking button gpio state
+ 		init_timer(&btn_timer);
+
+		btn_timer.expires = jiffies + TIMER_DELAY;
+		btn_timer.data = pin;
+		btn_timer.function = timer_function;
+	
+		add_timer(&btn_timer);
+	}
+	return IRQ_HANDLED;
+}
+
+
+/*+--------------------------------------------+
+Initial procedure, device driver interrupt 
+handler register IRQ3 and initialize the SIO(IT 
+8721) GPIO34/35.
+
+Returns:
++--------------------------------------------+*/
+static int __init matsubtn_init(void)
+{
+	int ret;
+
+        ret = request_irq(3, matsu_interrupt, IRQF_SHARED, DRVNAME, matsu_interrupt);
+    	if (ret){
+    		printk (KERN_ALERT "!!!!! Error requesting irq 3: returned %d\n", ret);
+		free_irq(3, 0);
+        	return -EBUSY;
+    	}
+ 
+	//Enter ITE config
+	EnterMBPnP();
+	
+	//Select LDN 07h	
+	outb(IT87_LDN_ADDR, CONFIG_ADDR_PORT);
+	outb(IT87_GPIO_LDN, CONFIG_DATA_PORT);
+	
+	//Set GPIO34/35 as De-bounce GPIO
+	outb(IT87_REG_PNL_DBOUNCE0, CONFIG_ADDR_PORT);
+	outb(IT87_GP34_LOC | IT87_IRQEN, CONFIG_DATA_PORT);
+	outb(IT87_REG_PNL_DBOUNCE1, CONFIG_ADDR_PORT);
+	outb(IT87_GP35_LOC, CONFIG_DATA_PORT);
+	
+	outb(IT87_REG_PNL_IRQ_SEL, CONFIG_ADDR_PORT);
+	outb(IT87_PNL_IRQ3, CONFIG_DATA_PORT);
+	//Exit ITE config
+	ExitMBPnP();
+
+	printk(KERN_INFO "MODULE %s %s IS INITIALIZED...\n", DRVNAME, DRVVER);        	
+	return 0;
+}
+
+/*+--------------------------------------------+
+Cleanup procedure, unregister IRQ3 and restore 
+system BIOS IT8721 GPIO34/35 settings.
+
+Returns:
++--------------------------------------------+*/
+
+static void __exit matsubtn_exit_cleanup(void)
+{
+	disable_irq(3);
+	free_irq(3, matsu_interrupt);
+	//Restore GPIO34/35 settings
+	EnterMBPnP();
+
+	outb(IT87_LDN_ADDR, CONFIG_ADDR_PORT);
+	outb(IT87_GPIO_LDN, CONFIG_DATA_PORT);
+	
+	outb(IT87_REG_PNL_DBOUNCE0, CONFIG_ADDR_PORT);
+	outb(0x00, CONFIG_DATA_PORT);
+	outb(IT87_REG_PNL_DBOUNCE1, CONFIG_ADDR_PORT);
+	outb(0x00, CONFIG_DATA_PORT);
+	
+	outb(IT87_REG_PNL_IRQ_SEL, CONFIG_ADDR_PORT);
+	outb(0x00, CONFIG_DATA_PORT);
+	
+	ExitMBPnP();
+
+	printk(KERN_INFO "MODULE %s %s HAS BEEN REMOVED!\n", DRVNAME, DRVVER);
+}
+
+module_init(matsubtn_init);
+module_exit(matsubtn_exit_cleanup);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-usi/Makefile F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-usi/Makefile
--- linux-3.10.69/arch/x86/plat-usi/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-usi/Makefile	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,32 @@
+
+# To build modules outside of the kernel tree, we run "make"
+# in the kernel source tree; the Makefile these then includes this
+# Makefile once again.
+# This conditional selects whether we are being included from the
+# kernel Makefile or not.
+ifeq ($(KERNELRELEASE),)
+
+    # Assume the source tree is where the running kernel was built
+    # You should set KERNELDIR in the environment if it's elsewhere
+    KERNELDIR ?= /lib/modules/$(shell uname -r)/build
+    # The current directory is passed to sub-makes as argument
+    PWD := $(shell pwd)
+
+modules:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
+
+modules_install:
+	$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install
+
+clean:
+	rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module.symvers modules.order
+
+.PHONY: modules modules_install clean
+
+else
+	# called from kernel build system: just declare what our modules are
+	obj-$(CONFIG_BUFFALO_USI_PLATFORM) += sugi_platform.o
+	
+endif
+
+
diff -rubB --new-file linux-3.10.69/arch/x86/plat-usi/sugi_platform.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-usi/sugi_platform.c
--- linux-3.10.69/arch/x86/plat-usi/sugi_platform.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-usi/sugi_platform.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,1840 @@
+/*	Sugi Platform Driver - V1.2
+ *
+ * 	Author: Gary Chen
+ *	Date  : 2012/07/11
+ */
+
+
+#include <asm/io.h>
+#include <asm/msr.h>
+#include <asm/errno.h>
+#include <linux/fs.h>
+#include <linux/irq.h>
+#include <linux/pci.h>
+#include <linux/cdev.h>
+#include <linux/init.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/sched.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/interrupt.h>
+#include "sugi_platform.h"
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 1
+ * Description: Global variabls and strctures
+ * ---------------------------------------------------------------------------------------------- */
+
+/* Define for procfs directory and file */
+#if defined(CONFIG_BUFFALO_PLATFORM)
+#include <buffalo/kernevnt.h>
+#endif
+
+
+
+/* **************** Button Driver **************** */
+
+/* declare for file and directory of procfs */
+static struct proc_dir_entry *buffalo_dir;
+static struct proc_dir_entry *gpio_dir;
+static struct proc_dir_entry *switch_dir;
+static struct proc_dir_entry *switch_file[MAX_SUPPORTED_BUTTONS];
+
+/* GPIO set3 base addr */
+static unsigned int it87_gpioset3_base_addr;
+
+/* declare timer function */
+static struct timer_list btn_timer;
+
+/* button information strcture */
+static struct button_info_st button_info[] = {
+	{"func", IT87_DEB0},
+	{"display", IT87_DEB1}
+};
+
+/* ************** Fan Control Driver ************* */
+
+/* class and device nodes */
+struct class *sugi_cls;
+struct device *fan_dev;
+dev_t sugit_fan = MKDEV(sugi_fan_major, sugi_fan_minor);
+
+/* IT8721 EC base address */
+unsigned int EC_BASE_ADDR;
+unsigned int IT87_EC_ADDR_REG;
+unsigned int IT87_EC_DATA_REG;
+
+/* core temp used */
+unsigned int tjmax[2] = {100,100};
+unsigned int eax;
+unsigned int edx;
+
+/* fan, temp information strcture */
+struct fan_info_st fan_info[] =
+{
+	{IT87_EC_FAN_TACO1, IT87_EC_FAN_TACO1_EXT, IT87_EC_FAN_SMART_PWM1, IT87_EC_FAN_PWM1, 0x1},
+	{IT87_EC_FAN_TACO2, IT87_EC_FAN_TACO2_EXT, IT87_EC_FAN_SMART_PWM2, IT87_EC_FAN_PWM2, 0x2},
+};
+
+/* 4 steps of speed */
+static unsigned char fan_stop_speed = 0;
+static unsigned char fan_slow_speed = 150;
+static unsigned char fan_fast_speed = 200;
+static unsigned char fan_full_speed = 255;
+
+/* threshold & flag */
+static unsigned int fan_threshold = 100;
+static unsigned int flag_show_speed_by_string = 1;
+
+/* ************** HDD Control Driver ************* */
+
+/* pci device */
+struct pci_dev *pdev = NULL;
+
+/* declare for file and directory of procfs */
+static struct proc_dir_entry *hotplug_dir;
+static struct proc_dir_entry *power_control_dir;
+static struct proc_dir_entry *hotplug_sata_file[MAX_SUPPORTED_DISKS];
+static struct proc_dir_entry *power_control_hdd_file[MAX_SUPPORTED_DISKS];
+
+/* GPIO base address */
+unsigned int ich10r_gpio_base_addr;
+
+/* polling timer */
+struct timer_list sata_hotplug_polling_timer;
+
+/* hotplug status information strcture */
+struct sata_hotplug_data_st sata_hotplug_data[MAX_SUPPORTED_DISKS];
+
+/* HDD information strcture */
+static struct sugi_hdd_info_st sugi_hdd_info[] = {
+	{GP_LVL,	HDD0_PRESENT_BIT,	GP_LVL,		HDD0_POWER_BIT,	HDD0_POWER_MASK},
+	{GP_LVL,	HDD1_PRESENT_BIT,	GP_LVL,		HDD1_POWER_BIT,	HDD1_POWER_MASK},
+	{GP_LVL,	HDD2_PRESENT_BIT,	GP_LVL,		HDD2_POWER_BIT,	HDD2_POWER_MASK},
+	{GP_LVL,	HDD3_PRESENT_BIT,	GP_LVL,		HDD3_POWER_BIT,	HDD3_POWER_MASK},
+	{GP_LVL,	HDD4_PRESENT_BIT,	GP_LVL2,	HDD4_POWER_BIT,	HDD4_POWER_MASK},
+	{GP_LVL,	HDD5_PRESENT_BIT,	GP_LVL2,	HDD5_POWER_BIT,	HDD5_POWER_MASK},
+	{GP_LVL,	HDD6_PRESENT_BIT,	GP_LVL2,	HDD6_POWER_BIT,	HDD6_POWER_MASK},
+	{GP_LVL,	HDD7_PRESENT_BIT,	GP_LVL2,	HDD7_POWER_BIT,	HDD7_POWER_MASK},
+};
+
+/* ***************** CMOS Driver ***************** */
+/* device nodes */
+struct device *cmos_dev;
+dev_t sugit_cmos = MKDEV(sugi_cmos_major, sugi_cmos_minor);
+
+unsigned int ich10r_pm_base_addr;
+unsigned short afterg3_en;
+
+/* Device ID offset */
+unsigned char device_id_offset[32] = {0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d,
+																0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55,
+																0x56, 0x57, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e,
+																0x5f, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c};
+
+/* checksum offset */
+unsigned char checksum_offset[4] = {0x79, 0x7a, 0x7b, 0x7c};
+
+/* ASCII string to integer */																
+struct strtoint_st strtoint_info[] = {
+	{0x30, 0x0}, {0x31, 0x1}, {0x32, 0x2}, {0x33, 0x3},
+	{0x34, 0x4}, {0x35, 0x5}, {0x36, 0x6}, {0x37, 0x7},
+	{0x38, 0x8}, {0x39, 0x9}, {0x61, 0xa}, {0x62, 0xb},
+	{0x63, 0xc}, {0x64, 0xd}, {0x65, 0xe}, {0x66, 0xf},
+	{0x41, 0xa}, {0x42, 0xb}, {0x43, 0xc}, {0x44, 0xd},
+	{0x45, 0xe}, {0x46, 0xf},
+};
+
+static unsigned int bios_ver;
+
+/* *************** Boaed ID Driver *************** */
+
+struct device *boardid_dev;
+dev_t sugit_boardid = MKDEV(sugi_boardid_major, sugi_boardid_minor);
+unsigned int boardid_num;
+
+/* ************* protocol for IT8721 ************* */
+void EnterMBPnP(void)
+{
+	outb(0x87, CONFIG_ADDR_PORT);
+	outb(0x01, CONFIG_ADDR_PORT);
+	outb(0x55, CONFIG_ADDR_PORT);
+	outb(0x55, CONFIG_ADDR_PORT);
+}
+void ExitMBPnP(void)
+{
+	outb(0x02, CONFIG_ADDR_PORT);
+	outb(0x02, CONFIG_DATA_PORT);
+}
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2-1
+ * Description: Implement functions of button driver
+ * ---------------------------------------------------------------------------------------------- */
+
+/* ************** implement function ************* */
+
+/* ----------- get GPIO status ----------- */
+static int it87_gpio_getsts(int pin)
+{
+	int	off;
+	if(pin == BTN_DISP){
+		off = IT87_GP35_BIT5;	//pin number of DISP button
+	}else{
+		off = IT87_GP34_BIT4;	//pin number of FUNC button
+	}		
+
+	return inb(it87_gpioset3_base_addr) & off;
+}
+
+/* ------------- button timer ------------ */	
+static void timer_function(unsigned long data)
+{
+	int	pin_sts;
+
+	pin_sts=it87_gpio_getsts(data);
+	
+	if(pin_sts){
+	//Clear de-bounce ping SMI status
+		EnterMBPnP();
+		outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+		outb(IT87_DEB0DEB1 | IT87_SMI_STS2_PBD, CONFIG_DATA_PORT);		
+		ExitMBPnP();
+	//Delete timer
+		del_timer(&btn_timer);
+	}
+	else
+    mod_timer(&btn_timer, jiffies + TIMER_DELAY);
+}
+
+/* ---------- get button status ---------- */
+static int show_button_status(struct seq_file *m, void *v)
+{
+	struct button_info_st *button_info;
+	unsigned char smi_sts;
+
+	button_info = (struct button_info_st *)m->private;
+	
+	EnterMBPnP();
+
+	//Get SMI status of two de-bounce pin
+	outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+	smi_sts = inb(CONFIG_DATA_PORT);
+	smi_sts &= IT87_SMI_DEB_MASK;
+
+	ExitMBPnP();
+
+	//Check which button was pressed
+	if ((smi_sts & button_info->reg_stat))
+		seq_printf(m, "on\n");
+	else
+		seq_printf(m, "off\n");
+
+	return 0;
+}
+
+static int open_button_status(struct inode *inode, struct file *file)
+{
+	return single_open(file, show_button_status, PDE_DATA(file_inode(file)));
+}
+
+static struct file_operations button_status_fops = {
+	.owner		= THIS_MODULE,
+        .open		= open_button_status,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release
+};
+
+/* ----------- interrupt handler ---------- */
+static irqreturn_t sugi_interrupt(int irq, void *dev_id)
+{
+	int	pin=0;
+	unsigned char smi_sts;
+	
+	#ifdef CONFIG_BUFFALO_PLATFORM
+		char msg[32];
+		memset(msg, 0, sizeof(msg));
+	#endif
+	
+	/* get SMI status of two de-bounce pin */
+	EnterMBPnP();	
+	
+	outb(IT87_REG_SMI_STS2, CONFIG_ADDR_PORT);
+	smi_sts = inb(CONFIG_DATA_PORT);
+	
+	ExitMBPnP();
+	
+	/* check if the interrupt source is PBD's IRQ */
+	if(smi_sts & IT87_SMI_STS2_PBD)
+	{
+		smi_sts &= IT87_SMI_DEB_MASK;
+		
+		/* check which button was pressed */
+		if(smi_sts == IT87_DEB0){
+			#ifdef CONFIG_BUFFALO_PLATFORM
+				sprintf(msg, "micon_interrupts");
+			#else
+				printk("EVENT IS OCCURRED\n");
+			#endif
+			pin = BTN_FUNC;
+		}
+		else if(smi_sts == IT87_DEB1){
+			#ifdef CONFIG_BUFFALO_PLATFORM
+				sprintf(msg, "micon_interrupts");
+			#else
+				printk("EVENT IS OCCURRED\n");
+			#endif
+			pin = BTN_DISP;
+		}
+		
+		/* setup timer for checking button GPIO status */
+ 		init_timer(&btn_timer);
+		btn_timer.expires = jiffies + TIMER_DELAY;
+		btn_timer.data = pin;
+		btn_timer.function = timer_function;
+		add_timer(&btn_timer);
+		
+		#ifdef CONFIG_BUFFALO_PLATFORM
+			if(msg[0] != '\0')
+				buffalo_kernevnt_queuein(msg);
+		#endif
+	}
+	return IRQ_HANDLED;
+}
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2-2
+ * Description: Implement functions of fan control driver
+ * ---------------------------------------------------------------------------------------------- */
+
+/* ************* implement functions ************* */
+
+/* ----------- get temperature ---------- */
+unsigned int get_temp(unsigned char temp_num)
+{
+	unsigned int	ret = 0;
+	
+	if(temp_num==2){
+		outb(IT87_EC_TMPIN3, IT87_EC_ADDR_REG);
+		ret = inb(IT87_EC_DATA_REG);
+		return ret;
+	}
+	
+	rdmsr_on_cpu(temp_num, MSR_IA32_THERM_STATUS, &eax, &edx);
+	ret = tjmax[temp_num] - ((eax >> 16)&0x7f);
+	
+	return ret;
+}
+
+/* ---------- get rotation speed --------- */
+unsigned int get_fan_rpm(unsigned char fan_num)
+{
+	unsigned int	read_value;
+	unsigned int	read_value_ext;
+	unsigned int	ret = 0;
+	
+	outb(fan_info[fan_num].reg, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	outb(fan_info[fan_num].reg_ext, IT87_EC_ADDR_REG);
+	read_value_ext = inb(IT87_EC_DATA_REG);
+	ret = 1350000/(read_value_ext*256+read_value)/2;
+
+	if(ret < fan_threshold)
+		ret = 0;
+	
+	return ret;
+}
+
+/* -------------- get speed -------------- */
+unsigned int get_fan_speed(unsigned char fan_num)
+{
+	unsigned int	read_value;
+
+		
+	outb(IT87_EC_FAN_MAIN_CTL, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value |= fan_info[fan_num].offset;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	outb(fan_info[fan_num].reg_smart_pwm, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+
+	return read_value;
+}
+
+/* -------------- set speed -------------- */
+unsigned int set_fan_speed(unsigned char fan_num, unsigned char set_val)
+{
+	unsigned int	write_data;
+	unsigned char	read_value;
+
+	/*if(fan_info[fan_num].reg_smart_pwm == 0 ||
+		fan_info[fan_num].reg_pwm == 0)
+	{
+		return -EINVAL;
+	}*/
+
+	outb(IT87_EC_FAN_MAIN_CTL, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value |= fan_info[fan_num].offset;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	write_data = set_val;
+	outb(fan_info[fan_num].reg_smart_pwm, IT87_EC_ADDR_REG);
+	outb(write_data, IT87_EC_DATA_REG);
+
+	outb(fan_info[fan_num].reg_pwm, IT87_EC_ADDR_REG);
+	read_value = inb(IT87_EC_DATA_REG);
+	read_value &= 0x7F;
+	outb(read_value, IT87_EC_DATA_REG);
+
+	return 0;
+}
+
+/* --------- convert string to ul -------- */
+static unsigned long fan_speed_str_to_ul(char *buf)
+{
+	int len = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if((len == 5) && (strncmp(buf, "stop", strlen("stop")) == 0))
+		return fan_stop_speed;
+	else if((len == 5) && (strncmp(buf, "slow", strlen("slow")) == 0))
+		return fan_slow_speed;
+	else if((len == 5) && (strncmp(buf, "fast", strlen("fast")) == 0))
+		return fan_fast_speed;
+	else if((len == 5) && (strncmp(buf, "full", strlen("full")) == 0))
+		return fan_full_speed;
+
+	return simple_strtoul(buf, NULL, 10);
+}
+
+/* --------- convert ul to string -------- */
+static unsigned long fan_speed_ul_to_str(char *buf, size_t len, unsigned long speed)
+{
+	if(speed <= fan_stop_speed)
+		snprintf(buf, len, "stop");
+	else if(speed > fan_stop_speed && speed <= fan_slow_speed)
+		snprintf(buf, len, "slow");
+	else if(speed > fan_slow_speed && speed <= fan_fast_speed)
+		snprintf(buf, len, "fast");
+	else if(speed > fan_fast_speed)
+		snprintf(buf, len, "full");
+	else
+		snprintf(buf, len, "Unknown");
+		
+	return 0;
+}
+
+/* ************** device attributes ************** */
+
+/* -------- temperature attributes ------- */
+static ssize_t show_temp1(struct device *dev, struct device_attribute *attr, char *buf)
+
+{
+	return sprintf(buf, "%d\n", get_temp(0));
+}
+
+static ssize_t show_temp2(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_temp(1));
+}
+
+static ssize_t show_temp3(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_temp(2));
+}
+
+DEVICE_ATTR(temp1, 0444, show_temp1, NULL);
+DEVICE_ATTR(temp2, 0444, show_temp2, NULL);
+DEVICE_ATTR(temp3, 0444, show_temp3, NULL);
+
+/* ------ rotation speed attributes ------ */
+static ssize_t show_fan1_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(0));
+}
+
+static ssize_t show_fan2_rpm(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", get_fan_rpm(1));
+}
+
+DEVICE_ATTR(fan1_rpm, 0444, show_fan1_rpm, NULL);
+DEVICE_ATTR(fan2_rpm, 0444, show_fan2_rpm, NULL);
+
+/* fan3_rpm and fan4_rpm nodes are added to fit Buffalo's requirement. */
+DEVICE_ATTR(fan3_rpm, 0444, show_fan1_rpm, NULL);
+DEVICE_ATTR(fan4_rpm, 0444, show_fan2_rpm, NULL);
+
+/* ----------- speed attributes ---------- */
+static ssize_t show_fan1_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(flag_show_speed_by_string == 1)
+	{
+		char szSpeed[32];
+		fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(0));
+		return sprintf(buf, "%s\n", szSpeed);
+	}
+	else
+		return sprintf(buf, "%d\n", get_fan_speed(0));
+}
+static ssize_t store_fan1_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(0, (unsigned char)(write_val & 0xff));
+
+	return count;
+}
+
+static ssize_t show_fan2_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(flag_show_speed_by_string == 1)
+	{
+		char szSpeed[32];
+		fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(1));
+		return sprintf(buf, "%s\n", szSpeed);
+	}
+	else
+		return sprintf(buf, "%d\n", get_fan_speed(1));
+}
+static ssize_t store_fan2_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+
+	set_fan_speed(1, (unsigned char)(write_val & 0xff));
+	return count;
+}
+
+static ssize_t show_fan3_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	unsigned int temp;
+	if(flag_show_speed_by_string == 1)
+	{
+		char szSpeed[32];
+		fan_speed_ul_to_str(szSpeed, sizeof(szSpeed), get_fan_speed(0));
+		/* get_fan_speed(1) is used to set fan4 as software control mode */
+		temp = get_fan_speed(1);
+		return sprintf(buf, "%s\n", szSpeed);
+	}
+	else{
+		/* get_fan_speed(1) is used to set fan4 as software control mode */
+		temp = get_fan_speed(1);
+		return sprintf(buf, "%d\n", get_fan_speed(0));
+	}
+}
+static ssize_t store_fan3_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long write_val = fan_speed_str_to_ul((char*) buf );
+	if(write_val > 0xff)
+		return -EINVAL;
+	
+	set_fan_speed(0, (unsigned char)(write_val & 0xff));
+	set_fan_speed(1, (unsigned char)(write_val & 0xff));
+	return count;
+}
+
+DEVICE_ATTR(fan1_speed, 0644, show_fan1_speed, store_fan1_speed);
+DEVICE_ATTR(fan2_speed, 0644, show_fan2_speed, store_fan2_speed);
+
+/* fan3_speed and fan4_speed are added to fit Buffalo's requirement,
+   and their behavior are same to Matsu. */
+DEVICE_ATTR(fan3_speed, 0644, show_fan3_speed, store_fan3_speed);
+DEVICE_ATTR(fan4_speed, 0644, show_fan2_speed, store_fan2_speed);
+
+/* ---------- 4 steps attributes --------- */
+static ssize_t show_fan_stop_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_stop_speed);
+}
+static ssize_t store_fan_stop_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xFF)
+		return -EINVAL;
+
+	fan_stop_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_slow_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_slow_speed);
+}
+static ssize_t store_fan_slow_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xFF)
+		return -EINVAL;
+
+	fan_slow_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_fast_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_fast_speed);
+}
+static ssize_t store_fan_fast_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xFF)
+		return -EINVAL;
+
+	fan_fast_speed = tmp_speed;
+	return count;
+}
+
+static ssize_t show_fan_full_speed(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_full_speed);
+}
+static ssize_t store_fan_full_speed(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_speed = simple_strtoul(buf, NULL, 10);
+	if(tmp_speed > 0xFF)
+		return -EINVAL;
+
+	fan_full_speed = tmp_speed;
+	return count;
+}
+
+DEVICE_ATTR(fan_stop_speed, 0644, show_fan_stop_speed, store_fan_stop_speed);
+DEVICE_ATTR(fan_slow_speed, 0644, show_fan_slow_speed, store_fan_slow_speed);
+DEVICE_ATTR(fan_fast_speed, 0644, show_fan_fast_speed, store_fan_fast_speed);
+DEVICE_ATTR(fan_full_speed, 0644, show_fan_full_speed, store_fan_full_speed);
+
+/* --------- read mode attribute --------- */
+static ssize_t show_show_speed_by_string(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", flag_show_speed_by_string);
+}
+static ssize_t store_show_speed_by_string(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long value = simple_strtoul(buf, NULL, 10);
+	
+	if(value != 0 && value != 1)
+		return -EINVAL;
+
+	flag_show_speed_by_string = value;
+
+	return count;
+}
+DEVICE_ATTR(show_speed_by_string, 0644, show_show_speed_by_string, store_show_speed_by_string);
+
+/* --------- threshold attribute --------- */
+static ssize_t show_fan_threshold(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", fan_threshold);
+}
+static ssize_t store_fan_threshold(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned long tmp_threshold = simple_strtoul(buf, NULL, 10);
+	fan_threshold = tmp_threshold;
+	return count;
+}
+DEVICE_ATTR(fan_threshold, 0644, show_fan_threshold, store_fan_threshold);
+
+/* ------- device number attribute ------- */
+static ssize_t show_sugi_fan_dev(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", sugi_fan_major);
+}
+DEVICE_ATTR(sugi_fan_dev, 0444, show_sugi_fan_dev, NULL);
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2-3
+ * Description: Implement functions of HDD control driver
+ * ---------------------------------------------------------------------------------------------- */
+
+/* -------- get HDD hotplug status ------- */
+static int show_hotplug_status(struct seq_file *m, void *v)
+{
+	struct sugi_hdd_info_st *hdd_info;
+
+	hdd_info = (struct sugi_hdd_info_st *)m->private;
+
+	if (inl(ich10r_gpio_base_addr + hdd_info->HDD_GPIO_PRESENT_REG) & hdd_info->HDD_PRESENT_BIT)
+		seq_printf(m, "unplugged\n");
+	else
+		seq_printf(m, "plugged\n");
+
+	return 0;
+}
+
+static int open_hotplug_status(struct inode *inode, struct file *file)
+{
+	return single_open(file, show_hotplug_status, PDE_DATA(file_inode(file)));
+}
+
+static struct file_operations hotplug_status_fops = {
+	.owner		= THIS_MODULE,
+	.open		= open_hotplug_status,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release
+};
+
+/* ----- get HDD power control status ---- */
+static int show_power_control_status(struct seq_file *m, void *v)
+{
+	struct sugi_hdd_info_st *hdd_info;
+
+	hdd_info = (struct sugi_hdd_info_st *)m->private;
+
+	if (inl(ich10r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG) & hdd_info->HDD_POWER_BIT)
+		seq_printf(m, "on\n");
+	else
+		seq_printf(m, "off\n");
+
+	return 0;
+}
+
+static int open_power_control_status(struct inode *inode, struct file *file)
+{
+	return single_open(file, show_power_control_status, PDE_DATA(file_inode(file)));
+}
+
+/* ----- set HDD power control status ---- */
+static int store_power_control_status(struct file *file, const char *buffer, size_t count, loff_t *offset)
+{
+	int tmpgpioval;
+	struct sugi_hdd_info_st *hdd_info = (struct sugi_hdd_info_st *)PDE_DATA(file_inode(file));
+
+	tmpgpioval = inl(ich10r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG);
+
+	if (strncmp(buffer, "off", strlen("off")) == 0) {
+		if (tmpgpioval & hdd_info->HDD_POWER_BIT) {
+			tmpgpioval &= hdd_info->HDD_POWER_MASK;
+			outl(tmpgpioval, ich10r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG);
+			return count;
+		}
+	}
+	
+	if(strncmp(buffer, "on", strlen("on")) == 0){
+		if (!(tmpgpioval & hdd_info->HDD_POWER_BIT)){
+			tmpgpioval |= hdd_info->HDD_POWER_BIT;
+			outl(tmpgpioval, ich10r_gpio_base_addr + hdd_info->HDD_GPIO_POWER_REG);
+			return count;
+		}
+	}
+	
+		return -EINVAL;
+}
+
+static struct file_operations power_control_status_fops = {
+	.owner		= THIS_MODULE,
+        .open		= open_power_control_status,
+        .write		= store_power_control_status,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release
+};
+
+/* ----------- polling function ---------- */
+
+static void SataHotplugPollingUpdatePinstat(void)
+{
+	unsigned int i = 0;
+	
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sata_hotplug_data[i].presentpinstat = (inl(ich10r_gpio_base_addr + sugi_hdd_info[i].HDD_GPIO_PRESENT_REG) & sugi_hdd_info[i].HDD_PRESENT_BIT)? SATA_STAT_UNPLUGGED:SATA_STAT_PLUGGED;
+	}
+}
+
+static void SataHotplugPolling(unsigned long data)
+{
+	unsigned int i = 0;
+	char buf[32];
+
+	SataHotplugPollingUpdatePinstat();
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		if(sata_hotplug_data[i].prevplugstat == sata_hotplug_data[i].presentpinstat)
+		{
+			sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+			continue;
+		}
+		--sata_hotplug_data[i].loops;
+
+		if(sata_hotplug_data[i].loops == 0)
+		{
+			if(sata_hotplug_data[i].presentpinstat == SATA_STAT_PLUGGED)
+				sprintf(buf, PLUGGED_EVENT_MSG, i);
+			else
+				sprintf(buf, UNPLUGGED_EVENT_MSG, i);
+
+			#ifdef CONFIG_BUFFALO_PLATFORM
+				buffalo_kernevnt_queuein(buf);
+			#else
+				printk("EVENT IS OCCURRED\n");
+			#endif
+			
+			sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+			sata_hotplug_data[i].prevplugstat = sata_hotplug_data[i].presentpinstat;
+		}
+	}
+	sata_hotplug_polling_timer.expires += SATA_POL_INTERVAL;
+	add_timer(&sata_hotplug_polling_timer);
+}
+
+static unsigned long SataHotplugPollingStart(void)
+{
+	unsigned int i = 0;
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++)
+	{
+		sata_hotplug_data[i].prevplugstat = SATA_STAT_UNKNOWN;
+		sata_hotplug_data[i].loops = SATA_POL_LOOPS;
+	}
+
+        init_timer(&sata_hotplug_polling_timer);
+        sata_hotplug_polling_timer.expires = jiffies + SATA_POL_INTERVAL;
+        sata_hotplug_polling_timer.function = SataHotplugPolling;
+        add_timer(&sata_hotplug_polling_timer);
+
+        return 0;
+}
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2-4
+ * Description: Implement functions of CMOS driver
+ * ---------------------------------------------------------------------------------------------- */
+static unsigned char checksum_caculation(unsigned char wol, unsigned char acp, unsigned char lan)
+{
+	return (CMOS_CHANGE_CHECKSUM - wol - (acp << 1) - (lan * 6));
+}
+static int smi_write(void)
+{
+	int smi_count = 0;
+	int read_count = 0;
+	
+	for(smi_count = 0; smi_count < 3; smi_count++){
+		outb(SW_SMI_WRITE, SW_SMI_OFFSET);
+		for(read_count = 0; read_count < 10; read_count++){
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			/* return error code of write "pass" or "fail" */
+			if(inb(CMOS_DATA_PORT) == 0x40 || inb(CMOS_DATA_PORT) == 0xEF || inb(CMOS_DATA_PORT) == 0xFF)
+				return inb(CMOS_DATA_PORT);
+			mdelay(100);
+		}
+	}
+	/* return 0 after sending SMI 3 times and waiting for 0.5s delay 10 times  */
+	return 0;
+}
+
+static int smi_read(void)
+{
+	int smi_count = 0;
+	int read_count = 0;
+	
+	/* clear 73h to 0 */
+	outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+	while(inb(CMOS_DATA_PORT))
+		outb(0x00, CMOS_DATA_PORT);
+	
+	for(smi_count = 0; smi_count < 3; smi_count++){
+		outb(SW_SMI_READ, SW_SMI_OFFSET);
+		for(read_count = 0; read_count < 10; read_count++){
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			/* return error code of read "pass" or "fail" */
+			if(inb(CMOS_DATA_PORT) == 0x40 || inb(CMOS_DATA_PORT) == 0xEF)
+				return inb(CMOS_DATA_PORT);
+			mdelay(100);
+		}
+	}
+	/* return 0 after sending SMI 3 times and waiting for 0.5s delay 10 times  */
+	return 0;
+}
+
+/* -------- wake on LAN attribute -------- */
+static ssize_t show_wol_setting(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret;
+	
+	if(bios_ver >= 209){
+		ret = smi_read();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0xEF:
+				printk("NVRAM_READ_FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0x40:
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	
+	outb(WOL_OFFSET, CMOS_INDEX_PORT);
+	ret = inb(CMOS_DATA_PORT);
+	
+	if(ret == 0){
+		return sprintf(buf, "off\n");
+	}
+	else if(ret == 1){
+		return sprintf(buf, "on\n");
+	}
+	return sprintf(buf, "UNKNOWN\n");
+}
+static ssize_t store_wol_setting(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	int len = 0;
+	unsigned char wol_setting_value = 0;
+	unsigned char power_setting_value = 0;
+	unsigned char lanboot_setting_value = 0;
+	unsigned char checksum_caculated = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if((len != 3) && (len != 4)){
+		printk("WRONG_STRING\n");
+		return count;
+	}
+	
+	if(bios_ver >= 209){
+		ret = smi_read();
+
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				return count;
+			case 0xEF:
+				printk("NVRAM_READ_FAIL\n");
+				return count;
+			case 0x40:
+				outb(LANBOOT_OFFSET, CMOS_INDEX_PORT);
+				lanboot_setting_value = inb(CMOS_DATA_PORT);
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				return count;
+		}
+	}
+	
+	outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+	power_setting_value = inb(CMOS_DATA_PORT);
+		
+	if((len == 3) && (strncmp(buf, "on", strlen("on")) == 0)){
+		outb(WOL_OFFSET, CMOS_INDEX_PORT);
+		outb(WOL_ENABLE, CMOS_DATA_PORT);
+		
+		wol_setting_value = inb(CMOS_DATA_PORT);
+		if(wol_setting_value == WOL_ENABLE){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+	
+	if((len == 4) && (strncmp(buf, "off", strlen("off")) == 0)){
+		outb(WOL_OFFSET, CMOS_INDEX_PORT);
+		outb(WOL_DISABLE, CMOS_DATA_PORT);
+		
+		wol_setting_value = inb(CMOS_DATA_PORT);
+		if(wol_setting_value == WOL_DISABLE){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+
+	if(bios_ver >=209){
+		ret = smi_write();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				break;
+			case 0xEF:
+				printk("NVRAM_CMOS_COMPARE_FAIL\n");
+				break;
+			case 0xFF:
+				printk("NVRAM_WRITE_FAIL\n");
+				break;
+			case 0x40:
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				break;
+		}
+	}
+
+	return count;
+}
+
+DEVICE_ATTR(wol_setting, 0644, show_wol_setting, store_wol_setting);
+
+/* ------- AC power loss attribute ------- */
+static ssize_t show_power_setting(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret;
+	
+	if(bios_ver >= 209){
+		ret = smi_read();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0xEF:
+				printk("NVRAM_READ_FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0x40:
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	
+	outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+	ret = inb(CMOS_DATA_PORT);
+	
+	if(ret==0){
+		return sprintf(buf, "off\n");
+	}
+	else if(ret==1){
+		return sprintf(buf, "on\n");
+	}
+	else if(ret==2){
+		return sprintf(buf, "last state\n");
+	}
+	return sprintf(buf, "UNKNOWN\n");
+}
+static ssize_t store_power_setting(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	int len = 0;
+	unsigned char wol_setting_value = 0;
+	unsigned char power_setting_value = 0;
+	unsigned char lanboot_setting_value = 0;
+	unsigned char checksum_caculated = 0;
+	
+	while(buf[len])
+		len++;
+		
+//	if((len != 3) || (len != 4) || (len != 5)){
+//		printk("WRONG_STRING [%d]\n", len);
+//		return count;
+//	}
+		
+	if(bios_ver >= 209){
+		ret = smi_read();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				return count;
+			case 0xEF:
+				printk("NVRAM_READ_FAIL\n");
+				return count;
+			case 0x40:
+				outb(LANBOOT_OFFSET, CMOS_INDEX_PORT);
+				lanboot_setting_value = inb(CMOS_DATA_PORT);
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				return count;
+		}
+	}
+	
+	outb(WOL_OFFSET, CMOS_INDEX_PORT);
+	wol_setting_value = inb(CMOS_DATA_PORT);
+	
+//	if((len == 3) && (strncmp(buf, "on", strlen("on")) == 0)){
+	if(strncmp(buf, "on", strlen("on")) == 0){
+		outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+		outb(AC_POWER_LOSS_POWER_ON, CMOS_DATA_PORT);
+		
+		if(bios_ver < 209){
+			ret = pci_read_config_word(pdev, GEN_PMCON_3, &afterg3_en);
+		afterg3_en &=(~0x0001);
+			ret = pci_write_config_word(pdev, GEN_PMCON_3, afterg3_en);
+		}
+		
+		power_setting_value = inb(CMOS_DATA_PORT);
+		if(power_setting_value == AC_POWER_LOSS_POWER_ON){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+	
+//	if((len == 4) && (strncmp(buf, "off", strlen("off")) == 0)){
+	if(strncmp(buf, "off", strlen("off")) == 0){
+		outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+		outb(AC_POWER_LOSS_POWER_OFF, CMOS_DATA_PORT);
+		
+		if(bios_ver < 209){
+			ret = pci_read_config_word(pdev, GEN_PMCON_3, &afterg3_en);
+		afterg3_en |= 0x0001;
+			ret = pci_write_config_word(pdev, GEN_PMCON_3, afterg3_en);
+		}
+		
+		power_setting_value = inb(CMOS_DATA_PORT);
+		if(power_setting_value == AC_POWER_LOSS_POWER_OFF){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+
+//	if((len == 5) && (strncmp(buf, "last", strlen("last")) == 0)){
+	if(strncmp(buf, "last", strlen("last")) == 0){
+		outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+		outb(AC_POWER_LOSS_LAST_STATE, CMOS_DATA_PORT);
+		
+		if(bios_ver){
+			ret = pci_read_config_word(pdev, GEN_PMCON_3, &afterg3_en);
+		afterg3_en &= 0xFFFE;
+			ret = pci_write_config_word(pdev, GEN_PMCON_3, afterg3_en);
+		}
+		
+		power_setting_value = inb(CMOS_DATA_PORT);
+		if(power_setting_value == AC_POWER_LOSS_LAST_STATE){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+
+	if(bios_ver >=209){
+		ret = smi_write();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				break;
+			case 0xEF:
+				printk("NVRAM_CMOS_COMPARE_FAIL\n");
+				break;
+			case 0xFF:
+				printk("NVRAM_WRITE_FAIL\n");
+				break;
+			case 0x40:
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				break;
+		}
+	}
+
+	return count;
+}
+
+DEVICE_ATTR(power_setting, 0644, show_power_setting, store_power_setting);
+
+/* -------- Gbe LAN boot attribute ------- */
+static ssize_t show_lanboot_setting(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int ret;
+	
+	if(bios_ver >= 209){
+		ret = smi_read();
+		
+		switch(ret){
+			case 0: 
+				printk("BIOS_NO_RESPONSE\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0xEF:
+				printk("NVRAM_READ_FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+			case 0x40:
+				break;
+			default:
+				printk("UNKNOWN FAIL\n");
+				return sprintf(buf, "UNKNOWN\n");
+		}
+	}
+	
+	outb(LANBOOT_OFFSET, CMOS_INDEX_PORT);
+	ret = inb(CMOS_DATA_PORT);
+	
+	if(ret==0){
+		return sprintf(buf, "off\n");
+	}
+	else if(ret==1){
+		return sprintf(buf, "on\n");
+	}
+
+	return sprintf(buf, "UNKNOWN\n");
+}
+static ssize_t store_lanboot_setting(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	int len = 0;
+	unsigned char wol_setting_value = 0;
+	unsigned char power_setting_value = 0;
+	unsigned char lanboot_setting_value = 0;
+	unsigned char checksum_caculated = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if((len != 3) && (len != 4)){
+		printk("WRONG_STRING\n");
+		return count;
+	}
+	
+	ret = smi_read();
+		
+	switch(ret){
+		case 0: 
+			printk("BIOS_NO_RESPONSE\n");
+			return count;
+		case 0xEF:
+			printk("NVRAM_READ_FAIL\n");
+			return count;
+		case 0x40:
+			break;
+		default:
+			printk("UNKNOWN FAIL\n");
+			return count;
+	}
+	
+	outb(WOL_OFFSET, CMOS_INDEX_PORT);
+	wol_setting_value = inb(CMOS_DATA_PORT);
+	outb(AC_POWER_LOSS_OFFSET, CMOS_INDEX_PORT);
+	power_setting_value = inb(CMOS_DATA_PORT);
+		
+	if((len == 3) && (strncmp(buf, "on", strlen("on")) == 0)){
+		outb(LANBOOT_OFFSET, CMOS_INDEX_PORT);
+		outb(LANBOOT_ENABLE, CMOS_DATA_PORT);
+		
+		lanboot_setting_value = inb(CMOS_DATA_PORT);
+		if(lanboot_setting_value == LANBOOT_ENABLE){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+	
+	if((len == 4) && (strncmp(buf, "off", strlen("off")) == 0)){
+		outb(LANBOOT_OFFSET, CMOS_INDEX_PORT);
+		outb(LANBOOT_DISABLE, CMOS_DATA_PORT);
+		
+		lanboot_setting_value = inb(CMOS_DATA_PORT);
+		if(lanboot_setting_value == LANBOOT_DISABLE){
+			checksum_caculated = checksum_caculation(wol_setting_value, power_setting_value, lanboot_setting_value);
+			outb(CMOS_CHECKSUM_OFFSET, CMOS_INDEX_PORT);
+			outb(checksum_caculated, CMOS_DATA_PORT);
+		}
+		else
+			printk("CMOS_VALUE_FAIL\n");
+	}
+
+	ret = smi_write();
+		
+	switch(ret){
+		case 0: 
+			printk("BIOS_NO_RESPONSE\n");
+			break;
+		case 0xEF:
+			printk("NVRAM_CMOS_COMPARE_FAIL\n");
+			break;
+		case 0xFF:
+			printk("NVRAM_WRITE_FAIL\n");
+			break;
+		case 0x40:
+			break;
+		default:
+			printk("UNKNOWN FAIL\n");
+			break;
+	}
+
+	return count;
+}
+
+DEVICE_ATTR(lanboot_setting, 0644, show_lanboot_setting, store_lanboot_setting);
+
+/* ------- device number attribute ------- */
+static ssize_t show_sugi_cmos_dev(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", sugi_cmos_major);
+}
+DEVICE_ATTR(sugi_cmos_dev, 0444, show_sugi_cmos_dev, NULL);
+
+/* ----------- PID attribute ------------ */
+static ssize_t show_device_id(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i=0;
+	char rv[32]; 
+	
+	for(i=0; i<=31; i++){
+		outb(device_id_offset[i], CMOS_INDEX_PORT);
+		rv[i] = inb(CMOS_DATA_PORT);
+	}
+	
+	return sprintf(buf, "%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c\n",
+	rv[0], rv[1], rv[2], rv[3], rv[4], rv[5], rv[6], rv[7], 
+	rv[8], rv[9], rv[10], rv[11], rv[12], rv[13], rv[14], rv[15],
+	rv[16], rv[17], rv[18], rv[19], rv[20], rv[21], rv[22], rv[23], 
+	rv[24], rv[25], rv[26], rv[27], rv[28], rv[29], rv[30], rv[31]);
+}
+
+static ssize_t store_device_id(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int i;
+	int len = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if(len != 33){
+		printk("WRONG_STRING\n");
+		return count;
+	}
+	
+	if(len == 33){
+		for(i = 0; i <= 31; i++){
+			if((buf[i] < 32) || (buf[i] > 126)){
+				printk("WRONG_STRING\n");
+				return count;
+			}
+		}
+	
+		for(i = 0; i <= 31; i++){
+			outb(device_id_offset[i], CMOS_INDEX_PORT);
+			outb(buf[i], CMOS_DATA_PORT);
+		}
+	}
+	
+	return count;
+}
+
+DEVICE_ATTR(device_id, 0644, show_device_id, store_device_id);
+
+/* --------- checksum attribute ---------- */
+static ssize_t show_checksum(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	int i;
+	unsigned int rv = 0;
+	
+	for(i=0; i<=3; i++) {
+		outb(checksum_offset[i], CMOS_INDEX_PORT);
+		rv |= inb(CMOS_DATA_PORT) << 8*(3-i);
+	}
+	
+	return sprintf(buf, "%08x\n", rv);
+}
+
+static ssize_t store_checksum(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	int i, j, tmp, len=0;
+	unsigned char checksum_orig[8];
+	unsigned char success_flag = 0;
+	
+	while(buf[len])
+		len++;
+	
+	if(len != 9){
+		printk("WRONG_STRING\n");
+		return count;
+	}
+	
+	else if(len == 9){
+		for(i=0; i<=7; i++) {
+			for(j=0; j<=21; j++) {
+				if(buf[i] == strtoint_info[j].strg){
+					checksum_orig[i] = strtoint_info[j].inte;
+					success_flag = 1;
+				}
+				else if (j == 21 && success_flag == 0){
+					printk("WRONG_STRING\n");
+					return count;
+				}
+			}
+			success_flag = 0;
+		}
+	
+		for(i=0; i<=3; i++) {
+			tmp = (checksum_orig[2*i] << 4) + checksum_orig[2*i+1];
+			outb(checksum_offset[i], CMOS_INDEX_PORT);
+			outb(tmp, CMOS_DATA_PORT);
+		}
+	}
+	
+	return count;
+}
+
+DEVICE_ATTR(checksum, 0644, show_checksum, store_checksum);
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2-5
+ * Description: Implement functions of board ID driver
+ * ---------------------------------------------------------------------------------------------- */
+
+/* ---------- board ID attribute --------- */
+static ssize_t show_board_id(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	if(boardid_num==0)
+		return sprintf(buf,"2HDD\n");
+	else if(boardid_num==1)
+		return sprintf(buf,"4HDD\n");
+	else if(boardid_num==2)
+		return sprintf(buf,"6HDD\n");
+	else if(boardid_num==3)
+		return sprintf(buf,"8HDD\n");
+	else if(boardid_num==4)
+		return sprintf(buf,"1U\n");
+	
+	return sprintf(buf, "Unknown\n");
+}
+
+DEVICE_ATTR(board_id, 0444, show_board_id, NULL);
+
+/* ------- device number attribute ------- */
+static ssize_t show_sugi_boardid_dev(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", sugi_boardid_major);
+}
+
+DEVICE_ATTR(sugi_boardid_dev, 0444, show_sugi_boardid_dev, NULL);
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 3
+ * Description: Chipsets and file system sheeting
+ * ---------------------------------------------------------------------------------------------- */
+
+/* ------- proc file system setting ------ */
+static int init_proc_files(void)
+{
+	int i = 0;
+	char buf[32];
+	
+	/* create /proc/buffalo */
+#if ! defined(CONFIG_BUFFALO_PLATFORM)
+	buffalo_dir = proc_mkdir(BUFFALO_DIR, NULL);
+#endif
+	
+	/* create /proc/buffalo/gpio */
+	gpio_dir = proc_mkdir(GPIO_DIR, NULL);
+	
+	
+	/* button driver */
+	/* create /proc/buffalo/gpio/switch */
+	switch_dir = proc_mkdir(SWITCH_DIR, NULL);
+	
+	/* create /proc/buffalo/gpio/switch/func(display) */
+	for(i = 0; i < MAX_SUPPORTED_BUTTONS; i++){
+		switch_file[i] = proc_create_data(button_info[i].name, 0444, switch_dir, &button_status_fops, &button_info[i]);
+}
+
+
+	/* HDD control driver */
+	/* create /proc/buffalo/gpio/hotplug */
+	hotplug_dir = proc_mkdir(HOTPLUG_DIR, NULL);
+	
+	/* create /proc/buffalo/gpio/hotplug/sata# */
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++){
+		sprintf(buf, "sata%d", i);
+		hotplug_sata_file[i] = proc_create_data(buf, 0444, hotplug_dir, &hotplug_status_fops, &sugi_hdd_info[i]);
+}
+
+	/* create /proc/buffalo/gpio/power_control */
+	power_control_dir = proc_mkdir(POWER_CONTROL_DIR, NULL);
+
+	/* create /proc/buffalo/gpio/power_control/hdd# */
+	for(i = 0; i < MAX_SUPPORTED_DISKS; i++){
+		sprintf(buf, "hdd%d", i);
+		power_control_hdd_file[i] = proc_create_data(buf, 0644, power_control_dir, &power_control_status_fops, &sugi_hdd_info[i]);
+	}	
+
+	return 0;
+}
+
+
+/* ---------- sysfs file system ---------- */
+static int init_sysfs_files(void)
+{
+	int rv;
+	
+	if(sugi_cls)
+		return -EINVAL;
+
+	/* create /sys/class/sugi */
+	sugi_cls = class_create(THIS_MODULE, "sugi");
+
+
+	/* fan control driver */
+	/* create /sys/class/sugi/fan */
+	fan_dev = device_create(sugi_cls, NULL, sugit_fan, NULL, "fan");
+	
+	/* create /sys/class/sugi/fan/temp# */
+	rv = device_create_file(fan_dev, &dev_attr_temp1);
+	rv = device_create_file(fan_dev, &dev_attr_temp2);
+	rv = device_create_file(fan_dev, &dev_attr_temp3);
+	
+	/* create /sys/class/sugi/fan/fan#_rpm */
+	rv = device_create_file(fan_dev, &dev_attr_fan1_rpm);
+	rv = device_create_file(fan_dev, &dev_attr_fan2_rpm);
+	rv = device_create_file(fan_dev, &dev_attr_fan3_rpm);
+	rv = device_create_file(fan_dev, &dev_attr_fan4_rpm);
+	
+	/* create /sys/class/sugi/fan/fan#_speed */
+	rv = device_create_file(fan_dev, &dev_attr_fan1_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan2_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan3_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan4_speed);
+    
+	/* create /sys/class/sugi/fan/fan_pattern_speed */
+	rv = device_create_file(fan_dev, &dev_attr_fan_stop_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan_slow_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan_fast_speed);
+	rv = device_create_file(fan_dev, &dev_attr_fan_full_speed);
+    
+	/* create /sys/class/sugi/fan/show_speed_by string */
+	rv = device_create_file(fan_dev, &dev_attr_show_speed_by_string);
+    
+	/* create /sys/class/sugi/fan/fan_threshold */
+	rv = device_create_file(fan_dev, &dev_attr_fan_threshold);
+    
+	/* create /sys/class/sugi/fan/sugi_fan_dev */
+	rv = device_create_file(fan_dev, &dev_attr_sugi_fan_dev);
+	
+	
+	/* CMOS driver */
+	/* create /sys/class/sugi/cmos */
+	cmos_dev = device_create(sugi_cls, NULL, sugit_cmos, NULL, "cmos");
+	
+	/* create /sys/class/sugi/cmos/wol_setting */
+	rv = device_create_file(cmos_dev, &dev_attr_wol_setting);
+		
+	/* create /sys/class/sugi/cmos/power_setting */
+	rv = device_create_file(cmos_dev, &dev_attr_power_setting);
+		
+	/* create /sys/class/sugi/cmos/sugi_cmos_dev */
+	rv = device_create_file(cmos_dev, &dev_attr_sugi_cmos_dev);
+	
+		/* create /sys/class/sugi/cmos/pid */
+	rv = device_create_file(cmos_dev, &dev_attr_device_id);
+	
+	/* create /sys/class/sugi/cmos/checksum */
+	rv = device_create_file(cmos_dev, &dev_attr_checksum);
+  
+  /* create /sys/class/sugi/cmos/lanboot_setting */
+  /* this node and the related funciton will be 
+     created if the BIOS version is newer than V209*/
+  if(bios_ver >= 209)
+  	rv = device_create_file(cmos_dev, &dev_attr_lanboot_setting);
+  
+	
+	/* board ID driver */
+	/* create /sys/class/sugi/board */
+	boardid_dev = device_create(sugi_cls, NULL, sugit_boardid, NULL, "board");
+	
+	/* create /sys/class/sugi/board/board_id */
+	rv = device_create_file(boardid_dev, &dev_attr_board_id);
+		
+	/* create /sys/class/sugi/board/sugi_boardid_dev */
+	rv = device_create_file(boardid_dev, &dev_attr_sugi_boardid_dev);
+	
+	return 0;
+}
+
+/* ---------- BIOS version check --------- */
+static int bios_version_check(void)
+{
+	int i;
+	unsigned char* smbios_sm = NULL;
+	unsigned char* smbios_dmi = NULL;
+	unsigned char* smbios_eps = NULL;
+	unsigned char* smbios_base = NULL;
+	unsigned char* smbios_ver = NULL;
+	unsigned int smbios_base_addr = 0;
+
+	for(i = 0; i <= 0xFFF0; i += 0x01){
+		smbios_sm = ioremap(0x000F0000 + i, 4);
+		if(strncmp(smbios_sm, "_SM_", strlen("_SM_")) == 0){
+			smbios_dmi = ioremap(0x000F0000 + i + 0x10, 4);
+			if(strncmp(smbios_dmi, "_DMI_", strlen("_DMI_"))== 0){
+				smbios_eps = ioremap(0x000F0000 + i + 0x18, 4);
+				smbios_base_addr = ioread32(smbios_eps);
+				break;
+			}
+		}
+	}
+	
+	for(i = 0; i <= 0xFF; i += 0x01){
+		smbios_base = ioremap(smbios_base_addr + i, 1);
+		if(ioread8(smbios_base) == 0x33){
+			if(strncmp(smbios_base, "31SUG", strlen("31SUG")) == 0){
+				smbios_ver = ioremap(smbios_base_addr + i + 0x05, 1);
+				bios_ver = simple_strtoul(smbios_ver, NULL, 10);
+				iounmap(smbios_sm);
+				iounmap(smbios_dmi);
+				iounmap(smbios_eps);
+				iounmap(smbios_base);
+				iounmap(smbios_ver);
+				printk("BIOS VERSION : V%d\n",bios_ver);
+				return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+/* ------------ IT8721 setting ----------- */
+	
+	/* button driver */
+void SetBTNMBPnP(void)
+{
+	unsigned int base_msb;
+	unsigned int base_lsb;
+	
+	/* select LDN 07h */	
+	outb(IT87_LDN_ADDR, CONFIG_ADDR_PORT);
+	outb(IT87_GPIO_LDN, CONFIG_DATA_PORT);
+	
+	/* find GPIO set3 base addr */
+	outb(IT87_SIMPLE_IO_BASE_MSB, CONFIG_ADDR_PORT);
+	base_msb = inb(CONFIG_DATA_PORT);
+	outb(IT87_SIMPLE_IO_BASE_LSB, CONFIG_ADDR_PORT);
+	base_lsb = inb(CONFIG_DATA_PORT);
+	it87_gpioset3_base_addr = (base_msb*256 + base_lsb) + GPIO_SET3_OFFSET;
+	
+	/* enable to generate SMI of PBD's IRQ */
+	outb(IT87_REG_SMI_CTL2, CONFIG_ADDR_PORT);
+	outb(inb(CONFIG_DATA_PORT)|0x01, CONFIG_DATA_PORT);
+	
+	/* set GPIO34/35 as de-bounce GPIO */
+	outb(IT87_REG_PNL_DBOUNCE0, CONFIG_ADDR_PORT);
+	outb(IT87_GP34_LOC | IT87_IRQEN, CONFIG_DATA_PORT);
+	
+	outb(IT87_REG_PNL_DBOUNCE1, CONFIG_ADDR_PORT);
+	outb(IT87_GP35_LOC, CONFIG_DATA_PORT);
+	
+	outb(IT87_REG_PNL_IRQ_SEL, CONFIG_ADDR_PORT);
+	outb(IT87_PNL_IRQ3, CONFIG_DATA_PORT);
+	}
+	
+/* fan control driver */
+void SetFANMBPnP(void)
+{
+	unsigned short BASE_ADDR_EXT;
+	unsigned short BASE_ADDR;
+
+	outb(IT87_LDN_ADDR, CONFIG_ADDR_PORT);
+	outb(IT87_EC_LDN, CONFIG_DATA_PORT);
+	outb(0x60,CONFIG_ADDR_PORT);
+	BASE_ADDR_EXT = inb(CONFIG_DATA_PORT)*256;
+	outb(0x61,CONFIG_ADDR_PORT);
+	BASE_ADDR = inb(CONFIG_DATA_PORT);
+  EC_BASE_ADDR = BASE_ADDR_EXT+BASE_ADDR;
+  IT87_EC_ADDR_REG = EC_BASE_ADDR+0x05;
+  IT87_EC_DATA_REG = EC_BASE_ADDR+0x06;
+}
+
+/* ------------ ich10r setting ----------- */
+static int ich10r_setting(void)
+{
+	int ret;
+	
+	pdev = pci_get_device(INTEL_ICH10R_VID, INTEL_ICH10R_DID, NULL);
+	if(!pdev)
+		return -ENODEV;
+	
+	ret = pci_read_config_dword(pdev, GPIOBASE, &ich10r_gpio_base_addr);
+	if(ret)
+		return -EINVAL;
+		
+	ret = pci_read_config_dword(pdev, PMBASE, &ich10r_pm_base_addr);
+	if(ret)
+		return -EINVAL;
+		
+	ich10r_gpio_base_addr &= 0x0000FF80;
+	
+	ich10r_pm_base_addr &= 0x0000FF80;
+	
+	/* Board ID driver */
+	/* set GPIO pin 29, 30 ,31 as GPIO function */
+	outl((inl(ich10r_gpio_base_addr+GP_USE_SEL)|0xE0000000), ich10r_gpio_base_addr+GP_USE_SEL);
+	
+	/* set GPIO pin 29, 30 ,31 as input */
+	outl((inl(ich10r_gpio_base_addr+GP_IO_SEL)|0xE0000000), ich10r_gpio_base_addr+GP_IO_SEL);
+	
+	/* get board ID relative GPIO pins status */
+	boardid_num = (inl(ich10r_gpio_base_addr+GP_LVL)&BOARD_ID_MASK) >> BOARD_ID_OFFSET;
+	
+	/* HDD control driver */
+	/* set relative GPIO pins as GPIO function */
+	outl((inl(ich10r_gpio_base_addr+GP_USE_SEL)|0x0002A6FD), ich10r_gpio_base_addr+GP_USE_SEL);
+	outl((inl(ich10r_gpio_base_addr+GP_USE_SEL2)|0x01000007), ich10r_gpio_base_addr+GP_USE_SEL2);
+	
+	/* set hotplug relative GPIO pins as input */
+	outl((inl(ich10r_gpio_base_addr+GP_IO_SEL)|0x0000A63C), ich10r_gpio_base_addr+GP_IO_SEL);
+	
+	/* set power control relative GPIO pins as outout */
+	outl((inl(ich10r_gpio_base_addr+GP_IO_SEL)&0xFFFDFF3D), ich10r_gpio_base_addr+GP_IO_SEL);
+	outl((inl(ich10r_gpio_base_addr+GP_IO_SEL2)&0xFEFFFFF8), ich10r_gpio_base_addr+GP_IO_SEL2);
+	
+	return 0;
+}
+
+/* ------------ initialization ----------- */
+static int __init sugi_platform_init(void)
+{  	
+	int ret;
+	
+	/* request IRQ3 */
+	ret = request_irq(3, sugi_interrupt, IRQF_SHARED, DRVNAME, sugi_interrupt);
+  if(ret){
+    printk("REQUEST IRQ3 FAIL\n");
+		free_irq(3, 0);
+    return -EBUSY;
+  }
+	
+	/* chipsets initilization */
+	/* ICH10R */
+	ret = ich10r_setting();
+	if(ret)
+		return -ENODEV;
+	/* IT8721 */	
+	EnterMBPnP();
+	SetFANMBPnP();
+	//ExitMBPnP();
+	
+	//EnterMBPnP();
+	SetBTNMBPnP();
+	ExitMBPnP();
+	
+	/* register device to system */	
+	ret = register_chrdev_region(sugit_fan, sugi_dev_count, DRVNAME);
+	ret = register_chrdev_region(sugit_cmos, sugi_dev_count, DRVNAME);
+	ret = register_chrdev_region(sugit_boardid, sugi_dev_count, DRVNAME);
+	
+	/* check BIOS verion */
+	ret = bios_version_check();
+	if(ret)
+		return -EINVAL;
+	
+	/* create sysfs file system */
+	ret = init_sysfs_files();
+	if(ret)
+		return -ENOMEM;
+		
+	/* create proc file system */
+	ret = init_proc_files();
+	if(ret)
+		return -ENOMEM;
+	
+	SataHotplugPollingStart();
+	
+	printk("SUGI_PLATFORM MODULE HAS BEEN INITIALIZED\n");
+	
+	return 0;
+}
+
+/* ----------------- exit ---------------- */
+static void __exit sugi_platform_exit(void)
+{
+	int i = 0;
+	char buf[32];
+	
+	/* delete hotplug polling timer */
+	del_timer(&sata_hotplug_polling_timer);
+	
+	/* disable and release IRQ3 */
+	disable_irq(3);
+	free_irq(3, sugi_interrupt);
+	
+	/* remove proc file system nodes */
+	for(i = 0; i < MAX_SUPPORTED_BUTTONS; i++){
+		remove_proc_entry(button_info[i].name, switch_dir);
+	}
+	
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++){
+		sprintf(buf, "hdd%d", i);
+		remove_proc_entry(buf, power_control_dir);
+	}
+	
+	for (i = 0; i < MAX_SUPPORTED_DISKS; i++){
+		sprintf(buf, "sata%d", i);
+		remove_proc_entry(buf, hotplug_dir);
+	}
+	
+	remove_proc_entry(SWITCH_DIR, NULL);
+	remove_proc_entry(HOTPLUG_DIR, NULL);
+	remove_proc_entry(POWER_CONTROL_DIR, NULL);
+	remove_proc_entry(GPIO_DIR, NULL);
+	remove_proc_entry(BUFFALO_DIR, NULL);
+	
+	/* remove sysfs file system */
+	device_remove_file(fan_dev, &dev_attr_temp1);
+	device_remove_file(fan_dev, &dev_attr_temp2);
+	device_remove_file(fan_dev, &dev_attr_temp3);
+	device_remove_file(fan_dev, &dev_attr_fan1_rpm);
+	device_remove_file(fan_dev, &dev_attr_fan2_rpm);
+	device_remove_file(fan_dev, &dev_attr_fan1_speed);
+	device_remove_file(fan_dev, &dev_attr_fan2_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_stop_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_slow_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_fast_speed);
+	device_remove_file(fan_dev, &dev_attr_fan_full_speed);
+	device_remove_file(fan_dev, &dev_attr_sugi_fan_dev);
+	device_remove_file(fan_dev, &dev_attr_fan_threshold);
+	device_remove_file(fan_dev, &dev_attr_show_speed_by_string);
+	
+	device_remove_file(cmos_dev, &dev_attr_wol_setting);
+	device_remove_file(cmos_dev, &dev_attr_power_setting);
+	device_remove_file(cmos_dev, &dev_attr_sugi_cmos_dev);
+	device_remove_file(cmos_dev, &dev_attr_device_id);
+	device_remove_file(cmos_dev, &dev_attr_checksum);
+	
+	if(bios_ver >= 209)
+		device_remove_file(cmos_dev, &dev_attr_lanboot_setting);
+	
+	device_remove_file(boardid_dev, &dev_attr_sugi_boardid_dev);
+	device_remove_file(boardid_dev, &dev_attr_board_id);
+	
+	device_destroy(sugi_cls, sugit_fan);
+	device_destroy(sugi_cls, sugit_cmos);
+	device_destroy(sugi_cls, sugit_boardid);
+	
+	class_destroy(sugi_cls);
+	
+	unregister_chrdev_region(sugit_fan, sugi_dev_count);
+	unregister_chrdev_region(sugit_cmos, sugi_dev_count);
+	unregister_chrdev_region(sugit_boardid, sugi_dev_count);
+  
+	printk("SUGI_PLATFORM MODULE HAS BEEN REMOVED\n");
+}
+
+module_init(sugi_platform_init);
+module_exit(sugi_platform_exit);
+MODULE_LICENSE("GPL");
diff -rubB --new-file linux-3.10.69/arch/x86/plat-usi/sugi_platform.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-usi/sugi_platform.h
--- linux-3.10.69/arch/x86/plat-usi/sugi_platform.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/arch/x86/plat-usi/sugi_platform.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,308 @@
+#if !defined __SUGI_PLATFORM_H__
+#define __SUGI_PLATFORM_H__
+
+/* common section */
+#define sugi_fan_major						125
+#define sugi_fan_minor						0
+#define sugi_cmos_major						124
+#define sugi_cmos_minor						0
+#define sugi_boardid_major				123
+#define sugi_boardid_minor				0
+#define sugi_dev_count        		1
+#define DRVNAME								"sugi_platform"
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 1
+ * Description: Definition of IT8721 registers
+ * ---------------------------------------------------------------------------------------------- */
+ 
+/* ----------- Common Sections ----------- */
+ 
+/* IT8721 config section */
+#define CONFIG_ADDR_PORT	       	0x2E
+#define CONFIG_DATA_PORT	       	0x2F
+#define IT87_LDN_ADDR		       		0x07
+ 
+/* ------------ Button Driver ------------ */
+
+/* IT8721 logic device number */
+#define	IT87_GPIO_LDN							0x07
+ 
+/* panel button de-bounce mapping */
+#define IT87_REG_PNL_DBOUNCE0			0xE0
+#define IT87_REG_PNL_DBOUNCE1			0xE1
+#define IT87_GP34_LOC							0x1C
+#define IT87_GP35_LOC							0x1D
+#define	IT87_IRQEN								0x40
+
+/* panel button de-bounce interrupt level select */
+#define IT87_REG_PNL_IRQ_SEL			0x70
+#define IT87_PNL_IRQ3							0x03	
+
+/* SMI control register, bit0 is used to enable PBD's IRQ */
+#define IT87_REG_SMI_CTL2 				0xF1
+#define SMI_CTL2_EN_PBD						0x01
+
+/* SMI status register2, bit7-6 is used to detect panel button de-bounce */
+#define IT87_REG_SMI_STS2					0xF3
+#define IT87_SMI_DEB_MASK					0xC0
+
+/* SMI status register2, bit0 is PBD's IRQ */
+#define IT87_SMI_STS2_PBD					0x01
+
+/* Simple I/O base addr */
+#define IT87_SIMPLE_IO_BASE_MSB		0x62
+#define IT87_SIMPLE_IO_BASE_LSB		0x63
+#define GPIO_SET3_OFFSET					0x2
+
+
+/* ---------- Fan Control Driver --------- */
+
+/* IT8721 logic device number */
+#define	IT87_EC_LDN								0x04
+
+/* IT8721 main fan control registers */
+#define IT87_EC_FAN_MAIN_CTL	   	0x13
+#define IT87_EC_FAN_CTL		       	0x14
+
+/* IT8721 fan tachometer registers */
+#define IT87_EC_FAN_TACO1	       	0x0D // FAN1
+#define IT87_EC_FAN_TACO2	       	0x0E // FAN2
+
+#define IT87_EC_FAN_TACO1_EXT	   	0x18
+#define IT87_EC_FAN_TACO2_EXT	   	0x19
+
+/* select PWM control mode  */
+#define IT87_EC_FAN_PWM1					0x15
+#define IT87_EC_FAN_PWM2					0x16
+
+/* set the PWM value */
+#define IT87_EC_FAN_SMART_PWM1		0x63
+#define IT87_EC_FAN_SMART_PWM2		0x6B
+
+/* IT8721 temprature registers */
+#define IT87_EC_TMPIN3						0x2B // SYSTIN(TMPIN3@schematic)
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 2
+ * Description: Definition of ICH10R registers
+ * ---------------------------------------------------------------------------------------------- */ 
+ 
+/* ----------- Common Sections ----------- */
+
+/* vendor and device ID for Intel ICH10R */
+#define INTEL_ICH10R_VID					0x8086
+#define INTEL_ICH10R_DID					0x3A16
+#define GPIOBASE									0x48
+#define PMBASE										0x40
+
+/* GPIO register*/
+#define GP_USE_SEL								0x00
+#define GP_USE_SEL2								0x30
+#define GP_IO_SEL									0x04
+#define GP_IO_SEL2								0x34
+#define GP_LVL										0x0C
+#define GP_LVL2										0x38
+
+/* Power management register */
+#define PMBASE										0x40
+#define PM1_STS										0x00
+#define PM1_EN										0x02
+#define GEN_PMCON_3								0xA4
+
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 3
+ * Description: Path of proc file system
+ * ---------------------------------------------------------------------------------------------- */
+ 
+/* ----------- Common Sections ----------- */
+#define BUFFALO_DIR								"buffalo"
+#define GPIO_DIR									"buffalo/gpio" 
+ 
+/* ------------ Button Driver ------------ */
+#define SWITCH_DIR								"buffalo/gpio/switch"
+#define MAX_SUPPORTED_BUTTONS 		2
+
+/* ---------- HDD Control Driver --------- */
+#define HOTPLUG_DIR								"buffalo/gpio/hotplug"
+#define POWER_CONTROL_DIR					"buffalo/gpio/power_control"
+#define MAX_SUPPORTED_DISKS				8
+
+/* ---------------------------------------------------------------------------------------------- *
+ * BLOCK 4
+ * Description: Definitions of individual drivers
+ * ---------------------------------------------------------------------------------------------- */
+ 
+/* ------------ Button Driver ------------ */
+
+/* period of timer */      
+#define TIMER_DELAY								(HZ/500)
+
+/* Buttons section */
+#define BTN_FUNC	    	   				0
+#define BTN_DISP	 	  		 				1
+
+/* select SMI status bit7-6 */
+#define IT87_DEB0									0x40	
+#define IT87_DEB1									0x80	
+#define IT87_DEB0DEB1							0xC0
+
+/* bit5-4 in GPIO set3 */
+#define IT87_GP34_BIT4						0x10
+#define IT87_GP35_BIT5						0x20
+
+/* button information structure */
+struct button_info_st
+{
+	char name[32];
+	unsigned char reg_stat;
+};
+
+/* ---------- Fan Control Driver --------- */
+
+/* fan control information */
+struct fan_info_st{
+	unsigned char reg;
+	unsigned char reg_ext;
+	unsigned char reg_smart_pwm;
+	unsigned char reg_pwm;
+	unsigned char offset;
+};
+
+/* ---------- HDD Control Driver --------- */
+
+/*
+    hotplug     |	power control
+----------------------------------
+sata0 -> GPIO2	|	hdd0 -> GPIO17
+sata1 -> GPIO3	|	hdd1 -> GPIO1
+sata2 -> GPIO4	|	hdd2 -> GPIO6
+sata3 -> GPIO5	|	hdd3 -> GPIO7
+sata4 -> GPIO15	|	hdd4 -> GPIO56
+sata5 -> GPIO9	|	hdd5 -> GPIO32
+sata6 -> GPIO13	|	hdd6 -> GPIO33
+sata7 -> GPIO10	|	hdd7 -> GPIO34
+
+*/
+
+/* GPIO pin definition */
+#define HDD0_PRESENT_BIT					0x00000004	/* GPIO2 */
+#define HDD1_PRESENT_BIT					0x00000008	/* GPIO3 */
+#define HDD2_PRESENT_BIT					0x00000010	/* GPIO4 */
+#define HDD3_PRESENT_BIT					0x00000020	/* GPIO5 */
+#define HDD4_PRESENT_BIT					0x00008000	/* GPIO15*/
+#define HDD5_PRESENT_BIT					0x00000200	/* GPIO9 */
+#define HDD6_PRESENT_BIT					0x00002000	/* GPIO13*/
+#define HDD7_PRESENT_BIT					0x00000400	/* GPIO10*/
+
+#define HDD0_POWER_BIT						0x00020000	/*GPIO17*/
+#define HDD1_POWER_BIT						0x00000002	/*GPIO1*/
+#define HDD2_POWER_BIT						0x00000040	/*GPIO6*/
+#define HDD3_POWER_BIT						0x00000080	/*GPIO7*/
+#define HDD4_POWER_BIT						0x01000000	/*GPIO56*/
+#define HDD5_POWER_BIT						0x00000001	/*GPIO32*/
+#define HDD6_POWER_BIT						0x00000002	/*GPIO33*/
+#define HDD7_POWER_BIT						0x00000004	/*GPIO34*/
+
+#define HDD0_POWER_MASK						0xFFFDFFFF
+#define HDD1_POWER_MASK						0xFFFFFFFD
+#define HDD2_POWER_MASK						0xFFFFFFBF
+#define HDD3_POWER_MASK						0xFFFFFF7F
+#define HDD4_POWER_MASK						0xFEFFFFFF
+#define HDD5_POWER_MASK						0xFFFFFFFE
+#define HDD6_POWER_MASK						0xFFFFFFFD
+#define HDD7_POWER_MASK						0xFFFFFFFB
+
+
+/* HDD information structure */
+struct sugi_hdd_info_st {
+	uint32_t HDD_GPIO_PRESENT_REG;
+	uint32_t HDD_PRESENT_BIT;
+	uint32_t HDD_GPIO_POWER_REG;
+	uint32_t HDD_POWER_BIT;
+	uint32_t HDD_POWER_MASK;
+};
+
+/* definitions of status */
+#define PLUGGED_EVENT_MSG       	"SATA %d plugged"
+#define UNPLUGGED_EVENT_MSG     	"SATA %d unplugged"
+
+/* polling timer */
+#define SATA_POL_INTERVAL       	HZ/100
+#define SATA_POL_LOOPS          	10
+
+/* hotplug ststus strcture */
+typedef enum _sata_plug_state {
+	SATA_STAT_UNKNOWN,
+	SATA_STAT_PLUGGED,
+	SATA_STAT_UNPLUGGED,
+}SATA_PLUG_STATE;
+
+/* hotplug information strcture */
+struct sata_hotplug_data_st {
+	SATA_PLUG_STATE presentpinstat;
+	SATA_PLUG_STATE prevplugstat;
+	unsigned int loops;
+};
+
+/* ------------- CMOS Driver ------------- */
+
+/* IO index */
+#define	CMOS_INDEX_PORT						0x70
+#define	CMOS_DATA_PORT						0x71
+
+/* wake on LAN setting */
+#define WOL_OFFSET								0x70
+#define WOL_DISABLE								0x00
+#define WOL_ENABLE								0x01
+
+/* AC power loss setting */
+#define	AC_POWER_LOSS_OFFSET			0x71
+#define AC_POWER_LOSS_POWER_OFF 	0x00
+#define AC_POWER_LOSS_POWER_ON  	0x01
+#define AC_POWER_LOSS_LAST_STATE	0x02
+
+/* Gbe LAN boot setting */
+#define LANBOOT_OFFSET						0x75
+#define LANBOOT_DISABLE						0x00
+#define LANBOOT_ENABLE						0x01
+
+/* CMOS setting */
+#define CMOS_CHECKSUM_OFFSET			0x73
+#define CMOS_CHANGE_CHECKSUM			0xBF
+
+
+/* ASCII string strcture */
+struct strtoint_st {
+	unsigned char strg;
+	unsigned char inte;
+};
+
+/* SW SMI setting and return code */
+#define SW_SMI_OFFSET							0xB2
+#define SW_SMI_READ								0x76
+#define SW_SMI_WRITE							0x77 
+
+/* ----------- Board ID Driver ----------- */
+ 
+/*
+     SKU   | GPIO31   GPIO30   GPIO29 
+ ----------|-------- -------- --------
+  2HDD box |   0        0        0    
+  4HDD box |   0        0        1    
+  6HDD box |   0        1        0    
+  8HDD box |   0        1        1    
+  1U       |   1        0        0    
+*/
+
+#define GPIO29										0x20000000
+#define GPIO30										0x40000000
+#define GPIO31										0x80000000
+#define BOARD_ID_MASK							(GPIO29 | GPIO30 | GPIO31)
+#define BOARD_ID_OFFSET						29
+
+
+#endif
\ No newline at end of file
diff -rubB --new-file linux-3.10.69/block/blk-core.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/block/blk-core.c
--- linux-3.10.69/block/blk-core.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/block/blk-core.c	2017-05-02 03:31:56.000000000 +0200
@@ -38,6 +38,10 @@
 #include "blk.h"
 #include "blk-cgroup.h"
 
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+#include <buffalo/kernevnt.h>
+#endif	/* CONFIG_BUFFALO_USE_KERNEVNT */
+
 EXPORT_TRACEPOINT_SYMBOL_GPL(block_bio_remap);
 EXPORT_TRACEPOINT_SYMBOL_GPL(block_rq_remap);
 EXPORT_TRACEPOINT_SYMBOL_GPL(block_bio_complete);
@@ -1713,6 +1717,25 @@
 		goto end_io;
 	}
 
+#ifdef CONFIG_BUFFALO_IOERRS
+	if (bio->bi_bdev->bd_disk->limit_io_errors > 0 &&
+	    (bio->bi_bdev->bd_disk->io_errors > bio->bi_bdev->bd_disk->limit_io_errors)) {
+		//printk("%s:io error limit\n",bdevname(bio->bi_bdev, b));
+		/* NOTE: (Temporary Fix)
+		 *	Skip setting the QUEUE_FLAG_DEAD flag here, because
+		 *	this setting causes process hang-up when opening
+		 *	'/dev/sd*' device file at Alpine platform by unknown
+		 *	reason.  Instead, stop issueing 'ioerror' event
+		 *	when ioerror counter reaches its limit.
+		 *	See NOTE in blk_update_request() function below.
+		 */
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+		kernevnt_DriveDead(bdevname(bio->bi_bdev, b));
+#endif	/* CONFIG_BUFFALO_USE_KERNEVNT */
+		goto end_io;
+	}
+#endif	/* CONFIG_BUFFALO_IOERRS */
+
 	part = bio->bi_bdev->bd_part;
 	if (should_fail_request(part, bio->bi_size) ||
 	    should_fail_request(&part_to_disk(part)->part0,
@@ -2338,6 +2361,31 @@
 
 	}
 
+#ifdef CONFIG_BUFFALO_IOERRS
+	if (error && req->cmd_type != REQ_TYPE_BLOCK_PC && req->rq_disk) {
+#ifdef CONFIG_BUFFALO_ERRCNT
+		if (atomic_inc_return(&req->rq_disk->nr_errs) < 0)
+			atomic_set(&req->rq_disk->nr_errs, INT_MAX);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#ifdef CONFIG_BUFFALO_USE_KERNEVNT
+		if (req->rq_disk->io_errors > req->rq_disk->limit_io_errors) {
+			/* NOTE: (Temporary Fix)
+			 *	Stop issueing 'ioerror' event when io_erroes
+			 *	counter reaches its limit, to avoid process
+			 *	hang-up at open() system-call for disk-device
+			 *	on Alpine Platform.
+			 */
+			;
+		} else {
+			kernevnt_IOErr(req->rq_disk->disk_name,
+			       (rq_data_dir(req) == WRITE) ? "WRITE" : "READ",
+			       (unsigned long long)blk_rq_pos(req),
+			       ++req->rq_disk->io_errors);
+		}
+#endif	/* CONFIG_BUFFALO_USE_KERNEVNT */
+	}
+#endif	/* CONFIG_BUFFALO_IOERRS */
+
 	blk_account_io_completion(req, nr_bytes);
 
 	total_bytes = 0;
diff -rubB --new-file linux-3.10.69/block/genhd.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/block/genhd.c
--- linux-3.10.69/block/genhd.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/block/genhd.c	2017-05-02 03:31:56.000000000 +0200
@@ -977,6 +977,74 @@
 	return sprintf(buf, "%d\n", queue_discard_alignment(disk->queue));
 }
 
+#ifdef CONFIG_BUFFALO_IOERRS
+static ssize_t disk_io_error_show(struct device *dev,
+				  struct device_attribute *attr, char *buf)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+
+	return sprintf(buf, "%u\n", disk->io_errors);
+}
+
+static ssize_t disk_limit_io_error_show(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+
+	return sprintf(buf, "%u\n", disk->limit_io_errors);
+}
+
+#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV)			\
+ssize_t __FUNC(struct device *dev, struct device_attribute *attr,	\
+	       const char *buf, size_t count)				\
+{									\
+	struct gendisk *disk = dev_to_disk(dev);			\
+	unsigned int __data;						\
+	char *p = (char *) buf;						\
+									\
+	__data = simple_strtoul(p, &p, 10);				\
+	if (__data < (MIN))						\
+		__data = (MIN);						\
+	else if (__data > (MAX))					\
+		__data = (MAX);						\
+	if (__CONV)							\
+		*(__PTR) = msecs_to_jiffies(__data);			\
+	else								\
+		*(__PTR) = __data;					\
+	return count;							\
+}
+
+static STORE_FUNCTION(disk_io_error_store, &disk->io_errors, 0, UINT_MAX, 0)
+static STORE_FUNCTION(disk_limit_io_error_store, &disk->limit_io_errors, 0, UINT_MAX, 0)
+
+#ifdef CONFIG_BUFFALO_ERRCNT
+static ssize_t disk_nr_errs_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+
+	return sprintf(buf, "%d\n", atomic_read(&disk->nr_errs));
+}
+
+static ssize_t disk_nr_errs_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct gendisk *disk = dev_to_disk(dev);
+	long n;
+	char *e, *p = (char *) buf;
+
+	n = simple_strtoul(p, &e, 10);
+	if (*p && (*e == 0 || *e == '\n') && n >= 0 ) {
+		atomic_set(&disk->nr_errs, n);
+		return count;
+	}
+	return -EINVAL;
+}
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#endif	/* CONFIG_BUFFALO_IOERRS */
+
 static DEVICE_ATTR(range, S_IRUGO, disk_range_show, NULL);
 static DEVICE_ATTR(ext_range, S_IRUGO, disk_ext_range_show, NULL);
 static DEVICE_ATTR(removable, S_IRUGO, disk_removable_show, NULL);
@@ -998,6 +1066,15 @@
 		part_timeout_store);
 #endif
 
+#ifdef CONFIG_BUFFALO_IOERRS
+static DEVICE_ATTR(io_errors, S_IRUGO|S_IWUSR, disk_io_error_show, disk_io_error_store);
+static DEVICE_ATTR(limit_io_errors, S_IRUGO|S_IWUSR, disk_limit_io_error_show, disk_limit_io_error_store);
+#ifdef CONFIG_BUFFALO_ERRCNT
+static DEVICE_ATTR(nr_errs, S_IRUGO|S_IWUSR, disk_nr_errs_show, disk_nr_errs_store);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#endif	/* CONFIG_BUFFALO_IOERRS */
+
+
 static struct attribute *disk_attrs[] = {
 	&dev_attr_range.attr,
 	&dev_attr_ext_range.attr,
@@ -1015,6 +1092,15 @@
 #ifdef CONFIG_FAIL_IO_TIMEOUT
 	&dev_attr_fail_timeout.attr,
 #endif
+
+#ifdef CONFIG_BUFFALO_IOERRS
+	&dev_attr_io_errors.attr,
+	&dev_attr_limit_io_errors.attr,
+#ifdef CONFIG_BUFFALO_ERRCNT
+	&dev_attr_nr_errs.attr,
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#endif	/* CONFIG_BUFFALO_IOERRS */
+
 	NULL
 };
 
@@ -1289,6 +1375,9 @@
 		hd_ref_init(&disk->part0);
 
 		disk->minors = minors;
+#ifdef CONFIG_BUFFALO_ERRCNT
+		atomic_set(&disk->nr_errs, 0);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 		rand_initialize_disk(disk);
 		disk_to_dev(disk)->class = &block_class;
 		disk_to_dev(disk)->type = &disk_type;
diff -rubB --new-file linux-3.10.69/buffalo/buffalo_nas_fw_atom_d510.config F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/buffalo/buffalo_nas_fw_atom_d510.config
--- linux-3.10.69/buffalo/buffalo_nas_fw_atom_d510.config	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/buffalo/buffalo_nas_fw_atom_d510.config	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,3072 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86_64 3.10.20-buffalo Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_ARCH_HAS_CPU_AUTOPROBE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_X86_64_SMP=y
+CONFIG_X86_HT=y
+CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11"
+CONFIG_ARCH_CPU_PROBE_RELEASE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_FHANDLE is not set
+CONFIG_AUDIT=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_RCU_USER_QS is not set
+CONFIG_RCU_FANOUT=64
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+CONFIG_RCU_FAST_NO_HZ=y
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_NOCB_CPU is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANTS_PROT_NUMA_PROT_NONE=y
+# CONFIG_NUMA_BALANCING is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_MEMCG is not set
+# CONFIG_CGROUP_HUGETLB is not set
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HOTPLUG=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_PCI_QUIRKS=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_MODULE_SIG is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_MPPARSE=y
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_VSMP is not set
+# CONFIG_X86_INTEL_LPSS is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_HYPERVISOR_GUEST is not set
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MEMTEST is not set
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_PROCESSOR_SELECT=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=256
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+# CONFIG_I8K is not set
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+# CONFIG_NUMA_EMU is not set
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_NEED_BOUNCE_POOL=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_X86_CHECK_BIOS_CORRUPTION=y
+CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+CONFIG_EFI=y
+# CONFIG_EFI_STUB is not set
+CONFIG_SECCOMP=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_KEXEC_JUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_ARCH_HIBERNATION_HEADER=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_VIDEO=y
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_I2C=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_HOTPLUG_CPU=y
+# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
+CONFIG_ACPI_THERMAL=y
+CONFIG_ACPI_NUMA=y
+CONFIG_ACPI_CUSTOM_DSDT_FILE=""
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+# CONFIG_ACPI_INITRD_TABLE_OVERRIDE is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_SBS=y
+# CONFIG_ACPI_HED is not set
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+# CONFIG_ACPI_BGRT is not set
+CONFIG_ACPI_APEI=y
+# CONFIG_ACPI_APEI_GHES is not set
+# CONFIG_ACPI_APEI_PCIEAER is not set
+# CONFIG_ACPI_APEI_MEMORY_FAILURE is not set
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+
+#
+# x86 CPU frequency scaling drivers
+#
+# CONFIG_X86_INTEL_PSTATE is not set
+# CONFIG_X86_PCC_CPUFREQ is not set
+CONFIG_X86_ACPI_CPUFREQ=y
+CONFIG_X86_ACPI_CPUFREQ_CPB=y
+CONFIG_X86_POWERNOW_K8=y
+# CONFIG_X86_AMD_FREQ_SENSITIVITY is not set
+CONFIG_X86_SPEEDSTEP_CENTRINO=y
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+CONFIG_CPU_IDLE=y
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+# CONFIG_PCI_IOV is not set
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_IOAPIC=y
+CONFIG_PCI_LABEL=y
+# CONFIG_ISA_DMA_API is not set
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_ACPI is not set
+CONFIG_HOTPLUG_PCI_CPCI=y
+# CONFIG_HOTPLUG_PCI_CPCI_ZT5550 is not set
+# CONFIG_HOTPLUG_PCI_CPCI_GENERIC is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_RAPIDIO is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+# CONFIG_IA32_AOUT is not set
+# CONFIG_X86_X32 is not set
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_KEYS_COMPAT=y
+CONFIG_HAVE_TEXT_POKE_SMP=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+# CONFIG_INET_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+CONFIG_NETLABEL=y
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+# CONFIG_NF_CONNTRACK is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+# CONFIG_NETFILTER_XT_MARK is not set
+
+#
+# Xtables targets
+#
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+
+#
+# Xtables matches
+#
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+# CONFIG_AX25 is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_DMA_SHARED_BUFFER=y
+
+#
+# Bus devices
+#
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_VMWARE_VMCI is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=y
+CONFIG_SCSI_SAS_LIBSAS=y
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_SAS_HOST_SMP=y
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_CHELSIO_FCOE is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+# CONFIG_SATA_ZPODD is not set
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=y
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+CONFIG_ATA_PIIX=y
+# CONFIG_SATA_HIGHBANK is not set
+CONFIG_SATA_MV=y
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SC1200 is not set
+CONFIG_PATA_SCH=y
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_RZ1000 is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_PATA_ACPI is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_AUTODETECT=y
+# CONFIG_MD_LINEAR is not set
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+# CONFIG_MD_RAID10 is not set
+CONFIG_MD_RAID456=y
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_CACHE is not set
+CONFIG_DM_MIRROR=y
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+CONFIG_DM_ZERO=y
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+# CONFIG_TARGET_CORE is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+CONFIG_BONDING=m
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+CONFIG_MII=y
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_E100=y
+CONFIG_E1000=y
+CONFIG_E1000E=m
+CONFIG_IGB=y
+CONFIG_IGB_HWMON=y
+# CONFIG_IGBVF is not set
+CONFIG_IXGB=y
+CONFIG_IXGBE=y
+CONFIG_IXGBE_HWMON=y
+# CONFIG_IXGBEVF is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_BROADCOM_PHY=y
+# CONFIG_BCM87XX_PHY is not set
+CONFIG_ICPLUS_PHY=y
+CONFIG_REALTEK_PHY=y
+CONFIG_NATIONAL_PHY=y
+CONFIG_STE10XP=y
+CONFIG_LSI_ET1011C_PHY=y
+# CONFIG_MICREL_PHY is not set
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_MOUSE_PS2_SENTELIC=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_HANWANG is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_WACOM is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=0
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_SYNCLINK_GT is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_ISI is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_STALDRV=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=48
+CONFIG_SERIAL_8250_RUNTIME_UARTS=32
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_DW is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+CONFIG_TTY_PRINTK=y
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+CONFIG_I2C_MUX_PCA9541=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_SMBUS=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCA=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+CONFIG_I2C_ALI1535=y
+CONFIG_I2C_ALI1563=y
+CONFIG_I2C_ALI15X3=y
+CONFIG_I2C_AMD756=y
+CONFIG_I2C_AMD756_S4882=y
+CONFIG_I2C_AMD8111=y
+CONFIG_I2C_I801=y
+CONFIG_I2C_ISCH=y
+# CONFIG_I2C_ISMT is not set
+CONFIG_I2C_PIIX4=y
+CONFIG_I2C_NFORCE2=y
+CONFIG_I2C_NFORCE2_S4985=y
+CONFIG_I2C_SIS5595=y
+CONFIG_I2C_SIS630=y
+CONFIG_I2C_SIS96X=y
+CONFIG_I2C_VIA=y
+CONFIG_I2C_VIAPRO=y
+
+#
+# ACPI drivers
+#
+CONFIG_I2C_SCMI=y
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+CONFIG_I2C_EG20T=y
+CONFIG_I2C_INTEL_MID=y
+CONFIG_I2C_OCORES=y
+CONFIG_I2C_PCA_PLATFORM=y
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_I2C_SIMTEC=y
+CONFIG_I2C_XILINX=y
+
+#
+# External I2C/SMBus adapter drivers
+#
+CONFIG_I2C_DIOLAN_U2C=m
+CONFIG_I2C_PARPORT_LIGHT=y
+CONFIG_I2C_TAOS_EVM=y
+CONFIG_I2C_TINY_USB=m
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+CONFIG_I2C_DEBUG_CORE=y
+CONFIG_I2C_DEBUG_ALGO=y
+CONFIG_I2C_DEBUG_BUS=y
+# CONFIG_SPI is not set
+
+#
+# Qualcomm MSM SSBI bus support
+#
+# CONFIG_SSBI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_APPLESMC is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_SENSORS_ACPI_POWER is not set
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_CPU_THERMAL is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_INTEL_POWERCLAMP is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_LPC_ICH is not set
+CONFIG_LPC_SCH=y
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=y
+# CONFIG_AGP_SIS is not set
+CONFIG_AGP_VIA=y
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_VGA_SWITCHEROO=y
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_I810 is not set
+CONFIG_DRM_I915=y
+# CONFIG_DRM_I915_KMS is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_HDMI=y
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+CONFIG_FB_ASILIANT=y
+CONFIG_FB_IMSTT=y
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_VESA is not set
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+CONFIG_FB_GEODE=y
+# CONFIG_FB_GEODE_LX is not set
+# CONFIG_FB_GEODE_GX is not set
+# CONFIG_FB_GEODE_GX1 is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_PLATFORM is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_APPLE is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_KCTL_JACK=y
+CONFIG_SND_DMA_SGBUF=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ASIHPI is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+CONFIG_SND_HDA_INTEL=y
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+# CONFIG_SND_HDA_HWDEP is not set
+# CONFIG_SND_HDA_INPUT_BEEP is not set
+# CONFIG_SND_HDA_INPUT_JACK is not set
+# CONFIG_SND_HDA_PATCH_LOADER is not set
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_SND_HDA_CODEC_HDMI=y
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_SND_HDA_CODEC_CA0110=y
+# CONFIG_SND_HDA_CODEC_CA0132 is not set
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_SND_HDA_GENERIC=y
+CONFIG_SND_HDA_POWER_SAVE_DEFAULT=0
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+# CONFIG_SND_USB is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PS3REMOTE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+# CONFIG_USB_XHCI_HCD_DEBUGGING is not set
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=m
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_CHIPIDEA is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_PHY is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+# CONFIG_X86_PLATFORM_DEVICES is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_AMD_IOMMU=y
+CONFIG_AMD_IOMMU_STATS=y
+# CONFIG_AMD_IOMMU_V2 is not set
+# CONFIG_INTEL_IOMMU is not set
+# CONFIG_IRQ_REMAP is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=y
+CONFIG_EDD_OFF=y
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+# CONFIG_DMI_SYSFS is not set
+CONFIG_ISCSI_IBFT_FIND=y
+# CONFIG_ISCSI_IBFT is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_VARS=y
+CONFIG_EFI_VARS_PSTORE=y
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_XFS_FS=y
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_FTRACE is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_EFIVAR_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+CONFIG_SCHED_TRACER=y
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+# CONFIG_UPROBE_EVENT is not set
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_FUNCTION_PROFILER=y
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_X86_PTDUMP is not set
+CONFIG_DEBUG_RODATA=y
+CONFIG_DEBUG_RODATA_TEST=y
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_DEBUG_NX_TEST is not set
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+# CONFIG_IO_DELAY_0X80 is not set
+CONFIG_IO_DELAY_0XED=y
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=1
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_SELINUX is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_IMA is not set
+# CONFIG_EVM is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_ASYNC_CORE=y
+CONFIG_ASYNC_MEMCPY=y
+CONFIG_ASYNC_XOR=y
+CONFIG_ASYNC_PQ=y
+CONFIG_ASYNC_RAID6_RECOV=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=y
+CONFIG_UCS2_STRING=y
+
+#
+# BUFFALO Features
+#
+CONFIG_BUFFALO_PLATFORM=y
+CONFIG_BUFFALO_MATSU_PLATFORM=y
+CONFIG_BUFFALO_MATSU_USE_EVT_BOARD=y
+CONFIG_BUFFALO_KIRI_PLATFORM=n
+CONFIG_BUFFALO_USE_MD_KERNEVNT=y
+CONFIG_BUFFALO_ERRCNT=y
+CONFIG_BUFFALO_USE_UPS=y
diff -rubB --new-file linux-3.10.69/buffalo/buffalo_nas_fw_kiri.config F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/buffalo/buffalo_nas_fw_kiri.config
--- linux-3.10.69/buffalo/buffalo_nas_fw_kiri.config	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/buffalo/buffalo_nas_fw_kiri.config	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,3173 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86_64 3.10.69-bromolow Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_ARCH_HAS_CPU_AUTOPROBE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_X86_64_SMP=y
+CONFIG_X86_HT=y
+CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11"
+CONFIG_ARCH_CPU_PROBE_RELEASE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_FHANDLE is not set
+CONFIG_AUDIT=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_RCU_USER_QS is not set
+CONFIG_RCU_FANOUT=64
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+CONFIG_RCU_FAST_NO_HZ=y
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_NOCB_CPU is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANTS_PROT_NUMA_PROT_NONE=y
+# CONFIG_NUMA_BALANCING is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_MEMCG is not set
+# CONFIG_CGROUP_HUGETLB is not set
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HOTPLUG=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_PCI_QUIRKS=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_MODULE_SIG is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_MPPARSE=y
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_VSMP is not set
+# CONFIG_X86_INTEL_LPSS is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_HYPERVISOR_GUEST is not set
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MEMTEST is not set
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_PROCESSOR_SELECT=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=256
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+# CONFIG_I8K is not set
+
+#
+# BUFFALO Features
+#
+CONFIG_BUFFALO_PLATFORM=y
+# CONFIG_BUFFALO_MATSU_PLATFORM is not set
+CONFIG_BUFFALO_KIRI_PLATFORM=y
+# CONFIG_BUFFALO_USI_PLATFORM is not set
+CONFIG_BUFFALO_USE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_DEGRADE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT=y
+CONFIG_BUFFALO_IOERRS=y
+CONFIG_BUFFALO_ERRCNT=y
+CONFIG_BUFFALO_SKIP_RESYNC=y
+CONFIG_BUFFALO_IGNORE_LUN=y
+CONFIG_BUFFALO_SCSI_GUID=y
+CONFIG_BUFFALO_EXT23_EXTENSION=y
+CONFIG_BUFFALO_USE_UPS=y
+CONFIG_BUFFALO_DISABLE_NCQ=y
+# CONFIG_BUFFALO_ADD_RECVFILE is not set
+CONFIG_MICROCODE=y
+CONFIG_MICROCODE_INTEL=y
+CONFIG_MICROCODE_AMD=y
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_MICROCODE_INTEL_LIB=y
+CONFIG_MICROCODE_INTEL_EARLY=y
+CONFIG_MICROCODE_EARLY=y
+CONFIG_X86_MSR=y
+CONFIG_X86_CPUID=y
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+# CONFIG_NUMA_EMU is not set
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_NEED_BOUNCE_POOL=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_X86_CHECK_BIOS_CORRUPTION=y
+CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+CONFIG_EFI=y
+# CONFIG_EFI_STUB is not set
+CONFIG_SECCOMP=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_KEXEC_JUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_ARCH_HIBERNATION_HEADER=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_VIDEO=y
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_I2C=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_HOTPLUG_CPU=y
+# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
+CONFIG_ACPI_THERMAL=y
+CONFIG_ACPI_NUMA=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+# CONFIG_ACPI_INITRD_TABLE_OVERRIDE is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_SBS=y
+# CONFIG_ACPI_HED is not set
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+# CONFIG_ACPI_BGRT is not set
+CONFIG_ACPI_APEI=y
+# CONFIG_ACPI_APEI_GHES is not set
+# CONFIG_ACPI_APEI_PCIEAER is not set
+# CONFIG_ACPI_APEI_MEMORY_FAILURE is not set
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+
+#
+# x86 CPU frequency scaling drivers
+#
+# CONFIG_X86_INTEL_PSTATE is not set
+# CONFIG_X86_PCC_CPUFREQ is not set
+CONFIG_X86_ACPI_CPUFREQ=y
+CONFIG_X86_ACPI_CPUFREQ_CPB=y
+CONFIG_X86_POWERNOW_K8=y
+# CONFIG_X86_AMD_FREQ_SENSITIVITY is not set
+CONFIG_X86_SPEEDSTEP_CENTRINO=y
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+CONFIG_CPU_IDLE=y
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+# CONFIG_PCI_IOV is not set
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_IOAPIC=y
+CONFIG_PCI_LABEL=y
+# CONFIG_ISA_DMA_API is not set
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_ACPI is not set
+CONFIG_HOTPLUG_PCI_CPCI=y
+# CONFIG_HOTPLUG_PCI_CPCI_ZT5550 is not set
+# CONFIG_HOTPLUG_PCI_CPCI_GENERIC is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_RAPIDIO is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+# CONFIG_IA32_AOUT is not set
+# CONFIG_X86_X32 is not set
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_KEYS_COMPAT=y
+CONFIG_HAVE_TEXT_POKE_SMP=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+# CONFIG_INET_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+CONFIG_NETLABEL=y
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+# CONFIG_NF_CONNTRACK is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+# CONFIG_NETFILTER_XT_MARK is not set
+
+#
+# Xtables targets
+#
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+
+#
+# Xtables matches
+#
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+# CONFIG_AX25 is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+CONFIG_DEBUG_DEVRES=y
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_DMA_SHARED_BUFFER=y
+
+#
+# Bus devices
+#
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_NVME=y
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=135000
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_VMWARE_VMCI is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+CONFIG_RAID_ATTRS=y
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=y
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+CONFIG_SCSI_MV_94xx=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_CHELSIO_FCOE is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+# CONFIG_SATA_ZPODD is not set
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=y
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+CONFIG_ATA_PIIX=y
+# CONFIG_SATA_HIGHBANK is not set
+CONFIG_SATA_MV=y
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ALI is not set
+CONFIG_PATA_AMD=y
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+CONFIG_PATA_OLDPIIX=y
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SC1200 is not set
+CONFIG_PATA_SCH=y
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_RZ1000 is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_PATA_ACPI is not set
+CONFIG_ATA_GENERIC=y
+# CONFIG_PATA_LEGACY is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_AUTODETECT=y
+# CONFIG_MD_LINEAR is not set
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+# CONFIG_MD_RAID10 is not set
+CONFIG_MD_RAID456=y
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM_BUILTIN=y
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_CACHE is not set
+CONFIG_DM_MIRROR=y
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+CONFIG_DM_ZERO=y
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+CONFIG_TARGET_CORE=m
+CONFIG_TCM_IBLOCK=m
+CONFIG_TCM_FILEIO=m
+CONFIG_TCM_PSCSI=m
+CONFIG_LOOPBACK_TARGET=m
+CONFIG_ISCSI_TARGET=m
+CONFIG_FUSION=y
+# CONFIG_FUSION_SPI is not set
+# CONFIG_FUSION_FC is not set
+CONFIG_FUSION_SAS=m
+CONFIG_FUSION_MAX_SGE=128
+CONFIG_FUSION_CTL=m
+# CONFIG_FUSION_LOGGING is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+CONFIG_BONDING=m
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+CONFIG_MII=y
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=m
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+CONFIG_NET_VENDOR_ADAPTEC=y
+# CONFIG_ADAPTEC_STARFIRE is not set
+CONFIG_NET_VENDOR_ALTEON=y
+# CONFIG_ACENIC is not set
+CONFIG_NET_VENDOR_AMD=y
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_PCNET32 is not set
+CONFIG_NET_VENDOR_ATHEROS=y
+# CONFIG_ATL2 is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_ALX is not set
+CONFIG_NET_CADENCE=y
+# CONFIG_ARM_AT91_ETHER is not set
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_BROADCOM=y
+# CONFIG_B44 is not set
+# CONFIG_BNX2 is not set
+# CONFIG_CNIC is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_BNX2X is not set
+CONFIG_NET_VENDOR_BROCADE=y
+# CONFIG_BNA is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+CONFIG_NET_VENDOR_CHELSIO=y
+# CONFIG_CHELSIO_T1 is not set
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_CHELSIO_T4 is not set
+# CONFIG_CHELSIO_T4VF is not set
+CONFIG_NET_VENDOR_CISCO=y
+# CONFIG_ENIC is not set
+# CONFIG_DNET is not set
+CONFIG_NET_VENDOR_DEC=y
+# CONFIG_NET_TULIP is not set
+CONFIG_NET_VENDOR_DLINK=y
+# CONFIG_DL2K is not set
+# CONFIG_SUNDANCE is not set
+CONFIG_NET_VENDOR_EMULEX=y
+CONFIG_BE2NET=m
+CONFIG_NET_VENDOR_EXAR=y
+# CONFIG_S2IO is not set
+# CONFIG_VXGE is not set
+CONFIG_NET_VENDOR_HP=y
+# CONFIG_HP100 is not set
+CONFIG_NET_VENDOR_INTEL=y
+# CONFIG_E100 is not set
+CONFIG_E1000=m
+CONFIG_E1000E=m
+# CONFIG_IGB is not set
+# CONFIG_IGBVF is not set
+CONFIG_IXGB=m
+CONFIG_IXGBE=m
+CONFIG_IXGBE_HWMON=y
+# CONFIG_IXGBEVF is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+CONFIG_NET_VENDOR_MICREL=y
+# CONFIG_KS8851_MLL is not set
+# CONFIG_KSZ884X_PCI is not set
+CONFIG_NET_VENDOR_MYRI=y
+# CONFIG_MYRI10GE is not set
+# CONFIG_FEALNX is not set
+CONFIG_NET_VENDOR_NATSEMI=y
+# CONFIG_NATSEMI is not set
+# CONFIG_NS83820 is not set
+CONFIG_NET_VENDOR_8390=y
+# CONFIG_NE2K_PCI is not set
+CONFIG_NET_VENDOR_NVIDIA=y
+# CONFIG_FORCEDETH is not set
+CONFIG_NET_VENDOR_OKI=y
+# CONFIG_PCH_GBE is not set
+# CONFIG_ETHOC is not set
+CONFIG_NET_PACKET_ENGINE=y
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_NET_VENDOR_QLOGIC=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_QLCNIC is not set
+# CONFIG_QLGE is not set
+# CONFIG_NETXEN_NIC is not set
+CONFIG_NET_VENDOR_REALTEK=y
+# CONFIG_8139CP is not set
+# CONFIG_8139TOO is not set
+# CONFIG_R8169 is not set
+CONFIG_NET_VENDOR_RDC=y
+# CONFIG_R6040 is not set
+CONFIG_NET_VENDOR_SEEQ=y
+CONFIG_NET_VENDOR_SILAN=y
+# CONFIG_SC92031 is not set
+CONFIG_NET_VENDOR_SIS=y
+# CONFIG_SIS900 is not set
+# CONFIG_SIS190 is not set
+# CONFIG_SFC is not set
+CONFIG_NET_VENDOR_SMSC=y
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC9420 is not set
+CONFIG_NET_VENDOR_STMICRO=y
+# CONFIG_STMMAC_ETH is not set
+CONFIG_NET_VENDOR_SUN=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+# CONFIG_NIU is not set
+CONFIG_NET_VENDOR_TEHUTI=y
+# CONFIG_TEHUTI is not set
+CONFIG_NET_VENDOR_TI=y
+# CONFIG_TLAN is not set
+CONFIG_NET_VENDOR_VIA=y
+# CONFIG_VIA_RHINE is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_NET_VENDOR_WIZNET=y
+# CONFIG_WIZNET_W5100 is not set
+# CONFIG_WIZNET_W5300 is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_BROADCOM_PHY=y
+# CONFIG_BCM87XX_PHY is not set
+CONFIG_ICPLUS_PHY=y
+CONFIG_REALTEK_PHY=y
+CONFIG_NATIONAL_PHY=y
+CONFIG_STE10XP=y
+CONFIG_LSI_ET1011C_PHY=y
+# CONFIG_MICREL_PHY is not set
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_MOUSE_PS2_SENTELIC=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_HANWANG is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_WACOM is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=0
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_SYNCLINK_GT is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_ISI is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_STALDRV=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=48
+CONFIG_SERIAL_8250_RUNTIME_UARTS=32
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_DW is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+CONFIG_TTY_PRINTK=y
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+CONFIG_I2C_MUX_PCA9541=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_SMBUS=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCA=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+CONFIG_I2C_ALI1535=y
+CONFIG_I2C_ALI1563=y
+CONFIG_I2C_ALI15X3=y
+CONFIG_I2C_AMD756=y
+CONFIG_I2C_AMD756_S4882=y
+CONFIG_I2C_AMD8111=y
+CONFIG_I2C_I801=y
+CONFIG_I2C_ISCH=y
+# CONFIG_I2C_ISMT is not set
+CONFIG_I2C_PIIX4=y
+CONFIG_I2C_NFORCE2=y
+CONFIG_I2C_NFORCE2_S4985=y
+CONFIG_I2C_SIS5595=y
+CONFIG_I2C_SIS630=y
+CONFIG_I2C_SIS96X=y
+CONFIG_I2C_VIA=y
+CONFIG_I2C_VIAPRO=y
+
+#
+# ACPI drivers
+#
+CONFIG_I2C_SCMI=y
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+CONFIG_I2C_EG20T=y
+CONFIG_I2C_INTEL_MID=y
+CONFIG_I2C_OCORES=y
+CONFIG_I2C_PCA_PLATFORM=y
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_I2C_SIMTEC=y
+CONFIG_I2C_XILINX=y
+
+#
+# External I2C/SMBus adapter drivers
+#
+CONFIG_I2C_DIOLAN_U2C=m
+CONFIG_I2C_PARPORT_LIGHT=y
+CONFIG_I2C_TAOS_EVM=y
+CONFIG_I2C_TINY_USB=m
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+CONFIG_I2C_DEBUG_CORE=y
+CONFIG_I2C_DEBUG_ALGO=y
+CONFIG_I2C_DEBUG_BUS=y
+# CONFIG_SPI is not set
+
+#
+# Qualcomm MSM SSBI bus support
+#
+# CONFIG_SSBI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=m
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=m
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_CORETEMP is not set
+# CONFIG_SENSORS_IT87 is not set
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_APPLESMC is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_SENSORS_ACPI_POWER is not set
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_CPU_THERMAL is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_INTEL_POWERCLAMP is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_LPC_ICH is not set
+CONFIG_LPC_SCH=y
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=y
+# CONFIG_AGP_SIS is not set
+CONFIG_AGP_VIA=y
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_VGA_SWITCHEROO=y
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_I810 is not set
+CONFIG_DRM_I915=y
+# CONFIG_DRM_I915_KMS is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_HDMI=y
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+CONFIG_FB_ASILIANT=y
+CONFIG_FB_IMSTT=y
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_VESA is not set
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+CONFIG_FB_GEODE=y
+# CONFIG_FB_GEODE_LX is not set
+# CONFIG_FB_GEODE_GX is not set
+# CONFIG_FB_GEODE_GX1 is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_PLATFORM is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_APPLE is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_KCTL_JACK=y
+CONFIG_SND_DMA_SGBUF=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ASIHPI is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+CONFIG_SND_HDA_INTEL=y
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+# CONFIG_SND_HDA_HWDEP is not set
+# CONFIG_SND_HDA_INPUT_BEEP is not set
+# CONFIG_SND_HDA_INPUT_JACK is not set
+# CONFIG_SND_HDA_PATCH_LOADER is not set
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_SND_HDA_CODEC_HDMI=y
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_SND_HDA_CODEC_CA0110=y
+CONFIG_SND_HDA_CODEC_CA0132=y
+# CONFIG_SND_HDA_CODEC_CA0132_DSP is not set
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_SND_HDA_GENERIC=y
+CONFIG_SND_HDA_POWER_SAVE_DEFAULT=0
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+# CONFIG_SND_USB is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PS3REMOTE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+# CONFIG_USB_XHCI_HCD_DEBUGGING is not set
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=m
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_CHIPIDEA is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_PHY is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+# CONFIG_X86_PLATFORM_DEVICES is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_AMD_IOMMU=y
+CONFIG_AMD_IOMMU_STATS=y
+# CONFIG_AMD_IOMMU_V2 is not set
+# CONFIG_INTEL_IOMMU is not set
+# CONFIG_IRQ_REMAP is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=y
+CONFIG_EDD_OFF=y
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+# CONFIG_DMI_SYSFS is not set
+CONFIG_ISCSI_IBFT_FIND=y
+# CONFIG_ISCSI_IBFT is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_VARS=y
+CONFIG_EFI_VARS_PSTORE=y
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_XFS_FS=y
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_FTRACE is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_EFIVAR_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+# CONFIG_ROOT_NFS is not set
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+CONFIG_NFSD_V4=y
+# CONFIG_NFSD_FAULT_INJECTION is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+CONFIG_DEBUG_STACK_USAGE=y
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+CONFIG_DEBUG_MEMORY_INIT=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+CONFIG_SCHED_TRACER=y
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+# CONFIG_UPROBE_EVENT is not set
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_FUNCTION_PROFILER=y
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_X86_PTDUMP is not set
+CONFIG_DEBUG_RODATA=y
+CONFIG_DEBUG_RODATA_TEST=y
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_DEBUG_NX_TEST is not set
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+# CONFIG_IO_DELAY_0X80 is not set
+CONFIG_IO_DELAY_0XED=y
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=1
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_SELINUX is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_IMA is not set
+# CONFIG_EVM is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_ASYNC_CORE=y
+CONFIG_ASYNC_MEMCPY=y
+CONFIG_ASYNC_XOR=y
+CONFIG_ASYNC_PQ=y
+CONFIG_ASYNC_RAID6_RECOV=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRC32C_INTEL=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=y
+CONFIG_UCS2_STRING=y
diff -rubB --new-file linux-3.10.69/buffalo/buffalo_nas_fw_usi.config F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/buffalo/buffalo_nas_fw_usi.config
--- linux-3.10.69/buffalo/buffalo_nas_fw_usi.config	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/buffalo/buffalo_nas_fw_usi.config	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,3096 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/x86_64 3.10.69-atom_usi Kernel Configuration
+#
+CONFIG_64BIT=y
+CONFIG_X86_64=y
+CONFIG_X86=y
+CONFIG_INSTRUCTION_DECODER=y
+CONFIG_OUTPUT_FORMAT="elf64-x86-64"
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/x86_64_defconfig"
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_MMU=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_NEED_SG_DMA_LENGTH=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_BUG_RELATIVE_POINTERS=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+CONFIG_ARCH_HAS_CPU_AUTOPROBE=y
+CONFIG_HAVE_SETUP_PER_CPU_AREA=y
+CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK=y
+CONFIG_NEED_PER_CPU_PAGE_FIRST_CHUNK=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ZONE_DMA32=y
+CONFIG_AUDIT_ARCH=y
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+CONFIG_X86_64_SMP=y
+CONFIG_X86_HT=y
+CONFIG_ARCH_HWEIGHT_CFLAGS="-fcall-saved-rdi -fcall-saved-rsi -fcall-saved-rdx -fcall-saved-rcx -fcall-saved-r8 -fcall-saved-r9 -fcall-saved-r10 -fcall-saved-r11"
+CONFIG_ARCH_CPU_PROBE_RELEASE=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_BZIP2=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_POSIX_MQUEUE_SYSCTL=y
+# CONFIG_FHANDLE is not set
+CONFIG_AUDIT=y
+CONFIG_AUDITSYSCALL=y
+CONFIG_AUDIT_WATCH=y
+CONFIG_AUDIT_TREE=y
+# CONFIG_AUDIT_LOGINUID_IMMUTABLE is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_IRQ_DOMAIN=y
+# CONFIG_IRQ_DOMAIN_DEBUG is not set
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_TIME_VSYSCALL=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_GENERIC_CLOCKEVENTS_BROADCAST=y
+CONFIG_GENERIC_CLOCKEVENTS_MIN_ADJUST=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ_COMMON=y
+# CONFIG_HZ_PERIODIC is not set
+CONFIG_NO_HZ_IDLE=y
+# CONFIG_NO_HZ_FULL is not set
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_PREEMPT_RCU is not set
+CONFIG_RCU_STALL_COMMON=y
+# CONFIG_RCU_USER_QS is not set
+CONFIG_RCU_FANOUT=64
+CONFIG_RCU_FANOUT_LEAF=16
+# CONFIG_RCU_FANOUT_EXACT is not set
+CONFIG_RCU_FAST_NO_HZ=y
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_RCU_NOCB_CPU is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_ARCH_SUPPORTS_NUMA_BALANCING=y
+CONFIG_ARCH_WANTS_PROT_NUMA_PROT_NONE=y
+# CONFIG_NUMA_BALANCING is not set
+CONFIG_CGROUPS=y
+# CONFIG_CGROUP_DEBUG is not set
+CONFIG_CGROUP_FREEZER=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CPUSETS=y
+CONFIG_PROC_PID_CPUSET=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_RESOURCE_COUNTERS=y
+# CONFIG_MEMCG is not set
+# CONFIG_CGROUP_HUGETLB is not set
+# CONFIG_CGROUP_PERF is not set
+CONFIG_CGROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_CFS_BANDWIDTH is not set
+CONFIG_RT_GROUP_SCHED=y
+CONFIG_BLK_CGROUP=y
+# CONFIG_DEBUG_BLK_CGROUP is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_PID_NS=y
+CONFIG_NET_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+# CONFIG_SYSFS_DEPRECATED is not set
+CONFIG_RELAY=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_SYSCTL_EXCEPTION_TRACE=y
+CONFIG_HOTPLUG=y
+CONFIG_HAVE_PCSPKR_PLATFORM=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_PCI_QUIRKS=y
+# CONFIG_EMBEDDED is not set
+CONFIG_HAVE_PERF_EVENTS=y
+
+#
+# Kernel Performance Events And Counters
+#
+CONFIG_PERF_EVENTS=y
+# CONFIG_DEBUG_PERF_USE_VMALLOC is not set
+CONFIG_VM_EVENT_COUNTERS=y
+# CONFIG_SLUB_DEBUG is not set
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+CONFIG_PROFILING=y
+CONFIG_TRACEPOINTS=y
+# CONFIG_OPROFILE is not set
+CONFIG_HAVE_OPROFILE=y
+CONFIG_OPROFILE_NMI_TIMER=y
+CONFIG_KPROBES=y
+CONFIG_JUMP_LABEL=y
+CONFIG_OPTPROBES=y
+CONFIG_KPROBES_ON_FTRACE=y
+# CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_OPTPROBES=y
+CONFIG_HAVE_KPROBES_ON_FTRACE=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_ATTRS=y
+CONFIG_USE_GENERIC_SMP_HELPERS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+CONFIG_HAVE_HW_BREAKPOINT=y
+CONFIG_HAVE_MIXED_BREAKPOINTS_REGS=y
+CONFIG_HAVE_USER_RETURN_NOTIFIER=y
+CONFIG_HAVE_PERF_EVENTS_NMI=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_HAVE_ARCH_JUMP_LABEL=y
+CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+CONFIG_HAVE_ALIGNED_STRUCT_PAGE=y
+CONFIG_HAVE_CMPXCHG_LOCAL=y
+CONFIG_HAVE_CMPXCHG_DOUBLE=y
+CONFIG_ARCH_WANT_COMPAT_IPC_PARSE_VERSION=y
+CONFIG_ARCH_WANT_OLD_COMPAT_IPC=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_SECCOMP_FILTER=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE=y
+CONFIG_MODULES_USE_ELF_RELA=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_COMPAT_OLD_SIGACTION=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_GCOV_KERNEL is not set
+# CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+CONFIG_MODULE_SRCVERSION_ALL=y
+# CONFIG_MODULE_SIG is not set
+CONFIG_STOP_MACHINE=y
+CONFIG_BLOCK=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+CONFIG_BLK_DEV_INTEGRITY=y
+CONFIG_BLK_DEV_THROTTLING=y
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_BLOCK_COMPAT=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_CFQ_GROUP_IOSCHED=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_MUTEX_SPIN_ON_OWNER=y
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_ZONE_DMA=y
+CONFIG_SMP=y
+CONFIG_X86_MPPARSE=y
+CONFIG_X86_EXTENDED_PLATFORM=y
+# CONFIG_X86_VSMP is not set
+# CONFIG_X86_INTEL_LPSS is not set
+CONFIG_X86_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_HYPERVISOR_GUEST is not set
+CONFIG_NO_BOOTMEM=y
+# CONFIG_MEMTEST is not set
+# CONFIG_MK8 is not set
+# CONFIG_MPSC is not set
+# CONFIG_MCORE2 is not set
+# CONFIG_MATOM is not set
+CONFIG_GENERIC_CPU=y
+CONFIG_X86_INTERNODE_CACHE_SHIFT=6
+CONFIG_X86_L1_CACHE_SHIFT=6
+CONFIG_X86_TSC=y
+CONFIG_X86_CMPXCHG64=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=64
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_PROCESSOR_SELECT=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR=y
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+CONFIG_GART_IOMMU=y
+CONFIG_CALGARY_IOMMU=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_SWIOTLB=y
+CONFIG_IOMMU_HELPER=y
+# CONFIG_MAXSMP is not set
+CONFIG_NR_CPUS=256
+CONFIG_SCHED_SMT=y
+CONFIG_SCHED_MC=y
+# CONFIG_PREEMPT_NONE is not set
+CONFIG_PREEMPT_VOLUNTARY=y
+# CONFIG_PREEMPT is not set
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_X86_IO_APIC=y
+CONFIG_X86_REROUTE_FOR_BROKEN_BOOT_IRQS=y
+CONFIG_X86_MCE=y
+CONFIG_X86_MCE_INTEL=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_X86_MCE_THRESHOLD=y
+# CONFIG_X86_MCE_INJECT is not set
+CONFIG_X86_THERMAL_VECTOR=y
+CONFIG_X86_16BIT=y
+CONFIG_X86_ESPFIX64=y
+# CONFIG_I8K is not set
+
+#
+# BUFFALO Features
+#
+CONFIG_BUFFALO_PLATFORM=y
+CONFIG_BUFFALO_USI_PLATFORM=y
+CONFIG_BUFFALO_KIRI_PLATFORM=n
+CONFIG_BUFFALO_MATSU_PLATFORM=n
+CONFIG_BUFFALO_USE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_DEGRADE_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT=y
+CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT=y
+CONFIG_BUFFALO_USE_UPS=y
+CONFIG_BUFFALO_DISABLE_NCQ=y
+CONFIG_BUFFALO_ERRCNT=y
+CONFIG_BUFFALO_IOERRS=y
+CONFIG_BUFFALO_SKIP_RESYNC=y
+CONFIG_BUFFALO_EXT23_EXTENSION=y
+CONFIG_BUFFALO_IGNORE_LUN=y
+CONFIG_BUFFALO_SCSI_GUID=y
+# CONFIG_BUFFALO_ADD_RECVFILE is not set
+
+# CONFIG_MICROCODE is not set
+# CONFIG_X86_MSR is not set
+# CONFIG_X86_CPUID is not set
+CONFIG_ARCH_PHYS_ADDR_T_64BIT=y
+CONFIG_ARCH_DMA_ADDR_T_64BIT=y
+CONFIG_DIRECT_GBPAGES=y
+CONFIG_NUMA=y
+CONFIG_AMD_NUMA=y
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_NODES_SPAN_OTHER_NODES=y
+# CONFIG_NUMA_EMU is not set
+CONFIG_NODES_SHIFT=6
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_ARCH_SPARSEMEM_DEFAULT=y
+CONFIG_ARCH_SELECT_MEMORY_MODEL=y
+CONFIG_ARCH_PROC_KCORE_TEXT=y
+CONFIG_ILLEGAL_POINTER_VALUE=0xdead000000000000
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_SPARSEMEM=y
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SPARSEMEM_VMEMMAP_ENABLE=y
+CONFIG_SPARSEMEM_ALLOC_MEM_MAP_TOGETHER=y
+CONFIG_SPARSEMEM_VMEMMAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+CONFIG_ARCH_DISCARD_MEMBLOCK=y
+CONFIG_MEMORY_ISOLATION=y
+# CONFIG_MOVABLE_NODE is not set
+# CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+# CONFIG_MEMORY_HOTPLUG is not set
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+CONFIG_PHYS_ADDR_T_64BIT=y
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_NEED_BOUNCE_POOL=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_KSM=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+CONFIG_ARCH_SUPPORTS_MEMORY_FAILURE=y
+CONFIG_MEMORY_FAILURE=y
+# CONFIG_HWPOISON_INJECT is not set
+# CONFIG_TRANSPARENT_HUGEPAGE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+CONFIG_X86_CHECK_BIOS_CORRUPTION=y
+CONFIG_X86_BOOTPARAM_MEMORY_CORRUPTION_CHECK=y
+CONFIG_X86_RESERVE_LOW=64
+CONFIG_MTRR=y
+CONFIG_MTRR_SANITIZER=y
+CONFIG_MTRR_SANITIZER_ENABLE_DEFAULT=0
+CONFIG_MTRR_SANITIZER_SPARE_REG_NR_DEFAULT=1
+CONFIG_X86_PAT=y
+CONFIG_ARCH_USES_PG_UNCACHED=y
+CONFIG_ARCH_RANDOM=y
+CONFIG_X86_SMAP=y
+CONFIG_EFI=y
+# CONFIG_EFI_STUB is not set
+CONFIG_SECCOMP=y
+CONFIG_CC_STACKPROTECTOR=y
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+CONFIG_KEXEC=y
+CONFIG_CRASH_DUMP=y
+CONFIG_KEXEC_JUMP=y
+CONFIG_PHYSICAL_START=0x1000000
+CONFIG_RELOCATABLE=y
+CONFIG_PHYSICAL_ALIGN=0x1000000
+CONFIG_HOTPLUG_CPU=y
+# CONFIG_BOOTPARAM_HOTPLUG_CPU0 is not set
+# CONFIG_DEBUG_HOTPLUG_CPU0 is not set
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_USE_PERCPU_NUMA_NODE_ID=y
+
+#
+# Power management and ACPI options
+#
+CONFIG_ARCH_HIBERNATION_HEADER=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HIBERNATE_CALLBACKS=y
+CONFIG_HIBERNATION=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_PM_SLEEP=y
+CONFIG_PM_SLEEP_SMP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM_RUNTIME=y
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+CONFIG_ACPI_PROCFS=y
+CONFIG_ACPI_PROCFS_POWER=y
+# CONFIG_ACPI_EC_DEBUGFS is not set
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_VIDEO=y
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_I2C=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_HOTPLUG_CPU=y
+# CONFIG_ACPI_PROCESSOR_AGGREGATOR is not set
+CONFIG_ACPI_THERMAL=y
+CONFIG_ACPI_NUMA=y
+CONFIG_ACPI_CUSTOM_DSDT_FILE=""
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+# CONFIG_ACPI_INITRD_TABLE_OVERRIDE is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+# CONFIG_ACPI_DEBUG is not set
+CONFIG_ACPI_PCI_SLOT=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_ACPI_CONTAINER=y
+CONFIG_ACPI_SBS=y
+# CONFIG_ACPI_HED is not set
+# CONFIG_ACPI_CUSTOM_METHOD is not set
+# CONFIG_ACPI_BGRT is not set
+CONFIG_ACPI_APEI=y
+# CONFIG_ACPI_APEI_GHES is not set
+# CONFIG_ACPI_APEI_PCIEAER is not set
+# CONFIG_ACPI_APEI_MEMORY_FAILURE is not set
+# CONFIG_ACPI_APEI_EINJ is not set
+# CONFIG_ACPI_APEI_ERST_DEBUG is not set
+CONFIG_SFI=y
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+
+#
+# x86 CPU frequency scaling drivers
+#
+# CONFIG_X86_INTEL_PSTATE is not set
+# CONFIG_X86_PCC_CPUFREQ is not set
+CONFIG_X86_ACPI_CPUFREQ=y
+CONFIG_X86_ACPI_CPUFREQ_CPB=y
+CONFIG_X86_POWERNOW_K8=y
+# CONFIG_X86_AMD_FREQ_SENSITIVITY is not set
+CONFIG_X86_SPEEDSTEP_CENTRINO=y
+# CONFIG_X86_P4_CLOCKMOD is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+CONFIG_CPU_IDLE=y
+# CONFIG_CPU_IDLE_MULTIPLE_DRIVERS is not set
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+# CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+CONFIG_INTEL_IDLE=y
+
+#
+# Memory power savings
+#
+# CONFIG_I7300_IDLE is not set
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_DOMAINS=y
+# CONFIG_PCI_CNB20LE_QUIRK is not set
+CONFIG_PCIEPORTBUS=y
+CONFIG_HOTPLUG_PCI_PCIE=y
+CONFIG_PCIEAER=y
+# CONFIG_PCIE_ECRC is not set
+# CONFIG_PCIEAER_INJECT is not set
+CONFIG_PCIEASPM=y
+# CONFIG_PCIEASPM_DEBUG is not set
+CONFIG_PCIEASPM_DEFAULT=y
+# CONFIG_PCIEASPM_POWERSAVE is not set
+# CONFIG_PCIEASPM_PERFORMANCE is not set
+CONFIG_PCIE_PME=y
+CONFIG_ARCH_SUPPORTS_MSI=y
+CONFIG_PCI_MSI=y
+# CONFIG_PCI_DEBUG is not set
+# CONFIG_PCI_REALLOC_ENABLE_AUTO is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_HT_IRQ=y
+CONFIG_PCI_ATS=y
+# CONFIG_PCI_IOV is not set
+CONFIG_PCI_PRI=y
+CONFIG_PCI_PASID=y
+CONFIG_PCI_IOAPIC=y
+CONFIG_PCI_LABEL=y
+# CONFIG_ISA_DMA_API is not set
+CONFIG_AMD_NB=y
+# CONFIG_PCCARD is not set
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_ACPI is not set
+CONFIG_HOTPLUG_PCI_CPCI=y
+# CONFIG_HOTPLUG_PCI_CPCI_ZT5550 is not set
+# CONFIG_HOTPLUG_PCI_CPCI_GENERIC is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+# CONFIG_RAPIDIO is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+CONFIG_COMPAT_BINFMT_ELF=y
+CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE=y
+CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS=y
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_HAVE_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_COREDUMP=y
+CONFIG_IA32_EMULATION=y
+# CONFIG_IA32_AOUT is not set
+# CONFIG_X86_X32 is not set
+CONFIG_COMPAT=y
+CONFIG_COMPAT_FOR_U64_ALIGNMENT=y
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_KEYS_COMPAT=y
+CONFIG_HAVE_TEXT_POKE_SMP=y
+CONFIG_X86_DEV_DMA_OPS=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
+CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_XFRM_USER is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+# CONFIG_IP_FIB_TRIE_STATS is not set
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_NET_IP_TUNNEL is not set
+CONFIG_IP_MROUTE=y
+# CONFIG_IP_MROUTE_MULTIPLE_TABLES is not set
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+# CONFIG_INET_DIAG is not set
+CONFIG_TCP_CONG_ADVANCED=y
+# CONFIG_TCP_CONG_BIC is not set
+CONFIG_TCP_CONG_CUBIC=y
+# CONFIG_TCP_CONG_WESTWOOD is not set
+# CONFIG_TCP_CONG_HTCP is not set
+# CONFIG_TCP_CONG_HSTCP is not set
+# CONFIG_TCP_CONG_HYBLA is not set
+# CONFIG_TCP_CONG_VEGAS is not set
+# CONFIG_TCP_CONG_SCALABLE is not set
+# CONFIG_TCP_CONG_LP is not set
+# CONFIG_TCP_CONG_VENO is not set
+# CONFIG_TCP_CONG_YEAH is not set
+# CONFIG_TCP_CONG_ILLINOIS is not set
+CONFIG_DEFAULT_CUBIC=y
+# CONFIG_DEFAULT_RENO is not set
+CONFIG_DEFAULT_TCP_CONG="cubic"
+CONFIG_TCP_MD5SIG=y
+# CONFIG_IPV6 is not set
+CONFIG_NETLABEL=y
+CONFIG_NETWORK_SECMARK=y
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+# CONFIG_NF_CONNTRACK is not set
+CONFIG_NETFILTER_XTABLES=y
+
+#
+# Xtables combined modules
+#
+# CONFIG_NETFILTER_XT_MARK is not set
+
+#
+# Xtables targets
+#
+CONFIG_NETFILTER_XT_TARGET_LOG=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+
+#
+# Xtables matches
+#
+# CONFIG_IP_SET is not set
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+# CONFIG_NF_DEFRAG_IPV4 is not set
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_IP_NF_MANGLE=y
+# CONFIG_IP_NF_RAW is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+CONFIG_NET_SCHED=y
+
+#
+# Queueing/Scheduling
+#
+# CONFIG_NET_SCH_CBQ is not set
+# CONFIG_NET_SCH_HTB is not set
+# CONFIG_NET_SCH_HFSC is not set
+# CONFIG_NET_SCH_PRIO is not set
+# CONFIG_NET_SCH_MULTIQ is not set
+# CONFIG_NET_SCH_RED is not set
+# CONFIG_NET_SCH_SFB is not set
+# CONFIG_NET_SCH_SFQ is not set
+# CONFIG_NET_SCH_TEQL is not set
+# CONFIG_NET_SCH_TBF is not set
+# CONFIG_NET_SCH_GRED is not set
+# CONFIG_NET_SCH_DSMARK is not set
+# CONFIG_NET_SCH_NETEM is not set
+# CONFIG_NET_SCH_DRR is not set
+# CONFIG_NET_SCH_MQPRIO is not set
+# CONFIG_NET_SCH_CHOKE is not set
+# CONFIG_NET_SCH_QFQ is not set
+# CONFIG_NET_SCH_CODEL is not set
+# CONFIG_NET_SCH_FQ_CODEL is not set
+# CONFIG_NET_SCH_INGRESS is not set
+# CONFIG_NET_SCH_PLUG is not set
+
+#
+# Classification
+#
+CONFIG_NET_CLS=y
+# CONFIG_NET_CLS_BASIC is not set
+# CONFIG_NET_CLS_TCINDEX is not set
+# CONFIG_NET_CLS_ROUTE4 is not set
+# CONFIG_NET_CLS_FW is not set
+# CONFIG_NET_CLS_U32 is not set
+# CONFIG_NET_CLS_RSVP is not set
+# CONFIG_NET_CLS_RSVP6 is not set
+# CONFIG_NET_CLS_FLOW is not set
+CONFIG_NET_CLS_CGROUP=y
+CONFIG_NET_EMATCH=y
+CONFIG_NET_EMATCH_STACK=32
+# CONFIG_NET_EMATCH_CMP is not set
+# CONFIG_NET_EMATCH_NBYTE is not set
+# CONFIG_NET_EMATCH_U32 is not set
+# CONFIG_NET_EMATCH_META is not set
+# CONFIG_NET_EMATCH_TEXT is not set
+CONFIG_NET_CLS_ACT=y
+# CONFIG_NET_ACT_POLICE is not set
+# CONFIG_NET_ACT_GACT is not set
+# CONFIG_NET_ACT_MIRRED is not set
+# CONFIG_NET_ACT_IPT is not set
+# CONFIG_NET_ACT_NAT is not set
+# CONFIG_NET_ACT_PEDIT is not set
+# CONFIG_NET_ACT_SIMP is not set
+# CONFIG_NET_ACT_SKBEDIT is not set
+# CONFIG_NET_ACT_CSUM is not set
+CONFIG_NET_SCH_FIFO=y
+# CONFIG_DCB is not set
+CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_MMAP is not set
+# CONFIG_NETLINK_DIAG is not set
+CONFIG_RPS=y
+CONFIG_RFS_ACCEL=y
+CONFIG_XPS=y
+# CONFIG_NETPRIO_CGROUP is not set
+CONFIG_BQL=y
+# CONFIG_BPF_JIT is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_NET_DROP_MONITOR is not set
+CONFIG_HAMRADIO=y
+
+#
+# Packet Radio protocols
+#
+# CONFIG_AX25 is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+# CONFIG_CFG80211 is not set
+# CONFIG_LIB80211 is not set
+
+#
+# CFG80211 needs to be enabled for MAC80211
+#
+# CONFIG_WIMAX is not set
+CONFIG_RFKILL=y
+CONFIG_RFKILL_INPUT=y
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+CONFIG_HAVE_BPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+# CONFIG_STANDALONE is not set
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+CONFIG_FW_LOADER_USER_HELPER=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_GENERIC_CPU_DEVICES is not set
+CONFIG_DMA_SHARED_BUFFER=y
+
+#
+# Bus devices
+#
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+# CONFIG_MTD is not set
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+# CONFIG_PNP_DEBUG_MESSAGES is not set
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_PCIESSD_MTIP32XX is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_NVME is not set
+# CONFIG_BLK_DEV_SX8 is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=65536
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_BLK_DEV_RSXX is not set
+
+#
+# Misc devices
+#
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_INTEL_MID_PTI is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ATMEL_SSC is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_BMP085_I2C is not set
+# CONFIG_PCH_PHUB is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_CB710_CORE is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_I2C is not set
+
+#
+# Altera FPGA firmware download module
+#
+# CONFIG_ALTERA_STAPL is not set
+# CONFIG_VMWARE_VMCI is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_MV_94xx=n
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+CONFIG_SCSI_LOGGING=y
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+CONFIG_SCSI_SAS_ATTRS=y
+CONFIG_SCSI_SAS_LIBSAS=y
+CONFIG_SCSI_SAS_ATA=y
+CONFIG_SCSI_SAS_HOST_SMP=y
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_CXGB3_ISCSI is not set
+# CONFIG_SCSI_CXGB4_ISCSI is not set
+# CONFIG_SCSI_BNX2_ISCSI is not set
+# CONFIG_SCSI_BNX2X_FCOE is not set
+# CONFIG_BE2ISCSI is not set
+# CONFIG_BLK_DEV_3W_XXXX_RAID is not set
+# CONFIG_SCSI_HPSA is not set
+# CONFIG_SCSI_3W_9XXX is not set
+# CONFIG_SCSI_3W_SAS is not set
+# CONFIG_SCSI_ACARD is not set
+# CONFIG_SCSI_AACRAID is not set
+# CONFIG_SCSI_AIC7XXX is not set
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_AIC94XX is not set
+# CONFIG_SCSI_MVSAS is not set
+# CONFIG_SCSI_MVUMI is not set
+# CONFIG_SCSI_DPT_I2O is not set
+# CONFIG_SCSI_ADVANSYS is not set
+# CONFIG_SCSI_ARCMSR is not set
+# CONFIG_MEGARAID_NEWGEN is not set
+# CONFIG_MEGARAID_LEGACY is not set
+# CONFIG_MEGARAID_SAS is not set
+# CONFIG_SCSI_MPT2SAS is not set
+# CONFIG_SCSI_MPT3SAS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_HPTIOP is not set
+# CONFIG_VMWARE_PVSCSI is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_FCOE is not set
+# CONFIG_FCOE_FNIC is not set
+# CONFIG_SCSI_DMX3191D is not set
+# CONFIG_SCSI_FUTURE_DOMAIN is not set
+# CONFIG_SCSI_ISCI is not set
+# CONFIG_SCSI_IPS is not set
+# CONFIG_SCSI_INITIO is not set
+# CONFIG_SCSI_INIA100 is not set
+# CONFIG_SCSI_STEX is not set
+# CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
+# CONFIG_SCSI_QLOGIC_1280 is not set
+# CONFIG_SCSI_QLA_FC is not set
+# CONFIG_SCSI_QLA_ISCSI is not set
+# CONFIG_SCSI_LPFC is not set
+# CONFIG_SCSI_DC395x is not set
+# CONFIG_SCSI_DC390T is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_PMCRAID is not set
+# CONFIG_SCSI_PM8001 is not set
+# CONFIG_SCSI_SRP is not set
+# CONFIG_SCSI_BFA_FC is not set
+# CONFIG_SCSI_CHELSIO_FCOE is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_VERBOSE_ERROR=y
+CONFIG_ATA_ACPI=y
+# CONFIG_SATA_ZPODD is not set
+CONFIG_SATA_PMP=y
+
+#
+# Controllers with non-SFF native interface
+#
+CONFIG_SATA_AHCI=y
+# CONFIG_SATA_AHCI_PLATFORM is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_SATA_ACARD_AHCI is not set
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+
+#
+# SFF controllers with custom DMA interface
+#
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_SX4 is not set
+CONFIG_ATA_BMDMA=y
+
+#
+# SATA SFF controllers with BMDMA
+#
+CONFIG_ATA_PIIX=y
+# CONFIG_SATA_HIGHBANK is not set
+CONFIG_SATA_MV=y
+# CONFIG_SATA_NV is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_SVW is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+
+#
+# PATA SFF controllers with BMDMA
+#
+# CONFIG_PATA_ALI is not set
+# CONFIG_PATA_AMD is not set
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_ATP867X is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_MARVELL is not set
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OLDPIIX is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RDC is not set
+# CONFIG_PATA_SC1200 is not set
+CONFIG_PATA_SCH=y
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_TOSHIBA is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+
+#
+# PIO-only SFF controllers
+#
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_MPIIX is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_PLATFORM is not set
+# CONFIG_PATA_RZ1000 is not set
+
+#
+# Generic fallback / legacy drivers
+#
+# CONFIG_PATA_ACPI is not set
+# CONFIG_ATA_GENERIC is not set
+# CONFIG_PATA_LEGACY is not set
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_AUTODETECT=y
+# CONFIG_MD_LINEAR is not set
+CONFIG_MD_RAID0=y
+CONFIG_MD_RAID1=y
+# CONFIG_MD_RAID10 is not set
+CONFIG_MD_RAID456=y
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+# CONFIG_BCACHE is not set
+CONFIG_BLK_DEV_DM_BUILTIN=y
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+CONFIG_DM_CRYPT=y
+# CONFIG_DM_SNAPSHOT is not set
+# CONFIG_DM_THIN_PROVISIONING is not set
+# CONFIG_DM_CACHE is not set
+CONFIG_DM_MIRROR=y
+# CONFIG_DM_RAID is not set
+# CONFIG_DM_LOG_USERSPACE is not set
+CONFIG_DM_ZERO=y
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_DM_FLAKEY is not set
+# CONFIG_DM_VERITY is not set
+CONFIG_TARGET_CORE=m
+CONFIG_TCM_IBLOCK=m
+CONFIG_TCM_FILEIO=m
+CONFIG_TCM_PSCSI=m
+CONFIG_LOOPBACK_TARGET=m
+CONFIG_ISCSI_TARGET=m
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_FIREWIRE_NOSY is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+CONFIG_NET_CORE=y
+CONFIG_BONDING=m
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_FC is not set
+CONFIG_MII=y
+# CONFIG_IFB is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+# CONFIG_ARCNET is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+# CONFIG_NET_DSA_MV88E6XXX is not set
+# CONFIG_NET_DSA_MV88E6060 is not set
+# CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+# CONFIG_NET_DSA_MV88E6131 is not set
+# CONFIG_NET_DSA_MV88E6123_61_65 is not set
+CONFIG_ETHERNET=y
+CONFIG_MDIO=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_CALXEDA_XGMAC is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_DNET is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EXAR is not set
+# CONFIG_NET_VENDOR_HP is not set
+CONFIG_NET_VENDOR_INTEL=y
+CONFIG_E100=y
+CONFIG_E1000=y
+CONFIG_E1000E=m
+CONFIG_IGB=y
+CONFIG_IGB_HWMON=y
+# CONFIG_IGBVF is not set
+CONFIG_IXGB=y
+CONFIG_IXGBE=y
+CONFIG_IXGBE_HWMON=y
+# CONFIG_IXGBEVF is not set
+CONFIG_NET_VENDOR_I825XX=y
+# CONFIG_IP1000 is not set
+# CONFIG_JME is not set
+CONFIG_NET_VENDOR_MARVELL=y
+# CONFIG_MVMDIO is not set
+# CONFIG_SKGE is not set
+# CONFIG_SKY2 is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_FEALNX is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_ETHOC is not set
+# CONFIG_NET_PACKET_ENGINE is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_SFC is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_NET_SB1000 is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AT803X_PHY is not set
+# CONFIG_AMD_PHY is not set
+CONFIG_MARVELL_PHY=y
+CONFIG_DAVICOM_PHY=y
+CONFIG_QSEMI_PHY=y
+CONFIG_LXT_PHY=y
+CONFIG_CICADA_PHY=y
+CONFIG_VITESSE_PHY=y
+CONFIG_SMSC_PHY=y
+CONFIG_BROADCOM_PHY=y
+# CONFIG_BCM87XX_PHY is not set
+CONFIG_ICPLUS_PHY=y
+CONFIG_REALTEK_PHY=y
+CONFIG_NATIONAL_PHY=y
+CONFIG_STE10XP=y
+CONFIG_LSI_ET1011C_PHY=y
+# CONFIG_MICREL_PHY is not set
+CONFIG_FIXED_PHY=y
+CONFIG_MDIO_BITBANG=y
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_HSO is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_VMXNET3 is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ADP5589 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_TCA8418 is not set
+# CONFIG_KEYBOARD_LM8333 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_MPR121 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+CONFIG_INPUT_MOUSE=y
+CONFIG_MOUSE_PS2=y
+CONFIG_MOUSE_PS2_ALPS=y
+CONFIG_MOUSE_PS2_LOGIPS2PP=y
+CONFIG_MOUSE_PS2_SYNAPTICS=y
+CONFIG_MOUSE_PS2_CYPRESS=y
+CONFIG_MOUSE_PS2_LIFEBOOK=y
+CONFIG_MOUSE_PS2_TRACKPOINT=y
+CONFIG_MOUSE_PS2_ELANTECH=y
+CONFIG_MOUSE_PS2_SENTELIC=y
+# CONFIG_MOUSE_PS2_TOUCHKIT is not set
+# CONFIG_MOUSE_SERIAL is not set
+# CONFIG_MOUSE_APPLETOUCH is not set
+# CONFIG_MOUSE_BCM5974 is not set
+# CONFIG_MOUSE_CYAPA is not set
+# CONFIG_MOUSE_VSXXXAA is not set
+# CONFIG_MOUSE_SYNAPTICS_I2C is not set
+# CONFIG_MOUSE_SYNAPTICS_USB is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_AS5011 is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_HANWANG is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_WACOM is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_MPU3050 is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+CONFIG_INPUT_UINPUT=y
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_CMA3000 is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_SERIO_ARC_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=0
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_SYNCLINK_GT is not set
+# CONFIG_NOZOMI is not set
+# CONFIG_ISI is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+# CONFIG_DEVKMEM is not set
+CONFIG_STALDRV=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_DEPRECATED_OPTIONS=y
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_SERIAL_8250_NR_UARTS=48
+CONFIG_SERIAL_8250_RUNTIME_UARTS=32
+CONFIG_SERIAL_8250_EXTENDED=y
+CONFIG_SERIAL_8250_MANY_PORTS=y
+CONFIG_SERIAL_8250_SHARE_IRQ=y
+# CONFIG_SERIAL_8250_DETECT_IRQ is not set
+CONFIG_SERIAL_8250_RSA=y
+# CONFIG_SERIAL_8250_DW is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_MFD_HSU is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_JSM is not set
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_PCH_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_RP2 is not set
+CONFIG_TTY_PRINTK=y
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+# CONFIG_HW_RANDOM_TIMERIOMEM is not set
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_VIA=y
+# CONFIG_NVRAM is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_MWAVE is not set
+# CONFIG_RAW_DRIVER is not set
+CONFIG_HPET=y
+CONFIG_HPET_MMAP=y
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+CONFIG_I2C_MUX_PCA9541=y
+CONFIG_I2C_MUX_PCA954x=y
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_SMBUS=y
+CONFIG_I2C_ALGOBIT=y
+CONFIG_I2C_ALGOPCA=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+CONFIG_I2C_ALI1535=y
+CONFIG_I2C_ALI1563=y
+CONFIG_I2C_ALI15X3=y
+CONFIG_I2C_AMD756=y
+CONFIG_I2C_AMD756_S4882=y
+CONFIG_I2C_AMD8111=y
+CONFIG_I2C_I801=y
+CONFIG_I2C_ISCH=y
+# CONFIG_I2C_ISMT is not set
+CONFIG_I2C_PIIX4=y
+CONFIG_I2C_NFORCE2=y
+CONFIG_I2C_NFORCE2_S4985=y
+CONFIG_I2C_SIS5595=y
+CONFIG_I2C_SIS630=y
+CONFIG_I2C_SIS96X=y
+CONFIG_I2C_VIA=y
+CONFIG_I2C_VIAPRO=y
+
+#
+# ACPI drivers
+#
+CONFIG_I2C_SCMI=y
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE_PCI is not set
+CONFIG_I2C_EG20T=y
+CONFIG_I2C_INTEL_MID=y
+CONFIG_I2C_OCORES=y
+CONFIG_I2C_PCA_PLATFORM=y
+# CONFIG_I2C_PXA_PCI is not set
+CONFIG_I2C_SIMTEC=y
+CONFIG_I2C_XILINX=y
+
+#
+# External I2C/SMBus adapter drivers
+#
+CONFIG_I2C_DIOLAN_U2C=m
+CONFIG_I2C_PARPORT_LIGHT=y
+CONFIG_I2C_TAOS_EVM=y
+CONFIG_I2C_TINY_USB=m
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+CONFIG_I2C_DEBUG_CORE=y
+CONFIG_I2C_DEBUG_ALGO=y
+CONFIG_I2C_DEBUG_BUS=y
+# CONFIG_SPI is not set
+
+#
+# Qualcomm MSM SSBI bus support
+#
+# CONFIG_SSBI is not set
+# CONFIG_HSI is not set
+
+#
+# PPS support
+#
+CONFIG_PPS=y
+# CONFIG_PPS_DEBUG is not set
+
+#
+# PPS clients support
+#
+# CONFIG_PPS_CLIENT_KTIMER is not set
+# CONFIG_PPS_CLIENT_LDISC is not set
+# CONFIG_PPS_CLIENT_GPIO is not set
+
+#
+# PPS generators support
+#
+
+#
+# PTP clock support
+#
+CONFIG_PTP_1588_CLOCK=y
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+# CONFIG_PTP_1588_CLOCK_PCH is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+CONFIG_GPIO_DEVRES=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GOLDFISH is not set
+# CONFIG_POWER_RESET is not set
+# CONFIG_POWER_AVS is not set
+CONFIG_HWMON=y
+# CONFIG_HWMON_VID is not set
+# CONFIG_HWMON_DEBUG_CHIP is not set
+
+#
+# Native drivers
+#
+# CONFIG_SENSORS_ABITUGURU is not set
+# CONFIG_SENSORS_ABITUGURU3 is not set
+# CONFIG_SENSORS_AD7414 is not set
+# CONFIG_SENSORS_AD7418 is not set
+# CONFIG_SENSORS_ADM1021 is not set
+# CONFIG_SENSORS_ADM1025 is not set
+# CONFIG_SENSORS_ADM1026 is not set
+# CONFIG_SENSORS_ADM1029 is not set
+# CONFIG_SENSORS_ADM1031 is not set
+# CONFIG_SENSORS_ADM9240 is not set
+# CONFIG_SENSORS_ADT7410 is not set
+# CONFIG_SENSORS_ADT7411 is not set
+# CONFIG_SENSORS_ADT7462 is not set
+# CONFIG_SENSORS_ADT7470 is not set
+# CONFIG_SENSORS_ADT7475 is not set
+# CONFIG_SENSORS_ASC7621 is not set
+# CONFIG_SENSORS_K8TEMP is not set
+# CONFIG_SENSORS_K10TEMP is not set
+# CONFIG_SENSORS_FAM15H_POWER is not set
+# CONFIG_SENSORS_ASB100 is not set
+# CONFIG_SENSORS_ATXP1 is not set
+# CONFIG_SENSORS_DS620 is not set
+# CONFIG_SENSORS_DS1621 is not set
+# CONFIG_SENSORS_I5K_AMB is not set
+# CONFIG_SENSORS_F71805F is not set
+# CONFIG_SENSORS_F71882FG is not set
+# CONFIG_SENSORS_F75375S is not set
+# CONFIG_SENSORS_FSCHMD is not set
+# CONFIG_SENSORS_G760A is not set
+# CONFIG_SENSORS_GL518SM is not set
+# CONFIG_SENSORS_GL520SM is not set
+# CONFIG_SENSORS_HIH6130 is not set
+# CONFIG_SENSORS_CORETEMP is not set
+CONFIG_SENSORS_IT87=y
+# CONFIG_SENSORS_JC42 is not set
+# CONFIG_SENSORS_LINEAGE is not set
+# CONFIG_SENSORS_LM63 is not set
+# CONFIG_SENSORS_LM73 is not set
+# CONFIG_SENSORS_LM75 is not set
+# CONFIG_SENSORS_LM77 is not set
+# CONFIG_SENSORS_LM78 is not set
+# CONFIG_SENSORS_LM80 is not set
+# CONFIG_SENSORS_LM83 is not set
+# CONFIG_SENSORS_LM85 is not set
+# CONFIG_SENSORS_LM87 is not set
+# CONFIG_SENSORS_LM90 is not set
+# CONFIG_SENSORS_LM92 is not set
+# CONFIG_SENSORS_LM93 is not set
+# CONFIG_SENSORS_LTC4151 is not set
+# CONFIG_SENSORS_LTC4215 is not set
+# CONFIG_SENSORS_LTC4245 is not set
+# CONFIG_SENSORS_LTC4261 is not set
+# CONFIG_SENSORS_LM95234 is not set
+# CONFIG_SENSORS_LM95241 is not set
+# CONFIG_SENSORS_LM95245 is not set
+# CONFIG_SENSORS_MAX16065 is not set
+# CONFIG_SENSORS_MAX1619 is not set
+# CONFIG_SENSORS_MAX1668 is not set
+# CONFIG_SENSORS_MAX197 is not set
+# CONFIG_SENSORS_MAX6639 is not set
+# CONFIG_SENSORS_MAX6642 is not set
+# CONFIG_SENSORS_MAX6650 is not set
+# CONFIG_SENSORS_MAX6697 is not set
+# CONFIG_SENSORS_MCP3021 is not set
+# CONFIG_SENSORS_NCT6775 is not set
+# CONFIG_SENSORS_NTC_THERMISTOR is not set
+# CONFIG_SENSORS_PC87360 is not set
+# CONFIG_SENSORS_PC87427 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_PMBUS is not set
+# CONFIG_SENSORS_SHT21 is not set
+# CONFIG_SENSORS_SIS5595 is not set
+# CONFIG_SENSORS_SMM665 is not set
+# CONFIG_SENSORS_DME1737 is not set
+# CONFIG_SENSORS_EMC1403 is not set
+# CONFIG_SENSORS_EMC2103 is not set
+# CONFIG_SENSORS_EMC6W201 is not set
+# CONFIG_SENSORS_SMSC47M1 is not set
+# CONFIG_SENSORS_SMSC47M192 is not set
+# CONFIG_SENSORS_SMSC47B397 is not set
+# CONFIG_SENSORS_SCH56XX_COMMON is not set
+# CONFIG_SENSORS_ADS1015 is not set
+# CONFIG_SENSORS_ADS7828 is not set
+# CONFIG_SENSORS_AMC6821 is not set
+# CONFIG_SENSORS_INA209 is not set
+# CONFIG_SENSORS_INA2XX is not set
+# CONFIG_SENSORS_THMC50 is not set
+# CONFIG_SENSORS_TMP102 is not set
+# CONFIG_SENSORS_TMP401 is not set
+# CONFIG_SENSORS_TMP421 is not set
+# CONFIG_SENSORS_VIA_CPUTEMP is not set
+# CONFIG_SENSORS_VIA686A is not set
+# CONFIG_SENSORS_VT1211 is not set
+# CONFIG_SENSORS_VT8231 is not set
+# CONFIG_SENSORS_W83781D is not set
+# CONFIG_SENSORS_W83791D is not set
+# CONFIG_SENSORS_W83792D is not set
+# CONFIG_SENSORS_W83793 is not set
+# CONFIG_SENSORS_W83795 is not set
+# CONFIG_SENSORS_W83L785TS is not set
+# CONFIG_SENSORS_W83L786NG is not set
+# CONFIG_SENSORS_W83627HF is not set
+# CONFIG_SENSORS_W83627EHF is not set
+# CONFIG_SENSORS_APPLESMC is not set
+
+#
+# ACPI drivers
+#
+# CONFIG_SENSORS_ACPI_POWER is not set
+# CONFIG_SENSORS_ATK0110 is not set
+CONFIG_THERMAL=y
+CONFIG_THERMAL_HWMON=y
+CONFIG_THERMAL_DEFAULT_GOV_STEP_WISE=y
+# CONFIG_THERMAL_DEFAULT_GOV_FAIR_SHARE is not set
+# CONFIG_THERMAL_DEFAULT_GOV_USER_SPACE is not set
+# CONFIG_THERMAL_GOV_FAIR_SHARE is not set
+CONFIG_THERMAL_GOV_STEP_WISE=y
+# CONFIG_THERMAL_GOV_USER_SPACE is not set
+# CONFIG_CPU_THERMAL is not set
+# CONFIG_THERMAL_EMULATION is not set
+# CONFIG_INTEL_POWERCLAMP is not set
+# CONFIG_WATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+
+#
+# Broadcom specific AMBA
+#
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_CS5535 is not set
+# CONFIG_MFD_AS3711 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_LPC_ICH is not set
+CONFIG_LPC_SCH=y
+# CONFIG_MFD_JANZ_CMODIO is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_RDC321X is not set
+# CONFIG_MFD_RTSX_PCI is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_VX855 is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=y
+# CONFIG_AGP_SIS is not set
+CONFIG_AGP_VIA=y
+CONFIG_VGA_ARB=y
+CONFIG_VGA_ARB_MAX_GPUS=16
+CONFIG_VGA_SWITCHEROO=y
+CONFIG_DRM=y
+CONFIG_DRM_KMS_HELPER=y
+# CONFIG_DRM_LOAD_EDID_FIRMWARE is not set
+
+#
+# I2C encoder or helper chips
+#
+# CONFIG_DRM_I2C_CH7006 is not set
+# CONFIG_DRM_I2C_SIL164 is not set
+# CONFIG_DRM_I2C_NXP_TDA998X is not set
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_NOUVEAU is not set
+# CONFIG_DRM_I810 is not set
+CONFIG_DRM_I915=y
+# CONFIG_DRM_I915_KMS is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_DRM_VMWGFX is not set
+# CONFIG_DRM_GMA500 is not set
+# CONFIG_DRM_UDL is not set
+# CONFIG_DRM_AST is not set
+# CONFIG_DRM_MGAG200 is not set
+# CONFIG_DRM_CIRRUS_QEMU is not set
+# CONFIG_DRM_QXL is not set
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_HDMI=y
+CONFIG_FB=y
+CONFIG_FIRMWARE_EDID=y
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+CONFIG_FB_ASILIANT=y
+CONFIG_FB_IMSTT=y
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_VESA is not set
+CONFIG_FB_EFI=y
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I740 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+CONFIG_FB_GEODE=y
+# CONFIG_FB_GEODE_LX is not set
+# CONFIG_FB_GEODE_GX is not set
+# CONFIG_FB_GEODE_GX1 is not set
+# CONFIG_FB_TMIO is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_GOLDFISH is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_AUO_K190X is not set
+# CONFIG_EXYNOS_VIDEO is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=m
+# CONFIG_LCD_PLATFORM is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_APPLE is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+# CONFIG_BACKLIGHT_ADP8860 is not set
+# CONFIG_BACKLIGHT_ADP8870 is not set
+# CONFIG_BACKLIGHT_LM3630 is not set
+# CONFIG_BACKLIGHT_LM3639 is not set
+# CONFIG_BACKLIGHT_LP855X is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+# CONFIG_VGACON_SOFT_SCROLLBACK is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+# CONFIG_SND_SUPPORT_OLD_API is not set
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+CONFIG_SND_KCTL_JACK=y
+CONFIG_SND_DMA_SGBUF=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+CONFIG_SND_PCI=y
+# CONFIG_SND_AD1889 is not set
+# CONFIG_SND_ALS300 is not set
+# CONFIG_SND_ALI5451 is not set
+# CONFIG_SND_ASIHPI is not set
+# CONFIG_SND_ATIIXP is not set
+# CONFIG_SND_ATIIXP_MODEM is not set
+# CONFIG_SND_AU8810 is not set
+# CONFIG_SND_AU8820 is not set
+# CONFIG_SND_AU8830 is not set
+# CONFIG_SND_AW2 is not set
+# CONFIG_SND_AZT3328 is not set
+# CONFIG_SND_BT87X is not set
+# CONFIG_SND_CA0106 is not set
+# CONFIG_SND_CMIPCI is not set
+# CONFIG_SND_OXYGEN is not set
+# CONFIG_SND_CS4281 is not set
+# CONFIG_SND_CS46XX is not set
+# CONFIG_SND_CS5535AUDIO is not set
+# CONFIG_SND_CTXFI is not set
+# CONFIG_SND_DARLA20 is not set
+# CONFIG_SND_GINA20 is not set
+# CONFIG_SND_LAYLA20 is not set
+# CONFIG_SND_DARLA24 is not set
+# CONFIG_SND_GINA24 is not set
+# CONFIG_SND_LAYLA24 is not set
+# CONFIG_SND_MONA is not set
+# CONFIG_SND_MIA is not set
+# CONFIG_SND_ECHO3G is not set
+# CONFIG_SND_INDIGO is not set
+# CONFIG_SND_INDIGOIO is not set
+# CONFIG_SND_INDIGODJ is not set
+# CONFIG_SND_INDIGOIOX is not set
+# CONFIG_SND_INDIGODJX is not set
+# CONFIG_SND_EMU10K1 is not set
+# CONFIG_SND_EMU10K1X is not set
+# CONFIG_SND_ENS1370 is not set
+# CONFIG_SND_ENS1371 is not set
+# CONFIG_SND_ES1938 is not set
+# CONFIG_SND_ES1968 is not set
+# CONFIG_SND_FM801 is not set
+CONFIG_SND_HDA_INTEL=y
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+# CONFIG_SND_HDA_HWDEP is not set
+# CONFIG_SND_HDA_INPUT_BEEP is not set
+# CONFIG_SND_HDA_INPUT_JACK is not set
+# CONFIG_SND_HDA_PATCH_LOADER is not set
+CONFIG_SND_HDA_CODEC_REALTEK=y
+CONFIG_SND_HDA_CODEC_ANALOG=y
+CONFIG_SND_HDA_CODEC_SIGMATEL=y
+CONFIG_SND_HDA_CODEC_VIA=y
+CONFIG_SND_HDA_CODEC_HDMI=y
+CONFIG_SND_HDA_CODEC_CIRRUS=y
+CONFIG_SND_HDA_CODEC_CONEXANT=y
+CONFIG_SND_HDA_CODEC_CA0110=y
+# CONFIG_SND_HDA_CODEC_CA0132 is not set
+CONFIG_SND_HDA_CODEC_CMEDIA=y
+CONFIG_SND_HDA_CODEC_SI3054=y
+CONFIG_SND_HDA_GENERIC=y
+CONFIG_SND_HDA_POWER_SAVE_DEFAULT=0
+# CONFIG_SND_HDSP is not set
+# CONFIG_SND_HDSPM is not set
+# CONFIG_SND_ICE1712 is not set
+# CONFIG_SND_ICE1724 is not set
+# CONFIG_SND_INTEL8X0 is not set
+# CONFIG_SND_INTEL8X0M is not set
+# CONFIG_SND_KORG1212 is not set
+# CONFIG_SND_LOLA is not set
+# CONFIG_SND_LX6464ES is not set
+# CONFIG_SND_MAESTRO3 is not set
+# CONFIG_SND_MIXART is not set
+# CONFIG_SND_NM256 is not set
+# CONFIG_SND_PCXHR is not set
+# CONFIG_SND_RIPTIDE is not set
+# CONFIG_SND_RME32 is not set
+# CONFIG_SND_RME96 is not set
+# CONFIG_SND_RME9652 is not set
+# CONFIG_SND_SONICVIBES is not set
+# CONFIG_SND_TRIDENT is not set
+# CONFIG_SND_VIA82XX is not set
+# CONFIG_SND_VIA82XX_MODEM is not set
+# CONFIG_SND_VIRTUOSO is not set
+# CONFIG_SND_VX222 is not set
+# CONFIG_SND_YMFPCI is not set
+# CONFIG_SND_USB is not set
+# CONFIG_SND_SOC is not set
+# CONFIG_SOUND_PRIME is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+CONFIG_HIDRAW=y
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LENOVO_TPKBD is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_PS3REMOTE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=m
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# USB HID Boot Protocol drivers
+#
+# CONFIG_USB_KBD is not set
+# CONFIG_USB_MOUSE is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB_ARCH_HAS_XHCI=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=m
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB=m
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_XHCI_HCD=m
+# CONFIG_USB_XHCI_HCD_DEBUGGING is not set
+CONFIG_USB_EHCI_HCD=m
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+CONFIG_USB_EHCI_PCI=m
+# CONFIG_USB_EHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=m
+# CONFIG_USB_OHCI_HCD_PLATFORM is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=m
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=m
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=m
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_CHIPIDEA is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_PHY is not set
+# CONFIG_USB_GADGET is not set
+# CONFIG_UWB is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+# CONFIG_NEW_LEDS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+# CONFIG_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+
+#
+# on-CPU RTC drivers
+#
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VFIO is not set
+# CONFIG_VIRT_DRIVERS is not set
+
+#
+# Virtio drivers
+#
+# CONFIG_VIRTIO_PCI is not set
+# CONFIG_VIRTIO_MMIO is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+# CONFIG_X86_PLATFORM_DEVICES is not set
+
+#
+# Hardware Spinlock drivers
+#
+CONFIG_CLKEVT_I8253=y
+CONFIG_I8253_LOCK=y
+CONFIG_CLKBLD_I8253=y
+# CONFIG_MAILBOX is not set
+CONFIG_IOMMU_API=y
+CONFIG_IOMMU_SUPPORT=y
+CONFIG_AMD_IOMMU=y
+CONFIG_AMD_IOMMU_STATS=y
+# CONFIG_AMD_IOMMU_V2 is not set
+# CONFIG_INTEL_IOMMU is not set
+# CONFIG_IRQ_REMAP is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_STE_MODEM_RPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_NTB is not set
+# CONFIG_VME_BUS is not set
+# CONFIG_PWM is not set
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+
+#
+# Firmware Drivers
+#
+CONFIG_EDD=y
+CONFIG_EDD_OFF=y
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+# CONFIG_DMI_SYSFS is not set
+CONFIG_ISCSI_IBFT_FIND=y
+# CONFIG_ISCSI_IBFT is not set
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# EFI (Extensible Firmware Interface) Support
+#
+CONFIG_EFI_VARS=y
+CONFIG_EFI_VARS_PSTORE=y
+# CONFIG_EFI_VARS_PSTORE_DEFAULT_DISABLE is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_EXT2_FS_SECURITY=y
+# CONFIG_EXT2_FS_XIP is not set
+CONFIG_EXT3_FS=y
+CONFIG_EXT3_DEFAULTS_TO_ORDERED=y
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_EXT4_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_EXT4_FS_SECURITY=y
+# CONFIG_EXT4_DEBUG is not set
+CONFIG_JBD=y
+# CONFIG_JBD_DEBUG is not set
+CONFIG_JBD2=y
+# CONFIG_JBD2_DEBUG is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_XFS_FS=y
+CONFIG_XFS_QUOTA=y
+CONFIG_XFS_POSIX_ACL=y
+# CONFIG_XFS_RT is not set
+# CONFIG_XFS_WARN is not set
+# CONFIG_XFS_DEBUG is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_EXPORTFS=y
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QUOTA_DEBUG is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+CONFIG_QUOTACTL_COMPAT=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_FUSE_FS=y
+# CONFIG_CUSE is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_NTFS_FS=y
+# CONFIG_NTFS_DEBUG is not set
+CONFIG_NTFS_RW=y
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_VMCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_TMPFS_XATTR=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+CONFIG_CONFIGFS_FS=m
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_LOGFS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+CONFIG_PSTORE=y
+# CONFIG_PSTORE_CONSOLE is not set
+# CONFIG_PSTORE_FTRACE is not set
+# CONFIG_PSTORE_RAM is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_F2FS_FS is not set
+# CONFIG_EFIVAR_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V2=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_SWAP is not set
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFS_USE_LEGACY_DNS is not set
+CONFIG_NFS_USE_KERNEL_DNS=y
+CONFIG_NFSD=y
+CONFIG_NFSD_V3=y
+# CONFIG_NFSD_V3_ACL is not set
+# CONFIG_NFSD_V4 is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+# CONFIG_SUNRPC_DEBUG is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=m
+CONFIG_NLS_ISO8859_2=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_NLS_ISO8859_4=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_NLS_KOI8_R=m
+CONFIG_NLS_KOI8_U=m
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+CONFIG_NLS_UTF8=m
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+# CONFIG_DETECT_HUNG_TASK is not set
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+CONFIG_STACKTRACE=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_INFO is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+CONFIG_RCU_CPU_STALL_TIMEOUT=21
+# CONFIG_RCU_CPU_STALL_INFO is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_KPROBES_SANITY_TEST is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_DEBUG_PER_CPU_MAPS is not set
+# CONFIG_LKDTM is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_ARCH_HAS_DEBUG_STRICT_USER_COPY_CHECKS=y
+# CONFIG_DEBUG_STRICT_USER_COPY_CHECKS is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_NOP_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_FP_TEST=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_FENTRY=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACER_MAX_TRACE=y
+CONFIG_TRACE_CLOCK=y
+CONFIG_RING_BUFFER=y
+CONFIG_EVENT_TRACING=y
+CONFIG_CONTEXT_SWITCH_TRACER=y
+CONFIG_TRACING=y
+CONFIG_GENERIC_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+CONFIG_FUNCTION_TRACER=y
+CONFIG_FUNCTION_GRAPH_TRACER=y
+# CONFIG_IRQSOFF_TRACER is not set
+CONFIG_SCHED_TRACER=y
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_TRACER_SNAPSHOT=y
+# CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+CONFIG_STACK_TRACER=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_KPROBE_EVENT=y
+# CONFIG_UPROBE_EVENT is not set
+CONFIG_PROBE_EVENTS=y
+CONFIG_DYNAMIC_FTRACE=y
+CONFIG_DYNAMIC_FTRACE_WITH_REGS=y
+CONFIG_FUNCTION_PROFILER=y
+CONFIG_FTRACE_MCOUNT_RECORD=y
+# CONFIG_FTRACE_STARTUP_TEST is not set
+CONFIG_MMIOTRACE=y
+# CONFIG_MMIOTRACE_TEST is not set
+# CONFIG_RING_BUFFER_BENCHMARK is not set
+# CONFIG_RING_BUFFER_STARTUP_TEST is not set
+# CONFIG_RBTREE_TEST is not set
+# CONFIG_INTERVAL_TREE_TEST is not set
+# CONFIG_PROVIDE_OHCI1394_DMA_INIT is not set
+# CONFIG_DYNAMIC_DEBUG is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_ASYNC_RAID6_TEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+CONFIG_HAVE_ARCH_KMEMCHECK=y
+# CONFIG_TEST_STRING_HELPERS is not set
+# CONFIG_TEST_KSTRTOX is not set
+CONFIG_STRICT_DEVMEM=y
+# CONFIG_X86_VERBOSE_BOOTUP is not set
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_X86_PTDUMP is not set
+CONFIG_DEBUG_RODATA=y
+CONFIG_DEBUG_RODATA_TEST=y
+# CONFIG_DEBUG_SET_MODULE_RONX is not set
+# CONFIG_DEBUG_NX_TEST is not set
+# CONFIG_DEBUG_TLBFLUSH is not set
+# CONFIG_IOMMU_DEBUG is not set
+# CONFIG_IOMMU_STRESS is not set
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+# CONFIG_X86_DECODER_SELFTEST is not set
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+# CONFIG_IO_DELAY_0X80 is not set
+CONFIG_IO_DELAY_0XED=y
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=1
+# CONFIG_DEBUG_BOOT_PARAMS is not set
+# CONFIG_CPA_DEBUG is not set
+CONFIG_OPTIMIZE_INLINING=y
+# CONFIG_DEBUG_NMI_SELFTEST is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEYS_DEBUG_PROC_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_PATH is not set
+# CONFIG_SECURITY_SELINUX is not set
+# CONFIG_SECURITY_SMACK is not set
+# CONFIG_SECURITY_TOMOYO is not set
+# CONFIG_SECURITY_APPARMOR is not set
+# CONFIG_SECURITY_YAMA is not set
+# CONFIG_IMA is not set
+# CONFIG_EVM is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_XOR_BLOCKS=y
+CONFIG_ASYNC_CORE=y
+CONFIG_ASYNC_MEMCPY=y
+CONFIG_ASYNC_XOR=y
+CONFIG_ASYNC_PQ=y
+CONFIG_ASYNC_RAID6_RECOV=y
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_PCRYPT is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_CRYPTO_CRC32C_INTEL=y
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRC32_PCLMUL is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+# CONFIG_CRYPTO_SHA1_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256_SSSE3 is not set
+# CONFIG_CRYPTO_SHA512_SSSE3 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+# CONFIG_CRYPTO_GHASH_CLMUL_NI_INTEL is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_X86_64 is not set
+# CONFIG_CRYPTO_AES_NI_INTEL is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_BLOWFISH_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAMELLIA_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAMELLIA_AESNI_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST5_AVX_X86_64 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_CAST6_AVX_X86_64 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_X86_64 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SERPENT_SSE2_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX_X86_64 is not set
+# CONFIG_CRYPTO_SERPENT_AVX2_X86_64 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64 is not set
+# CONFIG_CRYPTO_TWOFISH_X86_64_3WAY is not set
+# CONFIG_CRYPTO_TWOFISH_AVX_X86_64 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_ASYMMETRIC_KEY_TYPE is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+CONFIG_BINARY_PRINTF=y
+
+#
+# Library routines
+#
+CONFIG_RAID6_PQ=y
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_IO=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+# CONFIG_CRC8 is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+# CONFIG_XZ_DEC_X86 is not set
+# CONFIG_XZ_DEC_POWERPC is not set
+# CONFIG_XZ_DEC_IA64 is not set
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+# CONFIG_XZ_DEC_SPARC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_CHECK_SIGNATURE=y
+CONFIG_CPU_RMAP=y
+CONFIG_DQL=y
+CONFIG_NLATTR=y
+CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+# CONFIG_AVERAGE is not set
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+CONFIG_OID_REGISTRY=y
+CONFIG_UCS2_STRING=y
diff -rubB --new-file linux-3.10.69/drivers/ata/ahci.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/ata/ahci.c
--- linux-3.10.69/drivers/ata/ahci.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/ata/ahci.c	2017-05-02 03:31:56.000000000 +0200
@@ -1321,6 +1321,11 @@
 	if (ahci_sb600_enable_64bit(pdev))
 		hpriv->flags &= ~AHCI_HFLAG_32BIT_ONLY;
 
+#ifdef CONFIG_BUFFALO_DISABLE_NCQ
+	printk("** BUFFALO Disable Command Queuing Function [%s %s] **\n", dev_driver_string(&pdev->dev), dev_name(&pdev->dev));
+	hpriv->flags |= AHCI_HFLAG_NO_NCQ;
+#endif	/* CONFIG_BUFFALO_DISABLE_NCQ */
+
 	hpriv->mmio = pcim_iomap_table(pdev)[ahci_pci_bar];
 
 	n_msis = ahci_init_interrupts(pdev, hpriv);
diff -rubB --new-file linux-3.10.69/drivers/ata/libata-eh.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/ata/libata-eh.c
--- linux-3.10.69/drivers/ata/libata-eh.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/ata/libata-eh.c	2017-05-02 03:31:56.000000000 +0200
@@ -590,6 +590,9 @@
 	struct ata_port *ap = ata_shost_to_port(host);
 	unsigned long flags;
 	LIST_HEAD(eh_work_q);
+#ifdef CONFIG_BUFFALO_PLATFORM
+	extern int buffalo_booting;
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 
 	DPRINTK("ENTER\n");
 
@@ -603,6 +606,12 @@
 	   recover nr_timedout == 0 why exactly are we doing error recovery ? */
 	ata_scsi_port_error_handler(host, ap);
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+	if (!buffalo_booting) {
+		/* do nothing */
+	}
+	else
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	/* finish or retry handled scmd's and clean up */
 	WARN_ON(host->host_failed || !list_empty(&eh_work_q));
 
diff -rubB --new-file linux-3.10.69/drivers/ata/sata_mv.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/ata/sata_mv.c
--- linux-3.10.69/drivers/ata/sata_mv.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/ata/sata_mv.c	2017-05-02 03:31:56.000000000 +0200
@@ -4115,6 +4115,16 @@
 	}
 #endif
 
+#ifdef CONFIG_BUFFALO_DISABLE_NCQ
+	{
+		int i;
+
+		printk("** BUFFALO Disable Command Queuing Function [%s %s] **\n", dev_driver_string(&pdev->dev), dev_name(&pdev->dev));
+		for (i = 0; i < n_ports; i++)
+			host->ports[i]->flags &= ~ATA_FLAG_NCQ;
+	}
+#endif	/* CONFIG_BUFFALO_DISABLE_NCQ */
+
 	/*
 	 * (Re-)program MBUS remapping windows if we are asked to.
 	 */
@@ -4383,6 +4393,16 @@
 	hpriv->n_ports = n_ports;
 	hpriv->board_idx = board_idx;
 
+#ifdef CONFIG_BUFFALO_DISABLE_NCQ
+{
+	int i;
+
+	printk("** BUFFALO Disable Command Queuing Function [%s %s] **\n", dev_driver_string(&pdev->dev), dev_name(&pdev->dev));
+	for (i = 0; i < n_ports; i++)
+		host->ports[i]->flags &= ~ATA_FLAG_NCQ;
+}
+#endif
+
 	/* acquire resources */
 	rc = pcim_enable_device(pdev);
 	if (rc)
diff -rubB --new-file linux-3.10.69/drivers/md/md.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/md/md.c
--- linux-3.10.69/drivers/md/md.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/md/md.c	2017-05-02 03:31:56.000000000 +0200
@@ -54,6 +54,10 @@
 #include "md.h"
 #include "bitmap.h"
 
+#ifdef CONFIG_BUFFALO_USE_MD_KERNEVNT
+#include <buffalo/kernevnt.h>
+#endif	/* CONFIG_BUFFALO_USE_MD_KERNEVNT */
+
 #ifndef MODULE
 static void autostart_arrays(int part);
 #endif
@@ -97,7 +101,17 @@
  */
 
 static int sysctl_speed_limit_min = 1000;
+#ifdef CONFIG_BUFFALO_PLATFORM
+static int sysctl_speed_limit_max = 50000;
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+static int sysctl_skip_resync = 0;
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
+#ifdef CONFIG_BUFFALO_USE_MD_KERNEVNT
+static int sysctl_use_kernevnt = 1;
+#endif	/* CONFIG_BUFFALO_USE_MD_KERNEVNT */
+#else	/* CONFIG_BUFFALO_PLATFORM */
 static int sysctl_speed_limit_max = 200000;
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 static inline int speed_min(struct mddev *mddev)
 {
 	return mddev->sync_speed_min ?
@@ -120,6 +134,24 @@
 		.mode		= S_IRUGO|S_IWUSR,
 		.proc_handler	= proc_dointvec,
 	},
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+	{
+		.procname	= "skip_resync",
+		.data		= &sysctl_skip_resync,
+		.maxlen		= sizeof(int),
+		.mode		= S_IRUGO|S_IWUSR,
+		.proc_handler	= proc_dointvec,
+	},
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
+#ifdef CONFIG_BUFFALO_USE_MD_KERNEVNT
+	{
+		.procname	= "use_kernevnt",
+		.data		= &sysctl_use_kernevnt,
+		.maxlen		= sizeof(int),
+		.mode		= S_IRUGO|S_IWUSR,
+		.proc_handler	= proc_dointvec,
+	},
+#endif	/* CONFIG_BUFFALO_USE_MD_KERNEVNT */
 	{
 		.procname	= "speed_limit_max",
 		.data		= &sysctl_speed_limit_max,
@@ -3680,6 +3712,55 @@
 __ATTR(layout, S_IRUGO|S_IWUSR, layout_show, layout_store);
 
 
+#ifdef CONFIG_BUFFALO_ERRCNT
+static ssize_t
+maxerr_cnt_show(struct mddev *mddev, char *page)
+{
+	return sprintf(page, "%d\n", atomic_read(&mddev->maxerr_cnt));
+}
+
+static ssize_t
+maxerr_cnt_store(struct mddev *mddev, const char *buf, size_t len)
+{
+	char *e;
+	unsigned long n = simple_strtol(buf, &e, 10);
+
+	if (*buf &&
+	    (*e == 0 || *e == '\n') &&
+	    (n == -1 || (signed int)n >= 0)) {
+		atomic_set(&mddev->maxerr_cnt, n);
+		return len;
+	}
+	return -EINVAL;
+}
+static struct md_sysfs_entry md_maxerr_cnt =
+__ATTR(maxerr_cnt, S_IRUGO|S_IWUSR, maxerr_cnt_show, maxerr_cnt_store);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+static ssize_t
+skip_resync_show(struct mddev *mddev, char *page)
+{
+	return sprintf(page, "%d\n", atomic_read(&mddev->skip_resync));
+}
+static ssize_t
+skip_resync_store(struct mddev *mddev, const char *buf, size_t len)
+{
+	char *e;
+	unsigned long n = simple_strtol(buf, &e, 10);
+
+	if (*buf &&
+	    (*e == 0 || *e == '\n') &&
+	    (n == 1 || n == 0)) {
+		atomic_set(&mddev->skip_resync, n);
+		return len;
+	}
+	return -EINVAL;
+}
+static struct md_sysfs_entry md_skip_resync =
+__ATTR(skip_resync, S_IRUGO|S_IWUSR, skip_resync_show, skip_resync_store);
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
+
 static ssize_t
 raid_disks_show(struct mddev *mddev, char *page)
 {
@@ -4677,6 +4758,12 @@
 static struct attribute *md_default_attrs[] = {
 	&md_level.attr,
 	&md_layout.attr,
+#ifdef CONFIG_BUFFALO_ERRCNT
+	&md_maxerr_cnt.attr,
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+	&md_skip_resync.attr,
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
 	&md_raid_disks.attr,
 	&md_chunk_size.attr,
 	&md_size.attr,
@@ -5146,6 +5233,13 @@
 	if (mddev->flags)
 		md_update_sb(mddev, 0);
 
+#ifdef CONFIG_BUFFALO_ERRCNT
+	atomic_set(&mddev->maxerr_cnt, MAXERR_CNT_DEFAULT);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+	atomic_set(&mddev->skip_resync, 0);
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
+
 	md_new_event(mddev);
 	sysfs_notify_dirent_safe(mddev->sysfs_state);
 	sysfs_notify_dirent_safe(mddev->sysfs_action);
@@ -5336,8 +5430,14 @@
 		err = -EBUSY;
 		goto out;
 	}
-	if (bdev)
-		sync_blockdev(bdev);
+	if (bdev && !test_bit(MD_STILL_CLOSED, &mddev->flags)) {
+		/* Someone opened the device since we flushed it
+		 * so page cache could be dirty and it is too late
+		 * to flush.  So abort
+		 */
+		mutex_unlock(&mddev->open_mutex);
+		return -EBUSY;
+	}
 	if (mddev->pers) {
 		__md_stop_writes(mddev);
 
@@ -5372,14 +5472,14 @@
 		mutex_unlock(&mddev->open_mutex);
 		return -EBUSY;
 	}
-	if (bdev)
-		/* It is possible IO was issued on some other
-		 * open file which was closed before we took ->open_mutex.
-		 * As that was not the last close __blkdev_put will not
-		 * have called sync_blockdev, so we must.
+	if (bdev && !test_bit(MD_STILL_CLOSED, &mddev->flags)) {
+		/* Someone opened the device since we flushed it
+		 * so page cache could be dirty and it is too late
+		 * to flush.  So abort
 		 */
-		sync_blockdev(bdev);
-
+		mutex_unlock(&mddev->open_mutex);
+		return -EBUSY;
+	}
 	if (mddev->pers) {
 		if (mddev->ro)
 			set_disk_ro(disk, 0);
@@ -6414,6 +6514,20 @@
 		/* need to ensure md_delayed_delete() has completed */
 		flush_workqueue(md_misc_wq);
 
+	if (cmd == STOP_ARRAY || cmd == STOP_ARRAY_RO) {
+		/* Need to flush page cache, and ensure no-one else opens
+		 * and writes
+		 */
+		mutex_lock(&mddev->open_mutex);
+		if (atomic_read(&mddev->openers) > 1) {
+			mutex_unlock(&mddev->open_mutex);
+			err = -EBUSY;
+			goto abort;
+		}
+		set_bit(MD_STILL_CLOSED, &mddev->flags);
+		mutex_unlock(&mddev->open_mutex);
+		sync_blockdev(bdev);
+	}
 	err = mddev_lock(mddev);
 	if (err) {
 		printk(KERN_INFO 
@@ -6667,6 +6781,7 @@
 
 	err = 0;
 	atomic_inc(&mddev->openers);
+	clear_bit(MD_STILL_CLOSED, &mddev->flags);
 	mutex_unlock(&mddev->open_mutex);
 
 	check_disk_change(bdev);
@@ -6813,6 +6928,13 @@
 	if (!rdev || test_bit(Faulty, &rdev->flags))
 		return;
 
+#ifdef CONFIG_BUFFALO_USE_MD_DEGRADE_KERNEVNT
+	if (sysctl_use_kernevnt)
+		kernevnt_RaidDegraded(mddev->md_minor,
+				      MAJOR(rdev->bdev->bd_dev),
+				      MINOR(rdev->bdev->bd_dev));
+#endif	/* CONFIG_BUFFALO_USE_MD_DEGRADE_KERNEVNT */
+
 	if (!mddev->pers || !mddev->pers->error_handler)
 		return;
 	mddev->pers->error_handler(mddev,rdev);
@@ -7334,6 +7456,13 @@
 	struct md_rdev *rdev;
 	char *desc;
 	struct blk_plug plug;
+#ifdef CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT
+	int isRecovery, major=0, minor=0;
+#endif	/* CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT */
+
+#ifdef CONFIG_BUFFALO_PLATFORM
+	set_user_nice(current, 4);
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 
 	/* just incase thread restarts... */
 	if (test_bit(MD_RECOVERY_DONE, &mddev->recovery))
@@ -7350,6 +7479,12 @@
 			desc = "requested-resync";
 		else
 			desc = "resync";
+#ifdef CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT
+		if (test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+		    test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery) &&
+		    !test_bit(MD_RECOVERY_CHECK, &mddev->recovery))
+			kernevnt_RaidScan(mddev->md_minor, 1);
+#endif	/* CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT */
 	} else if (test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))
 		desc = "reshape";
 	else
@@ -7462,6 +7597,32 @@
 		}
 	}
 
+
+#ifdef CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT
+	if (sysctl_use_kernevnt) {
+		if((test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+		    !test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery)) ||
+		   (!test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+		    test_bit(MD_RECOVERY_RECOVER, &mddev->recovery))) {
+			struct md_rdev *rdev_tmp;
+			list_for_each_entry(rdev_tmp, &mddev->disks, same_set){
+				if (rdev_tmp->flags != In_sync) {
+					major = MAJOR(rdev_tmp->bdev->bd_dev);
+					minor = MINOR(rdev_tmp->bdev->bd_dev);
+					break;
+				}
+			}
+			isRecovery = !test_bit(MD_RECOVERY_SYNC,
+					       &mddev->recovery);
+			kernevnt_RaidRecovery(mddev->md_minor, 1,
+					      isRecovery, major, minor);
+		}
+		else if ((test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))) {
+			kernevnt_RaidReshape(mddev->md_minor, 1);
+		}
+	}
+#endif	/* CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT */
+
 	printk(KERN_INFO "md: %s of RAID array %s\n", desc, mdname(mddev));
 	printk(KERN_INFO "md: minimum _guaranteed_  speed:"
 		" %d KB/sec/disk.\n", speed_min(mddev));
@@ -7506,6 +7667,13 @@
 	while (j < max_sectors) {
 		sector_t sectors;
 
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+		if (sysctl_skip_resync || atomic_read(&mddev->skip_resync)) {
+			mddev->curr_resync = max_sectors;
+			break;
+		}
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
+
 		skipped = 0;
 
 		if (!test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery) &&
@@ -7617,6 +7785,21 @@
 	blk_finish_plug(&plug);
 	wait_event(mddev->recovery_wait, !atomic_read(&mddev->recovery_active));
 
+#ifdef CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT
+	if (sysctl_use_kernevnt) {
+		if((test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+		    !test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery)) ||
+		   (!test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+		    test_bit(MD_RECOVERY_RECOVER, &mddev->recovery)))
+			kernevnt_RaidRecovery(mddev->md_minor, 0,
+					      isRecovery, major, minor);
+                else if((test_bit(MD_RECOVERY_RESHAPE, &mddev->recovery))) {
+			printk("RaidReshape(mddev->md_minor, 0)\n");
+			kernevnt_RaidReshape(mddev->md_minor, 0);
+		}
+	}
+#endif	/* CONFIG_BUFFALO_USE_MD_REBUILD_KERNEVNT */
+
 	/* tell personality that we are finished */
 	mddev->pers->sync_request(mddev, max_sectors, &skipped, 1);
 
@@ -7663,6 +7846,12 @@
 	} else if (test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery))
 		mddev->resync_min = mddev->curr_resync_completed;
 	mddev->curr_resync = 0;
+#ifdef CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT
+	if (test_bit(MD_RECOVERY_SYNC, &mddev->recovery) &&
+	    test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery) &&
+	    !test_bit(MD_RECOVERY_CHECK, &mddev->recovery))
+		kernevnt_RaidScan(mddev->md_minor, 0);
+#endif	/* CONFIG_BUFFALO_USE_MD_SCAN_KERNEVNT */
 	wake_up(&resync_wait);
 	set_bit(MD_RECOVERY_DONE, &mddev->recovery);
 	md_wakeup_thread(mddev->thread);
diff -rubB --new-file linux-3.10.69/drivers/md/md.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/md/md.h
--- linux-3.10.69/drivers/md/md.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/md/md.h	2017-05-02 03:31:56.000000000 +0200
@@ -213,6 +213,9 @@
 #define MD_CHANGE_CLEAN 1	/* transition to or from 'clean' */
 #define MD_CHANGE_PENDING 2	/* switch from 'clean' to 'active' in progress */
 #define MD_ARRAY_FIRST_USE 3    /* First use of array, needs initialization */
+#define MD_STILL_CLOSED	4	/* If set, then array has not been opened since
+				 * md_ioctl checked on it.
+				 */
 
 	int				suspended;
 	atomic_t			active_io;
@@ -425,6 +428,19 @@
 	struct work_struct flush_work;
 	struct work_struct event_work;	/* used by dm to report failure event */
 	void (*sync_super)(struct mddev *mddev, struct md_rdev *rdev);
+
+#ifdef CONFIG_BUFFALO_ERRCNT
+#define MAXERR_CNT_DEFAULT		1000
+	atomic_t			maxerr_cnt; /* If rdev->bdev->bd_disk->
+						     * nr_err reaches to
+						     * maxerr_cnt (excepting
+						     * maxerr_cnt is -1),
+						     * disk will be faulty.
+						     */
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+	atomic_t			skip_resync;
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
 };
 
 
diff -rubB --new-file linux-3.10.69/drivers/md/raid1.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/md/raid1.c
--- linux-3.10.69/drivers/md/raid1.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/md/raid1.c	2017-05-02 03:31:56.000000000 +0200
@@ -309,6 +309,9 @@
 	struct r1bio *r1_bio = bio->bi_private;
 	int mirror;
 	struct r1conf *conf = r1_bio->mddev->private;
+#ifdef CONFIG_BUFFALO_ERRCNT
+	struct md_rdev *rdev;
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 
 	mirror = r1_bio->read_disk;
 	/*
@@ -316,6 +319,22 @@
 	 */
 	update_head_pos(mirror, r1_bio);
 
+#ifdef CONFIG_BUFFALO_ERRCNT
+	rcu_read_lock();
+	rdev = rcu_dereference(conf->mirrors[r1_bio->read_disk].rdev);
+	if (rdev != NULL) {
+		int maxerr_cnt = atomic_read(&conf->mddev->maxerr_cnt);
+
+		if (atomic_read(&rdev->bdev->bd_disk->nr_errs) > maxerr_cnt &&
+		    maxerr_cnt != -1)
+			if (conf->raid_disks - r1_bio->mddev->degraded != 1) {
+				rcu_read_unlock();
+				goto do_degrade;
+			}
+	}
+	rcu_read_unlock();
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+
 	if (uptodate)
 		set_bit(R1BIO_Uptodate, &r1_bio->state);
 	else {
@@ -340,6 +359,10 @@
 		 * oops, read error:
 		 */
 		char b[BDEVNAME_SIZE];
+
+#ifdef CONFIG_BUFFALO_ERRCNT
+do_degrade:
+#endif /* CONFIG_BUFFALO_ERRCNT */
 		printk_ratelimited(
 			KERN_ERR "md/raid1:%s: %s: "
 			"rescheduling sector %llu\n",
@@ -1955,6 +1978,25 @@
 	if (test_bit(MD_RECOVERY_REQUESTED, &mddev->recovery))
 		if (process_checks(r1_bio) < 0)
 			return;
+
+#ifdef CONFIG_BUFFALO_ERRCNT
+	rcu_read_lock();
+	for (i = 0; i < mddev->raid_disks; i++) {
+		struct md_rdev *rdev = rcu_dereference(conf->mirrors[i].rdev);
+		int maxerr_cnt = atomic_read(&mddev->maxerr_cnt);
+
+		if (r1_bio->bios[i]->bi_end_io != end_sync_read ||
+		    rdev == NULL)
+			continue;
+
+		if (atomic_read(&rdev->bdev->bd_disk->nr_errs) > maxerr_cnt &&
+		    maxerr_cnt != -1)
+			if (!test_bit(Faulty, &conf->mirrors[i].rdev->flags))
+				md_error(mddev, conf->mirrors[i].rdev);
+	}
+	rcu_read_unlock();
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+
 	/*
 	 * schedule writes
 	 */
@@ -2232,6 +2274,16 @@
 		freeze_array(conf, 1);
 		fix_read_error(conf, r1_bio->read_disk,
 			       r1_bio->sector, r1_bio->sectors);
+#ifdef CONFIG_BUFFALO_ERRCNT
+		rdev = conf->mirrors[r1_bio->read_disk].rdev;
+		if (rdev != NULL) {
+			int maxerr_cnt =
+				atomic_read(&mddev->maxerr_cnt);
+			if (atomic_read(&rdev->bdev->bd_disk->nr_errs) > maxerr_cnt &&
+			    maxerr_cnt != -1)
+				md_error(mddev, rdev);
+		}
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 		unfreeze_array(conf);
 	} else
 		md_error(mddev, conf->mirrors[r1_bio->read_disk].rdev);
diff -rubB --new-file linux-3.10.69/drivers/md/raid5.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/md/raid5.c
--- linux-3.10.69/drivers/md/raid5.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/md/raid5.c	2017-05-02 03:31:56.000000000 +0200
@@ -1766,6 +1766,18 @@
 		s = sh->sector + rdev->new_data_offset;
 	else
 		s = sh->sector + rdev->data_offset;
+
+#ifdef CONFIG_BUFFALO_ERRCNT
+	if (!(conf->mddev->degraded)) {
+		int maxerr_cnt = atomic_read(&conf->mddev->maxerr_cnt);
+
+		rdev = conf->disks[i].rdev;
+		if (atomic_read(&rdev->bdev->bd_disk->nr_errs) > maxerr_cnt &&
+		    maxerr_cnt != -1)
+			uptodate = 0;
+	}
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+
 	if (uptodate) {
 		set_bit(R5_UPTODATE, &sh->dev[i].flags);
 		if (test_bit(R5_ReadError, &sh->dev[i].flags)) {
@@ -1829,12 +1841,38 @@
 			       mdname(conf->mddev), bdn);
 		else
 			retry = 1;
+#ifdef CONFIG_BUFFALO_ERRCNT
+		if (retry) {
+			int maxerr_cnt;
+
+			if (test_bit(R5_ReadNoMerge, &sh->dev[i].flags)) {
+				set_bit(R5_ReadError, &sh->dev[i].flags);
+				clear_bit(R5_ReadNoMerge, &sh->dev[i].flags);
+			} else
+				set_bit(R5_ReadNoMerge, &sh->dev[i].flags);
+
+			printk("debug: Read Error dev[%d]: sector %llu(sh->sector=%llu)\n",
+			       i, (unsigned long long)sh->dev[i].sector,
+			       (unsigned long long)sh->sector);
+			/*
+			 * Don't forget the bracket {} put in the outside of
+			 * this macro, if you port this code to another
+			 * version of Linux.
+			 */
+			maxerr_cnt = atomic_read(&conf->mddev->maxerr_cnt);
+			rdev = conf->disks[i].rdev;
+			if (atomic_read(&rdev->bdev->bd_disk->nr_errs) > maxerr_cnt &&
+			    maxerr_cnt != -1)
+				md_error(conf->mddev, conf->disks[i].rdev);
+		}
+#else	/* CONFIG_BUFFALO_ERRCNT */
 		if (retry)
 			if (test_bit(R5_ReadNoMerge, &sh->dev[i].flags)) {
 				set_bit(R5_ReadError, &sh->dev[i].flags);
 				clear_bit(R5_ReadNoMerge, &sh->dev[i].flags);
 			} else
 				set_bit(R5_ReadNoMerge, &sh->dev[i].flags);
+#endif	/* CONFIG_BUFFALO_ERRCNT */
 		else {
 			clear_bit(R5_ReadError, &sh->dev[i].flags);
 			clear_bit(R5_ReWrite, &sh->dev[i].flags);
@@ -5616,7 +5654,7 @@
 		mddev->queue->limits.discard_granularity = stripe;
 		/*
 		 * unaligned part of discard request will be ignored, so can't
-		 * guarantee discard_zeroes_data
+		 * guarantee discard_zerors_data
 		 */
 		mddev->queue->limits.discard_zeroes_data = 0;
 
diff -rubB --new-file linux-3.10.69/drivers/net/ethernet/intel/e1000e/netdev.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/net/ethernet/intel/e1000e/netdev.c
--- linux-3.10.69/drivers/net/ethernet/intel/e1000e/netdev.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/net/ethernet/intel/e1000e/netdev.c	2017-05-02 03:31:56.000000000 +0200
@@ -4717,6 +4717,21 @@
 	}
 }
 
+#if defined(CONFIG_BUFFALO_PLATFORM)
+static void buffalo_kernevnt_notify(struct e1000_adapter *adapter)
+{
+       char kernevnt_msg[128];
+       memset(kernevnt_msg, 0, sizeof(kernevnt_msg));
+
+       if (adapter->link_speed == 0)
+               sprintf(kernevnt_msg, "lanact 0 half %s", adapter->netdev->name);
+       else
+               sprintf(kernevnt_msg, "lanact %d %s %s", adapter->link_speed, (adapter->link_duplex == FULL_DUPLEX)? "full":"half", adapter->netdev->name);
+
+       extern void buffalo_kernevnt_queuein(const char *cmd);
+       buffalo_kernevnt_queuein((const char *)kernevnt_msg);
+}
+#endif
 static void e1000_print_link_info(struct e1000_adapter *adapter)
 {
 	struct e1000_hw *hw = &adapter->hw;
@@ -4729,6 +4744,9 @@
 		(ctrl & E1000_CTRL_TFCE) && (ctrl & E1000_CTRL_RFCE) ? "Rx/Tx" :
 		(ctrl & E1000_CTRL_RFCE) ? "Rx" :
 		(ctrl & E1000_CTRL_TFCE) ? "Tx" : "None");
+#if defined(CONFIG_BUFFALO_PLATFORM)
+       buffalo_kernevnt_notify(adapter);
+#endif
 }
 
 static bool e1000e_has_link(struct e1000_adapter *adapter)
@@ -4952,6 +4970,9 @@
 			adapter->link_duplex = 0;
 			/* Link status message must follow this format */
 			pr_info("%s NIC Link is Down\n", adapter->netdev->name);
+#if defined(CONFIG_BUFFALO_PLATFORM)
+			buffalo_kernevnt_notify(adapter);
+#endif
 			netif_carrier_off(netdev);
 			if (!test_bit(__E1000_DOWN, &adapter->state))
 				mod_timer(&adapter->phy_info_timer,
diff -rubB --new-file linux-3.10.69/drivers/scsi/Kconfig F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/Kconfig
--- linux-3.10.69/drivers/scsi/Kconfig	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/Kconfig	2017-05-02 03:31:56.000000000 +0200
@@ -330,6 +330,12 @@
 	default y
 
 if SCSI_LOWLEVEL && SCSI
+config SCSI_MV_94xx
+	tristate "Marvell Storage Controller 9180/9480"
+	depends on SCSI && BLK_DEV_SD
+	help
+		Provides support for Marvell 94xx Storage Controller series.
+
 
 config ISCSI_TCP
 	tristate "iSCSI Initiator over TCP/IP"
diff -rubB --new-file linux-3.10.69/drivers/scsi/Makefile F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/Makefile
--- linux-3.10.69/drivers/scsi/Makefile	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/Makefile	2017-05-02 03:31:56.000000000 +0200
@@ -50,6 +50,7 @@
 obj-$(CONFIG_A2091_SCSI)	+= a2091.o	wd33c93.o
 obj-$(CONFIG_GVP11_SCSI)	+= gvp11.o	wd33c93.o
 obj-$(CONFIG_MVME147_SCSI)	+= mvme147.o	wd33c93.o
+obj-$(CONFIG_SCSI_MV_94xx)	+= mv/
 obj-$(CONFIG_SGIWD93_SCSI)	+= sgiwd93.o	wd33c93.o
 obj-$(CONFIG_ATARI_SCSI)	+= atari_scsi.o
 obj-$(CONFIG_MAC_SCSI)		+= mac_scsi.o
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/cc.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/cc.h
--- linux-3.10.69/drivers/scsi/mv/cc.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/cc.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,63 @@
+#ifndef _MODULE_CC_H
+#define _MODULE_CC_H
+
+/*
+ * Here is the definition for the command consolidate sub module
+ * This is only changed when we modify the consolidate algorithm.
+ */
+typedef struct _Consolidate_Object
+{
+	MV_LBA Last_LBA;                                    /* last LBA*/
+	PMV_Request Holding_Request;                        /* Internal request which already consolidate some external requests. */
+	MV_U8 Sequential;                                   /* sequential counter */
+	MV_BOOLEAN Is_Read;                                 /* The last request is read or write. */
+	MV_U16 io_count;
+	MV_BOOLEAN	Enable_Consolidate;	/* If consolidation is enalbed on this device */
+	MV_U8	Cons_SG_Count;		/* Consolidation SG Count */										/* (SG Count of cache request is different from core request) */
+	MV_U8	Cons_Req_Count;
+	MV_U8	Reserved;
+} Consolidate_Object, *PConsolidate_Object;
+
+typedef struct _ModConsolidate_Extension
+{
+	List_Head Free_Queue;
+	PConsolidate_Object pConsolid_Obj;
+	MV_PVOID pUpperExtension;
+	MV_PVOID pNextExtension;
+	MV_VOID (*pNextFunction) (MV_PVOID, PMV_Request);
+	MV_U16 dev_count;
+	MV_BOOLEAN ModCons_Enabled;		/* 1 - module consolidation is enabled on the adapter */
+	MV_U8 Reserved0;
+} ModConsolidate_Extension, *PModConsolidate_Extension;
+
+/*============= Consolidate usage ==========================
+step:
+	1. call "Consolid_GetResourceQuota" to get resource 	requirement of Consolidate.
+	2. call "Consolid_InitializeExtension" to initial resource of Consolidate.
+	3. call "Consolid_SetSendFunction" to set executing function of Consolidate.
+	4. call "Consolid_ModuleSendRequest" to process your request.
+	5. call "Consolid_PushFireRequest" to chech if holding request need to push.
+
+========================================================*/
+MV_U32 ModConsolid_GetResourceQuota(
+		MV_U16 reqCount,
+		MV_U16 DevCount,
+		MV_U16 sgCount);
+
+void ModConsolid_InitializeExtension(
+		MV_PVOID This,
+		MV_U16 reqCount,
+		MV_U16 devCount,
+		MV_U16 sgCount);
+
+void ModConsolid_SetSendFunction(
+		MV_PVOID This,
+		MV_PVOID current_ext,
+		MV_PVOID next_ext,
+		MV_VOID (*next_function) (MV_PVOID, PMV_Request));
+
+void ModConsolid_ModuleSendRequest(MV_PVOID This, PMV_Request pReq);
+void ModConsolid_PushFireRequest(MV_PVOID This, PMV_Request pReq);
+void ModConsolid_SetDevice(MV_PVOID This, struct mod_notif_param *p_notify);
+void ModConsolid_InitConsDev(MV_PVOID p_module);
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/hba_api.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_api.h
--- linux-3.10.69/drivers/scsi/mv/hba_api.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_api.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef _HBA_API_H
+#define _HBA_API_H
+typedef struct _RAID_Feature
+{
+	List_Head Internal_Request;
+	MV_PVOID pHBA;
+	MV_PVOID pUpperExtension;
+	MV_PVOID pNextExtension;
+	MV_VOID (*pNextFunction) (MV_PVOID, PMV_Request);
+	MV_U16 SMART_Status_Timer_Handle;
+	MV_U8 reserved[2];
+
+} RAID_Feature, *PRAID_Feature;
+
+MV_U32 RAID_Feature_GetResourceQuota(MV_U16 maxIo);
+void RAID_Feature_Initialize(MV_PVOID This, MV_U16 maxIo);
+void RAID_Feature_SetSendFunction( MV_PVOID This,
+	MV_PVOID current_ext,
+	MV_PVOID next_ext,
+	MV_VOID (*next_function) (MV_PVOID, PMV_Request));
+void mvSetAdapterConfig( MV_PVOID This, PMV_Request pReq);
+void mvGetAdapterConfig( MV_PVOID This, PMV_Request pReq);
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/hba_exp.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_exp.c
--- linux-3.10.69/drivers/scsi/mv/hba_exp.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_exp.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,1024 @@
+#include "linux_main.h"
+#include "hba_mod.h"
+#include "linux_iface.h"
+#include "hba_timer.h"
+#include "hba_api.h"
+#if defined(SUPPORT_MODULE_CONSOLIDATE)
+#include "cc.h"
+#endif		/* SUPPORT_MODULE_CONSOLIDATE */
+
+#ifdef RAID_DRIVER
+#include "raid_structure.h"
+#endif
+/*
+ *
+ * Other exposed functions
+ *
+ */
+
+MV_U32 MV_PCI_READ_DWORD(MV_PVOID This, MV_U8 reg)
+{
+   	MV_U32 v;
+	PHBA_Extension p_hba = (PHBA_Extension)HBA_GetModuleExtension(This,MODULE_HBA);
+	MV_ASSERT( p_hba != NULL );
+	MV_PCI_READ_CONFIG_DWORD(p_hba, reg, &v);
+	return v;
+}
+
+MV_VOID  MV_PCI_WRITE_DWORD(MV_PVOID This, MV_U32 val, MV_U8 reg)
+{
+	PHBA_Extension p_hba = (PHBA_Extension)HBA_GetModuleExtension(This,MODULE_HBA);
+	MV_ASSERT( p_hba != NULL );
+	MV_PCI_WRITE_CONFIG_DWORD(p_hba, reg, val);
+	return;
+}
+
+/*
+ * The extension is the calling module extension.
+ *   It can be any module extension.
+ */
+void HBA_ModuleStarted(MV_PVOID extension)
+{
+	struct mv_mod_desc *mod_desc = __ext_to_gen(extension)->desc;
+	struct hba_extension *hba;
+	struct mv_mod_desc *desc;
+	struct mv_adp_desc *hba_desc;
+	MV_DPRINT(( "start HBA_ModuleStarted addr %p, id %d.\n",mod_desc, mod_desc->module_id));
+	mod_desc->status = MV_MOD_STARTED;
+	desc = mod_desc;
+	while (desc->parent)
+		desc = desc->parent; /* hba to be the uppermost */
+	hba = (struct hba_extension *) desc->extension;
+	hba_desc = hba->desc->hba_desc;
+	if (__mv_is_mod_all_started(desc->hba_desc)) {
+		MV_DPRINT(( "all modules have been started.\n"));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+		atomic_set(&hba_desc->hba_sync, 0);
+#else
+		complete(&hba_desc->cmpl);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+		/* We are totally ready for requests handling. */
+		hba->State = DRIVER_STATUS_STARTED;
+
+		/* Module 0 is the last module */
+		hba->desc->ops->module_notification(hba,
+						    EVENT_MODULE_ALL_STARTED,
+						    NULL);
+	} else {
+		/*
+		 * TBD: hba's start has already been called, so we should not
+		 * call it here. (hba is the highest module, it has no parent.)
+		 */
+		if (mod_desc->parent && mod_desc->parent->parent)
+		{
+			MV_DPRINT(("start module %d.....\n",mod_desc->parent->module_id));
+			mod_desc->parent->ops->module_start(mod_desc->parent->extension);
+		}
+	}
+
+}
+
+void hba_map_sg_to_buffer(void *preq)
+{
+	struct scsi_cmnd *scmd =NULL;
+	struct scatterlist *sg =NULL;
+	PMV_Request        req =NULL;
+	void * virt_address;
+	unsigned long flags = 0;
+	unsigned int i = 0;
+
+	req  = (PMV_Request) preq;
+
+	if (REQ_TYPE_OS != req->Req_Type)
+		return;
+	scmd = (struct scsi_cmnd *) req->Org_Req_Scmd;
+	sg = (struct scatterlist *) mv_rq_bf(scmd);
+
+	if (mv_use_sg(scmd)) {
+		BUG_ON(!req->Data_Transfer_Length);
+		req->Data_Buffer = hba_mem_alloc(req->Data_Transfer_Length, MV_TRUE);
+		if (!req->Data_Buffer) {
+			MV_DPRINT(("can not allocate memory %x.\n", req->Data_Transfer_Length));
+		}
+		BUG_ON(!req->Data_Buffer);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)) && !defined(MV_VMK_ESXI5)
+		req->Data_Transfer_Length = 0;
+		for(i = 0; i < mv_use_sg(scmd); i++, sg++) {
+			local_irq_save(flags);
+		#ifndef MV_VMK_ESX35
+			virt_address = map_sg_page(sg);
+		#else
+			req->Data_Buffer = kmalloc(sg->length, GFP_ATOMIC);
+			if (req->Data_Buffer) {
+				memset(req->Data_Buffer, 0, sg->length);
+			}
+		#endif
+			memcpy(req->Data_Buffer + req->Data_Transfer_Length ,\
+				 virt_address + sg->offset, sg->length);
+			kunmap_atomic(virt_address, KM_IRQ0);
+			req->Data_Transfer_Length += sg->length;
+			local_irq_restore(flags);
+		}
+#else
+		memset(req->Data_Buffer, 0, req->Data_Transfer_Length);
+		local_irq_save(flags);
+		if (scmd->sc_data_direction == DMA_TO_DEVICE)
+			sg_copy_to_buffer(scsi_sglist(scmd),  scsi_sg_count(scmd), req->Data_Buffer, req->Data_Transfer_Length);
+		local_irq_restore(flags);
+
+#endif
+	} else {
+#ifndef MV_VMK_ESX35
+	        req->Data_Buffer = mv_rq_bf(scmd);
+#else
+		vmk_verify_memory_for_io(scmd->request_bufferMA,scmd->request_bufflen);
+		req->Data_Buffer = vmk_phys_to_kmap(scmd->request_bufferMA, scmd->request_bufflen);
+#endif
+	}
+}
+
+void hba_unmap_sg_to_buffer(void *preq)
+{
+	struct scsi_cmnd *scmd = NULL;
+	struct scatterlist *sg = NULL;
+	PMV_Request        req = NULL;
+	unsigned long flags = 0;
+	void * virt_address;
+	unsigned long i = 0;
+
+	req  = (PMV_Request) preq;
+
+	if (REQ_TYPE_OS != req->Req_Type)
+		return;
+
+	scmd = (struct scsi_cmnd *) req->Org_Req_Scmd;
+	sg   = (struct scatterlist *) mv_rq_bf(scmd);
+
+	if (mv_use_sg(scmd)) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,26)) && !defined(MV_VMK_ESXI5)
+		req->Data_Transfer_Length = 0;
+		for(i = 0; i < mv_use_sg(scmd); i++, sg++) {
+			local_irq_save(flags);
+#ifndef MV_VMK_ESX35
+			virt_address = map_sg_page(sg);
+#else
+			vmk_verify_memory_for_io(sg_dma_address(sg),sg_dma_len(sg));
+			virt_address = vmk_phys_to_kmap(sg_dma_address(sg),sg_dma_len(sg));
+#endif
+			memcpy(virt_address + sg->offset,req->Data_Buffer
+				+ req->Data_Transfer_Length, sg->length);
+#ifndef MV_VMK_ESX35
+			kunmap_atomic(virt_address , KM_IRQ0);
+#else
+			vmk_phys_to_kmap_free(virt_address);
+#endif
+			req->Data_Transfer_Length += sg->length;
+			local_irq_restore(flags);
+		}
+#else
+
+		local_irq_save(flags);
+		if (scmd->sc_data_direction == DMA_FROM_DEVICE)
+			sg_copy_from_buffer(scsi_sglist(scmd),  scsi_sg_count(scmd), req->Data_Buffer, req->Data_Transfer_Length);
+		local_irq_restore(flags);
+#endif
+
+#ifndef MV_VMK_ESX35
+		hba_mem_free(req->Data_Buffer,req->Data_Transfer_Length, MV_TRUE);
+#else
+		kfree(req->Data_Buffer);
+#endif
+		req->Data_Buffer = mv_rq_bf(scmd);
+	}
+}
+
+MV_BOOLEAN hba_test_enabled(void *ext)
+{
+	struct hba_extension *phba = (struct hba_extension *)HBA_GetModuleExtension(ext, MODULE_HBA);
+	return (phba->test_enabled);
+}
+
+MV_BOOLEAN hba_msi_enabled(void *ext)
+{
+	struct hba_extension *phba = (struct hba_extension *)HBA_GetModuleExtension(ext, MODULE_HBA);
+	return (phba->msi_enabled);
+}
+
+MV_PVOID HBA_GetModuleExtension(MV_PVOID ext, MV_U32 mod_id)
+{
+	struct mv_mod_desc *mod_desc;
+	struct mv_adp_desc *hba_desc ;
+
+	if(ext == NULL)
+		return	NULL;
+	mod_desc=(struct mv_mod_desc *)__ext_to_gen(ext)->desc;
+	BUG_ON(NULL == mod_desc);
+	hba_desc = mod_desc->hba_desc;
+
+	MV_ASSERT(mod_id<MAX_MODULE_NUMBER);
+	if (hba_desc !=NULL ) {
+		LIST_FOR_EACH_ENTRY(mod_desc, &hba_desc->online_module_list, mod_entry)
+		{
+			BUG_ON(NULL == mod_desc);
+			if (mod_desc->status != MV_MOD_GONE) {
+				if ((mod_desc->module_id == mod_id) && (mod_desc->extension)) {
+					MV_DASSERT(mod_desc->extension);
+					return mod_desc->extension;
+				}
+			}
+		}
+	}
+	return	NULL;
+}
+
+MV_BOOLEAN __is_scsi_cmd_simulated(MV_U8 cmd_type)
+{
+	switch (cmd_type)
+	{
+	case SCSI_CMD_INQUIRY:
+	case SCSI_CMD_READ_CAPACITY_10:
+	case SCSI_CMD_READ_CAPACITY_16:
+	case SCSI_CMD_SYNCHRONIZE_CACHE_10:
+	case SCSI_CMD_TEST_UNIT_READY:
+	case SCSI_CMD_REQUEST_SENSE:
+	case SCSI_CMD_RESERVE_6:
+	case SCSI_CMD_RELEASE_6:
+	case SCSI_CMD_REPORT_LUN:
+	case SCSI_CMD_MODE_SENSE_6:
+	case SCSI_CMD_MODE_SENSE_10:
+	case SCSI_CMD_MODE_SELECT_6:
+	case SCSI_CMD_MODE_SELECT_10:
+#ifdef SUPPORT_LINUX_ATA_SMART
+	case SCSI_CMD_LOG_SENSE:
+	case SCSI_CMD_READ_DEFECT_DATA_10:
+#endif
+#ifdef SUPPORT_CONFIG_FILE
+	case APICDB0_PHY:
+#endif
+#ifdef CORE_SUPPORT_API
+	case APICDB0_PD:
+#ifdef SUPPORT_FLASH
+	case APICDB0_FLASH:
+#endif
+#ifdef SUPPORT_CSMI
+	case APICDB0_CSMI_CORE:
+#endif /* SUPPORT_CSMI */
+#endif /* CORE_SUPPORT_API */
+		return MV_TRUE;
+	default:
+		return MV_FALSE;
+	}
+}
+MV_BOOLEAN __is_scsi_cmd_rcv_snd_diag(MV_U8 cmd_type)
+{
+	switch (cmd_type){
+	case API_SCSI_CMD_RCV_DIAG_RSLT:
+	case API_SCSI_CMD_SND_DIAG	:
+		return  MV_TRUE;
+	default:
+		return MV_FALSE;
+	}
+}
+
+#ifdef SUPPORT_PASS_THROUGH_DIRECT
+void HBARequestCallback(MV_PVOID This,PMV_Request pReq)
+{
+	struct hba_extension *phba = (struct hba_extension *)HBA_GetModuleExtension(This, MODULE_HBA);
+#if defined(MV_BLK_IOCTL)
+	{
+		struct scsi_cmnd *scmd = (struct scsi_cmnd *)pReq->Org_Req_Scmd;
+		mv_complete_request(phba, scmd, pReq);
+		phba->Io_Count--;
+	#ifdef USE_REQ_POOL
+		hba_req_cache_free(phba,pReq);
+	#else
+		res_free_req_to_pool(phba->req_pool, pReq);
+	#endif
+	}
+#else
+	{
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+		atomic_set(&phba->desc->hba_desc->hba_ioctl_sync, 0);
+	#else
+		complete(&phba->desc->hba_desc->ioctl_cmpl);
+	#endif
+	#ifdef USE_REQ_POOL
+		hba_req_cache_free(phba,pReq);
+	#else
+		res_free_req_to_pool(phba->req_pool, pReq);
+	#endif
+	}
+#endif
+}
+#endif
+
+void HBA_GetControllerInfor(
+	IN MV_PVOID extension,
+	OUT PController_Infor pController
+	)
+{
+	pController->Base_Address = __ext_to_gen(extension)->desc->hba_desc->Base_Address;
+	pController->Vendor_Id = __ext_to_gen(extension)->desc->hba_desc->Vendor_Id;
+	pController->Device_Id = __ext_to_gen(extension)->desc->hba_desc->Device_Id;
+	pController->Revision_Id = __ext_to_gen(extension)->desc->hba_desc->Revision_Id;
+	pController->Pci_Device = __ext_to_gen(extension)->desc->hba_desc->dev;
+	pController->run_as_none_raid = __ext_to_gen(extension)->desc->hba_desc->RunAsNonRAID;
+}
+
+ void mv_hba_get_controller_pre(
+	 IN MV_PVOID extension,
+	 OUT PController_Infor pController
+	 )
+ {
+	 struct mv_adp_desc *hba_desc=(struct mv_adp_desc *)extension;
+	 pController->Base_Address = hba_desc->Base_Address;
+	 pController->Vendor_Id = hba_desc->Vendor_Id;
+	 pController->Device_Id = hba_desc->Device_Id;
+	 pController->Revision_Id = hba_desc->Revision_Id;
+ }
+
+MV_U32 HBA_ModuleGetResourceQuota(enum Resource_Type type, MV_U16 maxIo)
+{
+	MV_U32 size = 0;
+
+	if (type == RESOURCE_CACHED_MEMORY) {
+		/* Fixed memory */
+		size = sizeof(HBA_Extension);
+		//The reserved space is for 32 bit OS. Because OS will give us 4-byte aligned address.
+		//If we round this address with 8-byte aligned, it will cause buffer overlap. By: Walter
+		size += 8;
+		size = ROUNDING(size, 8);
+
+		size +=  RAID_Feature_GetResourceQuota(maxIo);
+		size = ROUNDING(size, 8);
+
+	#ifdef SUPPORT_TIMER
+		size += Timer_GetResourceQuota(maxIo);
+		size = ROUNDING(size, 8);
+	#endif
+
+	#ifdef SUPPORT_EVENT
+		size += sizeof(Driver_Event_Entry) * MAX_EVENTS;
+		size = ROUNDING(size, 8);
+		MV_ASSERT(size == ROUNDING(size, 8));
+	#endif /* SUPPORT_EVENT */
+	
+		size += sizeof(struct mv_lu) * MV_MAX_ID;
+		size = ROUNDING(size, 8);
+		MV_ASSERT(size == ROUNDING(size, 8));
+		
+	#if defined(SUPPORT_MODULE_CONSOLIDATE)
+			size += ModConsolid_GetResourceQuota(maxIo, MAX_DEVICE_SUPPORTED_PERFORMANCE, MAX_SG_ENTRY);
+	#endif
+
+	}
+	return size;
+}
+
+#ifdef SUPPORT_TASKLET
+void core_disable_ints(void * ext);
+void core_enable_ints(void * ext);
+MV_BOOLEAN Core_InterruptCheckIRQ(MV_PVOID This);
+void Core_InterruptHandleIRQ(MV_PVOID This);
+#ifdef RAID_DRIVER
+extern void RAID_HandleWaitingReq(PRAID_Core pRaidCore);
+#endif
+static void run_tasklet(PHBA_Extension   phba)
+{
+	struct mv_mod_desc *core_desc;
+
+	int retval = MV_FALSE;
+		
+	spin_lock_bh(&phba->desc->hba_desc->global_lock);
+	core_desc=__get_lowest_module(phba->desc->hba_desc);
+	       
+	retval = Core_InterruptCheckIRQ(core_desc->extension);
+       if(!retval)
+       	goto out;
+       
+	Core_InterruptHandleIRQ(core_desc->extension);
+		
+#ifdef RAID_DRIVER
+	/* Run stress on VD, hotplug HDD under expander, saw system hang.
+	 * Found requests are hold in RAID while Core Driver is free. So add push. */
+	if (!phba->RunAsNonRAID)// added by liang, if set NonRAID feature, below case should not happened
+	{
+		PRAID_Core pRaidCore;
+		pRaidCore = (PRAID_Core)HBA_GetModuleExtension(phba, MODULE_RAID);;
+		if(pRaidCore!= NULL)
+			RAID_HandleWaitingReq(pRaidCore);
+	}
+#endif		/* RAID_DRIVER */
+
+out:
+	spin_unlock_bh(&phba->desc->hba_desc->global_lock);
+       core_enable_ints(core_desc->extension);
+	
+}
+#endif
+
+void HBA_ModuleInitialize(MV_PVOID ext,
+				 MV_U32   size,
+				 MV_U16   max_io)
+{
+	PHBA_Extension phba = (PHBA_Extension)ext;
+	MV_PTR_INTEGER temp = (MV_PTR_INTEGER)phba + sizeof(HBA_Extension);
+	MV_U32 i;
+	MV_U32 sg_num;
+
+#ifdef SUPPORT_EVENT
+	PDriver_Event_Entry pEvent = NULL;
+#endif /* SUPPORT_EVENT */
+
+	phba->State    = DRIVER_STATUS_IDLE;
+	phba->Io_Count = 0;
+	phba->Ioctl_Io_Count = 0;
+	phba->Max_Io   = max_io;
+
+	init_completion(&phba->desc->hba_desc->cmpl);
+	init_completion(&phba->desc->hba_desc->ioctl_cmpl);
+
+	if (max_io > 1)
+		sg_num   = MAX_SG_ENTRY;
+	else
+		sg_num   = MAX_SG_ENTRY_REDUCED;
+
+#ifdef USE_NEW_SGVP
+	sg_num *= 2;
+#endif
+	MV_DPRINT(("check struct _MV_Request  %x.\n",sizeof(struct _MV_Request)));
+
+#ifdef  USE_REQ_POOL
+	phba->max_sg_count = sg_num;
+	MV_DPRINT(("HBA allocate max sg count %d.\n",phba->max_sg_count));
+	hba_req_cache_create(phba);
+	//BUG_ON(!phba->mv_mempool);
+	if(!phba->mv_mempool){
+		MV_PRINT("allcate cache failed\n");
+		alloc_uncached_failed(HBA_GetModuleExtension( ext, MODULE_HBA ));
+		return;
+		}
+#else
+	phba->req_pool = (MV_PVOID) res_reserve_req_pool(MODULE_HBA,
+							 max_io,
+							 sg_num);
+	//BUG_ON(NULL == phba->req_pool);
+	if(!phba->req_pool){
+		MV_PRINT("allcate cache failed\n");
+		alloc_uncached_failed(HBA_GetModuleExtension( ext, MODULE_HBA ));
+		return;
+		}
+#endif
+
+#ifdef SUPPORT_TASKLET
+	tasklet_init(&phba->desc->hba_desc->mv_tasklet,
+			(void (*)(unsigned long))run_tasklet, (unsigned long)phba);
+	spin_lock_init(&phba->desc->hba_desc->tasklet_count_lock);	
+#endif
+
+
+
+#ifdef SUPPORT_EVENT
+	MV_LIST_HEAD_INIT(&phba->Stored_Events);
+	MV_LIST_HEAD_INIT(&phba->Free_Events);
+	phba->Num_Stored_Events = 0;
+	phba->SequenceNumber = 0;	/* Event sequence number */
+
+	MV_ASSERT(sizeof(Driver_Event_Entry) ==
+		  ROUNDING(sizeof(Driver_Event_Entry), 8));
+	temp = ROUNDING(((MV_PTR_INTEGER) temp), 8);
+
+	for (i = 0; i < MAX_EVENTS; i++) {
+		pEvent = (PDriver_Event_Entry) temp;
+		List_AddTail(&pEvent->Queue_Pointer, &phba->Free_Events);
+		temp += sizeof(Driver_Event_Entry);
+	}
+#endif /* SUPPORT_EVENT */
+
+	for (i = 0; i < MV_MAX_TARGET_NUMBER; i++) {
+		phba->mv_unit[i].sdev = NULL;
+		phba->mv_unit[i].lun = 0xFFFF;
+		phba->mv_unit[i].id = i;
+		phba->mv_unit[i].target_id = 0xFFFF;
+	}
+	
+	phba->p_raid_feature = (MV_PVOID)temp;
+	RAID_Feature_Initialize(phba->p_raid_feature , max_io);
+	temp += RAID_Feature_GetResourceQuota(max_io);
+
+#if defined(SUPPORT_MODULE_CONSOLIDATE)
+	phba->PCC_Extension = (MV_PVOID)temp;
+	ModConsolid_InitializeExtension(phba->PCC_Extension, max_io, MAX_DEVICE_SUPPORTED_PERFORMANCE, MAX_SG_ENTRY);
+	temp += ModConsolid_GetResourceQuota(max_io, MAX_DEVICE_SUPPORTED_PERFORMANCE, MAX_SG_ENTRY);
+#endif
+
+#ifdef SUPPORT_TIMER
+	Timer_Initialize(phba, (MV_PU8)temp, max_io);
+#endif
+
+}
+
+
+void HBA_ModuleShutdown(MV_PVOID extension)
+{
+	PHBA_Extension hba = (PHBA_Extension) extension;
+	struct mv_adp_desc *hba_desc = hba->desc->hba_desc;
+
+#ifndef MV_BLK_IOCTL
+	mv_unregister_chdev(hba);
+#endif
+
+	if (DRIVER_STATUS_STARTED == hba->State) {
+#ifndef MV_VMK_ESX35
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+	if (hba->reg_enabled)
+	{
+		if (NULL != hba->reg_info)
+		{
+			if (NULL != hba->reg_info->data)
+				kfree(hba->reg_info->data);
+			remove_proc_entry(hba->proc_name, hba->proc_dir);
+		}   
+	}
+#endif
+		scsi_remove_host(hba_desc->hba_host);
+#endif
+		/* for non-raid driver, temporal disable Core_Shutdown req. */
+		hba_send_shutdown_req((MV_PVOID)hba);
+		while(hba->Io_Count)
+			HBA_SleepMillisecond(NULL,10);
+		free_irq(hba_desc->dev->irq, hba);
+		
+		if (hba->msi_enabled)
+			pci_disable_msi(hba->desc->hba_desc->dev);
+
+#ifndef MV_VMK_ESX35
+		scsi_host_put(hba_desc->hba_host);
+#endif
+		hba_desc->hba_host = NULL;
+	}
+#ifdef SUPPORT_TASKLET
+	tasklet_kill(&hba_desc->mv_tasklet);
+#endif
+
+#ifdef USE_REQ_POOL
+	hba_req_cache_destroy(hba);
+#else
+	res_release_req_pool(hba->req_pool);
+#endif
+
+#ifdef SUPPORT_TIMER
+	/* Stop the Timer */
+	Timer_Stop(hba);
+#endif
+
+	/*if hba state is shutdown ,mv_ioctl will return*/
+	hba->State = DRIVER_STATUS_SHUTDOWN;
+}
+
+#ifdef SUPPORT_EVENT
+MV_BOOLEAN add_event(IN MV_PVOID extension,
+			    IN MV_U32 eventID,
+			    IN MV_U16 deviceID,
+			    IN MV_U8 severityLevel,
+			    IN MV_U8 param_cnt,
+			    IN MV_PU32 params,
+			    IN MV_U8 SenseLength,
+			    IN MV_PU8 psense,
+			    IN MV_U16 trans_bit)
+{
+	struct hba_extension * hba = (struct hba_extension *) extension;
+	PDriver_Event_Entry pEvent;
+	static MV_U32 local_time=0;
+
+	if (param_cnt > MAX_EVENT_PARAMS)
+		return MV_FALSE;
+
+#if defined(__VMKLNX__) || defined(MV_VMK_ESX35)
+	local_time = ossw_get_time_in_sec();
+#else
+	local_time = ossw_get_local_time();
+#endif
+	if (List_Empty(&hba->Free_Events)) {
+		/* No free entry, we need to reuse the oldest entry from
+		 * Stored_Events.
+		 */
+		MV_ASSERT(!List_Empty(&hba->Stored_Events));
+		MV_ASSERT(hba->Num_Stored_Events == MAX_EVENTS);
+		pEvent = List_GetFirstEntry((&hba->Stored_Events), Driver_Event_Entry, Queue_Pointer);
+	} else {
+		pEvent = List_GetFirstEntry((&hba->Free_Events), Driver_Event_Entry, Queue_Pointer);
+		hba->Num_Stored_Events++;
+		MV_ASSERT(hba->Num_Stored_Events <= MAX_EVENTS);
+	}
+
+
+	pEvent->Event.Event.AdapterID = hba->desc->hba_desc->id;
+	pEvent->Event.Event.EventID = eventID;
+	pEvent->Event.Event.SequenceNo = hba->SequenceNumber++;
+	pEvent->Event.Event.Severity = severityLevel;
+	pEvent->Event.Event.DeviceID = deviceID;
+//	pEvent->Event.Param_Cnt = param_cnt;
+	pEvent->Event.Event.TimeStamp = local_time;
+
+	if (param_cnt > 0 && params != NULL)
+		MV_CopyMemory( (MV_PVOID)pEvent->Event.Event.Params, (MV_PVOID)params, param_cnt * 4 );
+	if(SenseLength>0&&psense!=NULL)
+	{
+		if(SenseLength>MAX_EVENT_SENSE_DATA_COUNT)
+			SenseLength=MAX_EVENT_SENSE_DATA_COUNT;
+		pEvent->Event.SenseDataLength=SenseLength;
+		MV_CopyMemory((MV_PVOID)pEvent->Event.SenseData, (MV_PVOID)psense, SenseLength);
+	}
+	else
+		pEvent->Event.SenseDataLength=0;
+
+	List_AddTail(&pEvent->Queue_Pointer, &hba->Stored_Events);
+	return MV_TRUE;
+}
+
+void get_event(MV_PVOID This, PMV_Request pReq)
+{
+	struct hba_extension * hba = (struct hba_extension *) This;
+	PEventRequest_V2 pEventReq = (PEventRequest_V2)pReq->Data_Buffer;
+	PDriver_Event_Entry pfirst_event;
+	MV_U8 count = 0;
+
+	pEventReq->Count = 0;
+
+	if ( hba->Num_Stored_Events > 0 )
+	{
+		MV_DASSERT( !List_Empty(&hba->Stored_Events) );
+		while (!List_Empty(&hba->Stored_Events) &&
+		       (count < MAX_EVENTS_RETURNED)) {
+			pfirst_event = List_GetFirstEntry((&hba->Stored_Events), Driver_Event_Entry, Queue_Pointer);
+			MV_CopyMemory(&pEventReq->Events[count],
+				      &pfirst_event->Event,
+				      sizeof(DriverEvent_V2));
+			hba->Num_Stored_Events--;
+			List_AddTail(&pfirst_event->Queue_Pointer,
+				      &hba->Free_Events );
+			count++;
+		}
+		pEventReq->Count = count;
+	}
+
+	pReq->Scsi_Status = REQ_STATUS_SUCCESS;
+	return;
+}
+#else /* SUPPORT_EVENT */
+MV_BOOLEAN add_event(IN MV_PVOID extension,
+				   IN MV_U32 eventID,
+				   IN MV_U16 deviceID,
+				   IN MV_U8 severityLevel,
+				   IN MV_U8 param_cnt,
+			    	   IN MV_PU32 params,
+			          IN MV_U8 SenseLength,
+			          IN MV_PU8 psense){}
+
+void get_event(MV_PVOID This, PMV_Request pReq) {}
+#endif /* SUPPORT_EVENT */
+
+void HBA_ModuleNotification(MV_PVOID This, enum Module_Event event, struct mod_notif_param *event_param)
+{
+	/* "This" passed in is not hba extension, it is caller's extension */
+	/* has to find own extension like the implementation in HBA */
+	struct hba_extension * hba = (struct hba_extension *)HBA_GetModuleExtension(This, MODULE_HBA);
+	// MV_DPRINT(("Enter HBA_ModuleNotification event %x\n",event));
+	switch (event) {
+	case EVENT_LOG_GENERATED:
+		add_event(hba, event_param->event_id,
+			  event_param->dev_id, event_param->severity_lvl,
+			  event_param->param_count, (MV_PU32) event_param->p_param,
+			  event_param->sense_length, (MV_PU8)event_param->p_sense,
+			  event_param->tran_hex_bit);
+		break;
+	case EVENT_DEVICE_ARRIVAL:
+#ifdef SUPPORT_MODULE_CONSOLIDATE
+		ModConsolid_SetDevice(hba->PCC_Extension, event_param);
+#endif		/* SUPPORT_MODULE_CONSOLIDATE */
+	case EVENT_DEVICE_REMOVAL:
+		if (hba->first_scan==0) {
+			hba_msg_insert(hba,
+				       event,
+#ifdef SUPPORT_MUL_LUN
+				       (event_param == NULL)?0:(event_param->lo|((event_param->hi<<16)&0xffff0000)) );
+#else
+				       (event_param == NULL)?0: event_param->lo);
+#endif
+		}
+		break;
+
+#if defined(SUPPORT_MODULE_CONSOLIDATE) && defined(CACHE_MODULE_SUPPORT)
+	case EVENT_DEVICE_CACHE_MODE_CHANGED:
+		ModConsolid_SetDevice(hba->PCC_Extension, event_param);
+		break;
+#endif		/* SUPPORT_MODULE_CONSOLIDATE */
+
+
+	default:
+		break;
+	}
+}
+
+
+int HBA_GetResource(void *extension,
+		    enum Resource_Type type,
+		    MV_U32  size,
+		    Assigned_Uncached_Memory *dma_res)
+{
+	struct mv_mod_res *mod_res;
+	struct mv_mod_desc *mod_desc = __ext_to_gen(extension)->desc;
+	if(!mod_desc){
+		MV_DPRINT(("mod decript is destried.\n"));
+	}
+	mod_res = hba_mem_alloc(sizeof(struct mv_mod_res),MV_FALSE);
+	if (NULL == mod_res) {
+		MV_PRINT("unable to allocate memory for module %d resource management.\n", mod_desc->module_id);
+		return -1;
+	}
+
+	memset(mod_res, 0, sizeof(struct mv_mod_res));
+	mod_res->size = size;
+	mod_res->type = type;
+	switch (type) {
+	case RESOURCE_UNCACHED_MEMORY :
+		if (__alloc_consistent_mem(mod_res, mod_desc->hba_desc->dev)) {
+			MV_PRINT("unable to allocate 0x%x uncached mem.\n", size);
+			hba_mem_free(mod_res,sizeof(struct mv_mod_res),MV_FALSE);
+			return -1;
+		}
+		List_Add(&mod_res->res_entry, &mod_desc->res_list);
+		memset(mod_res->virt_addr, 0, size);
+		dma_res->Virtual_Address  = mod_res->virt_addr;
+		dma_res->Physical_Address = mod_res->bus_addr;
+		dma_res->Byte_Size        = size;
+		break;
+	case RESOURCE_CACHED_MEMORY :
+	default:
+		hba_mem_free(mod_res,sizeof(struct mv_mod_res),MV_FALSE);
+		MV_PRINT("unknown resource type %d.\n", type);
+		return -1;
+	}
+	return 0;
+}
+
+int hba_get_uncache_resource(void *extension,
+		    MV_U32  size,
+		    Assigned_Uncached_Memory *dma_res)
+{
+		return HBA_GetResource(extension, RESOURCE_UNCACHED_MEMORY, size,dma_res);
+}
+
+
+void alloc_uncached_failed(void *extension)
+{	
+	struct mv_mod_desc *mod_desc = __ext_to_gen(extension)->desc;
+	mod_desc->hba_desc->alloc_uncahemem_failed = MV_TRUE;
+}
+
+void * os_malloc_mem(void *extension, MV_U32 size, MV_U8 mem_type, MV_U16 alignment, MV_PHYSICAL_ADDR *phy)
+{
+	Assigned_Uncached_Memory dma_res;
+	
+	size = ROUNDING(size, alignment);
+	if(HBA_GetResource(extension, mem_type, size, &dma_res))
+		return NULL;
+	phy->value = dma_res.Physical_Address.value;
+	return dma_res.Virtual_Address;
+}
+
+MV_VOID
+HBA_GetNextModuleSendFunction(
+	IN MV_PVOID self_extension,
+	OUT MV_PVOID *next_extension,
+	OUT MV_VOID (**next_function)(MV_PVOID , PMV_Request)
+	)
+
+ {
+	   *(next_extension) = __ext_to_gen(self_extension)->desc->child->extension;
+	   *(next_function) =  __ext_to_gen(self_extension)->desc->child->ops->module_sendrequest;
+ }
+
+MV_VOID
+HBA_GetUpperModuleNotificationFunction(
+	IN MV_PVOID self_extension,
+	OUT MV_PVOID *upper_extension,
+	OUT MV_VOID (**upper_notificaton_function)(MV_PVOID,
+						   enum Module_Event,
+						   struct mod_notif_param *))
+{
+	*(upper_extension) = __ext_to_gen(self_extension)->desc->parent->extension;
+	*(upper_notificaton_function) = __ext_to_gen(self_extension)->desc->parent->ops->module_notification;
+}
+
+
+void hba_notify_upper_md(
+			IN MV_PVOID extension,
+			  enum Module_Event notifyEvent,
+			  MV_PVOID event_param)
+{
+	__ext_to_gen(extension)->desc->parent->ops->module_notification(
+                                            __ext_to_gen(extension)->desc->parent->extension,
+					    					notifyEvent,
+					    					event_param);
+}
+
+/* modified by Ying Chu, any suggestions will be thankful. */
+#ifndef CONFIG_X86_64
+#define ossw_mdelay(x) ((__builtin_constant_p(x) && (x)<5)? ossw_udelay((x)*1000):\
+	({unsigned long __ms=(x); while (__ms--) ossw_udelay(1000);}))
+#else
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,13))
+	#ifndef CONFIG_ARM
+#define ossw_mdelay(x) ((__builtin_constant_p(x) && (x)<5)? ossw_udelay((x)*1000):\
+	({unsigned long __ms=(x); while (__ms--){ if(__ms%2000) {touch_nmi_watchdog();touch_softlockup_watchdog();} ossw_udelay(1000);}}))
+	#else
+#define ossw_mdelay(x) ((__builtin_constant_p(x) && (x)<5)? ossw_udelay((x)*1000):\
+	({unsigned long __ms=(x); while (__ms--){ if(__ms%2000) {touch_nmi_watchdog();} ossw_udelay(1000);}}))
+	#endif
+
+#else
+#define ossw_mdelay(x) ((__builtin_constant_p(x) && (x)<5)? ossw_udelay((x)*1000):\
+	({unsigned long __ms=(x); while (__ms--){ if(__ms%2000) touch_nmi_watchdog(); ossw_udelay(1000);}}))
+#endif
+#endif
+
+//reset nmi watchdog before delay
+static void mv_touch_nmi_watchdog(void)
+{
+#ifdef CONFIG_X86_64
+	touch_nmi_watchdog();
+#endif /* CONFIG_X86_64*/
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13)
+#ifndef CONFIG_ARM
+	touch_softlockup_watchdog();
+#endif
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 13) */
+}
+
+void HBA_SleepMillisecond(MV_PVOID ext, MV_U32 msec)
+{
+	MV_U32 	tmp=0;
+	MV_U32	mod_msec=2000;
+	if (in_interrupt() || irqs_disabled()){
+		mv_touch_nmi_watchdog();
+		if (msec<=mod_msec)
+			ossw_mdelay(msec);
+		else {
+			for (tmp=0;tmp<msec/mod_msec;tmp++) {
+				ossw_mdelay(mod_msec);
+				mv_touch_nmi_watchdog();
+			}
+			if (msec%mod_msec)
+				ossw_mdelay(msec%mod_msec);
+		}
+		mv_touch_nmi_watchdog();
+	} else {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout( msec );
+	}
+}
+
+MV_PVOID hba_mem_alloc(MV_U32 size,MV_BOOLEAN sg_use)
+{
+	MV_PVOID mem_pool;
+
+	/*As default, vmalloc can max alloc 128M mem, but  can't use in interrupt and irq disabled
+	  context.kmalloc can max alloc 128k mem , sg map and <16K use kmalloc*/
+	if(sg_use){
+		if(size > (128*1024 -16))
+			WARN_ON(1);
+	}
+	if( (size <= 4*PAGE_SIZE)||(sg_use))
+		mem_pool = kmalloc(size,GFP_ATOMIC);
+	else if ((size > 4*PAGE_SIZE)&&(!in_interrupt())&&(!irqs_disabled()))
+		mem_pool = vmalloc(size);
+	else
+		mem_pool = kmalloc(size,GFP_ATOMIC);
+	//BUG_ON(!mem_pool);
+
+	return mem_pool;
+}
+
+MV_VOID hba_mem_free(MV_PVOID mem_pool, MV_U32 size,MV_BOOLEAN sg_use)
+{
+	if( (size <= 4*PAGE_SIZE)||(sg_use))
+		kfree(mem_pool);
+	else if( (size > 4*PAGE_SIZE)&&(!in_interrupt())&&(!irqs_disabled()))
+		vfree(mem_pool);
+	else
+		kfree(mem_pool);
+}
+
+void mvs_hexdump(u32 size, u8 *data, u32 baseaddr, const char *prefix)
+{
+#ifdef MV_DEBUG
+	u32 i;
+	u32 run;
+	u32 offset;
+
+	offset = 0;
+	printk("%s : \n", prefix);
+	while (size) {
+		printk("%08X : ", baseaddr + offset);
+		if (size >= 16)
+			run = 16;
+		else
+			run = size;
+		size -= run;
+		for (i = 0; i < 16; i++) {
+			if (i < run)
+				printk("%02X ", (u32)data[i]);
+			else
+				printk("   ");
+		}
+		printk(": ");
+		for (i = 0; i < run; i++)
+			printk("%c",
+				isalnum(data[i]) ? data[i] : '.');
+		printk("\n");
+		data = &data[16];
+		offset += run;
+	}
+	printk("\n");
+#endif
+}
+
+MV_BOOLEAN HBA_CheckIsFlorence(MV_PVOID ext)
+{
+	struct hba_extension *phba = (struct hba_extension *)HBA_GetModuleExtension(ext, MODULE_HBA);
+	MV_U16 device_id;
+	device_id = phba->Device_Id;
+	return (device_id == DEVICE_ID_948F ? MV_TRUE : MV_FALSE);
+}
+
+MV_U32 hba_parse_ata_protocol(struct scsi_cmnd *scmd)
+{
+	MV_U8 protocol = 0, t_length = 0, t_dir = 0;
+	MV_U32 cmd_flag =0;
+
+	protocol = (scmd->cmnd[1]>> 1) & 0x0F;
+	if(protocol== HRST || protocol==SRST){
+		return cmd_flag;
+	}
+	
+	t_length = scmd->cmnd[2] & 0x03;
+	t_dir = (scmd->cmnd[2] >> 3) & 0x01;
+	
+	if (t_length == 0){
+		cmd_flag = CMD_FLAG_NON_DATA;
+	}else {
+		if (t_dir == 0)
+			cmd_flag = CMD_FLAG_DATA_OUT;
+		else
+			cmd_flag = CMD_FLAG_DATA_IN;
+	}
+	switch (protocol) {
+	case NON_DATA:
+		cmd_flag |= CMD_FLAG_NON_DATA;
+		break;
+	case PIO_DATA_IN:
+		cmd_flag |= CMD_FLAG_PIO;
+		if (!(cmd_flag & CMD_FLAG_DATA_IN))
+			cmd_flag |= CMD_FLAG_DATA_IN;
+		break;
+	case PIO_DATA_OUT:
+		cmd_flag |= CMD_FLAG_PIO;
+		if (!(cmd_flag & CMD_FLAG_DATA_OUT))
+			cmd_flag |= CMD_FLAG_DATA_OUT;
+		break;
+	case DMA:
+		cmd_flag |= CMD_FLAG_DMA;
+		break;
+	case DMA_QUEUED:
+		cmd_flag |= (CMD_FLAG_DMA | CMD_FLAG_TCQ);
+		break;
+	case DEVICE_DIAGNOSTIC:
+	case DEVICE_RESET:
+		/* Do nothing*/
+		break;
+	case UDMA_DATA_IN:
+		cmd_flag |= CMD_FLAG_DMA;
+		if (!(cmd_flag & CMD_FLAG_DATA_IN))
+			cmd_flag |= CMD_FLAG_DATA_IN;
+		break;
+	case UDMA_DATA_OUT:
+		cmd_flag |= CMD_FLAG_DMA;
+		if (!(cmd_flag & CMD_FLAG_DATA_OUT))
+			cmd_flag |= CMD_FLAG_DATA_OUT;
+		break;
+	case FPDMA:
+		cmd_flag |= (CMD_FLAG_DMA | CMD_FLAG_NCQ);
+		break;
+	case RTN_INFO:
+		break;
+	default:
+		MV_PRINT("Unsupported ATA Protocol = 0x%x\n", protocol);
+		break;
+	}
+	return cmd_flag;
+}
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/hba_exp.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_exp.h
--- linux-3.10.69/drivers/scsi/mv/hba_exp.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_exp.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,242 @@
+#ifndef __HBA_EXPOSE_H__
+#define __HBA_EXPOSE_H__
+#include "hba_header.h"
+
+typedef struct _Assigned_Uncached_Memory
+{
+	MV_PVOID		Virtual_Address;
+	MV_PHYSICAL_ADDR	Physical_Address;
+	MV_U32			Byte_Size;
+	MV_U32			Reserved0;
+} Assigned_Uncached_Memory, *PAssigned_Uncached_Memory;
+
+typedef struct _Controller_Infor
+{
+	MV_LPVOID *Base_Address;
+	MV_PVOID Pci_Device;
+	MV_U16 Vendor_Id;
+	MV_U16 Device_Id;
+	MV_U8 Revision_Id;
+	MV_U8 run_as_none_raid;
+	MV_U8 Reserved[2];
+} Controller_Infor, *PController_Infor;
+
+typedef struct _SCSI_PASS_THROUGH_DIRECT {
+	unsigned short Length;
+	unsigned char  ScsiStatus;
+	unsigned char  PathId;
+	unsigned char  TargetId;
+	unsigned char  Lun;
+	unsigned char  CdbLength;
+	unsigned char  SenseInfoLength;
+	unsigned char  DataIn;
+	unsigned long  DataTransferLength;
+	unsigned long  TimeOutValue;
+	void __user    *DataBuffer;
+	unsigned long  SenseInfoOffset;
+	unsigned char  Cdb[16];
+}SCSI_PASS_THROUGH_DIRECT, *PSCSI_PASS_THROUGH_DIRECT,SCSI_REQUEST_BLOCK, *PSCSI_REQUEST_BLOCK;
+
+/*ATA Protocols*/
+enum _ATA_PROTOCOL {
+	HRST 			= 0x00,
+	SRST  			= 0x01,
+ 	BUS_IDLE 		= 0x02,
+	NON_DATA 		= 0x03,
+	PIO_DATA_IN 	= 0x04,
+	PIO_DATA_OUT 	= 0x05,     
+	DMA			= 0x06, 
+	DMA_QUEUED	= 0x07,
+	DEVICE_DIAGNOSTIC	= 0x08,
+	DEVICE_RESET		= 0x09,
+	UDMA_DATA_IN		= 0x0A,
+	UDMA_DATA_OUT	= 0x0B,
+	FPDMA				= 0x0C,
+	RTN_INFO			= 0x0F,
+};
+
+#include "com_event_struct.h"
+#include "com_event_define.h"
+#include "com_event_define_ext.h"
+#define MSG_QUEUE_DEPTH	2048
+
+#ifdef SUPPORT_EVENT
+/* wrapper for DriverEvent, needed to implement queue */
+typedef struct _Driver_Event_Entry
+{
+	List_Head Queue_Pointer;
+	DriverEvent_V2 Event;
+} Driver_Event_Entry, *PDriver_Event_Entry;
+#endif /* SUPPORT_EVENT */
+
+#ifdef SUPPORT_MODULE_CONSOLIDATE
+void ModConsolid_ChangeConsSetting(MV_PVOID p_module, MV_BOOLEAN f_enable);
+#endif		/* SUPPORT_MODULE_CONSOLIDATE */
+
+MV_VOID
+HBA_GetNextModuleSendFunction(
+	IN MV_PVOID self_extension,
+	OUT MV_PVOID *next_extension,
+	OUT MV_VOID (**next_function)(MV_PVOID , PMV_Request)
+	);
+
+MV_VOID
+HBA_GetUpperModuleNotificationFunction(
+	IN MV_PVOID self_extension,
+	OUT MV_PVOID *upper_extension,
+	OUT MV_VOID (**upper_notificaton_function)(MV_PVOID,
+						   enum Module_Event,
+						   struct mod_notif_param *));
+
+void hba_notify_upper_md(
+			IN MV_PVOID extension,
+			  enum Module_Event notifyEvent,
+			  MV_PVOID event_param);
+
+
+#define HBA_SleepMicrosecond(_x, _y) ossw_udelay(_y)
+#define HBA_GetTimeInSecond          ossw_get_time_in_sec
+#define HBA_GetMillisecondInDay      ossw_get_msec_of_time
+
+MV_BOOLEAN HBA_CheckIsFlorence(MV_PVOID ext);
+
+/*read pci config space*/
+MV_U32 MV_PCI_READ_DWORD(MV_PVOID This, MV_U8 reg);
+MV_VOID  MV_PCI_WRITE_DWORD(MV_PVOID This, MV_U32 val, MV_U8 reg);
+void HBA_ModuleStarted(MV_PVOID extension);
+
+
+void HBA_GetControllerInfor(
+	IN MV_PVOID extension,
+	OUT PController_Infor pController
+	);
+
+
+/* map bus addr in sg entry into cpu addr (access via. Data_Buffer) */
+void hba_map_sg_to_buffer(void *preq);
+void hba_unmap_sg_to_buffer(void *preq);
+
+MV_BOOLEAN hba_test_enabled(void *ext);
+MV_BOOLEAN hba_msi_enabled(void *ext);
+
+static inline MV_BOOLEAN
+HBA_ModuleGetPhysicalAddress(MV_PVOID Module,
+			     MV_PVOID Virtual,
+			     MV_PVOID TranslationContext,
+			     MV_PU64 PhysicalAddress,
+			     MV_PU32 Length)
+{
+	panic("not supposed to be called.\n");
+	return MV_FALSE;
+};
+
+int HBA_GetResource(void *extension,
+		    enum Resource_Type type,
+		    MV_U32  size,
+		    Assigned_Uncached_Memory *dma_res);
+
+int hba_get_uncache_resource(void *extension,
+		    MV_U32  size,
+		    Assigned_Uncached_Memory *dma_res);
+
+void alloc_uncached_failed(void *extension);
+
+MV_PVOID HBA_GetModuleExtension(MV_PVOID ext, MV_U32 mod_id);
+
+MV_PVOID sgd_kmap(sgd_t  *sg);
+MV_VOID sgd_kunmap(sgd_t  *sg,MV_PVOID mapped_addr);
+
+MV_BOOLEAN __is_scsi_cmd_simulated(MV_U8 cmd_type);
+MV_BOOLEAN __is_scsi_cmd_rcv_snd_diag(MV_U8 cmd_type);
+
+#ifdef SUPPORT_PASS_THROUGH_DIRECT
+void HBARequestCallback(MV_PVOID This,PMV_Request pReq);
+#endif
+void HBA_SleepMillisecond(MV_PVOID ext, MV_U32 msec);
+void HBA_ModuleInitialize(MV_PVOID ext,
+				 MV_U32   size,
+				 MV_U16   max_io);
+void HBA_ModuleShutdown(MV_PVOID extension);
+void HBA_ModuleNotification(MV_PVOID This,
+			     enum Module_Event event,
+			     struct mod_notif_param *event_param);
+
+MV_U32 HBA_ModuleGetResourceQuota(enum Resource_Type type, MV_U16 maxIo);
+void HBA_ModuleStart(MV_PVOID extension);
+void HBA_ModuleSendRequest(MV_PVOID this, PMV_Request req);
+
+
+MV_U16 Timer_AddRequest(
+	IN MV_PVOID extension,
+	IN MV_U32 time_unit,
+	IN MV_VOID (*routine) (MV_PVOID, MV_PVOID),
+	IN MV_PVOID context1,
+	IN MV_PVOID context2
+	);
+
+#ifdef SUPPORT_SMALL_TIMER
+MV_U16 Timer_AddSmallRequest(
+	IN MV_PVOID extension,
+	IN MV_U32 time_unit,
+	IN MV_VOID (*routine) (MV_PVOID, MV_PVOID),
+	IN MV_PVOID context1,
+	IN MV_PVOID context2
+	);
+#else
+#define Timer_AddSmallRequest Timer_AddRequest
+#endif
+
+
+void Timer_CancelRequest(
+	IN MV_PVOID extension,
+	IN MV_U16 request_index
+	);
+
+void Timer_CheckRequest(
+	IN MV_PVOID extension
+	);
+
+MV_U32 Timer_GetResourceQuota(MV_U16 maxIo);
+void Timer_Initialize(
+	IN  MV_PVOID This,
+	IN MV_PU8 pool,
+	IN MV_U16 max_io
+	);
+void Timer_Stop(MV_PVOID This);
+
+void * os_malloc_mem(void *extension, MV_U32 size, MV_U8 mem_type, MV_U16 alignment, MV_PHYSICAL_ADDR *phy);
+MV_VOID core_push_queues(MV_PVOID core_p);
+#define NO_CURRENT_TIMER		0xffff
+
+void mv_hba_get_controller_pre(
+	IN MV_PVOID extension,
+	OUT PController_Infor pController
+	);
+
+MV_BOOLEAN add_event(IN MV_PVOID extension,
+			    IN MV_U32 eventID,
+			    IN MV_U16 deviceID,
+			    IN MV_U8 severityLevel,
+			    IN MV_U8 param_cnt,
+			    IN MV_PU32 params,
+			    IN MV_U8 SenseLength,
+			    IN MV_PU8 psense,
+			    IN MV_U16 trans_bit);
+
+void get_event(MV_PVOID This, PMV_Request pReq);
+MV_PVOID hba_mem_alloc(MV_U32 size,MV_BOOLEAN sg_use);
+MV_VOID hba_mem_free(MV_PVOID mem_pool, MV_U32 size,MV_BOOLEAN sg_use);
+void mvs_hexdump(u32 size, u8 *data, u32 baseaddr, const char *prefix);
+
+#ifdef SUPPORT_IO_DELAY
+MV_U16 hba_get_io_delay_value(void);
+#endif
+MV_U32 hba_parse_ata_protocol(struct scsi_cmnd *scmd);
+#if (defined(SUPPORT_DIF) || defined(SUPPORT_DIX)) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+extern unsigned int mv_prot_mask;
+extern unsigned char mv_prot_guard;
+#endif
+MV_U16 mv_get_register_mode(void);
+
+#endif
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/hba_header.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_header.h
--- linux-3.10.69/drivers/scsi/mv/hba_header.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_header.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,21 @@
+#if !defined(MV_INCLUDE_H)
+#define MV_INCLUDE_H
+#include "mv_config.h"
+#include "mv_os.h"
+#include "com_type.h"
+#include "com_u64.h"
+#include "com_util.h"
+#include "com_roll.h"
+#include "com_list.h"
+#include "com_dbg.h"
+#include "com_tag.h"
+#include "com_mod_mgmt.h"
+#include "com_struct.h"
+#include "com_scsi.h"
+#include "com_api.h"
+#include "com_extern.h"
+#include "hba_inter.h"
+#include "hba_exp.h"
+
+#endif /* MV_INCLUDE_H */
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/hba_inter.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_inter.h
--- linux-3.10.69/drivers/scsi/mv/hba_inter.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_inter.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,157 @@
+#ifndef HBA_INTERNAL_H
+#define HBA_INTERNAL_H
+#include "hba_header.h"
+#include "com_tag.h"
+#ifdef SUPPORT_TIMER
+typedef struct _Timer_Request
+{
+	List_Head Queue_Pointer;
+	MV_PVOID Context1;
+	MV_PVOID Context2;
+	MV_PVOID Reserved0;
+	MV_VOID (*Routine) (MV_PVOID, MV_PVOID);
+	MV_BOOLEAN Valid;
+	MV_U8 Reserved1[7];
+	MV_U64 Time_Stamp;		// when this requested function wants to be called
+} Timer_Request, *PTimer_Request;
+
+
+typedef struct _Timer_Module
+{
+	/* Because we are supporting performance mode, */
+	/* we cannot use array for running request */
+	/*	PTimer_Request Running_Requests[MAX_TIMER_REQUEST]; */
+	/* Use pointer, remember to allocate continuous memory for it */
+	PTimer_Request *Running_Requests;
+	MV_U16 Timer_Request_Number;
+	MV_U8 Reserved0[6];
+	Tag_Stack Tag_Pool;
+	MV_U64 Time_Stamp;		// current time
+} Timer_Module, *PTimer_Module;
+
+#endif
+
+enum hba_info_flags {
+	MVF_MSI		= (1U << 0),	/* MSI is enabled */
+#ifdef SUPPORT_TARGET
+	MVF_TARGET_MODE_ENABLE	= (1U << 1),	/* Target Mode Enable */
+	MVF_HOST_SHUTTING_DOWN	= (1U << 2),	/* Shutting down HBA */
+#endif
+};
+
+/* Per logical unit */
+struct mv_lu
+{
+	MV_U16 id; //device->ID
+	MV_U16 lun;
+	MV_U16 reserved0[2];	
+	MV_U16 target_id;	
+	struct scsi_device	*sdev;		/* attached SCSI device */
+};
+
+typedef struct hba_extension
+{
+	/* self-descriptor */
+	struct mv_mod_desc *desc;
+
+	void    *req_pool;
+	/* Device extention */
+	MV_PVOID Device_Extension;
+	/* System resource */
+	MV_LPVOID Base_Address[MAX_BASE_ADDRESS];
+	MV_U32 State;
+	MV_BOOLEAN Is_Dump;		/* Is OS during hibernation or crash dump? */
+	MV_U32 Io_Count;			/* Outstanding requests count */
+	MV_U32	hba_flags;
+	
+	/* Adapter information */
+	MV_U8 Adapter_Bus_Number;
+	MV_U8 Adapter_Device_Number;
+	MV_U16 Vendor_Id;
+	MV_U16 Device_Id;
+	MV_U8 Revision_Id;
+	MV_U8 RunAsNonRAID;		/* initialize it before InitModules is called */
+	MV_BOOLEAN msi_enabled;
+	MV_BOOLEAN test_enabled;
+	MV_U16 RaidMode;			/*raid mode*/
+	MV_U16 Sub_Vendor_Id;
+	MV_U16 Sub_System_Id;
+
+	MV_U8 pcie_max_lnk_spd;	/* PCIe Max Supported Link Speed */
+	MV_U8 pcie_max_bus_wdth;	/* PCIe Max Supported Bus Width */
+	MV_U8 pcie_neg_lnk_spd;		/* PCIe Negotiated Link Speed */
+	MV_U8 pcie_neg_bus_wdth;	/* PCIe Negotiated Bus Width */
+	
+	MV_U8 reserved1[2];
+	MV_U32 MvAdapterSignature;
+#ifdef SUPPORT_ESATA
+	MV_U8 eSATAPortCount;
+	MV_U8 reserved3[7];
+
+	MV_U8 eSATAPort[8];
+#endif
+	/* Timer module */
+	Timer_Module TimerModule;
+	MV_PVOID			uncached_virtual;
+	MV_PHYSICAL_ADDR	uncached_physical;
+	MV_U32				uncached_quota;
+	MV_U32				scsiport_allocated_uncached;
+	MV_U16				Max_Io;
+	MV_U16				waiting_cb_cnt;
+
+	/* Request queue */
+#ifndef USE_SRBEXT_AS_REQ
+	List_Head Free_Request;		/* Free MV_Request queue */
+#endif
+	List_Head Waiting_Request;	/* MV_Request waiting queue */
+
+#ifdef USE_REQ_POOL
+	MV_U32 max_sg_count;
+	mempool_t * mv_mempool;
+	
+	 kmem_cache_t  *mv_request_cache;
+	 kmem_cache_t  *mv_request_sg_cache;
+	
+	char cache_name[CACHE_NAME_LEN];
+	char sg_name[CACHE_NAME_LEN];
+
+#ifdef HAVE_HW_COMPLIANT_SG
+    char sgpool_name[CACHE_NAME_LEN];
+    struct pci_pool *mv_sgtable_pool;
+#endif
+#endif
+
+#ifdef SUPPORT_EVENT
+	List_Head Stored_Events;
+	List_Head Free_Events;
+	MV_U32	SequenceNumber;
+	MV_U8 Num_Stored_Events;
+	MV_U8 Reserved2[3];	/* make the structure 8 byte aligned */
+#endif
+
+	struct mv_lu mv_unit[MV_MAX_TARGET_NUMBER];
+
+	MV_U8 FlashBad;
+	MV_U8 FlashErase;
+	MV_U8 Ioctl_Io_Count;
+	MV_U8 first_scan;
+
+#ifdef SUPPORT_MODULE_CONSOLIDATE
+   	MV_PVOID PCC_Extension;
+#endif
+	MV_PVOID		pNextExtension;
+	MV_VOID 		(*pNextFunction)(MV_PVOID , PMV_Request);
+	MV_PVOID p_raid_feature;
+
+    struct proc_dir_entry *proc_dir;
+    struct proc_dir_entry *reg_info;
+    char proc_name[15];
+	MV_BOOLEAN reg_enabled;
+}HBA_Extension, *PHBA_Extension;
+
+#define DRIVER_STATUS_IDLE      1    /* The first status */
+#define DRIVER_STATUS_STARTING  2    /* Begin to start all modules */
+#define DRIVER_STATUS_STARTED   3    /* All modules are all settled. */
+#define DRIVER_STATUS_SHUTDOWN   4   /* All modules shutdown. */
+
+#endif /* HBA_INTERNAL_H */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/hba_mod.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_mod.c
--- linux-3.10.69/drivers/scsi/mv/hba_mod.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_mod.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,788 @@
+#include "hba_header.h"
+#include "linux_main.h"
+#include "linux_iface.h"
+#include "hba_mod.h"
+#include "hba_timer.h"
+#include "hba_api.h"
+#if defined(SUPPORT_MODULE_CONSOLIDATE)
+#include "cc.h"
+#endif		/* SUPPORT_MODULE_CONSOLIDATE */
+
+static MV_LIST_HEAD(mv_online_adapter_list);
+
+int __mv_get_adapter_count(void)
+{
+	struct mv_adp_desc *p;
+	int i = 0;
+	LIST_FOR_EACH_ENTRY(p, &mv_online_adapter_list, hba_entry)
+	i++;
+
+	return i;
+}
+
+struct mv_adp_desc *__dev_to_desc(struct pci_dev *dev)
+{
+	struct mv_adp_desc *p;
+
+	LIST_FOR_EACH_ENTRY(p, &mv_online_adapter_list, hba_entry)
+	if (p->dev == dev)
+		return p;
+	return NULL;
+}
+
+MV_PVOID *mv_get_hba_extension(struct mv_adp_desc *hba_desc)
+{
+	struct mv_mod_desc *p;
+
+	LIST_FOR_EACH_ENTRY(p, &hba_desc->online_module_list, mod_entry)
+		if (MODULE_HBA == p->module_id)
+			return p->extension;
+	return NULL;
+}
+
+static inline void __mv_release_hba(struct mv_adp_desc *hba_desc)
+{
+	struct mv_mod_desc *mod_desc, *p;
+
+	LIST_FOR_EACH_ENTRY_SAFE(mod_desc,
+				p,
+				&hba_desc->online_module_list,
+				mod_entry) {
+		List_Del(&mod_desc->mod_entry);
+		hba_mem_free(mod_desc,sizeof(struct mv_mod_desc),MV_FALSE);
+	}
+
+	List_Del(&hba_desc->hba_entry);
+	hba_mem_free(hba_desc,sizeof(struct mv_adp_desc),MV_FALSE);
+}
+
+#if defined(__VMKLNX__) || defined(MV_VMK_ESX35) 
+extern  struct mv_adp_desc *gl_hba_desc;
+#endif
+static struct mv_adp_desc *mv_hba_init_modmm(struct pci_dev *dev)
+{
+	struct mv_adp_desc *hba_desc;
+
+	hba_desc = hba_mem_alloc(sizeof(struct mv_adp_desc),MV_FALSE);
+	if (NULL == hba_desc) {
+		MV_PRINT("Unable to get memory at hba init.\n");
+		return NULL;
+	}
+#if defined(__VMKLNX__) || defined(MV_VMK_ESX35) 
+	gl_hba_desc = hba_desc;
+#endif
+	memset(hba_desc, 0, sizeof(struct mv_adp_desc));
+	hba_desc->dev = dev;
+	MV_LIST_HEAD_INIT(&hba_desc->online_module_list);
+	List_Add(&hba_desc->hba_entry, &mv_online_adapter_list);
+
+	return hba_desc;
+}
+
+static void mv_hba_release_modmm(struct pci_dev *dev)
+{
+	struct mv_adp_desc *hba_desc;
+
+	hba_desc = __dev_to_desc(dev);
+
+	if (hba_desc)
+		__mv_release_hba(hba_desc);
+	else
+		MV_PRINT("Weired! dev %p unassociated with any desc.\n", dev);
+}
+
+static inline struct mv_mod_desc *__alloc_mod_desc(void)
+{
+	struct mv_mod_desc *mod_desc;
+
+	mod_desc = hba_mem_alloc(sizeof(struct mv_mod_desc),MV_FALSE);
+	if (mod_desc)
+		memset(mod_desc, 0, sizeof(struct mv_mod_desc));
+	return mod_desc;
+}
+
+struct mv_module_ops *mv_hba_register_module(void)
+{
+	static struct mv_module_ops hba_module_interface = {
+		.module_id              = MODULE_HBA,
+		.get_res_desc           = HBA_ModuleGetResourceQuota,
+		.module_initialize      = HBA_ModuleInitialize,
+		.module_start           = HBA_ModuleStart,
+		.module_stop            = HBA_ModuleShutdown,
+		.module_notification    = HBA_ModuleNotification,
+		.module_sendrequest     = HBA_ModuleSendRequest,
+	};
+
+	return &hba_module_interface;
+}
+
+
+static int register_online_modules(struct mv_adp_desc *hba_desc)
+{
+	struct mv_mod_desc *mod_desc, *prev;
+	struct mv_module_ops *ops;
+
+	/*
+	 * iterate through online_module_list manually , from the lowest(CORE)
+	 * to the highest layer (HBA)
+	 */
+	hba_desc->running_mod_num = 0;
+	/* CORE */
+	ops = mv_core_register_module();
+	if (NULL == ops) {
+		MV_PRINT("No core no life.\n");
+		return -1;
+	}
+	mod_desc = __alloc_mod_desc();
+	if (NULL == mod_desc)
+		goto disaster;
+
+	mod_desc->hba_desc	= hba_desc;
+	mod_desc->ops		= ops;
+	mod_desc->status	= MV_MOD_REGISTERED;
+	mod_desc->module_id = MODULE_CORE;
+	mod_desc->child 	= NULL;
+	List_Add(&mod_desc->mod_entry, &hba_desc->online_module_list);
+	hba_desc->running_mod_num++;
+
+	/* when running in non-RAID, both CACHE and RAID must be disabled */
+	if(!hba_desc->RunAsNonRAID)
+	{
+#ifdef RAID_DRIVER
+	/* RAID */
+	ops = mv_raid_register_module();
+	if (ops) {
+		prev = mod_desc;
+		mod_desc = __alloc_mod_desc();
+		if (NULL == mod_desc)
+			goto disaster;
+
+		mod_desc->hba_desc	= hba_desc;
+		mod_desc->ops		= ops;
+		mod_desc->status	= MV_MOD_REGISTERED;
+		mod_desc->module_id = MODULE_RAID;
+		mod_desc->child 	= prev;
+		prev->parent		= mod_desc;
+		List_Add(&mod_desc->mod_entry, &hba_desc->online_module_list);
+		hba_desc->running_mod_num++;
+	}
+#endif
+
+#ifdef CACHE_MODULE_SUPPORT
+	/* CACHE */
+	ops = mv_cache_register_module();
+	if (ops) {
+		prev = mod_desc;
+		mod_desc = __alloc_mod_desc();
+		if (NULL == mod_desc)
+			goto disaster;
+
+		mod_desc->hba_desc	= hba_desc;
+		mod_desc->ops		= ops;
+		mod_desc->status	= MV_MOD_REGISTERED;
+		mod_desc->module_id = MODULE_CACHE;
+		mod_desc->child 	= prev;
+		prev->parent		= mod_desc;
+		List_Add(&mod_desc->mod_entry, &hba_desc->online_module_list);
+		hba_desc->running_mod_num++;
+	}
+#endif
+
+	}
+
+	/* HBA */
+	prev = mod_desc;
+	mod_desc = __alloc_mod_desc();
+	if (NULL == mod_desc)
+		goto disaster;
+
+	mod_desc->ops = mv_hba_register_module();
+	if (NULL == mod_desc->ops) {
+		MV_PRINT("No HBA no life.\n");
+		return -1;
+	}
+
+	mod_desc->hba_desc	= hba_desc;
+	mod_desc->status	= MV_MOD_REGISTERED;
+	mod_desc->module_id = MODULE_HBA;
+	mod_desc->child 	= prev;
+	mod_desc->parent	= NULL;
+	prev->parent		= mod_desc;
+	List_Add(&mod_desc->mod_entry, &hba_desc->online_module_list);
+	hba_desc->running_mod_num++;
+
+	return 0;
+disaster:
+	return -1;
+
+}
+
+
+static void __release_consistent_mem(struct mv_mod_res *mod_res,
+				     struct pci_dev *dev)
+{
+	dma_addr_t       dma_addr;
+	MV_PHYSICAL_ADDR phy_addr;
+
+	phy_addr = mod_res->bus_addr;
+	dma_addr = (dma_addr_t) (phy_addr.parts.low |
+				 ((u64) phy_addr.parts.high << 32));
+	pci_free_consistent(dev,
+			    mod_res->size,
+			    mod_res->virt_addr,
+			    dma_addr);
+}
+
+int __alloc_consistent_mem(struct mv_mod_res *mod_res,
+				  struct pci_dev *dev)
+{
+	unsigned long size;
+	dma_addr_t    dma_addr;
+	BUS_ADDRESS   bus_addr;
+	MV_PHYSICAL_ADDR phy_addr;
+
+	size = mod_res->size;
+	size = ROUNDING(size, 8);
+	mod_res->virt_addr = (MV_PVOID) pci_alloc_consistent(dev,
+							     size,
+							     &dma_addr);
+	if (NULL == mod_res->virt_addr) {
+		MV_DPRINT(("unable to alloc 0x%lx consistent mem.\n",
+		       size));
+		return -1;
+	}
+	memset(mod_res->virt_addr, 0, size);
+	bus_addr            = (BUS_ADDRESS) dma_addr;
+	phy_addr.parts.low  = LO_BUSADDR(bus_addr);
+	phy_addr.parts.high = HI_BUSADDR(bus_addr);
+	mod_res->bus_addr   = phy_addr;
+
+	return 0;
+}
+
+
+
+static void __release_resource(struct mv_adp_desc *hba_desc,
+			       struct mv_mod_desc *mod_desc)
+{
+	struct mv_mod_res *mod_res, *tmp;
+
+	LIST_FOR_EACH_ENTRY_SAFE(mod_res,
+				tmp,
+				&mod_desc->res_list,
+				res_entry) {
+		switch (mod_res->type) {
+		case RESOURCE_UNCACHED_MEMORY :
+			__release_consistent_mem(mod_res, hba_desc->dev);
+			break;
+		case RESOURCE_CACHED_MEMORY :
+			hba_mem_free(mod_res->virt_addr,mod_res->size,MV_FALSE);
+			break;
+		default:
+			MV_DPRINT(("res type %d unknown.\n",
+			       mod_res->type));
+			break;
+		}
+		List_Del(&mod_res->res_entry);
+		hba_mem_free(mod_res,sizeof(struct mv_mod_res),MV_FALSE);
+	}
+}
+
+static void __release_module_resource(struct mv_mod_desc *mod_desc)
+{
+	__release_resource(mod_desc->hba_desc, mod_desc);
+}
+
+static int __alloc_module_resource(struct mv_mod_desc *mod_desc,
+				   unsigned int max_io)
+{
+	struct mv_mod_res *mod_res = NULL;
+	unsigned int size = 0;
+
+	/*
+	 * alloc only cached mem at this stage, uncached mem will be alloc'ed
+	 * during mod init.
+	 */
+	MV_LIST_HEAD_INIT(&mod_desc->res_list);
+	mod_res = hba_mem_alloc(sizeof(struct mv_mod_res),MV_FALSE);
+	if (NULL == mod_res)
+		return -1;
+	memset(mod_res, 0, sizeof(sizeof(struct mv_mod_res)));
+	mod_desc->res_entry = 1;
+
+	size = mod_desc->ops->get_res_desc(RESOURCE_CACHED_MEMORY, max_io);
+	if (size) {
+		mod_res->virt_addr = hba_mem_alloc(size,MV_FALSE);
+		if (NULL == mod_res->virt_addr) {
+			hba_mem_free(mod_res,sizeof(struct mv_mod_res),MV_FALSE);
+			MV_DASSERT(MV_FALSE);
+			return -1;
+		}
+		memset(mod_res->virt_addr, 0, size);
+		mod_res->type                = RESOURCE_CACHED_MEMORY;
+		mod_res->size                = size;
+		mod_desc->extension          = mod_res->virt_addr;
+		mod_desc->extension_size     = size;
+		List_Add(&mod_res->res_entry, &mod_desc->res_list);
+	}
+	MV_DPRINT(("show module id[%d] cached size[0x%x], addr[0x%p].\n",mod_desc->module_id,size,mod_res->virt_addr));
+
+	return 0;
+}
+
+static void mv_release_module_resource(struct mv_adp_desc *hba_desc)
+{
+	struct mv_mod_desc *mod_desc;
+
+	LIST_FOR_EACH_ENTRY(mod_desc, &hba_desc->online_module_list,
+			    mod_entry) {
+		if (mod_desc->status == MV_MOD_INITED) {
+			__release_module_resource(mod_desc);
+			mod_desc->status = MV_MOD_REGISTERED;
+		}
+	}
+}
+
+static int mv_alloc_module_resource(struct mv_adp_desc *hba_desc)
+{
+	struct mv_mod_desc *mod_desc;
+	int ret;
+
+	LIST_FOR_EACH_ENTRY(mod_desc, &hba_desc->online_module_list,
+			    mod_entry) {
+		ret = __alloc_module_resource(mod_desc, hba_desc->max_io);
+		if (ret)
+			goto err_out;
+		mod_desc->status = MV_MOD_INITED;
+		__ext_to_gen(mod_desc->extension)->desc = mod_desc;
+	}
+	return 0;
+
+err_out:
+	MV_DPRINT(("error %d allocating resource for mod %d.\n",
+	       ret, mod_desc->module_id));
+	LIST_FOR_EACH_ENTRY(mod_desc, &hba_desc->online_module_list,
+			    mod_entry) {
+		if (mod_desc->status == MV_MOD_INITED) {
+			__release_module_resource(mod_desc);
+			mod_desc->status = MV_MOD_REGISTERED;
+		}
+	}
+	return -1;
+}
+
+struct mv_mod_desc * __get_lowest_module(struct mv_adp_desc *hba_desc)
+{
+	struct mv_mod_desc *p;
+
+	/* take a random module, and trace through its child */
+	p = LIST_ENTRY(hba_desc->online_module_list.next,
+		       struct mv_mod_desc,
+		       mod_entry);
+
+	WARN_ON(NULL == p);
+	while (p) {
+		if (NULL == p->child)
+			break;
+		p = p->child;
+	}
+	return p;
+}
+
+struct mv_mod_desc * __get_highest_module(struct mv_adp_desc *hba_desc)
+{
+	struct mv_mod_desc *p;
+
+	/* take a random module, and trace through its parent */
+	p = LIST_ENTRY(hba_desc->online_module_list.next,
+		       struct mv_mod_desc,
+		       mod_entry);
+
+	WARN_ON(NULL == p);
+	while (p) {
+		if (NULL == p->parent)
+			break;
+		p = p->parent;
+	}
+	return p;
+}
+
+static void __map_pci_addr(struct pci_dev *dev, MV_PVOID *addr_array)
+{
+	int i;
+	resource_size_t addr;
+	resource_size_t range;
+
+	for (i = 0; i < MAX_BASE_ADDRESS; i++) {
+		addr  = pci_resource_start(dev, i);
+		range = pci_resource_len(dev, i);
+
+		if (pci_resource_flags(dev, i) & IORESOURCE_MEM){
+			addr_array[i] =(MV_PVOID) ioremap(addr, (unsigned long)range);
+		}
+		else{
+			addr_array[i] = (MV_PVOID)((unsigned long)addr);
+		}
+		MV_DPRINT(( "%s : BAR %d : %p.\n", mv_product_name,
+		       i, addr_array[i]));
+	}
+}
+
+static void __unmap_pci_addr(struct pci_dev *dev, MV_PVOID *addr_array)
+{
+	int i;
+
+	for (i = 0; i < MAX_BASE_ADDRESS; i++)
+		if (pci_resource_flags(dev, i) & IORESOURCE_MEM)
+                        iounmap(addr_array[i]);
+}
+
+int __mv_is_mod_all_started(struct mv_adp_desc *adp_desc)
+{
+	struct mv_mod_desc *mod_desc;
+
+	mod_desc = __get_lowest_module(adp_desc);
+
+	while (mod_desc) {
+		if (MV_MOD_STARTED != mod_desc->status)
+			return 0;
+
+		mod_desc = mod_desc->parent;
+	}
+	return 1;
+}
+
+static void __mv_save_hba_configuration(struct mv_adp_desc *hba_desc, void *hba_ext)
+{
+	u8 i;
+	PHBA_Extension phba = (PHBA_Extension)hba_ext;
+	phba->Vendor_Id = hba_desc->Vendor_Id;
+	phba->Device_Id = hba_desc->Device_Id ;
+	phba->Revision_Id = hba_desc->Revision_Id;
+	phba->Sub_Vendor_Id = hba_desc->Sub_Vendor_Id;
+	phba->Sub_System_Id = hba_desc->Sub_System_Id;
+	phba->pcie_max_lnk_spd = hba_desc->pcie_max_lnk_spd;
+	phba->pcie_max_bus_wdth = hba_desc->pcie_max_bus_wdth;
+	phba->pcie_neg_lnk_spd = hba_desc->pcie_neg_lnk_spd;
+	phba->pcie_neg_bus_wdth = hba_desc->pcie_neg_bus_wdth;
+	for (i = 0;i < MAX_BASE_ADDRESS; i++)
+		phba->Base_Address[i] = hba_desc->Base_Address[i];
+
+	MV_DPRINT(( "HBA device id 0x%x, RunAsNonRAID:%x.\n", phba->Device_Id, phba->RunAsNonRAID));
+
+}
+
+static void __hba_module_stop(struct mv_adp_desc *hba_desc)
+{
+	struct mv_mod_desc *mod_desc;
+
+	mod_desc = __get_highest_module(hba_desc);
+	if (NULL == mod_desc)
+		return;
+
+	/* starting from highest module, unlike module_start */
+	while (mod_desc) {
+		if (MV_MOD_STARTED == mod_desc->status) {
+			mod_desc->ops->module_stop(mod_desc->extension);
+			mod_desc->status = MV_MOD_INITED;
+		}
+		mod_desc = mod_desc->child;
+	}
+}
+
+struct hba_extension *__mv_get_ext_from_adp_id(int id)
+{
+	struct mv_adp_desc *p;
+
+	LIST_FOR_EACH_ENTRY(p, &mv_online_adapter_list, hba_entry)
+		if (p->id == id)
+			return __get_highest_module(p)->extension;
+
+	return NULL;
+}
+#ifdef SUPPORT_STAGGERED_SPIN_UP
+extern MV_U8 enable_spin_up(MV_PVOID hba);
+#endif
+
+int mv_hba_start(struct pci_dev *dev)
+{
+	struct mv_adp_desc *hba_desc;
+	struct mv_mod_desc *mod_desc;
+	struct hba_extension *hba;
+	unsigned long flags;
+	hba_desc = __dev_to_desc(dev);
+
+	/* YC 1. HBA module setup IRQ and so on. */
+	if(NULL == (mod_desc = __get_highest_module(hba_desc)))
+		return -1;
+
+	mod_desc->ops->module_start(mod_desc->extension);
+	hba = (struct hba_extension *)mod_desc->extension;
+	if(hba_desc->hba_host == NULL){
+		MV_DPRINT(("Start highest module failed.\n"));
+		return	-1;
+	}
+#ifndef SUPPORT_STAGGERED_SPIN_UP
+	hba->first_scan = 1;
+#endif
+
+	HBA_GetNextModuleSendFunction(hba, &hba->pNextExtension, &hba->pNextFunction);
+	RAID_Feature_SetSendFunction(hba->p_raid_feature, hba, hba->pNextExtension, hba->pNextFunction);
+#ifdef SUPPORT_MODULE_CONSOLIDATE
+    	ModConsolid_SetSendFunction(hba->PCC_Extension, hba, hba->pNextExtension, hba->pNextFunction);
+	/* Initialize Consolidate device */
+	ModConsolid_InitConsDev(hba);
+#endif
+
+
+#ifdef SUPPORT_TIMER
+	ossw_add_timer(&hba->desc->hba_desc->hba_timer,
+		TIMER_INTERVAL_OS, (void (*)(unsigned long))Timer_CheckRequest,(unsigned long)hba);
+#endif
+
+	/* YC 2. Core Module SAS/SATA initializing */
+	mod_desc = __get_lowest_module(hba_desc);
+	if (NULL == mod_desc)
+		return -1;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&hba_desc->hba_sync, 1);
+#endif
+
+	mod_desc->ops->module_start(mod_desc->extension);
+
+	/* YC 3.  Set HBA module started status */
+	hba->desc->status = MV_MOD_STARTED;
+	HBA_ModuleStarted(hba);
+	hba_house_keeper_run();
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	/* Fixed issue --- reboot failed on SUSE platform.
+                      Increase wait time to 1000 seconds */
+	if (0 == __hba_wait_for_atomic_timeout(&hba_desc->hba_sync, 1000 * HZ))
+		goto err_wait_cmpl;
+#else
+	if (0 == wait_for_completion_timeout(&hba_desc->cmpl, 1000 * HZ))
+		goto err_wait_cmpl;
+#endif
+
+#ifndef MV_VMK_ESX35
+#ifdef MV_VMK_ESXI5
+		memcpy(hba_desc->hba_host->name, mv_esxi_apt_name, 12);
+		hba_desc->hba_host->useDriverNamingDevice = 1;
+#endif
+	if (scsi_add_host(hba_desc->hba_host, &hba_desc->dev->dev))
+		goto err_wait_cmpl;
+	
+#if defined(SUPPORT_DIF) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+	if (mv_prot_mask) {
+#ifdef SUPPORT_DIX
+		if (mv_prot_guard) {
+			scsi_host_set_guard(hba_desc->hba_host, mv_prot_guard);
+			mv_prot_mask |= (SHOST_DIX_TYPE1_PROTECTION | SHOST_DIX_TYPE2_PROTECTION 
+					| SHOST_DIX_TYPE3_PROTECTION);
+		}
+#endif
+		scsi_host_set_prot(hba_desc->hba_host, mv_prot_mask);
+	}
+#endif
+
+#ifdef SUPPORT_STAGGERED_SPIN_UP
+	if(!enable_spin_up(hba)) {
+#endif
+	MV_PRINT("Start scsi_scan_host.\n");
+	scsi_scan_host(hba_desc->hba_host);
+
+	/* after scsi_scan_host, enable hotplug process switch */
+	hba->first_scan = 0;
+#ifdef SUPPORT_STAGGERED_SPIN_UP
+	}
+#endif
+#endif
+
+
+#ifndef MV_BLK_IOCTL
+	if (mv_register_chdev(hba))
+		MV_PRINT("Unable to register character device interface.\n");
+#endif
+	MV_DPRINT(("Finished Driver Initialization.\n"));
+
+	return 0;
+
+err_wait_cmpl:
+	MV_PRINT("Timeout waiting for module start.\n");
+	free_irq(hba_desc->dev->irq, hba);
+
+	return -1;
+}
+
+
+/* stop all HBAs if dev == NULL */
+void mv_hba_stop(struct pci_dev *dev)
+{
+	struct mv_adp_desc *hba_desc;
+	MV_DPRINT(("mv_hba_stop: before hba_house_keeper_exit\n"));
+	hba_house_keeper_exit();
+
+	if (dev) {
+		hba_desc = __dev_to_desc(dev);
+		__hba_module_stop(hba_desc);
+	} else {
+		list_for_each_entry(hba_desc, &mv_online_adapter_list, hba_entry)
+			__hba_module_stop(hba_desc);
+	}
+}
+
+void mv_hba_release(struct pci_dev *dev)
+{
+	struct mv_adp_desc *hba_desc;
+
+	hba_desc = __dev_to_desc(dev);
+	MV_DPRINT(("mv_hba_release\n"));
+	if (NULL != hba_desc) {
+		MV_DPRINT(("NULL != hba_desc\n"));
+		__unmap_pci_addr(hba_desc->dev, hba_desc->Base_Address);
+		mv_release_module_resource(hba_desc);
+		mv_hba_release_modmm(hba_desc->dev);
+	}
+}
+
+#ifdef RAID_DRIVER
+void mv_get_hba_page_info( MV_PVOID This, MV_U16 Device_Id, MV_U8 *NonRaid);
+#endif
+
+#ifdef PRODUCTNAME_ODIN
+MV_U16 core_set_device_id(MV_U32 pad_test);
+#endif
+
+int mv_hba_init(struct pci_dev *dev, MV_U32 max_io)
+{
+	struct mv_adp_desc *hba_desc;
+	struct mv_mod_desc *mod_desc;
+	PHBA_Extension phba = NULL ;
+	MV_U32 tmp1 = 0, tmp2 = 0;
+
+	int    dbg_ret = 0;
+	hba_desc = mv_hba_init_modmm(dev);
+	if (NULL == hba_desc)
+		goto ext_err_init;
+	hba_desc->dev = dev;
+	hba_desc->max_io = max_io;
+	hba_desc->id     = __mv_get_adapter_count() - 1;
+
+	if (pci_read_config_byte(hba_desc->dev,
+				 PCI_REVISION_ID,
+				 &hba_desc->Revision_Id)) {
+		MV_PRINT("%s : Failed to get hba's revision id.\n",
+		       mv_product_name);
+		goto ext_err_pci;
+	}
+
+	hba_desc->Vendor_Id = dev->vendor;
+	hba_desc->Device_Id = dev->device;
+	hba_desc->Sub_Vendor_Id = dev->subsystem_vendor;
+	hba_desc->Sub_System_Id = dev->subsystem_device;
+	MV_DPRINT(("original device id=%04X.\n",hba_desc->Device_Id));
+	/* WORKAROUND: Odin 2 was released with Device ID set to 6440, and
+	   Sub Device ID set to 6480. Supposedly both should be 6480.
+	   We correct this here. */
+	if (hba_desc->Device_Id == DEVICE_ID_6440) {
+		if (hba_desc->Sub_System_Id == DEVICE_ID_6480)
+			hba_desc->Device_Id = DEVICE_ID_6480;
+	}
+	__map_pci_addr(dev, hba_desc->Base_Address);
+
+	/* PCIe Link Speed and Bus Width */
+#if defined( PRODUCTNAME_ODIN) || defined(PRODUCTNAME_THOR)
+	pci_read_config_dword(dev, 0xec, &tmp1);
+	pci_read_config_dword(dev, 0xf0, &tmp2);
+#elif defined(PRODUCTNAME_VANIR) || defined(PRODUCTNAME_VANIRLITES)
+	pci_read_config_dword(dev, 0x7c, &tmp1);;
+	pci_read_config_dword(dev, 0x80, &tmp2);
+#elif defined(PRODUCTNAME_ATHENA)
+	pci_read_config_dword(dev, 0xcc, &tmp1);
+	pci_read_config_dword(dev, 0xd0, &tmp2);
+#endif
+	hba_desc->pcie_max_lnk_spd = (MV_U8)(tmp1 & 0x0F);
+	hba_desc->pcie_max_bus_wdth = (MV_U8)((tmp1 >> 4) & 0x3F);
+	hba_desc->pcie_neg_lnk_spd = (MV_U8)((tmp2 >> 16) & 0x0F);
+	hba_desc->pcie_neg_bus_wdth = (MV_U8)((tmp2 >> 20) & 0x3F);
+
+#ifdef PRODUCTNAME_ODIN
+	if ((hba_desc->Device_Id != DEVICE_ID_6480)&&( hba_desc->Device_Id != DEVICE_ID_6485)) {
+		MV_U32 padTest = 0;
+		pci_read_config_dword(dev, 0x60, &padTest);
+		hba_desc->Device_Id = core_set_device_id(padTest);
+		if (hba_desc->Device_Id == DEVICE_ID_6445)
+			hba_desc->RunAsNonRAID = MV_TRUE;
+
+	}
+#endif
+
+		/*Read RAID  information saved in Flash/NVRAM*/
+#ifdef RAID_DRIVER
+	mv_get_hba_page_info(hba_desc, hba_desc->Device_Id, &hba_desc->RunAsNonRAID);
+#endif
+
+	spin_lock_init(&hba_desc->global_lock);
+#ifdef SUPPORT_STAGGERED_SPIN_UP
+	spin_lock_init(&hba_desc->device_spin_up);
+#endif
+
+	MV_DPRINT(( "HBA ext struct init'ed at %p.\n",hba_desc));
+
+	if (register_online_modules(hba_desc))
+		goto ext_err_modmm;
+
+	if (mv_alloc_module_resource(hba_desc))
+		goto ext_err_modmm;
+
+	mod_desc = __get_highest_module(hba_desc);
+	if (NULL == mod_desc)
+		goto ext_err_pci;
+	__mv_save_hba_configuration(hba_desc, mod_desc->extension);
+	
+	phba=(PHBA_Extension)mod_desc->extension;
+#ifdef RAID_DRIVER
+	raid_get_hba_page_info(mod_desc->extension);
+#else
+	phba->RunAsNonRAID = 1;
+#endif
+	hba_desc->RunAsNonRAID = phba->RunAsNonRAID;
+
+#ifdef CONFIG_PM
+	mod_desc =  __get_highest_module(hba_desc);
+	pci_set_drvdata(dev,mod_desc);
+#endif
+	mod_desc = __get_lowest_module(hba_desc);
+	if (NULL == mod_desc)
+		goto ext_err_pci;
+
+	hba_desc->alloc_uncahemem_failed = MV_FALSE;
+	while (mod_desc) {
+		if (MV_MOD_INITED != mod_desc->status)
+			continue;
+		// Save mod description at module extension, do not zero module extension.
+		mod_desc->ops->module_initialize(mod_desc->extension,
+						 mod_desc->extension_size,
+						 hba_desc->max_io);
+		if (hba_desc->alloc_uncahemem_failed)
+			goto ext_err_pci;
+		/* there's no support for sibling module at the moment  */
+		mod_desc = mod_desc->parent;
+	}
+
+	return 0;
+
+ext_err_pci:
+	++dbg_ret;
+	mv_release_module_resource(hba_desc);
+ext_err_modmm:
+	++dbg_ret;
+	mv_hba_release_modmm(dev);
+ext_err_init:
+        ++dbg_ret;
+	return dbg_ret;
+}
+
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/hba_mod.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_mod.h
--- linux-3.10.69/drivers/scsi/mv/hba_mod.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_mod.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,99 @@
+#ifndef __MODULE_MANAGE_H__
+#define __MODULE_MANAGE_H__
+
+#include "hba_header.h"
+
+/* module management & hba module code */
+extern struct mv_module_ops *mv_core_register_module(void);
+extern struct mv_module_ops *mv_hba_register_module(void);
+
+#ifdef RAID_DRIVER
+extern struct mv_module_ops *mv_raid_register_module(void);
+#else
+static inline struct mv_module_ops *mv_raid_register_module(void)
+{
+	return NULL;
+}
+#endif /* RAID_DRIVER */
+
+#if defined(CACHE_MODULE_SUPPORT)
+extern struct mv_module_ops *mv_cache_register_module(void);
+#else
+static inline struct mv_module_ops *mv_cache_register_module(void)
+{
+	return NULL;
+}
+#endif /* CACHE_DRIVER */
+
+/* adapter descriptor */
+struct mv_adp_desc {
+	List_Head hba_entry;
+	List_Head  online_module_list;
+	spinlock_t   global_lock;
+#ifdef SUPPORT_STAGGERED_SPIN_UP
+	spinlock_t   device_spin_up;
+#endif
+	struct timer_list hba_timer;
+	struct pci_dev    *dev;
+	dev_t   dev_no;
+#ifndef MV_VMK_ESX35
+	struct cdev 	cdev;
+#endif
+	struct Scsi_Host	*hba_host;
+	struct completion		cmpl;
+	struct completion		ioctl_cmpl;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_t				hba_sync;
+	atomic_t				hba_ioctl_sync;
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+
+#ifdef SUPPORT_TASKLET
+	struct tasklet_struct mv_tasklet;
+	atomic_t		tasklet_active_count;
+	spinlock_t	tasklet_count_lock;
+#endif
+
+	/* adapter information */
+	MV_U8             Adapter_Bus_Number;
+	MV_U8             Adapter_Device_Number;
+	MV_U8             Revision_Id;
+	MV_U8             id;             /* multi-hba support, start from 0 */
+	MV_U8             running_mod_num;/* number of up & running modules */
+	MV_U8             RunAsNonRAID;		/* initialize it before InitModules is called */
+	MV_U16            RaidMode;			/*raid mode*/
+	MV_U16            Vendor_Id;
+	MV_U16            Device_Id;
+	MV_U16            Sub_System_Id;
+	MV_U16            Sub_Vendor_Id;	
+	
+	MV_U8		pcie_max_lnk_spd;	/* PCIe Max Supported Link Speed */
+	MV_U8		pcie_max_bus_wdth;	/* PCIe Max Supported Bus Width */
+	MV_U8		pcie_neg_lnk_spd;		/* PCIe Negotiated Link Speed */
+	MV_U8		pcie_neg_bus_wdth;	/* PCIe Negotiated Bus Width */
+	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+	unsigned int   pci_config_space[16];
+#endif
+	/* System resource */
+	MV_PVOID          Base_Address[ROUNDING(MAX_BASE_ADDRESS, 2)];
+	MV_U32            max_io;
+	MV_BOOLEAN    alloc_uncahemem_failed;
+
+};
+
+int  mv_hba_init(struct pci_dev *dev, MV_U32 max_io);
+void mv_hba_release(struct pci_dev *dev);
+void mv_hba_stop(struct pci_dev *dev);
+int  mv_hba_start(struct pci_dev *dev);
+MV_PVOID *mv_get_hba_extension(struct mv_adp_desc *hba_desc);
+int __mv_get_adapter_count(void);
+void raid_get_hba_page_info( MV_PVOID This);
+struct mv_mod_desc * __get_lowest_module(struct mv_adp_desc *hba_desc);
+struct mv_mod_desc * __get_highest_module(struct mv_adp_desc *hba_desc);
+int __mv_is_mod_all_started(struct mv_adp_desc *adp_desc);
+int __alloc_consistent_mem(struct mv_mod_res *mod_res,
+				  struct pci_dev *dev);
+
+#endif /* __MODULE_MANAGE_H__ */
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/hba_timer.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_timer.c
--- linux-3.10.69/drivers/scsi/mv/hba_timer.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_timer.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,630 @@
+#include "hba_header.h"
+#include "hba_exp.h"
+#include "hba_mod.h"
+#include "hba_timer.h"
+
+/* how long a time between which should each keeper work be done */
+#define KEEPER_SHIFT (HZ >> 1)
+
+static struct mv_hba_msg_queue mv_msg_queue;
+
+#if !defined(SUPPORT_WORKQUEUE) || (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+static struct task_struct *house_keeper_task = NULL;
+#endif
+
+static int shutdown = 0;
+static int __msg_queue_state;
+
+static inline int queue_state_get(void)
+{
+	return __msg_queue_state;
+}
+
+static inline void queue_state_set(int state)
+{
+	__msg_queue_state = state;
+}
+MV_U8 pal_set_down_disk_from_upper(void *ext, MV_U16 device_target_id, MV_U16 device_lun);
+MV_U8 pal_check_disk_exist(void *ext, MV_U16 device_target_id, MV_U16 device_lun);
+static void hba_proc_msg(struct mv_hba_msg *pmsg)
+{
+	PHBA_Extension phba;
+	struct scsi_device *psdev=NULL;
+	struct mv_adp_desc *hba_desc;
+	struct mv_lu *lu = NULL; 
+	MV_U16 dev_id;
+	MV_U16 dev_lun = (MV_U16)(pmsg->param>>16)&0xffff;
+	unsigned long flags;
+	/* we don't do things without pmsg->data */
+	if (NULL == pmsg->data){
+		MV_DPRINT(( "__MV__ In hba_proc_msg pmsg->data == NULL return.\n"));
+		return;
+	}
+
+#ifdef MV_VMK_ESX35
+	/* not support  */
+	return;
+#endif
+	phba = (PHBA_Extension) pmsg->data;
+	hba_desc= phba->desc->hba_desc;
+	dev_id = (MV_U16)pmsg->param;	//low word target ID
+	dev_lun = (MV_U16)(pmsg->param>>16)&0xffff;	// high word LUN
+	lu = mv_get_device_by_target_lun(phba, dev_id, dev_lun);
+	MV_DPRINT(( "__MV__ In hba_proc_msg.\n"));
+
+	MV_ASSERT(pmsg);
+	MV_ASSERT(phba->desc->hba_desc->hba_host);
+
+	switch (pmsg->msg) {
+	case EVENT_DEVICE_ARRIVAL:
+		if(lu == NULL)
+			lu = mv_get_avaiable_device(phba, dev_id, dev_lun);
+		if (lu == NULL){
+			MV_ASSERT(lu != NULL);
+			return;
+		}
+		if ( lu->sdev ) {
+			MV_DPRINT(( "__MV__ add scsi disk %d-%d-%d failed, it existed.\n", 0, dev_id, dev_lun));
+			break;
+		}
+#ifdef __VMKLNX__
+		psdev = __scsi_add_device(hba_desc->hba_host, 0, dev_id, dev_lun, 0);
+		if (IS_ERR(psdev)) {
+			MV_DPRINT(( "__MV__ add scsi disk %d-%d-%d failed.\n", 0, pmsg->param, 0));
+		} else {
+			MV_DPRINT(( "__MV__ add scsi disk %d-%d-%d.\n", 0, pmsg->param, 0));
+			scsi_device_put(psdev);
+		}
+#else		
+		if (scsi_add_device(hba_desc->hba_host, 0, dev_id, dev_lun)) {
+			MV_DPRINT(( "__MV__ add scsi disk %d-%d-%d failed.\n", 0, dev_id, dev_lun));
+			if (hba_desc->RunAsNonRAID) {
+				spin_lock_irqsave(&hba_desc->global_lock, flags);
+				pal_set_down_disk_from_upper(phba, dev_id, dev_lun);
+				spin_unlock_irqrestore(&hba_desc->global_lock, flags);
+			}
+			else
+				MV_ASSERT(0);
+		} else {
+			MV_DPRINT(( "__MV__ add scsi disk %d-%d-%d.\n", 0, dev_id, dev_lun));
+		}
+#endif
+		break;
+	case EVENT_DEVICE_REMOVAL:	
+		if (lu == NULL){
+			MV_ASSERT(lu != NULL);
+			return;
+		}
+		psdev = lu->sdev;
+#ifdef __VMKLNX__
+		if (!psdev)
+			psdev = scsi_device_lookup(hba_desc->hba_host, 0, lu->target_id, 0);
+#endif
+ 		if ( psdev ) {
+	 		if ( scsi_device_get(psdev) != 0 ) {
+				WARN_ON(1);
+				MV_DPRINT(("__MV__ no disk to remove %d-%d-%d\n", 0, psdev->id, psdev->lun));
+				psdev = NULL;
+			}
+ 		}		
+ 		if ( psdev) {
+			MV_DPRINT((  "__MV__ remove scsi disk %d-%d-%d.\n", 0,psdev->id, psdev->lun));
+			scsi_remove_device(psdev);
+			scsi_device_put(psdev);
+		}
+		break;
+	default:
+		break;
+	}
+}
+MV_U8	need_rescan = MV_FALSE;
+void *rescan_hba=NULL;
+
+int	hba_scan_host(void)
+{
+	MV_U32 target=0, lun=0;
+	int res= 0;
+	struct mv_lu * lu=NULL;
+	PHBA_Extension phba;
+	unsigned long flags;
+	spin_lock_irqsave(&mv_msg_queue.lock, flags);
+	if ((need_rescan == MV_FALSE) || !rescan_hba) {
+		spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
+		return 0;
+	}
+	phba = (PHBA_Extension)rescan_hba;
+	need_rescan = MV_FALSE;
+	rescan_hba = NULL;
+	spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
+
+	if (!phba->RunAsNonRAID){
+		//TBD, raid driver not support.
+		return 0;
+	}
+	
+	MV_DPRINT(("start scan host.\n"));
+	for (target =0; target < MV_MAX_TARGET_NUMBER; target++) {
+		lu = mv_get_device_by_target_lun(phba, target, lun);	//TBD single lun 
+		res = pal_check_disk_exist(phba, target, lun);
+		if (res && (!lu || !lu->sdev)){
+			MV_DPRINT(("device %d-%d has added.\n", target, lun));
+			hba_msg_insert(phba, EVENT_DEVICE_ARRIVAL, target | (lun << 16));
+		} else if (!res && (lu && lu->sdev)){
+			MV_DPRINT(("device %d-%d has gone.\n", target, lun));
+			hba_msg_insert(phba, EVENT_DEVICE_REMOVAL, target | (lun << 16));
+		}
+	}
+	MV_DPRINT(("finshed scan host.\n"));
+	return 0;
+	
+}
+
+
+static void mv_proc_queue(void)
+{
+	struct mv_hba_msg *pmsg;
+	unsigned long flags;
+
+	/* work on queue non-stop, pre-empty  */
+	queue_state_set(MSG_QUEUE_PROC);
+
+	while (1) {
+		MV_DPRINT((  "__MV__ process queue starts.\n"));
+		spin_lock_irqsave(&mv_msg_queue.lock, flags);
+		if (List_Empty(&mv_msg_queue.tasks)) {
+			/* it's important we put queue_state_set here. */
+			queue_state_set(MSG_QUEUE_IDLE);
+			spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
+			MV_DPRINT((  "__MV__ process queue ends.\n"));
+			break;
+		}
+		pmsg = LIST_ENTRY(mv_msg_queue.tasks.next, struct mv_hba_msg, msg_list);
+		spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
+		if (NULL == pmsg) {
+			MV_DPRINT((   "__MV__ pmsg == NULL .\n"));
+			return;
+		}
+		hba_proc_msg(pmsg);
+		/*clean the data before returning it to free list*/
+		pmsg->data = NULL;
+
+		spin_lock_irqsave(&mv_msg_queue.lock, flags);
+		List_MoveTail(&pmsg->msg_list, &(mv_msg_queue.free));
+		spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
+		MV_DPRINT((  "__MV__ process queue ends.\n"));
+	}
+	hba_scan_host();
+}
+
+static inline MV_U32 hba_msg_queue_empty(void)
+{
+	return List_Empty(&(mv_msg_queue.tasks));
+}
+
+
+#ifndef SUPPORT_WORKQUEUE
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+static int hba_house_keeper(void *data)
+{
+	set_user_nice(current, -15);
+	MV_DPRINT((  "Enter House keeper!\n"));
+	while (!kthread_should_stop()) {
+		if (!hba_msg_queue_empty() &&
+			MSG_QUEUE_IDLE == queue_state_get()) {
+			MV_DPRINT((  "mv_proc_queue runing.\n"));
+			mv_proc_queue();
+		}
+		MV_DPRINT(("House keeper sleep!\n"));
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule();
+		__set_current_state(TASK_RUNNING);
+		MV_DPRINT((  "House keeper wake up!\n"));
+	}
+	return 0;
+}
+#else
+/*Marvell hotplug kernel thread.*/
+struct completion marvell_hp_completion;
+long marvell_hp_thread_id = 0;
+DECLARE_WAIT_QUEUE_HEAD(wait_queue);
+static int hba_house_keeper(void *data)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	siginitsetinv(&current->blocked, 0);
+	sprintf(current->comm, "mv64xx_hp");
+	/* Flush resources */
+	daemonize();
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
+	reparent_to_init();
+#endif
+	init_completion(&marvell_hp_completion);
+	set_current_state(TASK_UNINTERRUPTIBLE);
+	add_wait_queue(&wait_queue,&wait);
+	while(1){
+		if(shutdown == 1)
+			break;
+                if (!hba_msg_queue_empty() &&
+                    MSG_QUEUE_IDLE == queue_state_get()) {
+                        mv_proc_queue();
+                }
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&wait_queue,&wait);
+	complete(&marvell_hp_completion);
+	return 0;
+}
+#endif
+
+#endif
+
+#ifdef SUPPORT_WORKQUEUE
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+
+#ifdef TIMER_INITIALIZER
+#undef TIMER_INITIALIZER
+#endif
+#define TIMER_INITIALIZER(_function, _expires, _data) {		\
+		.function = (_function),		\
+		.expires = (_expires),			\
+		.data = (_data),				\
+		.base = NULL,					\
+		.magic = TIMER_MAGIC,		\
+	}
+
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+static void mv_wq_handler(void *work)
+#else
+static void mv_wq_handler(struct work_struct *work)
+#endif
+{
+	if (hba_msg_queue_empty()) {
+		MV_DPRINT(("__MV__  msg queue is empty.\n"));
+		return;
+	} else if (!hba_msg_queue_empty() &&
+		MSG_QUEUE_IDLE == queue_state_get()) {
+	    	MV_DPRINT(("__MV__  msg queue isn't empty.\n"));
+		mv_proc_queue();
+	}
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
+#ifndef __VMKLNX__
+static DECLARE_WORK(mv_wq, mv_wq_handler,NULL);
+#else
+static DECLARE_WORK(mv_wq, mv_wq_handler);
+#endif
+#else
+static DECLARE_WORK(mv_wq, mv_wq_handler);
+#endif
+
+#endif
+
+static void hba_msg_queue_init(void)
+{
+	int i;
+
+	memset(&mv_msg_queue, 0, sizeof(sizeof(struct mv_hba_msg_queue)));
+	spin_lock_init(&mv_msg_queue.lock);
+
+	/* as we're in init, there should be no need to hold the spinlock*/
+	MV_LIST_HEAD_INIT(&(mv_msg_queue.free));
+	MV_LIST_HEAD_INIT(&(mv_msg_queue.tasks));
+
+	for (i = 0; i < MSG_QUEUE_DEPTH; i++) {
+		List_AddTail(&mv_msg_queue.msgs[i].msg_list,
+			      &mv_msg_queue.free);
+	}
+
+}
+
+
+void hba_house_keeper_init(void)
+{
+	hba_msg_queue_init();
+
+	queue_state_set(MSG_QUEUE_NO_START);
+#ifndef SUPPORT_WORKQUEUE
+#if LINUX_KERNEL_VERSION > KERNEL_VERSION(2,6,0)
+	house_keeper_task = kthread_create(hba_house_keeper, NULL, "399B4F5");
+		MV_DPRINT((  "hba_house_keeper_init: house_keeper_task->%p\n", house_keeper_task));
+	if (IS_ERR(house_keeper_task)) {
+		MV_DPRINT((  "Error creating kthread, out of memory?\n"));
+		house_keeper_task = NULL;
+	}
+#else
+	marvell_hp_thread_id = kernel_thread((int (*)(void *))hba_house_keeper, NULL, 0);
+#endif
+#endif
+}
+
+void hba_house_keeper_run(void)
+{
+	queue_state_set(MSG_QUEUE_IDLE);
+}
+
+void hba_house_keeper_exit(void)
+{
+	queue_state_set(MSG_QUEUE_NO_START);
+#if !defined(SUPPORT_WORKQUEUE) && (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0))
+	if (house_keeper_task)
+		kthread_stop(house_keeper_task);
+	house_keeper_task = NULL;
+	return;
+#endif
+
+#if defined(SUPPORT_WORKQUEUE)
+	flush_scheduled_work();
+	return ;
+#endif
+#ifdef  MV_VMK_ESX35
+	shutdown = 1;
+	wake_up(&wait_queue);
+	wait_for_completion(&marvell_hp_completion);
+	kill_proc(marvell_hp_thread_id, SIGKILL, 0);
+#endif
+}
+
+
+void hba_msg_insert(void *data, unsigned int msg, unsigned int param)
+{
+	struct mv_hba_msg *pmsg;
+	unsigned long flags;
+
+	MV_DPRINT(( "__MV__ msg insert  %d.\n", msg));
+	spin_lock_irqsave(&mv_msg_queue.lock, flags);
+	if (List_Empty(&mv_msg_queue.free)) {
+		/* should wreck some havoc ...*/
+		MV_DPRINT(("-- MV -- Message queue is full.\n"));
+		need_rescan = MV_TRUE;
+		rescan_hba = data;
+		spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
+		return;
+	}
+
+	MV_DPRINT((   "__MV__ Message queue is not full.\n"));
+	pmsg = LIST_ENTRY(mv_msg_queue.free.next, struct mv_hba_msg, msg_list);
+	spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
+
+	pmsg->data = data;
+	pmsg->msg  = msg;
+
+	switch (msg) {
+	case EVENT_DEVICE_REMOVAL:
+	case EVENT_DEVICE_ARRIVAL:
+		pmsg->param = param;
+		break;
+	default:
+		pmsg->param = param;
+		/*(NULL==param)?0:*((unsigned int*) param);*/
+		break;
+	}
+
+	spin_lock_irqsave(&mv_msg_queue.lock, flags);
+	List_MoveTail(&pmsg->msg_list, &mv_msg_queue.tasks);
+	spin_unlock_irqrestore(&mv_msg_queue.lock, flags);
+
+#ifdef SUPPORT_WORKQUEUE
+	schedule_work(&mv_wq);
+#else
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
+	if (house_keeper_task)
+		wake_up_process(house_keeper_task);
+#else
+	wake_up(&wait_queue);
+#endif
+#endif
+}
+
+#ifdef SUPPORT_TIMER
+
+MV_U16 Timer_GetRequestCount(MV_U16 maxIo)
+{
+	MV_U16 reqCount;
+
+	/* when not in hibernation mode, allocate twice as many timers as # of
+	  * devices because hot plug now requires a timer also for each device
+	  */
+	if (maxIo==1)
+		reqCount = MAX_DEVICE_SUPPORTED_PERFORMANCE; /* no smart timer */
+	else
+		reqCount = (MAX_DEVICE_SUPPORTED_PERFORMANCE + 1) * 2;
+#if defined(SUPPORT_CHIP_TIMEOUT)
+	reqCount+=2;
+#endif
+	return reqCount;
+}
+
+MV_U32 Timer_GetResourceQuota(MV_U16 maxIo)
+{
+	MV_U32 sz;
+	MV_U16 reqCount;
+
+	reqCount = Timer_GetRequestCount(maxIo);
+	/* Memory for timer tag pool */
+	sz = ROUNDING((sizeof(MV_U16) * reqCount), 8);
+	/* Memory for timer request array */
+	sz += ROUNDING((sizeof(PTimer_Request) * reqCount), 8);
+	/* Memory for timer request */
+	sz += ROUNDING((sizeof(Timer_Request) * reqCount), 8);
+	return sz;
+}
+
+void Timer_Initialize(
+	IN  MV_PVOID This,
+	IN MV_PU8 pool,
+	IN MV_U16 max_io
+	)
+{
+	PHBA_Extension pHBA = (PHBA_Extension)This;
+	PTimer_Module	pTimer=(PTimer_Module)&pHBA->TimerModule;
+	MV_PTR_INTEGER temp = (MV_PTR_INTEGER)pool;
+	PTimer_Request pTimerReq;
+	MV_U16 i, reqCount;
+
+	ossw_init_timer(&pHBA->desc->hba_desc->hba_timer);
+
+	reqCount = Timer_GetRequestCount(max_io);
+	pTimer->Timer_Request_Number = reqCount;
+	MV_DPRINT(("Timer_Request_Number = %d.\n", pTimer->Timer_Request_Number));
+	/* allocate memory for timer request tag pool */
+	pTimer->Tag_Pool.Stack = (MV_PU16)temp;
+	pTimer->Tag_Pool.Size = reqCount;
+	temp += sizeof(MV_U16) * reqCount;
+	Tag_Init( &pTimer->Tag_Pool, reqCount );
+
+	U64_ZERO_VALUE(pTimer->Time_Stamp);
+	MV_ASSERT( sizeof(Timer_Request)==ROUNDING(sizeof(Timer_Request),8) );
+	/* allocate memory for timer request array */
+	pTimer->Running_Requests = (PTimer_Request *)temp;
+	temp += sizeof(PTimer_Request) * reqCount;
+	for (i = 0; i < reqCount; i++) {
+		pTimerReq = (PTimer_Request)temp;
+		U64_ZERO_VALUE(pTimerReq->Time_Stamp);
+		pTimer->Running_Requests[i] = pTimerReq;
+		temp += sizeof( Timer_Request );
+	}
+}
+
+void Timer_Stop(MV_PVOID This)
+{
+	PHBA_Extension pHBA = (PHBA_Extension)This;
+	ossw_del_timer(&pHBA->desc->hba_desc->hba_timer);
+}
+
+
+#ifdef SUPPORT_SMALL_TIMER
+MV_U16 Timer_AddSmallRequest(
+	IN MV_PVOID extension,
+	IN MV_U32 time_unit,
+	IN MV_VOID (*routine) (MV_PVOID, MV_PVOID),
+	IN MV_PVOID context1,
+	IN MV_PVOID context2
+	)
+{
+	PHBA_Extension pHBA = (PHBA_Extension)HBA_GetModuleExtension(extension, MODULE_HBA);
+	PTimer_Module pTimer = &pHBA->TimerModule;
+	PTimer_Request pTimerReq;
+	MV_U16 index;
+
+	if (!Tag_IsEmpty( &pTimer->Tag_Pool )) {
+		index = Tag_GetOne( &pTimer->Tag_Pool );
+		pTimerReq = pTimer->Running_Requests[index];
+
+		pTimerReq->Valid = MV_TRUE;
+		pTimerReq->Context1 = context1;
+		pTimerReq->Context2 = context2;
+		pTimerReq->Routine = routine;
+		pTimerReq->Time_Stamp = U64_ADD_U32(pTimer->Time_Stamp,
+			time_unit * TIMER_INTERVAL_SMALL_UNIT );
+
+		return index;
+	}
+
+	/* shouldn't happen - we should always allocate enough timer slots for all devices */
+	MV_DASSERT( MV_FALSE );
+	return NO_CURRENT_TIMER;
+}
+#endif
+
+MV_U16 Timer_AddRequest(
+	IN MV_PVOID extension,
+	IN MV_U32 time_unit,
+	IN MV_VOID (*routine) (MV_PVOID, MV_PVOID),
+	IN MV_PVOID context1,
+	IN MV_PVOID context2
+	)
+{
+	PHBA_Extension pHBA = (PHBA_Extension)HBA_GetModuleExtension(extension, MODULE_HBA);
+	PTimer_Module pTimer = &pHBA->TimerModule;
+	PTimer_Request pTimerReq;
+	MV_U16 index;
+
+	if (!Tag_IsEmpty( &pTimer->Tag_Pool)) {
+		index = (MV_U16)Tag_GetOne( &pTimer->Tag_Pool );
+		pTimerReq = pTimer->Running_Requests[index];
+
+		pTimerReq->Valid = MV_TRUE;
+		pTimerReq->Context1 = context1;
+		pTimerReq->Context2 = context2;
+		pTimerReq->Routine = routine;
+		pTimerReq->Time_Stamp = U64_ADD_U32(pTimer->Time_Stamp,
+			time_unit * TIMER_INTERVAL_LARGE_UNIT );
+		return index;
+	}
+
+	/* shouldn't happen - we should always allocate enough timer slots for all devices */
+	MV_DPRINT(("Timer_AddRequest: no enough timer slots \n"));
+	MV_DASSERT( MV_FALSE );
+	return NO_CURRENT_TIMER;
+}
+
+void Timer_CheckRequest(
+	IN MV_PVOID extension
+	)
+{
+	PHBA_Extension pHBA = (PHBA_Extension)HBA_GetModuleExtension(extension, MODULE_HBA);
+	PTimer_Module pTimer = &pHBA->TimerModule;
+	PTimer_Request pTimerReq;
+	MV_PVOID core = NULL;
+	MV_U16 i; 
+#ifndef SUPPORT_TASKLET
+		MV_ULONG flags;
+		spin_lock_irqsave(&pHBA->desc->hba_desc->global_lock, flags);
+#else
+		spin_lock_bh(&pHBA->desc->hba_desc->global_lock);
+#endif
+		pTimer->Time_Stamp = U64_ADD_U32(pTimer->Time_Stamp, TIMER_INTERVAL_OS);
+
+		for (i=0; i<pTimer->Timer_Request_Number; i++) {
+			pTimerReq = pTimer->Running_Requests[i];
+			if (pTimerReq && pTimerReq->Valid && (pTimerReq->Time_Stamp.value <= pTimer->Time_Stamp.value)) {
+				MV_DASSERT( pTimerReq->Routine != NULL );
+				pTimerReq->Routine( pTimerReq->Context1, pTimerReq->Context2 );
+				if (pTimerReq->Valid) {
+					pTimerReq->Valid = MV_FALSE;
+					Tag_ReleaseOne( &pTimer->Tag_Pool, i );
+				}
+			}
+		}
+
+#ifdef CORE_NO_RECURSIVE_CALL
+		core = (MV_PVOID)HBA_GetModuleExtension(extension, MODULE_CORE);
+		core_push_queues(core);
+#endif
+
+		mod_timer(&pHBA->desc->hba_desc->hba_timer, jiffies + msecs_to_jiffies(TIMER_INTERVAL_OS));
+
+#ifndef SUPPORT_TASKLET
+		spin_unlock_irqrestore(&pHBA->desc->hba_desc->global_lock, flags);
+#else
+		spin_unlock_bh(&pHBA->desc->hba_desc->global_lock);
+#endif
+
+}
+
+void Timer_CancelRequest(
+	IN MV_PVOID extension,
+	IN MV_U16 request_index
+	)
+{
+	PHBA_Extension pHBA = (PHBA_Extension)HBA_GetModuleExtension(extension, MODULE_HBA);
+	PTimer_Module pTimer = &pHBA->TimerModule;
+	PTimer_Request pTimerReq;
+
+	if (request_index < pTimer->Timer_Request_Number) {
+		pTimerReq = pTimer->Running_Requests[request_index];
+
+		if(pTimerReq->Valid && (pTimerReq->Time_Stamp.value >=  pTimer->Time_Stamp.value)) {
+			pTimerReq->Valid = MV_FALSE;
+			Tag_ReleaseOne( &pTimer->Tag_Pool, (MV_U16)request_index );
+		}
+	}
+}
+#endif
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/hba_timer.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_timer.h
--- linux-3.10.69/drivers/scsi/mv/hba_timer.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/hba_timer.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,58 @@
+#ifndef __HBA_TIMER_H__
+#define __HBA_TIMER_H__
+
+#include "com_tag.h"
+#include "hba_exp.h"
+
+enum _tag_hba_msg_state{
+	MSG_QUEUE_IDLE=0,
+	MSG_QUEUE_PROC,
+	MSG_QUEUE_NO_START
+};
+
+struct mv_hba_msg {
+	MV_PVOID data;
+	MV_U32   msg;
+	MV_U32   param;
+	List_Head msg_list;
+};
+
+struct mv_hba_msg_queue {
+	spinlock_t lock;
+	List_Head free;
+	List_Head tasks;
+	struct mv_hba_msg msgs[MSG_QUEUE_DEPTH];
+};
+
+enum {
+	HBA_TIMER_IDLE = 0,
+	HBA_TIMER_RUNNING,
+	HBA_TIMER_LEAVING,
+};
+void hba_house_keeper_init(void);
+void hba_house_keeper_run(void);
+void hba_house_keeper_exit(void);
+void hba_msg_insert(void *data, unsigned int msg, unsigned int param);
+void hba_init_timer(PMV_Request req);
+void hba_remove_timer(PMV_Request req);
+void hba_remove_timer_sync(PMV_Request req);
+void hba_add_timer(PMV_Request req, int timeout,
+		   MV_VOID (*function)(MV_PVOID data));
+extern struct mv_lu *mv_get_device_by_target_lun(struct hba_extension *hba, MV_U16  target_id, MV_U16 lun);
+extern struct mv_lu *mv_get_avaiable_device(struct hba_extension * hba, MV_U16 target_id, MV_U16 lun);
+extern MV_U16 get_id_by_targetid_lun(MV_PVOID ext, MV_U16 id,MV_U16 lun);
+
+#if  defined(__VMKLNX__) || defined (MV_VMK_ESX35)
+/*vmware use 100 for HZ*/
+#define TIMER_INTERVAL_OS		100		/* 10 millisecond */
+#define TIMER_INTERVAL_LARGE_UNIT	50		/* 10 millisecond */
+#define TIMER_INTERVAL_SMALL_UNIT	10		/* 10 millisecond */
+#else
+#define TIMER_INTERVAL_OS		1000		/* millisecond */
+#define TIMER_INTERVAL_LARGE_UNIT	500		/* millisecond */
+#define TIMER_INTERVAL_SMALL_UNIT	100		/* millisecond */
+#endif
+
+#endif /* __HBA_TIMER_H__ */
+
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_adapter_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_adapter_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_adapter_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_adapter_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,272 @@
+#ifndef __MV_COM_ADAPTER_STRUCT_H__
+#define __MV_COM_ADAPTER_STRUCT_H__
+
+#include "com_define.h"
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+#define BASE_ADDRESS_MAX_NUM                    6
+
+/* The following Version definition is kept here for backward compatability. */
+/* Each fields are two bytes too big. */
+typedef struct _Version_Info
+{
+	 MV_U32        VerMajor;
+	 MV_U32        VerMinor;
+	 MV_U32        VerOEM;
+	 MV_U32        VerBuild;
+}Version_Info, *PVersion_Info;
+
+/* The following Version definition are copied from CIM_SoftwareIdentity class */
+typedef struct _Version_Info_CIM
+{
+	 MV_U16        MajorVersion;
+	 MV_U16        MinorVersion;
+	 MV_U16        RevisionNumber;
+	 MV_U16        BuildNumber;
+}Version_Info_CIM, *PVersion_Info_CIM;
+
+#ifndef _MARVELL_SDK_PACKAGE_NONRAID
+#define SUPPORT_LD_MODE_RAID0                   MV_BIT(0)
+#define SUPPORT_LD_MODE_RAID1                   MV_BIT(1)
+#define SUPPORT_LD_MODE_RAID10                  MV_BIT(2)
+#define SUPPORT_LD_MODE_RAID1E                  MV_BIT(3)
+#define SUPPORT_LD_MODE_RAID5                   MV_BIT(4)
+#define SUPPORT_LD_MODE_RAID6                   MV_BIT(5)
+#define SUPPORT_LD_MODE_RAID50                  MV_BIT(6)
+#define SUPPORT_LD_MODE_JBOD                    MV_BIT(7)
+#define SUPPORT_LD_MODE_RAID60                  MV_BIT(8)
+#define SUPPORT_LD_MODE_CROSS_SATA_SSD          MV_BIT(9)
+#define SUPPORT_LD_MODE_HYPPER_HDD_MIRROR       MV_BIT(10)
+#define SUPPORT_LD_MODE_HYBRID_HDD_MIRROR       MV_BIT(11)
+
+#define FEATURE_BGA_REBUILD_SUPPORT             MV_BIT(0)
+#define FEATURE_BGA_BKINIT_SUPPORT              MV_BIT(1)
+#define FEATURE_BGA_SYNC_SUPPORT                MV_BIT(2)
+#define FEATURE_BGA_MIGRATION_SUPPORT           MV_BIT(3)
+#define FEATURE_BGA_MEDIAPATROL_SUPPORT         MV_BIT(4)
+#define FEATURE_BGA_FEINIT_SUPPORT              MV_BIT(5)
+#define FEATURE_BGA_COPY_BACK_SUPPORT           MV_BIT(6)
+#define FEATURE_PD_OF_SAME_TYPE_WHEN_CREATE_VD  MV_BIT(7) // PDs must of the same type when used to create VD or DG
+#endif
+//_MARVELL_SDK_PACKAGE_NONRAID
+
+#define ADV_FEATURE_EVENT_WITH_SENSE_CODE       MV_BIT(0)
+#define ADV_FEATURE_BIG_STRIPE_SUPPORT          MV_BIT(1)
+#define ADV_FEATURE_BIOS_OPTION_SUPPORT         MV_BIT(2) // to inform API if support upload/download bios
+#define ADV_FEATURE_HAS_BBU                     MV_BIT(3)
+#define ADV_FEATURE_CONFIG_IN_FLASH             MV_BIT(4)
+#define ADV_FEATURE_CPU_EFFICIENCY_SUPPORT      MV_BIT(5)  // to inform API if support optimized CPU efficiency
+#ifndef _MARVELL_SDK_PACKAGE_NONRAID
+#define ADV_FEATURE_NO_MUTIL_VD_PER_PD          MV_BIT(6)
+#endif
+#define ADV_FEATURE_SPC_4_BUFFER                MV_BIT(7)
+#define ADV_FEATURE_SES_DIRECT                  MV_BIT(8)
+#define ADV_FEATURE_MODULE_CONSOLIDATE          MV_BIT(9)
+#define ADV_FEATURE_IMAGE_HEALTH                MV_BIT(10) // support Image health
+#define ADV_FEATURE_SATA_PHY_CTRL_BY_PORT       MV_BIT(11) // support SATA PHY Control, port base.
+#define ADV_FEATURE_CRYPTO_SUPPORT              MV_BIT(12) // AES encryption, port based.
+#define ADV_FEATURE_OS_TIME_SUPPORT             MV_BIT(13) // OS time support
+#define ADV_FEATURE_NO_VD_WRITE_CACHE_SUPPORT   MV_BIT(14) // Magni not support VD write cache
+#define ADV_FEATURE_NO_VD_READ_CACHE_SUPPORT    MV_BIT(15) // Magni not support VD read cache
+#define ADV_FEATURE_NO_HD_SMART_SUPPORT         MV_BIT(16) // Magni not support HD smart
+#define ADV_FEATURE_NO_VD_ROUNDING_SUPPORT      MV_BIT(17) // Magni not support VD GB Rounding
+#define ADV_FEATURE_NO_HD_SETFREE_SUPPORT       MV_BIT(18) // Magni not support set free
+#define ADV_FEATURE_NO_HD_WRITE_CACHE_SUPPORT   MV_BIT(19) // Magni not support HD write cache
+#define ADV_FEATURE_NO_ENC_SUPPORT              MV_BIT(20) // Magni not support encloure
+#define ADV_FEATURE_NO_BGA_RATE_CHANGE          MV_BIT(21) // Magni lite support bga but can not change rate
+#define ADV_FEATURE_AES_PARTITION               MV_BIT(22) // Magni AES Partition
+#define ADV_FEATURE_HYPERDUO_INTELLIGENT_INIT   MV_BIT(23) // Magni+
+#define ADV_FEATURE_NO_SPARE_SUPPORT            MV_BIT(24) // Magni+ support rebuild without assign spare
+#define ADV_FEATURE_HYBRID_SWITCH_SUPPORT       MV_BIT(25) // Magni+ support hybrid raid sp cache mode, cover vd cache policy
+#define ADV_FEATURE_HOT_PLUG_SUPPORT            MV_BIT(26) // USB to SATA support Hot plug
+#define ADV_FEATURE_ATA_PASS_THROUGH            MV_BIT(27) // Magni+ support ATA pass through
+#define ADV_FEATURE_HYPERDUO_REMAP_SUPPORT      MV_BIT(28)
+#define ADV_FEATURE_ACCESS_REGISTER             MV_BIT(29)
+#define ADV_FEATURE_OEM_DATA                    MV_BIT(30) // enc notify for oem
+#define ADV_FEATURE_FLASH_PER                   MV_BIT(31) // support image size api
+
+#define PCIE_SPEED_UNKNOWN                      0
+/* Gen I (2.5Gbps) */
+#define PCIE_SPEED_GEN_I                        1
+/* Gen II (5Gbps) */
+#define PCIE_SPEED_GEN_II                       2
+/* Gen III (8Gbps)*/
+#define PCIE_SPEED_GEN_III                      3
+
+#define PORT_PHY_PD     		MV_BIT(6)
+#define PORT_PHY_DIS    		MV_BIT(5)
+#define PORT_PHY_LOCK   		MV_BIT(4)
+#define PORT_PHY_EN     		MV_BIT(3)
+#define PORT_PHY_SPD    		0x7
+#define PORT_PHY_SPD_G3 		3
+#define PORT_PHY_SPD_G2 		2
+#define PORT_PHY_SPD_G1 		1
+#define PORT_PHY_SPD_MAX        0       // Max speed of HBA supports.
+
+#define STRIPE_SIZE_16 			MV_BIT(0)	// 16K
+#define STRIPE_SIZE_32 			MV_BIT(1)	// 32K
+#define STRIPE_SIZE_64 			MV_BIT(2)	// 64K
+#define STRIPE_SIZE_128 		MV_BIT(3)	// 128K
+#define STRIPE_SIZE_256			MV_BIT(4)	// 256K
+#define STRIPE_SIZE_512 		MV_BIT(5)	// 512K
+#define STRIPE_SIZE_1024 		MV_BIT(6)	// 1024K
+#define STRIPE_SIZE_MASK		(0x7F)		// all above
+
+typedef struct _Adapter_Info
+{
+	Version_Info        DriverVersion;
+	Version_Info_CIM    BIOSVersion;
+	Version_Info_CIM    FirmwareVersion;
+	Version_Info_CIM    BootLoaderVersion;
+	MV_U64              Reserved1[1];     /* Reserve for firmware */
+
+	MV_U32              SystemIOBusNumber;
+	MV_U32              SlotNumber;
+
+	MV_U32              InterruptLevel;
+	MV_U32              InterruptVector;
+
+	MV_U16              VenID;
+	MV_U16              SubVenID;
+	MV_U16              DevID;
+	MV_U16              SubDevID;
+
+	MV_U8               PortCount;
+	MV_U8               PortSupportType;  /* SATA, SAS, PATA etc, use MV_BIT */
+	MV_U8               Features;         /* Feature bits.  See FEATURE_XXX */
+	MV_BOOLEAN          AlarmSupport;
+	MV_U8               RevisionID;       /* Chip revision */
+	MV_U8				MaxPDPerVD;
+	MV_U16              StripeSizeSupported;  // Supported stripe size.  See STRIPE_SIZE_XXX
+
+	MV_U32              AdvancedFeatures; /* Advanced feature bits.  See ADV_FEATURE_XXX */
+	MV_U8               MaxPDPerDG;
+	MV_U8               MaxVDPerDG;
+	MV_U8               MaxParityDisks;   /* Max parity disks for RAID6.  Multiply it by 2 for RAID60 */
+	MV_U8               MaxDiskGroup;
+
+	MV_U8               MaxTotalBlocks;
+	MV_U8               MaxBlockPerPD;
+	MV_U8               MaxHD;             /* Deprecated. Leave it here for backward compatibility.  New driver should use MaxHD_Ext */
+	MV_U8               MaxExpander;
+	MV_U8               MaxPM;
+	MV_U8               MaxLogicalDrive;
+	MV_U16              LogicalDriverMode;
+
+	MV_U8               WWN[8];            /* For future VDS use. */
+
+	MV_U16              MaxHD_Ext;		    /* Added to support max HD of 1024.  If it is 0, application should use MaxHD instead */
+	MV_U16              MaxBufferSize;		/* Max contiguous buffer size driver can handle in unit of 1024. Application based on this to allocate space in API */
+	MV_U16              MaxTotalBlocks_V2;	// For support 1024 and more blocks
+	MV_U8               MaxAESPort;
+	MV_U8               MaxHyperHdd;
+	MV_U8               MaxSSDPerHyperDuo;
+	MV_U8               MaxAESEntry;
+	MV_U8               MaxSSDSegment;
+	MV_U8               Reserved3[9];
+	MV_U8               SerialNo[20];
+	MV_U8               PortSasAddress[16][8];  // SAS address of each port on the adapter
+	MV_U8               MaxSpeed;//Gen I (2.5Gbps)/Gen II (5Gbps)/
+	MV_U8               CurrentSpeed;//Gen I (2.5Gbps)/Gen II (5Gbps)/
+	MV_U8               MaxLinkWidth;//1x,2x,4x,8x
+	MV_U8               CurrentLinkWidth;//1x,2x,4x,8x
+	            // ADV_FEATURE_IMAGE_HEALTH ***
+	MV_BOOLEAN         img_health;         // AND all below image health state.
+	MV_BOOLEAN         autoload_img_health;
+	MV_BOOLEAN         boot_loader_img_health;
+	MV_BOOLEAN         firmware_img_health;
+	MV_BOOLEAN         boot_rom_img_health;    // func 0
+	MV_BOOLEAN         hba_info_img_health;
+	            // // ADV_FEATURE_IMAGE_HEALTH ###
+	MV_U8              Reserved4[2];        // pad
+	MV_U8              ModelNumber[20];
+} Adapter_Info, *PAdapter_Info;
+
+typedef struct _Adapter_Config_V2 {
+	MV_BOOLEAN      AlarmOn;
+	MV_BOOLEAN      AutoRebuildOn;
+	MV_U8           BGARate;
+	MV_BOOLEAN      PollSMARTStatus;
+	MV_U8           MediaPatrolRate;
+	MV_BOOLEAN      CopyBack;
+	MV_U8           SyncRate;				// syncronization rate (consistency check and fix)
+	MV_U8           InitRate;				// Initialization rate
+
+	MV_U8           RebuildRate;
+	MV_U8           MigrationRate;
+	MV_U8           CopybackRate;
+	MV_BOOLEAN      InterruptCoalescing;       // enable or disable
+	MV_BOOLEAN      ModuleConsolidate;
+	MV_BOOLEAN     v_atapi_disable;    // Virtual ATAPI disable. 0: enable/default; 1: disable
+	MV_U8          sgpio_enable;       // sgpio enable
+	MV_U8          reserved0;       // pad MV_U8
+	MV_U8			port_phy_ctrl[8];  // Phy control of ports, ADV_FEATURE_SATA_PHY_CTRL_BY_PORT
+	MV_U8 		SerialNo[20];
+	MV_U8          ModelNumber[20];
+} Adapter_Config_V2, *PAdapter_Config_V2;
+
+/* To be backward compatible, keep the original Adapter_Config */
+typedef struct _Adapter_Config {
+	MV_BOOLEAN      AlarmOn;
+	MV_BOOLEAN      AutoRebuildOn;
+	MV_U8           BGARate;
+	MV_BOOLEAN      PollSMARTStatus;
+	MV_U8           MediaPatrolRate;
+	MV_BOOLEAN      CopyBack;
+	MV_U8           Reserved[2];
+} Adapter_Config, *PAdapter_Config;
+
+#define TYPE_MAILBOX_REGISTER         0
+
+typedef struct _Adapter_Register_Value {
+	MV_U8           offset;
+	MV_U8           size;
+    MV_U8           reserved1[6];
+	MV_U32          value;
+	MV_U8           reserved2[4];
+} Adapter_Register_Value, *PAdapter_Register_Value;
+
+typedef struct _Adapter_OEM_Data {
+	MV_U16          cbSize;
+    MV_U8           reserved[2];
+	MV_U8           vendor_id[4];
+	MV_U8           data[64];
+} Adapter_OEM_Data, *PAdapter_OEM_Data;
+
+#define  UNUSED_SENSOR   0xFFFF
+
+typedef struct _Adapter_Sensor_Data {
+	MV_I16          temperature1; /*unit is 0.01 Celsius */
+    MV_U8           reserved[126];
+} Adapter_Sensor_Data, *PAdapter_Sensor_Data;
+
+#if(defined(_OS_DOS)&&defined(PRODUCTNAME_ATHENA))
+typedef struct _AdapterInfo AdapterInfo;
+struct _AdapterInfo
+{
+    MV_U32      flags;
+    MV_U16      devId;
+    MV_U32      classCode;
+    MV_U8       revId;
+    MV_U8       bus;
+    MV_U8       devFunc;
+    void*       bar[6];
+    MV_U32      ExpRomBaseAddr;
+    MV_U8       version;
+    MV_U8       subVersion;
+
+    MV_U16      FlashID;
+    MV_U32      FlashSize; 
+    MV_U32      FlashSectSize;
+
+    void*       FlashBar;
+};
+#endif
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_aes_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_aes_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_aes_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_aes_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,85 @@
+#ifndef __MV_COM_AES_STRUCT_H__
+#define __MV_COM_AES_STRUCT_H__
+
+#include "com_define.h"
+
+#define MAX_SUPPORT_AES_SATA_PORT	4 /*4:9230, 9236 2:9220*/
+#define AES_KEY_SPI_ENTRY_NUMBER    10 // total entry number for user use
+
+#define AES_KEY_CONTENT_LENGTH                 32
+
+#define MV_AES_KEY_CLEAR                   0
+#define MV_AES_KEY_128                     16
+#define MV_AES_KEY_256                     32
+#define MV_AES_KEY_PERSIST                 0xFF
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _aes_entry_info
+{
+    MV_U8 aes_port[MAX_SUPPORT_AES_SATA_PORT][2]; // supply current port id and aes entry
+    MV_U8 entry[AES_KEY_SPI_ENTRY_NUMBER]; // available / not available
+    MV_U8 reserved[2];
+}aes_entry_info,*Paes_entry_info;
+
+typedef struct _entry_link
+{
+    MV_U8       port_id;
+    MV_U8       entry;
+    MV_U8       reserved[6];                            // for 64 bit align
+    MV_U8       user_auth[AES_KEY_CONTENT_LENGTH];      // user authentication key 32 bytes.
+} entry_link, *Pentry_link;
+
+typedef struct _AES_Entry_Config {
+    MV_U8       entry_id;                               //SPI entry 0~9
+    MV_U8       key_length;                             //0: remove, 16: 128bit, 32: 256bit, 0xFF: no change
+    MV_U8       reserved[6];                            // for 64 bit align
+    MV_U8       key_content[AES_KEY_CONTENT_LENGTH];    // Fill up 128 bit or 256 bit key.
+    MV_U8       user_auth[AES_KEY_CONTENT_LENGTH];      // user authentication key 32 bytes.
+} AES_Entry_Config, *PAES_Entry_Config;
+
+typedef struct _AES_Port_Config{
+    MV_U8       port_id;
+    MV_BOOLEAN  aes_enable;
+    MV_U8       reserved[6];
+} AES_Port_Config, *PAES_Port_Config;
+
+typedef struct _AES_Entry_Verify {
+    MV_U8       entry_id;                               //SPI entry 0~9
+    MV_U8       key_length;                             //16: 128bit, 32: 256bit
+    MV_U8       reserved[6];                            // for 64 bit align
+    MV_U8       key_content[AES_KEY_CONTENT_LENGTH];    // Fill up 128 bit or 256 bit key.
+    MV_U8       user_auth[AES_KEY_CONTENT_LENGTH];      // user authentication key 32 bytes.
+} AES_Entry_Verify, *PAES_Entry_Verify;
+
+typedef struct _AES_Change_Passwd {
+    MV_U8       entry_id;                               // SPI entry 0~9
+    MV_U8       reserved[7];                            // for 64 bit align
+    MV_U8       old_user_auth[AES_KEY_CONTENT_LENGTH];  // user authentication key 32 bytes.
+    MV_U8       new_user_auth[AES_KEY_CONTENT_LENGTH];  // user authentication key 32 bytes.
+} AES_Change_Passwd, *PAES_Change_Passwd;
+
+typedef struct _AES_PORT_INFO
+{
+    MV_U8       id;
+    MV_U8       entry;
+    MV_U8       Reserved[6]; //Align to 64bits
+} AES_PORT_INFO, *PAES_PORT_INFO;
+
+#define AES_ENTRY_STATUS_AVAILABLE           1
+#define AES_ENTRY_STATUS_NOT_AVAILABLE       0
+
+typedef struct _AES_KEY_ENTRY_INFO
+{
+    MV_U8        id;
+    MV_U8        status;//AES_ENTRY_STATUS_XXXXXX
+    MV_U8        Reserved[6]; //Align to 64bits
+} AES_KEY_ENTRY_INFO, *PAES_KEY_ENTRY_INFO;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_api.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_api.h
--- linux-3.10.69/drivers/scsi/mv/include/com_api.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_api.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,289 @@
+#ifndef  __MV_COM_API_H__
+#define  __MV_COM_API_H__
+
+#define APICDB15_VARIABLE_SIZE_REQUEST			1
+
+/* CDB definitions */
+#define APICDB0_ADAPTER                        0xF0
+#define APICDB0_LD                             0xF1
+#define APICDB0_BLOCK                          0xF2
+#define APICDB0_PD                             0xF3
+#define APICDB0_EVENT                          0xF4
+#define APICDB0_DBG                            0xF5
+#define APICDB0_FLASH                          0xF6
+#define APICDB0_AES                            0xF7
+
+#define APICDB0_IOCONTROL		 			   0xF9
+#define APICDB0_PASS_THRU_CMD_SCSI			   0xFA
+#define APICDB0_PASS_THRU_CMD_ATA			   0xFB
+#define APICDB0_PASS_THRU_COMMON			   0xFD
+
+/* Pass through for CDB[16].  The actually CDB is in the first 16 bytes of the input buffer. */
+#define APICDB0_PASS_THRU_CMD_SCSI_16          0xFC
+
+#define APICDB0_EXTENSION                      0xFF		// reserved, used only when 0xF0 to 0xFE above are all used up!
+
+/* for IOCONTROL */
+#define APICDB1_GET_OS_DISK_INFO		0
+#define APICDB1_SET_OS_DISK_QUEUE_DEPTH	1
+#define APICDB1_SET_OS_DISK_QUEUE_TYPE	2
+
+/* for Adapter */
+#define APICDB1_ADAPTER_GETCOUNT               0
+#define APICDB1_ADAPTER_GETINFO                (APICDB1_ADAPTER_GETCOUNT + 1)
+#define APICDB1_ADAPTER_GETCONFIG              (APICDB1_ADAPTER_GETCOUNT + 2)
+#define APICDB1_ADAPTER_SETCONFIG              (APICDB1_ADAPTER_GETCOUNT + 3)
+#define APICDB1_ADAPTER_POWER_STATE_CHANGE     (APICDB1_ADAPTER_GETCOUNT + 4)
+#define APICDB1_ADAPTER_BBU_INFO               (APICDB1_ADAPTER_GETCOUNT + 5)
+#define APICDB1_ADAPTER_BBU_SET_THRESHOLD      (APICDB1_ADAPTER_GETCOUNT + 6)
+#define APICDB1_ADAPTER_BBU_POWER_CHANGE       (APICDB1_ADAPTER_GETCOUNT + 7)
+#define APICDB1_ADAPTER_AES_GETCONFIG          (APICDB1_ADAPTER_GETCOUNT + 8)
+#define APICDB1_ADAPTER_AES_SETCONFIG          (APICDB1_ADAPTER_GETCOUNT + 9)
+#define APICDB1_ADAPTER_BBU_SETSTATUS_DBG      (APICDB1_ADAPTER_GETCOUNT + 10)// only for test BBU function
+#define APICDB1_ADAPTER_MUTE                   (APICDB1_ADAPTER_GETCOUNT + 11)
+#define APICDB1_ADAPTER_ROOT_RESET             (APICDB1_ADAPTER_GETCOUNT + 12)
+#define APICDB1_ADAPTER_SET_HOST_BUFFER        (APICDB1_ADAPTER_GETCOUNT + 13)
+#define APICDB1_ADAPTER_READ_REGISTER          (APICDB1_ADAPTER_GETCOUNT + 14)
+#define APICDB1_ADAPTER_WRITE_REGISTER         (APICDB1_ADAPTER_GETCOUNT + 15)
+#define APICDB1_ADAPTER_OEM_GET_DATA           (APICDB1_ADAPTER_GETCOUNT + 16)
+#define APICDB1_ADAPTER_OEM_SET_DATA           (APICDB1_ADAPTER_GETCOUNT + 17)
+#define APICDB1_ADAPTER_GET_SENSOR_DATA        (APICDB1_ADAPTER_GETCOUNT + 18)
+#define APICDB1_ADAPTER_MAX                    (APICDB1_ADAPTER_GETCOUNT + 19)
+
+#define APICDB1_ADAPTER_BBU_CHARGE_THRESHOLD   (APICDB1_ADAPTER_GETCOUNT + 6)
+
+#define APICDB2_ADAPTER_POWER_CHANGE_LEAVING_S0   0
+#define APICDB2_ADAPTER_POWER_CHANGE_ENTER_S0     1
+#define APICDB2_ADAPTER_POWER_CHANGE_SHUTDOWN     2
+
+/* for LD */
+#define APICDB1_LD_CREATE                      0
+#define APICDB1_LD_GETMAXSIZE                  (APICDB1_LD_CREATE + 1)
+#define APICDB1_LD_GETINFO                     (APICDB1_LD_CREATE + 2)
+#define APICDB1_LD_GETTARGETLDINFO             (APICDB1_LD_CREATE + 3)
+#define APICDB1_LD_DELETE                      (APICDB1_LD_CREATE + 4)
+#define APICDB1_LD_GETSTATUS                   (APICDB1_LD_CREATE + 5)
+#define APICDB1_LD_GETCONFIG                   (APICDB1_LD_CREATE + 6)
+#define APICDB1_LD_SETCONFIG                   (APICDB1_LD_CREATE + 7)
+#define APICDB1_LD_STARTREBUILD                (APICDB1_LD_CREATE + 8)	// single target rebuild on VD only (see APICDB1_LD_DG_STARTREBUILD)
+#define APICDB1_LD_STARTCONSISTENCYCHECK       (APICDB1_LD_CREATE + 9)
+#define APICDB1_LD_STARTINIT                   (APICDB1_LD_CREATE + 10)
+#define APICDB1_LD_STARTMIGRATION              (APICDB1_LD_CREATE + 11)
+#define APICDB1_LD_BGACONTROL                  (APICDB1_LD_CREATE + 12)
+#define APICDB1_LD_WIPEMDD                     (APICDB1_LD_CREATE + 13)
+#define APICDB1_LD_GETSPARESTATUS              (APICDB1_LD_CREATE + 14)
+#define APICDB1_LD_SETGLOBALSPARE              (APICDB1_LD_CREATE + 15)
+#define APICDB1_LD_SETLDSPARE                  (APICDB1_LD_CREATE + 16)
+#define APICDB1_LD_REMOVESPARE                 (APICDB1_LD_CREATE + 17)
+#define APICDB1_LD_HD_SETSTATUS                (APICDB1_LD_CREATE + 18)
+#define APICDB1_LD_SHUTDOWN                    (APICDB1_LD_CREATE + 19)
+#define APICDB1_LD_HD_FREE_SPACE_INFO          (APICDB1_LD_CREATE + 20)
+#define APICDB1_LD_HD_GETMBRINFO               (APICDB1_LD_CREATE + 21)
+#define APICDB1_LD_SIZEOF_MIGRATE_TARGET       (APICDB1_LD_CREATE + 22)
+#define APICDB1_LD_TARGET_LUN_TYPE			   (APICDB1_LD_CREATE + 23)
+#define APICDB1_LD_HD_START_MEDIAPATROL        (APICDB1_LD_CREATE + 24)
+#define APICDB1_LD_HD_RESERVED				   (APICDB1_LD_CREATE + 25)
+#define APICDB1_LD_HD_GET_RCT_COUNT            (APICDB1_LD_CREATE + 26)
+#define APICDB1_LD_HD_RCT_REPORT               (APICDB1_LD_CREATE + 27)
+#define APICDB1_LD_HD_START_DATASCRUB          (APICDB1_LD_CREATE + 28)
+#define APICDB1_LD_HD_BGACONTROL	           (APICDB1_LD_CREATE + 29)
+#define APICDB1_LD_HD_GETBGASTATUS             (APICDB1_LD_CREATE + 30)
+#define APICDB1_LD_CREATE_MODIFY_DG			   (APICDB1_LD_CREATE + 31)	// Create or modify Disk Group (DG)
+#define APICDB1_LD_CREATE_MODIFY_VD			   (APICDB1_LD_CREATE + 32)	// Create or modify VD using DG
+#define APICDB1_LD_DELETE_DG				   (APICDB1_LD_CREATE + 33)	// Delete DG
+#define APICDB1_LD_GET_DG_INFO				   (APICDB1_LD_CREATE + 34)	// Get DG info
+#define APICDB1_LD_DG_STARTREBUILD			   (APICDB1_LD_CREATE + 35) // Start rebuild on VD or DG with one or multiple target (see APICDB1_LD_STARTREBUILD)
+#define APICDB1_LD_DG_STARTCONSISTENCYCHECK    (APICDB1_LD_CREATE + 36) // Start sync on DG
+#define APICDB1_LD_DG_STARTINIT                (APICDB1_LD_CREATE + 37)	// Start init on DG
+#define APICDB1_LD_DG_STARTMIGRATION           (APICDB1_LD_CREATE + 38) // Start migration on DG
+#define APICDB1_LD_DG_BGACONTROL               (APICDB1_LD_CREATE + 39) // BGA control on DG
+#define APICDB1_LD_RESERVED1                   (APICDB1_LD_CREATE + 40) // Reserved, can be re-used!
+#define APICDB1_LD_SET_DG_SPARE                (APICDB1_LD_CREATE + 41)
+#define APICDB1_LD_DG_GETSETTING               (APICDB1_LD_CREATE + 42)
+#define APICDB1_LD_DG_SETSETTING               (APICDB1_LD_CREATE + 43)
+#define APICDB1_LD_COPYBACK                    (APICDB1_LD_CREATE + 44) // Currently internal used by RAID core
+#define APICDB1_LD_IMPORT                      (APICDB1_LD_CREATE + 45)
+#define APICDB1_LD_GET_WORKING_LD 		       (APICDB1_LD_CREATE + 46)
+#define APICDB1_LD_REPORTED_LD		           (APICDB1_LD_CREATE + 47) // used to report the LD to OS
+#define APICDB1_LD_GETCROSSINFO		           (APICDB1_LD_CREATE + 48)
+#define APICDB1_LD_GETHYPERFREEINFO            (APICDB1_LD_CREATE + 49)
+#define APICDB1_LD_FS_ENTRIES                  (APICDB1_LD_CREATE + 50)
+#define APICDB1_LD_REMOVE_ENTRIES_TABLE        (APICDB1_LD_CREATE + 51)
+#define APICDB1_LD_GET_ENTRIES_TABLE           (APICDB1_LD_CREATE + 52)
+#define APICDB1_LD_HYPERDUO_MAP_SYSTEM         (APICDB1_LD_CREATE + 53)
+#define APICDB1_HYPERDUO_GET_MAP_SYSTEM        (APICDB1_LD_CREATE + 54)
+#define APICDB1_HYPERDUO_REMOVE_ALL_MAP_SYSTEM (APICDB1_LD_CREATE + 55)
+#define APICDB1_LD_GET_HDD_LINK                (APICDB1_LD_CREATE + 56)
+#define APICDB1_LD_ADD_HDD_LINK                (APICDB1_LD_CREATE + 57)
+#define APICDB1_LD_MAX                         (APICDB1_LD_CREATE + 58)
+
+/* for PD */
+#define APICDB1_PD_GETHD_INFO                  0
+#define APICDB1_PD_GETEXPANDER_INFO            (APICDB1_PD_GETHD_INFO + 1)
+#define APICDB1_PD_GETPM_INFO                  (APICDB1_PD_GETHD_INFO + 2)
+#define APICDB1_PD_GETSETTING                  (APICDB1_PD_GETHD_INFO + 3)
+#define APICDB1_PD_SETSETTING                  (APICDB1_PD_GETHD_INFO + 4)
+#define APICDB1_PD_BSL_DUMP                    (APICDB1_PD_GETHD_INFO + 5)
+#define APICDB1_PD_GETENCLOSURE_INFO		   (APICDB1_PD_GETHD_INFO + 6)
+#define APICDB1_PD_RESERVED2				   (APICDB1_PD_GETHD_INFO + 7)	// not used
+#define APICDB1_PD_GETSTATUS                   (APICDB1_PD_GETHD_INFO + 8)
+#define APICDB1_PD_GETHD_INFO_EXT              (APICDB1_PD_GETHD_INFO + 9)	// APICDB1_PD_GETHD_INFO extension
+#define APICDB1_PD_VERIFY_DISK                 (APICDB1_PD_GETHD_INFO + 10)
+#define APICDB1_PD_FORMATUNIT_DISK             (APICDB1_PD_GETHD_INFO + 11)
+#define APICDB1_PD_GET_PERCENTAGE              (APICDB1_PD_GETHD_INFO + 12)
+#define APICDB1_PD_FORCE_ONLINE				   (APICDB1_PD_GETHD_INFO + 13) // cdb[2] is did;  force disk online that be offlined by AES protection method.
+#ifdef SUPPORT_SECURITY_FEATURE
+#define APICDB1_PD_SECURITY_FEATURE		(APICDB1_PD_GETHD_INFO + 14)
+#define APICDB1_PD_MAX						(APICDB1_PD_GETHD_INFO + 15)
+#else
+#define APICDB1_PD_MAX						(APICDB1_PD_GETHD_INFO + 14)
+#endif
+
+/* Sub command for APICDB1_PD_SETSETTING */
+#define APICDB4_PD_SET_WRITE_CACHE_OFF         0
+#define APICDB4_PD_SET_WRITE_CACHE_ON          1
+#define APICDB4_PD_SET_SMART_OFF               2
+#define APICDB4_PD_SET_SMART_ON                3
+#define APICDB4_PD_SMART_RETURN_STATUS         4
+#define APICDB4_PD_SET_SPEED_3G				   5
+#define APICDB4_PD_SET_SPEED_1_5G			   6
+#define APICDB4_PD_GET_SMART_INFO			   7
+
+/* for Block */
+#define APICDB1_BLOCK_GETINFO                  0
+#define APICDB1_BLOCK_HD_BLOCKIDS              (APICDB1_BLOCK_GETINFO + 1)
+#define APICDB1_BLOCK_MAX                      (APICDB1_BLOCK_GETINFO + 2)
+
+/* for event */
+#define APICDB1_EVENT_GETEVENT                 0
+#define APICDB1_HOST_GETEVENT                  1
+#define APICDB1_EVENT_MAX                      (APICDB1_HOST_GETEVENT + 1)
+
+/* for DBG */
+#define APICDB1_DBG_PDWR                       0
+#define APICDB1_DBG_MAP						   (APICDB1_DBG_PDWR + 1)
+#define APICDB1_DBG_LDWR					   (APICDB1_DBG_PDWR + 2)
+#define APICDB1_DBG_ADD_RCT_ENTRY			   (APICDB1_DBG_PDWR + 3)
+#define APICDB1_DBG_REMOVE_RCT_ENTRY		   (APICDB1_DBG_PDWR + 4)
+#define APICDB1_DBG_REMOVE_ALL_RCT			   (APICDB1_DBG_PDWR + 5)
+#define APICDB1_DBG_ADD_CORE_ERROR			   (APICDB1_DBG_PDWR + 6)
+#define APICDB1_DBG_REMOVE_CORE_ERROR		   (APICDB1_DBG_PDWR + 7)
+#define APICDB1_DBG_REMOVE_ALL_CORE_ERROR	   (APICDB1_DBG_PDWR + 8)
+#define APICDB1_DBG_GET_CORE_ERROR		       (APICDB1_DBG_PDWR + 9)
+
+#define APICDB1_DBG_ABORT_TASK                 (APICDB1_DBG_PDWR + 10)
+#define APICDB1_DBG_SMP_PHY_CTL				   (APICDB1_DBG_PDWR + 11)
+#define APICDB1_DBG_MAX						   (APICDB1_DBG_PDWR + 12)
+
+
+#define DBG_REQUEST_READ						MV_BIT(0)
+#define DBG_REQUEST_WRITE						MV_BIT(1)
+#define DBG_REQUEST_VERIFY						MV_BIT(2)
+
+#define DBG_INJECT_TYPE_NORMAL				MV_BIT(0)
+#define DBG_INJECT_TYPE_HW				MV_BIT(1)
+
+/* for FLASH */
+#define APICDB1_FLASH_BIN                      0
+#define APICDB1_ERASE_FLASH	                   (APICDB1_FLASH_BIN + 1)
+#define APICDB1_TEST_FLASH                     (APICDB1_FLASH_BIN + 2)
+#define APICDB1_BUFFER_DETAIL_FLASH            (APICDB1_FLASH_BIN + 3)
+#define APICDB1_FLASH_NVSRAM                   (APICDB1_FLASH_BIN + 4) // WD request
+#define APICDB1_FLASH_PRE_DATA                 (APICDB1_FLASH_BIN + 5) // WD request
+#define APICDB1_FLASH_MAX                      (APICDB1_FLASH_BIN + 6)
+
+/* for AES */
+#define APICDB1_AES_INFO          		0 //For Magni used only
+#define APICDB1_AES_SET_LINK		    (APICDB1_AES_INFO + 1)
+#define APICDB1_AES_CLEAR_LINK          (APICDB1_AES_INFO + 2)
+#define APICDB1_AES_GETPORTCONFIG		(APICDB1_AES_INFO + 3)  
+#define APICDB1_AES_SETPORTCONFIG		(APICDB1_AES_INFO + 4)  
+#define APICDB1_AES_GETENTRYCONFIG		(APICDB1_AES_INFO + 5) //For Magni used only
+#define APICDB1_AES_SETENTRYCONFIG		(APICDB1_AES_INFO + 6)  
+#define APICDB1_AES_VERIFY_KEY          (APICDB1_AES_INFO + 7) //For Magni used only
+#define APICDB1_AES_CHANGE_PASSWORD     (APICDB1_AES_INFO + 8)
+#define APICDB1_AES_PORT_INFO           (APICDB1_AES_INFO + 9)  /*For Magni-Plus*/
+#define APICDB1_AES_KEY_ENTRY_INFO          (APICDB1_AES_INFO + 10)  /*For Magni-Plus*/
+
+/* for passthru commands
+	Cdb[0]: APICDB0_PASS_THRU_CMD_SCSI or APICDB0_PASS_THRU_CMD_ATA
+	Cdb[1]: APICDB1 (Data flow)
+	Cdb[2]: TargetID MSB
+	Cdb[3]: TargetID LSB
+	Cdb[4]-Cdb[15]: SCSI/ATA command is embedded here
+		SCSI command: SCSI command Cdb bytes is in the same order as the spec
+		ATA Command:
+			Features = pReq->Cdb[0];
+			Sector_Count = pReq->Cdb[1];
+			LBA_Low = pReq->Cdb[2];
+			LBA_Mid = pReq->Cdb[3];
+			LBA_High = pReq->Cdb[4];
+			Device = pReq->Cdb[5];
+			Command = pReq->Cdb[6];
+
+			if necessary:
+			Feature_Exp = pReq->Cdb[7];
+			Sector_Count_Exp = pReq->Cdb[8];
+			LBA_Low_Exp = pReq->Cdb[9];
+			LBA_Mid_Exp = pReq->Cdb[10];
+			LBA_High_Exp = pReq->Cdb[11];
+*/
+#define APICDB0_PASS_THRU_CMD_SCSI			      0xFA
+#define APICDB0_PASS_THRU_CMD_ATA				  0xFB
+
+#define APICDB1_SCSI_NON_DATA					  0x00
+#define APICDB1_SCSI_PIO_IN					  0x01 // goes with Read Long
+#define APICDB1_SCSI_PIO_OUT					  0x02 // goes with Write Long
+
+#define APICDB1_ATA_NON_DATA					  0x00
+#define APICDB1_ATA_PIO_IN						  0x01
+#define APICDB1_ATA_PIO_OUT				         0x02
+
+#define API_SCSI_CMD_RCV_DIAG_RSLT			  0x1C
+#define API_SCSI_CMD_SND_DIAG					  0x1D
+
+#define API_GENERIC						0xD1
+#define APICDB0_PHY                          		(API_GENERIC + 1)
+#define APICDB0_I2C 						(API_GENERIC + 2)
+#define APICDB0_NVSRAM					(API_GENERIC + 3)
+#define APICDB0_SGPIO 					(API_GENERIC + 4)
+#define APICDB0_BUZZER 					(API_GENERIC + 5)
+#define APICDB0_LED						(API_GENERIC + 6)
+#define APICDB0_BIST					(API_GENERIC + 7)
+
+#define APICDB1_PHY       					 0
+#define APICDB1_PHY_TEST		    		 (APICDB1_PHY + 1)
+#define APICDB1_PHY_STATUS		    		 (APICDB1_PHY + 2)
+#define APICDB1_PHY_CONFIG                   (APICDB1_PHY + 3)
+#define APICDB1_PHY_SET_CONFIG               (APICDB1_PHY + 4)
+#define APICDB1_PHY_GET_CONFIG               (APICDB1_PHY + 5)
+
+
+#define APICDB1_SGPIO               			0
+#define APICDB1_SGPIO_TEST                  	(APICDB1_SGPIO + 1)
+
+#define APICDB1_BUZZER 					0
+#define APICDB1_BUZZER_OFF				(APICDB1_BUZZER + 1)
+#define APICDB1_BUZZER_ON				(APICDB1_BUZZER + 2)
+#define APICDB1_BUZZER_MUTE				(APICDB1_BUZZER + 3)
+
+#define APICDB1_LED						0
+#define APICDB1_LED_ACT_OFF			(APICDB1_LED + 1)
+#define APICDB1_LED_ACT_ON				(APICDB1_LED + 2)
+#define APICDB1_LED_FLT_OFF			(APICDB1_LED + 3)
+#define APICDB1_LED_FLT_ON				(APICDB1_LED + 4)
+
+#define APICDB1_BIST      					0
+#define APICDB1_BIST_TEST		    	 	(APICDB1_BIST + 1)
+
+#define APICDB2_SSD_INIT 				0xF0
+#define APICDB2_SSD_SAFECODE_MODE	(APICDB2_SSD_INIT + 1)
+#define APICDB2_SSD_DO_RESET			(APICDB2_SSD_INIT + 2)
+#define APICDB2_SSD_NORMAL_MODE		(APICDB2_SSD_INIT + 3)
+#define APICDB2_SSD_DETECT_PHY_READY (APICDB2_SSD_INIT + 4)
+
+#define APICDB1_ATA_PD                      0
+#define APICDB1_ATA_MAX                     (APICDB1_ATA_PD + 1)
+
+#endif /*  __MV_COM_API_H__ */
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_array_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_array_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_array_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_array_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,130 @@
+#ifndef __MV_COM_ARRAY_STRUCT_H__
+#define __MV_COM_ARRAY_STRUCT_H__
+
+#if !defined(_MARVELL_SDK_PACKAGE_NONRAID)
+
+#include "com_raid_struct.h"
+#include "com_vd_struct.h"
+
+#ifndef _OS_BIOS
+#define MAX_DG_SUPPORTED_API                    64
+#endif
+
+#define DG_STATUS_FUNCTIONAL                    0
+#define DG_STATUS_PD_MISSING                    1
+#define DG_STATUS_PD_OFFLINE                    2
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _CreateOrModify_DG_Param
+{
+	MV_U16     DGID;                        // <=> InstanceID
+	MV_U8      Reserved1[2];
+	MV_U8      Name[LD_MAX_NAME_LENGTH];    // <=> ElementName.
+	MV_U8      RaidMode;                    // <=> Goal
+	MV_U8      SubVDCount;                  // for raid 10, 50, 60
+	MV_U8      NumParityDisk;               // for RAID 6
+	MV_U8      Reserved2[7];
+	MV_U16     StripeBlockSize;             // <=> Goal.UserDataStripeDepth (between API and driver, it is # of BlockSize)
+	MV_U64     Size;                        // <=> Size (in unit of BlockSize to/from driver)
+	MV_U32     BlockSize;                   // returned from driver (in byte)
+	MV_U8      InitializationOption;        // refer to INIT_XXXX
+#ifdef LACIE_THUNDERBOLT
+	MV_U8      Reserved3;
+	MV_U8	  CreateSpare;
+#else
+	MV_U8      Reserved3[2];
+#endif
+	MV_U8      PDCount;
+	MV_U16     PDIDs[MAX_HD_SUPPORTED_API]; // <=> InExtents[]
+	MV_U8      Reserved4[128];
+} CreateOrModify_DG_Param, * PCreateOrModify_DG_Param;
+
+typedef struct  _CreateOrModify_VD_Param
+{
+	MV_U16     VDID;                      // <=> DeviceID
+	MV_U16     DGID;                      // <=> InPool  (parent pool)
+	MV_U8      Name[LD_MAX_NAME_LENGTH];  // <=> ElementName
+	MV_U8      RaidMode;                  // <=> Goal
+	MV_U8      SubVDCount;                // for raid 10, 50, 60
+	MV_U8      NumParityDisk;             // for RAID 6
+	MV_U8      DGSlotNum;                 // Specify which DG slot the VD will be created upon. If set to 0xFF, driver will pick a slot with closest specified size.
+	MV_U8      Reserved1[6];
+	MV_U16     StripeBlockSize;           // <=> Goal.UserDataStripeDepth (between API and driver, it is # of BlockSize)
+	MV_U64     Size;                      // <=> Size (in unit of BlockSize to/from driver)
+
+	MV_U8      RoundingScheme;            // refer to ROUNDING_SCHEME_XXX
+	MV_U8      CachePolicy;               // refer to CACHEMODE_XXXX
+	MV_U8      InitializationOption;      //  refer to INIT_XXXX.
+	MV_U8      SectorCoefficient;         // (sector size) 1=>512 (default)
+	MV_U32     BlockSize;                 // used to calculate StripeBlockSize.
+	MV_U8      Reserved[256];
+} CreateOrModify_VD_Param, * PCreateOrModify_VD_Param;
+
+typedef struct _DG_Info
+{
+	MV_U16     DGID;                      // <=> InstanceID
+	MV_U8      Reserved1[2];
+	MV_U8      Name[LD_MAX_NAME_LENGTH];  // <=> ElementName
+	// other properties proprietary to Marvell
+	MV_U8      RaidMode;
+	MV_U8      SubVDCount;                // for raid 10, 50, 60
+	MV_U8      NumParityDisk;             // for RAID 6
+	MV_U8      AdapterID;
+
+	MV_U8      Reserved2[2];
+	MV_U16     StripeBlockSize;           // between RAIDAPI and driver, it is # of BlockSize
+	MV_U32     BlockSize;                 // disk block size
+
+	MV_U64     TotalManagedSpace;         // <=> TotalManagedSpace (in unit of BlockSize between API and driver)
+	MV_U64     RemainingManagedSpace;     // <=> RemainingManagedSpace in unit of BlockSize between API and driver)
+	MV_U64     SmallestAvailablePDSize;   // Available size of the smallest PD in this DG in unit of BlockSize between API and driver
+	MV_U8      Status;                    // OperationalStatus, refer to DG_STATUS_xxx
+	MV_BOOLEAN PDBgaRunning;
+	MV_U8      Reserved3;
+	MV_U8      PDCount;
+	MV_U16     PDIDs[MAX_HD_SUPPORTED_API];
+	MV_U8      Reserved4[3];
+	// VD slots are contiguous space in DG with existing VD on it or can be used to create VD.
+	// If VD created on empty slot does not use up all its slot space, the remaing space will be used to create
+	// another slot unless total slots number reaches MaxVDPerDG as defined in Adapter_Info. When total slots reaches
+	// it maximum number, VD created on the slot has to use up all its space.
+	MV_U8      VDSlotCount;						// current number of slots in DG
+	MV_U64     VDSlotSize[MAX_LD_SUPPORTED_API]; // size of each slot (including slot with VD)
+	MV_U16     VDIDs[MAX_LD_SUPPORTED_API];		 // VD ID corresponding to above slot. Entries with 0xFFFF means empty slot
+	MV_U8      Reserved5[3];
+	MV_U8      SparePDCount;
+	MV_U16     SparePDIDs[MAX_SPARE_PD_SUPPORTED_API];
+	MV_U16     BgaType;
+	MV_U8      BgaState;
+	MV_U8      Reserved6[25];
+} DG_Info, *PDG_Info;
+
+// Returning all PDs (and its status) that are not used by any DG on given adapter including spare, offline PD etc.
+typedef struct _PD_NotInAny_DG
+{
+	MV_U8      AdapterID;
+	MV_U8      Reserved1[1];
+	MV_U16     PDCount;
+	MV_U16     PDIDs[MAX_HD_SUPPORTED_API];
+	MV_U8      Status[MAX_HD_SUPPORTED_API];   // Status of the corresponding PD in PDIDs above.  Refer to HD_STATUS_XXX.
+	MV_U8      Reserved2[252];
+} PD_NotInAny_DG, *PPD_NotInAny_DG;
+
+typedef struct _DG_CONFIG
+{
+	MV_U16            DGID;
+	MV_BOOLEAN        WriteCacheOn;            // 1: enable write cache
+	MV_U8             Reserved;
+	MV_U8             Name[LD_MAX_NAME_LENGTH];  // DG Name
+	MV_U8             Reserved1[12];
+}DG_Config, *PDG_Config;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+#endif
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_ata_pass_through.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_ata_pass_through.h
--- linux-3.10.69/drivers/scsi/mv/include/com_ata_pass_through.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_ata_pass_through.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef __MV_ATA_PASS_THROUGH_STRUCT_H__
+#define __MV_ATA_PASS_THROUGH_STRUCT_H__
+
+#include "com_define.h"
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _ATA_REGS
+{
+	MV_U8     drive_regs[7];
+	MV_U8     bReserved;
+	MV_U16    buffer_size;
+	MV_U8     reserved[6];
+	MV_U8     data[1];
+}ATA_REGS,*PATA_REGS;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_bbu_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_bbu_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_bbu_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_bbu_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,97 @@
+#ifndef __MV_COM_BBU_STRUCT_H__
+#define __MV_COM_BBU_STRUCT_H__
+
+#include "com_define.h"
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+/* battery status */
+#define BBU_STATUS_NOT_PRESENT          0
+#define BBU_STATUS_PRESENT              MV_BIT(0)
+#define BBU_STATUS_LOW_BATTERY          MV_BIT(1)
+#define BBU_STATUS_CHARGING             MV_BIT(2)
+#define BBU_STATUS_FULL_CHARGED         MV_BIT(3)
+#define BBU_STATUS_DISCHARGE            MV_BIT(4)
+#define BBU_STATUS_RELEARN              MV_BIT(5)
+#define BBU_STATUS_OVER_TEMP_WARNING    MV_BIT(6)
+#define BBU_STATUS_OVER_TEMP_ERROR      MV_BIT(7)
+#define BBU_STATUS_UNDER_TEMP_WARNING   MV_BIT(8)
+#define BBU_STATUS_UNDER_TEMP_ERROR     MV_BIT(9)
+#define BBU_STATUS_OVER_VOLT_WARNING    MV_BIT(10)
+#define BBU_STATUS_OVER_VOLT_ERROR      MV_BIT(11)
+#define BBU_STATUS_UNDER_VOLT_WARNING   MV_BIT(12)
+#define BBU_STATUS_UNDER_VOLT_ERROR     MV_BIT(13)
+#define BBU_STATUS_GREATER_LOWERBOUND	MV_BIT(14)
+#define BBU_STATUS_POWER_STOP_ALL	MV_BIT(15)
+
+#define BBU_NOT_PRESENT         0
+#define BBU_NORMAL                   1
+#define BBU_ABNORMAL               2
+
+#define BBU_SUPPORT_NONE                 0
+#define BBU_SUPPORT_SENSOR_TEMPERATURE   MV_BIT(0)
+#define BBU_SUPPORT_SENSOR_VOLTAGE       MV_BIT(1)
+#define BBU_SUPPORT_SENSOR_ECAPACITY     MV_BIT(2)
+#define BBU_SUPPORT_CHANGE_MAXEC         MV_BIT(3)
+#define BBU_SUPPORT_RELEARN              MV_BIT(4)
+
+#define BBU_SENSOR_NOTSUPPORT    0
+#define BBU_SENSOR_TEMPERATURE   MV_BIT(0)
+#define BBU_SENSOR_VOLTAGE       MV_BIT(1)
+#define BBU_SENSOR_ECAPACITY     MV_BIT(2)
+#define BBU_CHANGE_MAXEC         MV_BIT(3)
+#define BBU_SUPPORT_RELEARN      MV_BIT(4)
+
+#define BBU_FLAG_EDVF            MV_BIT(0)
+#define BBU_FLAG_EDV1            MV_BIT(1)
+#define BBU_FLAG_NO_ACT          MV_BIT(6)
+#define BBU_FLAG_CHARGING        MV_BIT(7)
+
+#define BBU_MAX_RETRY_CHARGE_COUNT      10
+
+typedef struct _BBU_Info
+{
+    //Total 64 Bytes
+    MV_U32          status;
+    MV_U32          prev_status;
+    
+    MV_U16          voltage; /* unit is 1 mV */
+    MV_U16          supportMaxCapacity;
+    MV_U16          supportMinCapacity;
+    MV_U16          maxCapacity;
+    
+    MV_U16          curCapacity;
+    MV_U16          time_to_empty;
+    MV_U16          time_to_full;
+    MV_U16          recharge_cycle;
+
+    MV_U16          featureSupport;
+    MV_I16          temperature; /*unit is 0.01 Celsius */
+    MV_U16           volt_lowerbound;
+    MV_U16           volt_upperbound;
+    
+    MV_U8           temp_lowerbound;
+    MV_U8           temp_upperbound;
+    MV_U8           percentage;			// current percentage of barrtery capacity.
+    MV_U8           percent_to_charge;	// if percentage is lower than this number,it should begin to charge.
+    MV_U8           flags;
+    MV_U8           stop_charge_count;
+    MV_U8           last_notify_state;
+	MV_U8           reserved2[25];
+} BBU_Info, *PBBU_Info;
+
+#define BBU_ACT_RELEARN          0
+#define BBU_ACT_FORCE_CHARGE     1
+#define BBU_ACT_FORCE_DISCHARGE  2
+#define BBU_ACT_STOP_ALL         3
+
+#define BBU_THRESHOLD_TYPE_CAPACITY        0
+#define BBU_THRESHOLD_TYPE_TEMPERATURE     1
+#define BBU_THRESHOLD_TYPE_VOLTAGE         2
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_buffer.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_buffer.h
--- linux-3.10.69/drivers/scsi/mv/include/com_buffer.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_buffer.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,156 @@
+#ifndef __MV_COM_BUFFER_H__
+#define __MV_COM_BUFFER_H__
+#if !defined(MAGNI_PLUS)
+#include "com_define.h"
+#endif
+/*
+from document spc4r16.pdf
+READ BUFFER command (6.16) to download data (BIOS, firmware) from driver
+WRITE BUFFER command (6.39) to upload data (BIOS, firmware) to driver
+*/
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /*  _OS_BIOS */
+  typedef struct _MV_BUFFER_DETAIL {
+	MV_U8      PathID;
+	MV_U8      TargetID;
+	MV_U8      Lun;
+	MV_U8      VirtualID;
+	MV_U8      totalSizeHigh;     			//third byte of 24 bits  total size  [16-23] bit
+	MV_U8      totalSizeMiddle;  			//second byte of 24 bits  total size  [8-15] bit
+	MV_U8      totalSizeLow;      			//first byte of 24 bits  total size [0-7] bit
+	MV_U8      startBufferID;
+	MV_U8      startBufferOffsetHigh;    	// third byte of 24 bits  total size  [16-23] bit
+	MV_U8      startBufferOffsetMiddle; 	// second byte of 24 bits  total size  [8-15] bit
+	MV_U8      startBufferOffsetLow;     	// first byte of 24 bits  total size  [0-7] bit
+	MV_U8      reserved[5];
+	MV_U64    Generation;
+  } MV_BUFFER_DETAIL,*PMV_BUFFER_DETAIL;
+
+#define    BUFFER_TYPE_START            0
+#define    BUFFER_TYPE_CONFIG           0 // HBA info Page
+#define    BUFFER_TYPE_BIN              1
+#define    BUFFER_TYPE_BIOS             2 //BIOS
+#define    BUFFER_TYPE_FIRMWARE         3 //firmware
+#define    BUFFER_TYPE_AUTOLOAD         4 //
+#define    BUFFER_TYPE_NVSRAM           5
+#define    BUFFER_TYPE_RAW              6
+#define    BUFFER_TYPE_MAX              7
+
+//table 181 READ BUFFER command
+
+typedef struct _MV_READ_BUFFER_COMMAND{
+	MV_U8    operationCode;
+	MV_U8    mode:5;                    		//mode code
+	MV_U8    reserved:3;
+	MV_U8    bufferID;
+	MV_U8    bufferOffsetHigh;            	//third byte of 24 bits buffersize   [16-23] bit
+	MV_U8    bufferOffsetMiddle;         	//second byte of 24 bits buffersize  [8-15] bit
+	MV_U8    bufferOffsetLow;             	//first byte of 24 bits buffersize   [0-7] bit
+	MV_U8    allocationOffsetHigh;       	//third byte of 24 bits allocation offset  [16-23] bit
+	MV_U8    allocationOffsetMiddle;      	//second byte of 24 bits allocation offset [8-15] bit
+	MV_U8    allocationOffsetLow;         	//first byte of 24 bits allocation offset  [0-7] bit
+	MV_U8    control;
+} MV_READ_BUFFER_COMMAND;
+
+
+//table 182 READ BUFFER mode field
+#define READ_BUFFER_MODE_DATA                 0x2
+#define READ_BUFFER_MODE_DESCRIPTOR           0x3
+
+//table 181 READ BUFFER command
+
+typedef struct _MV_READ_BUFFER_DESCRIPTOR{
+	MV_U8    offsetBoundary;
+	MV_U8    capacityHigh;              //third byte of 24 bits capacity   [16-23] bit
+	MV_U8    capacityMiddle;           //second byte of 24 bits capacity  [8-15] bit
+	MV_U8    capacityLow;               //first byte of 24 bits capacity   [0-7] bit
+} MV_READ_BUFFER_DESCRIPTOR,*PMV_READ_BUFFER_DESCRIPTOR;
+
+
+#define READ_BUFFER_COMMAND_OPERATION          0x3c
+
+//table 196 WRITE BUFFER command
+typedef struct _MV_WRITE_BUFFER_COMMAND
+{
+	MV_U8     operationCode;
+	MV_U8     mode:5;
+	MV_U8     reserved:3;
+	MV_U8     bufferID;
+	MV_U8     bufferOffsetHigh;            	//third byte of 24 bits buffersize   [16-23] bit
+	MV_U8     bufferOffsetMiddle;         	//second byte of 24 bits buffersize  [8-15] bit
+	MV_U8     bufferOffsetLow;            	//first byte of 24 bits buffersize   [0-7] bit
+	MV_U8     parameterListHigh;             //third byte of 24 bits parameterList offset  [16-23] bit
+	MV_U8     parameterListMiddle;         //second byte of 24 bits parameterList offset [8-15] bit
+	MV_U8     parameterListLow;             //first byte of 24 bits parameterList offset  [0-7] bit
+	MV_U8     control;
+}MV_WRITE_BUFFER_COMMAND;
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /*  _OS_BIOS */
+
+#define WRITE_BUFFER_COMMAND_OPERATION		0x3b
+
+//table 197 WRITE BUFFER MODE field
+#define WRITE_BUFFER_MODE_DATA	0x2
+#define MAX_FLASH_BUFFER_OFFSET_BOUNDARY		0x0a  // 1K
+#define MAX_FLASH_BUFFER_CAPACITY_BIT_POWER	15
+// 1 Buffer is 32KB, current flash size is 8MB
+#define MAX_FLASH_BUFFER_ID						256
+#define MAX_FLASH_BUFFER_CAPACITY	MV_BIT(MAX_FLASH_BUFFER_CAPACITY_BIT_POWER) //32K
+#define FLASH_IMAGE_SIGNATURE "MV_FLASH"
+
+#pragma pack(1)
+typedef struct _FLASH_IMAGE_HEADER{
+	MV_U8	signature[8];
+	MV_U8	type;
+	MV_U8	version_major;
+	MV_U8	version_minor;
+	MV_U8	version_oem;
+	MV_U8	version_build_beta;
+	MV_U8	version_build_alpha;
+	MV_U32	image_length;
+	MV_U16	adapter_device_id;
+	MV_U8	reserved[40];
+	MV_U32	crc;
+}FLASH_IMAGE_HEADER,*PFLASH_IMAGE_HEADER;
+#pragma pack()
+
+typedef struct _FLASH_IMAGE_GENERATION{
+	MV_U32	value;
+	MV_U32	crc;
+}FLASH_IMAGE_GENERATION,*PFLASH_IMAGE_GENERATION;
+
+#ifdef SCSI_RW_BUFFER_CMD
+MV_BOOLEAN core_flash_operation_flash_data(
+	MV_VOID * p_core_ext,
+	MV_U8		buf_id,
+	MV_U32		offset,
+	MV_U32		alloc_len,
+	MV_PVOID	p_buffer,
+	MV_U8		opCode
+	);
+MV_VOID core_flash_get_flashbuf_offset_boundary(
+	MV_VOID *p_core_ext,
+	MV_PVOID 			p_buf_desc
+	);
+
+#ifdef FLASH_IMAGE_HEADER_CHECK
+MV_BOOLEAN core_flash_image_data_crc_check(
+	MV_VOID *p_core_ext,
+	MV_PVOID 			header,
+	MV_U8				last_buffer_id,
+	MV_U32				last_buffer_offset,
+	MV_PVOID			last_buffer
+	);
+MV_BOOLEAN core_flash_image_header_check(
+	MV_PVOID 			p_buffer,
+	PFLASH_IMAGE_HEADER	tmp_header
+	);
+MV_BOOLEAN core_flash_image_header_signature_check(
+	MV_PU8	signature
+	);
+#endif /* FLASH_IMAGE_HEADER_CHECK */
+
+#endif/* SCSI_RW_BUFFER_CMD */
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_cross_raid_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_cross_raid_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_cross_raid_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_cross_raid_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,26 @@
+#ifndef __MV_COM_CROSS_RAID_STRUCT_H__
+#define __MV_COM_CROSS_RAID_STRUCT_H__
+
+#if !defined(_MARVELL_SDK_PACKAGE_NONRAID)
+
+#include "com_raid_struct.h"
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _Cross_VD_Info
+{
+ MV_U16            ID;
+ MV_U8             Reserved1[6];
+
+ MV_U64            SSDStartLBA;/* SSD start LBA in the VD */
+ MV_U64            SSDEndLBA;/* SSD end LBA in the VD */          
+}Cross_VD_Info, *PCross_VD_Info;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+#endif
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_dbg.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_dbg.h
--- linux-3.10.69/drivers/scsi/mv/include/com_dbg.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_dbg.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,202 @@
+#if !defined(COMMON_DEBUG_H)
+#define COMMON_DEBUG_H
+
+/* 
+ *	Marvell Debug Interface
+ * 
+ *	MACRO
+ *		MV_DEBUG is defined in debug version not in release version.
+ *	
+ *	Debug funtions:
+ *		MV_PRINT:	print string in release and debug build.
+ *		MV_DPRINT:	print string in debug build.
+ *		MV_TRACE:	print string including file name, line number in release and debug build.
+ *		MV_DTRACE:	print string including file name, line number in debug build.
+ *		MV_ASSERT:	assert in release and debug build.
+ *		MV_DASSERT: assert in debug build.
+  *		MV_WARNON: warn in debug build.
+ */
+
+#include "com_define.h"
+/*
+ *
+ * Debug funtions
+ *
+ */
+
+/* For both debug and release version */
+#if defined(SIMULATOR)
+#   include <assert.h>
+#   define MV_PRINT printf
+#   define MV_ASSERT assert
+#   define MV_TRACE(_x_)                                   \
+              do {	                                   \
+                 MV_PRINT("%s(%d) ", __FILE__, __LINE__);  \
+                 MV_PRINT _x_;                             \
+	      } while (0)
+#   define MV_DUMP_SP()
+#elif defined(_OS_WINDOWS)
+	#if !defined(_OS_FIRMWARE)
+
+
+/* for VISTA */
+#   if (_WIN32_WINNT >= 0x0600)
+       ULONG _cdecl MV_PRINT(char* format, ...);
+#   else
+#      define MV_PRINT                      DbgPrint
+#   endif /* (_WIN32_WINNT >= 0x0600) */
+
+#   if (defined(_CPU_IA_64B) || defined(_CPU_AMD_64B))
+#      if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
+#         define NTAPI __stdcall
+#      else
+#         define NTAPI
+#      endif /* (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED) */
+	
+       void NTAPI DbgBreakPoint(void);
+#      define MV_ASSERT(_condition_)    \
+                 do { if (!(_condition_)) DbgBreakPoint(); } while(0)
+#   else
+#      define MV_ASSERT(_condition_)    \
+                 do { if (!(_condition_)) {__asm int 3}; } while(0)
+#   endif /*  (defined(_CPU_IA_64B) || defined(_CPU_AMD_64B)) */
+
+#   define MV_TRACE(_x_)                                        \
+              do {                                              \
+                 MV_PRINT("%s(%d) ", __FILE__, __LINE__);       \
+                 MV_PRINT _x_;                                  \
+              } while (0)
+	
+
+	#else /* _OS_FIRMWARE */
+		#define MV_TRACE(_x_)
+
+		#define FM_DBG_PRINT
+		#if !defined(FM_DBG_PRINT)
+			#define MV_PRINT(_x_, ...)		        
+			#define MV_ASSERT(_x_)
+
+			#define FM_PRINT(_x_, ...)		
+		#else
+			void __std_printf (const char *fmt, ...);
+			#define FM_PRINT			__std_printf
+			#define MV_PRINT		FM_PRINT
+			#define MV_ASSERT(_x_)	{															\
+				if ( !(_x_) ) {																	\
+					MV_DPRINT(("ASSERT FAILURE at %s %d %s!\n", __FILE__, __LINE__, __FUNCTION__));\
+				}	\
+			}
+
+		#endif	
+
+	#endif /* _OS_FIRMWARE */
+#define MV_DUMP_SP()
+#elif defined(_OS_LINUX)
+#define MV_PRINT(format, arg...) 	ossw_printk(format,##arg);
+#ifdef MV_LINUX_KGDB
+#define MV_ASSERT(_x_)                do{ if (!(_x_)) asm("int3");}while(0)
+#else
+#define MV_ASSERT(_x_)  do{if (!(_x_)) MV_PRINT("ASSERT: function:%s, line:%d\n", __FUNCTION__, __LINE__);}while(0)//BUG_ON(!(_x_))
+#endif
+
+#   define MV_TRACE(_x_)                                        \
+              do {                                              \
+                 MV_PRINT("%s(%d) ", __FILE__, __LINE__);       \
+                 MV_PRINT _x_;                                  \
+           } while(0)
+#elif defined(__QNXNTO__)
+#   define MV_PRINT      printk("%s: ", mv_full_name), printk
+#   define MV_ASSERT(_x_)                                       \
+              do {                                              \
+		 if (!(_x_))                                    \
+                    MV_PRINT("Assert at File %s: Line %d.\n",   \
+                             __FILE__, __LINE__);               \
+              } while (0)
+#   define MV_TRACE(_x_)                                        \
+              do {                                              \
+                 MV_PRINT("%s(%d) ", __FILE__, __LINE__);       \
+                 printk   _x_;                                  \
+           } while(0)
+#elif defined(_OS_BIOS)
+//
+//TBD
+//
+#elif defined(_OS_UKRN)
+extern int dbg_printf_ex(unsigned int flags, const char *fmt, ...);
+#   define MV_PRINT(fmt, args...)    dbg_printf_ex(0x100, fmt, ##args)
+#   define FM_PRINT MV_PRINT
+#    define MV_ASSERT(_condition_)    \
+                 do { if (!(_condition_)) {__breakpoint(1);}; } while(0)
+#   define MV_TRACE(_x_)                                \
+          do {	                                        \
+             MV_PRINT("%s(%d) ", __FILE__, __LINE__);   \
+             MV_PRINT _x_;                              \
+      } while (0)
+#   define MV_DUMP_SP()
+#else /* OTHER OSes */
+#   define MV_PRINT(_x_)
+#   define MV_ASSERT(_condition_)
+#   define MV_TRACE(_x_)
+#define MV_DUMP_SP()
+#endif /* _OS_WINDOWS */
+
+ 
+/* For debug version only */
+#if defined(SUPPORT_CHANGE_DEBUG_MODE)
+extern MV_U16 mv_debug_mode;
+#define MV_DPRINT(_x_)                do {\
+	if (mv_debug_mode & GENERAL_DEBUG_INFO) \
+	MV_PRINT _x_;\
+	} while (0)
+#define MV_DASSERT(x)	        do {\
+	if (mv_debug_mode & GENERAL_DEBUG_INFO) \
+	MV_ASSERT(x);\
+	} while (0)
+#define MV_DTRACE	        MV_DTRACE
+#else
+#if defined(MV_DEBUG)
+#ifdef _OS_FIRMWARE
+	#define MV_DPRINT(x)	   FM_PRINT x
+#else
+	#define MV_DPRINT(x)	   MV_PRINT x
+#endif
+
+#define MV_DASSERT	        MV_ASSERT
+#define MV_DTRACE	        MV_DTRACE
+#elif defined(_OS_BIOS)
+//
+//TBD
+//
+#else
+#define MV_DPRINT(x)
+#define MV_DASSERT(x)
+#define MV_DTRACE(x)
+#endif /* MV_DEBUG */
+#endif /*SUPPORT_CHANGE_DEBUG_MODE*/
+
+#ifdef SUPPORT_ROC
+#define LED_DBG_PRINT(x)	   FM_PRINT x
+#elif defined(_OS_LINUX)
+
+#if defined(SUPPORT_CHANGE_DEBUG_MODE)
+#define LED_DBG_PRINT(_x_)                do {\
+	if (mv_debug_mode & LL_DEBUG_INFO) \
+	MV_PRINT _x_;\
+	} while (0)
+
+#else
+#define LED_DBG_PRINT(x)
+#endif
+
+#else
+#define LED_DBG_PRINT(x)
+#endif
+
+MV_BOOLEAN mvLogRegisterModule(MV_U8 moduleId, MV_U32 filterMask, char* name);
+MV_BOOLEAN mvLogSetModuleFilter(MV_U8 moduleId, MV_U32 filterMask);
+MV_U32 mvLogGetModuleFilter(MV_U8 moduleId);
+void mvLogMsg(MV_U8 moduleId, MV_U32 type, char* format, ...);
+
+
+#endif /* COMMON_DEBUG_H */
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_dbg_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_dbg_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_dbg_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_dbg_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,81 @@
+#ifndef __MV_COM_DBG_STRUCT_H__
+#define __MV_COM_DBG_STRUCT_H__
+
+#include "com_define.h"
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+// Type of request for which the error should trigger.
+#define DBG_REQUEST_READ                        MV_BIT(0)
+#define DBG_REQUEST_WRITE                       MV_BIT(1)
+#define DBG_REQUEST_VERIFY                      MV_BIT(2)
+
+
+// The following data structure is dynamically allocated.  Depends on
+// NumSectors, the total size of the data structure should be
+// (8 + 4 + (SECTOR_LENGTH * NumSectors))
+// Where 8 is the size of LBA and 4 is the size of NumSectors itself.
+typedef struct _DBG_DATA
+{
+	MV_U64            LBA;
+	MV_U32            NumSectors;
+	MV_U8             Data[1];
+}DBG_Data, *PDBG_Data;
+
+typedef struct _DBG_HD
+{
+	MV_U64            LBA;
+	MV_U16            HDID;
+	MV_BOOLEAN        isUsed;
+	MV_U8             Reserved[5];
+}DBG_HD;
+
+typedef struct _DBG_FLASH
+{
+	MV_U32            OffSet;
+	MV_U16            NumBytes;
+	MV_U8             Data[1];
+}DBG_Flash, *PDBG_Flash;
+
+typedef struct _DBG_NVSRAM
+{
+	MV_U32     Offset;
+	MV_U16     NumBytes;
+	MV_U16     ReturnedCount;
+	MV_U8      Reserved[8];
+	MV_U8      Data[256];
+}DBG_NVSRAM, *PDBG_NVSRAM;
+
+// Map to/from VD LBA to/from PD LBA
+typedef struct _DBG_MAP
+{
+	MV_U64            VD_LBA;
+	MV_U64            PD_LBA;
+	MV_U16            VDID;          // if 'mapDirection' is DBG_PD2VD, set it to 0xFFFF as input and driver will return the mapped VD ID
+	MV_U16            PDID;          // must specified in any case
+	MV_BOOLEAN        parity;        // [out](true or false) if 'mapDirection' is DBG_VD2PD, this tells if the specified PD is a parity disk or not.
+	MV_U8             mapDirection;  // DBG_VD2PD or DBG_PD2VD
+	MV_U8             Reserved[34];
+}DBG_Map, *PDBG_Map;
+
+typedef struct _DBG_Error_Injection
+{
+	MV_U64     LBA;
+	MV_U32     Count;
+	MV_U16     HDID;
+	MV_U8      Error_case;
+	MV_U8      Error_Status;
+	MV_U8      Request_Type;
+	MV_U8      Sense_idx;
+	MV_U8      Reserved[6];
+}DBG_Error_Injection, *PDBG_Error_Injection;
+
+#define DBG_VD2PD                               0
+#define DBG_PD2VD                               1
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_define.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_define.h
--- linux-3.10.69/drivers/scsi/mv/include/com_define.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_define.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,528 @@
+#ifndef COM_DEFINE_H
+#define COM_DEFINE_H
+
+#include "mv_os.h"
+
+/*
+ *  This file defines Marvell OS independent primary data type for all OS.
+ *
+ *  We have macros to differentiate different CPU and OS.
+ *
+ *  CPU definitions:
+ *  _CPU_X86_16B  
+ *  Specify 16bit x86 platform, this is used for BIOS and DOS utility.
+ *  _CPU_X86_32B
+ *  Specify 32bit x86 platform, this is used for most OS drivers.
+ *  _CPU_IA_64B
+ *  Specify 64bit IA64 platform, this is used for IA64 OS drivers.
+ *  _CPU_AMD_64B
+ *  Specify 64bit AMD64 platform, this is used for AMD64 OS drivers.
+ *
+ *  OS definitions:
+ *  _OS_WINDOWS
+ *  _OS_LINUX
+ *  _OS_FREEBSD
+ *  _OS_BIOS
+ *  __QNXNTO__
+ */
+
+#if defined(_OS_DOS) && defined(COM_DEBUG)
+ #include "vsprintf.h"
+#endif
+
+#if !defined(IN)
+#   define IN
+#endif
+
+#if !defined(OUT)
+#   define OUT
+#endif
+
+#if defined(_OS_LINUX) || defined(__QNXNTO__) || defined(_OS_UKRN)
+#   define    BUFFER_PACKED               __attribute__((packed))
+#elif defined(_OS_WINDOWS) || defined(_OS_DOS)
+    #if !defined(_OS_FIRMWARE)
+#   define    BUFFER_PACKED
+    #else
+#   define    BUFFER_PACKED               __attribute__((packed))
+    #endif
+#elif defined(_OS_BIOS)
+#   define    BUFFER_PACKED
+#endif /* defined(_OS_LINUX) || defined(__QNXNTO__) */
+
+#define MV_BIT(x)                         (1UL << (x))
+
+#if !defined(NULL)
+#   define NULL 0
+#endif  /* NULL */
+
+#define MV_TRUE                           1
+#define MV_FALSE                          0
+#define MV_SUCCESS						  1
+#define MV_FAIL							  0
+#define MV_REG_FAIL 1
+#define MV_REG_SUCCESS 0
+
+
+
+typedef unsigned char  MV_BOOLEAN, *MV_PBOOLEAN;
+typedef unsigned char  MV_U8, *MV_PU8;
+typedef signed char  MV_I8, *MV_PI8;
+
+typedef unsigned short  MV_U16, *MV_PU16;
+typedef signed short  MV_I16, *MV_PI16;
+
+typedef void    MV_VOID, *MV_PVOID;
+typedef unsigned long MV_ULONG, *MV_PULONG;
+
+#ifdef _OS_BIOS
+    typedef MV_U8 GEN_FAR*  MV_LPU8;
+    typedef MV_I8 GEN_FAR*  MV_LPI8;
+    typedef MV_U16 GEN_FAR* MV_LPU16;
+    typedef MV_I16 GEN_FAR* MV_LPI16;
+
+    typedef MV_U32 GEN_FAR* MV_LPU32;
+    typedef MV_I32 GEN_FAR* MV_LPI32;
+    typedef void GEN_FAR*   MV_LPVOID;
+#else
+    typedef void            *MV_LPVOID;
+#endif /* _OS_BIOS */
+
+/* Pre-define segment in C code*/
+#if defined(_OS_BIOS)
+#   define BASEATTR         __based(__segname("_CODE")) 
+#   define BASEATTRData     __based(__segname("_CODE")) 
+#else
+#   define BASEATTR 
+#endif /* _OS_BIOS */
+
+#ifdef DEBUG_COM_SPECIAL
+	#define MV_DUMP_COM_SPECIAL(pString)  						{bDbgPrintStr(pString);bCOMEnter();}
+	#define MV_DUMP32_COM_SPECIAL(pString, value) 				bDbgPrintStr_U32(pString, value)
+	#define MV_DUMP16_COM_SPECIAL(pString, value)  				bDbgPrintStr_U16(pString, value)
+	#define MV_DUMP32_COM_SPECIAL3(pString, value1, value2)  	bDbgPrintStr_U32_3(pString, value1, value2)
+	#define MV_DUMP8_COM_SPECIAL(pString, value)  				bDbgPrintStr_U8(pString, value)	
+	#define MV_HALTKEY_SPECIAL									waitForKeystroke()
+
+#else
+	#define MV_DUMP_COM_SPECIAL(pString)  						
+	#define MV_DUMP32_COM_SPECIAL(pString, value) 				
+	#define MV_DUMP16_COM_SPECIAL(pString, value)  				
+	#define MV_DUMP32_COM_SPECIAL3(pString, value1, value2)  	
+	#define MV_DUMP8_COM_SPECIAL(pString, value)  				
+	#define MV_HALTKEY_SPECIAL									
+#endif
+/* For debug version only */
+#if (defined(DEBUG_BIOS)) || (defined(_OS_DOS) && defined(COM_DEBUG))
+ #ifdef DEBUG_SHOW_ALL
+	#define MV_DUMP32(_x_) 		{mvDebugDumpU32(_x_);bCOMEnter();}
+	#define MV_DUMP16(_x_)  	{mvDebugDumpU16(_x_);bCOMEnter();}
+	#define MV_DUMP8(_x_)  		{mvDebugDumpU8(_x_);bCOMEnter();}
+	#define MV_DUMPC32(_x_)  	{mvDebugDumpU32(_x_);bCOMEnter();}
+	#define MV_DUMPC16(_x_)  	{mvDebugDumpU16(_x_);bCOMEnter();}
+	#define MV_DUMPC8(_x_)  	{mvDebugDumpU8(_x_);bCOMEnter();}
+	#define MV_DUMPE32(_x_) 	{mvDebugDumpU32(_x_);bCOMEnter();}
+	#define MV_DUMPE16(_x_) 	{mvDebugDumpU16(_x_);bCOMEnter();}
+	#define MV_DUMPE8(_x_)  	{mvDebugDumpU8(_x_);bCOMEnter();}
+ 	#define MV_DUMP_COM(pString)  						{bDbgPrintStr(pString);bCOMEnter();}
+	#define MV_DUMP32_COM(pString, value) 				bDbgPrintStr_U32(pString, value)
+	#define MV_DUMP16_COM(pString, value)  				bDbgPrintStr_U16(pString, value)
+	#define MV_DUMP32_COM3(pString, value1, value2)  	bDbgPrintStr_U32_3(pString, value1, value2)
+	#define MV_DUMP8_COM(pString, value)  				bDbgPrintStr_U8(pString, value)
+ #else
+	#define MV_DUMP32(_x_) 		//{mvDebugDumpU32(_x_);bCOMEnter();}
+	#define MV_DUMP16(_x_)  	//{mvDebugDumpU16(_x_);bCOMEnter();}
+	#define MV_DUMP8(_x_)  		//{mvDebugDumpU8(_x_);bCOMEnter();}
+	#define MV_DUMPC32(_x_)  	//{mvDebugDumpU32(_x_);bCOMEnter();}
+	#define MV_DUMPC16(_x_)  	//{mvDebugDumpU16(_x_);bCOMEnter();}
+	#define MV_DUMPC8(_x_)  	//{mvDebugDumpU8(_x_);bCOMEnter();}
+	#define MV_DUMPE32(_x_) 	//{mvDebugDumpU32(_x_);bCOMEnter();}
+	#define MV_DUMPE16(_x_) 	//{mvDebugDumpU16(_x_);bCOMEnter();}
+	#define MV_DUMPE8(_x_)  	//{mvDebugDumpU8(_x_);bCOMEnter();}
+ 	#define MV_DUMP_COM(pString)  						//{bDbgPrintStr(pString);bCOMEnter();}
+	#define MV_DUMP32_COM(pString, value) 				//bDbgPrintStr_U32(pString, value)
+	#define MV_DUMP16_COM(pString, value)  				//bDbgPrintStr_U16(pString, value)
+	#define MV_DUMP32_COM3(pString, value1, value2)  	//bDbgPrintStr_U32_3(pString, value1, value2)
+	#define MV_DUMP8_COM(pString, value)  				//bDbgPrintStr_U8(pString, value)
+ 
+ #endif
+ 
+	#define MV_BIOSDEBUG(pString, value)				bDbgPrintStr_U32(pString, value)				
+	#define MV_HALTKEY			waitForKeystroke()
+	#define MV_ENTERLINE		//mvChangLine()
+#else
+	#define MV_DUMP32(_x_) 		//{mvDebugDumpU32(_x_);bCOMEnter();}
+	#define MV_DUMP16(_x_)  	//{mvDebugDumpU16(_x_);bCOMEnter();}
+	#define MV_DUMP8(_x_)  		//{mvDebugDumpU8(_x_);bCOMEnter();}
+	#define MV_DUMPC32(_x_)  	//{mvDebugDumpU32(_x_);bCOMEnter();}
+	#define MV_DUMPC16(_x_)  	//{mvDebugDumpU16(_x_);bCOMEnter();}
+	#define MV_DUMPC8(_x_)  	//{mvDebugDumpU8(_x_);bCOMEnter();}
+	#define MV_DUMPE32(_x_) 	//{mvDebugDumpU32(_x_);bCOMEnter();}
+	#define MV_DUMPE16(_x_) 	//{mvDebugDumpU16(_x_);bCOMEnter();}
+	#define MV_DUMPE8(_x_)  	//{mvDebugDumpU8(_x_);bCOMEnter();}
+ 	#define MV_DUMP_COM(pString)  						//{bDbgPrintStr(pString);bCOMEnter();}
+	#define MV_DUMP32_COM(pString, value) 				//bDbgPrintStr_U32(pString, value)
+	#define MV_DUMP16_COM(pString, value)  				//bDbgPrintStr_U16(pString, value)
+	#define MV_DUMP32_COM3(pString, value1, value2)  	//bDbgPrintStr_U32_3(pString, value1, value2)
+	#define MV_DUMP8_COM(pString, value)  				//bDbgPrintStr_U8(pString, value)
+
+	#define MV_BIOSDEBUG(pString, value)
+#if defined(_OS_DOS) && defined(MV_DEBUG)
+	#define MV_HALTKEY mv_waitfor_key_stroke()
+#else
+#if defined(DEBUG_FW30)
+	#define MV_HALTKEY  waitForKeystroke()
+#else
+	#define MV_HALTKEY
+#endif
+#endif	
+	#define MV_ENTERLINE
+	
+#endif
+
+#if defined(_OS_LINUX) || defined(__QNXNTO__) || defined(_OS_FIRMWARE) || defined(_OS_MAC)
+    /* unsigned/signed long is 64bit for AMD64, so use unsigned int instead */
+    typedef unsigned int MV_U32, *MV_PU32;
+    typedef   signed int MV_I32, *MV_PI32;
+    typedef   signed long MV_ILONG, *MV_PILONG;
+#else
+    /* unsigned/signed long is 32bit for x86, IA64 and AMD64 */
+    typedef unsigned long MV_U32, *MV_PU32;
+    typedef   signed long MV_I32, *MV_PI32;
+#endif /*  defined(_OS_LINUX) || defined(__QNXNTO__) */
+
+#if defined(_OS_WINDOWS) || defined(_OS_DOS) || defined(_OS_FIRMWARE)
+  #if !defined(_OS_FIRMWARE)
+    typedef unsigned __int64 _MV_U64;
+    typedef   signed __int64 _MV_I64;
+  #else
+    typedef unsigned long long _MV_U64;
+    typedef   signed long long _MV_I64;
+  #endif  
+#elif defined(_OS_LINUX) || defined(__QNXNTO__)
+    typedef unsigned long long _MV_U64;
+    typedef   signed long long _MV_I64;
+#elif defined(_OS_FREEBSD)
+#   error "No Where"
+#elif defined(_OS_BIOS)
+//
+//NA
+//
+#elif defined(_OS_MAC)
+/*typedef unsigned char  MV_BOOLEAN, *MV_PBOOLEAN;
+typedef unsigned char  MV_U8, *MV_PU8;
+typedef signed char  MV_I8, *MV_PI8;
+
+typedef unsigned short  MV_U16, *MV_PU16;
+typedef signed short  MV_I16, *MV_PI16;
+
+typedef void    MV_VOID, *MV_PVOID;
+typedef unsigned int MV_U32, *MV_PU32;
+typedef   signed int MV_I32, *MV_PI32;*/
+typedef unsigned long long _MV_U64;
+typedef   signed long long _MV_I64;
+#else
+#   error "No Where"
+#endif /* _OS_WINDOWS */
+
+//typedef _MV_U64 BUS_ADDRESS;
+
+#ifdef _OS_LINUX
+#   if defined(__KCONF_64BIT__)
+#      define _SUPPORT_64_BIT
+#   else
+#      ifdef _SUPPORT_64_BIT
+#         error Error 64_BIT CPU Macro
+#      endif
+#   endif /* defined(__KCONF_64BIT__) */
+#elif defined(_OS_BIOS) || defined(__QNXNTO__)
+#   undef  _SUPPORT_64_BIT
+#else
+  #if !defined(_OS_FIRMWARE)
+#   define _SUPPORT_64_BIT
+  #else
+#   if defined(__KCONF_64BIT__)
+#      define _SUPPORT_64_BIT
+#   else
+#      ifdef _SUPPORT_64_BIT
+#         error Error 64_BIT CPU Macro
+#      endif
+#   endif /* defined(__KCONF_64BIT__) */
+  #endif /* _OS_FIRMWARE */
+#endif /* _OS_LINUX */
+
+/*
+ * Primary Data Type
+ */
+#if defined(_OS_WINDOWS) || defined(_OS_DOS) || defined(_OS_FIRMWARE) || defined(_OS_MAC)
+  #if !defined(_OS_FIRMWARE)
+    typedef union {
+        struct {
+            MV_U32 low;
+            MV_U32 high;
+        } parts;
+        _MV_U64 value;
+    } MV_U64, *PMV_U64, *MV_PU64;
+  #else
+    typedef union {
+        struct {
+#   if defined (__MV_LITTLE_ENDIAN__)
+            MV_U32 low;
+            MV_U32 high;
+#   elif defined (__MV_BIG_ENDIAN__)
+            MV_U32 high;
+            MV_U32 low;
+#   else
+#           error "undefined endianness"
+#   endif /* __MV_LITTLE_ENDIAN__ */
+        } parts;
+        _MV_U64 value;
+    } MV_U64, *PMV_U64, *MV_PU64;
+  #endif	
+#elif defined(_OS_LINUX) || defined(__QNXNTO__)
+    typedef union {
+        struct {
+#   if defined (__MV_LITTLE_ENDIAN__)
+            MV_U32 low;
+            MV_U32 high;
+#   elif defined (__MV_BIG_ENDIAN__)
+            MV_U32 high;
+            MV_U32 low;
+#   else
+#           error "undefined endianness"
+#   endif /* __MV_LITTLE_ENDIAN__ */
+        } parts;
+        _MV_U64 value;
+    } MV_U64, *PMV_U64, *MV_PU64;
+#else
+/* BIOS compiler doesn't support 64 bit data structure. */
+    typedef union {
+        struct {
+             MV_U32 low;
+             MV_U32 high;
+        };
+				struct {
+					MV_U32 low;
+					MV_U32 high;
+				}parts;
+        struct {
+             MV_U32 value;
+             MV_U32 value1;
+        };
+    } _MV_U64,MV_U64, *MV_PU64, *PMV_U64;
+#endif /* defined(_OS_LINUX) || defined(_OS_WINDOWS) || defined(__QNXNTO__)*/
+
+typedef _MV_U64 BUS_ADDRESS;
+
+/* PTR_INTEGER is necessary to convert between pointer and integer. */
+#if defined(_SUPPORT_64_BIT)
+   typedef _MV_U64 MV_PTR_INTEGER;
+#else
+   typedef MV_U32 MV_PTR_INTEGER;
+#endif /* defined(_SUPPORT_64_BIT) */
+
+#ifdef _SUPPORT_64_BIT
+#define _64_BIT_COMPILER     1
+#endif
+
+/* LBA is the logical block access */
+typedef MV_U64 MV_LBA;
+
+#if defined(_CPU_16B)
+    typedef MV_U32 MV_PHYSICAL_ADDR;
+#else
+    typedef MV_U64 MV_PHYSICAL_ADDR;
+#endif /* defined(_CPU_16B) */
+
+#if defined (_OS_WINDOWS)
+	#if !defined(_OS_FIRMWARE)
+		typedef MV_PVOID MV_FILE_HANDLE;
+	#else
+		typedef MV_I32 MV_FILE_HANDLE;
+	#endif
+#elif defined(_OS_LINUX) || defined(__QNXNTO__) || defined (_OS_MAC)
+typedef MV_I32 MV_FILE_HANDLE;
+#elif defined (_OS_DOS)
+typedef int MV_FILE_HANDLE;
+#endif
+
+#include "com_product.h"
+
+/* OS_LINUX depedent definition*/
+
+#if defined(_OS_LINUX) || defined(__QNXNTO__)
+#define hba_local_irq_disable() ossw_local_irq_disable()
+#define hba_local_irq_enable() ossw_local_irq_enable()
+#define hba_local_irq_save(flag) ossw_local_irq_save(&flag)
+#define hba_local_irq_restore(flag) ossw_local_irq_restore(&flag)
+
+/* expect pointers */
+#define OSSW_LOCAL_IRQ_SAVE(flag)	ossw_local_irq_save(&flag)
+#define OSSW_LOCAL_IRQ_RESTORE(flag)	ossw_local_irq_restore(&flag)
+#define OSSW_INIT_SPIN_LOCK(ext) ossw_init_spin_lock(ext)
+#define OSSW_SPIN_LOCK(ext)            ossw_spin_lock(ext)
+#define OSSW_SPIN_UNLOCK(ext)          ossw_spin_unlock(ext)
+#define OSSW_SPIN_LOCK_IRQ(ext)            ossw_spin_lock_irq(ext)
+#define OSSW_SPIN_UNLOCK_IRQ(ext)          ossw_spin_unlock_irq(ext)
+#define OSSW_SPIN_LOCK_IRQSAVE(ext, flag)          ossw_spin_lock_irq_save(ext, &flag)
+#define OSSW_SPIN_UNLOCK_IRQRESTORE(ext, flag)           ossw_spin_unlock_irq_restore(ext, &flag)
+
+/* for hw multi-queue */
+#define OSSW_GET_CPU_NUM() ossw_get_cpu_num()
+
+#define OSSW_SPIN_LOCK_HBA(ext, flag) ossw_spin_lock_hba(ext, &flag)
+#define OSSW_SPIN_UNLOCK_HBA(ext, flag) ossw_spin_unlock_hba(ext, &flag)
+#define OSSW_SPIN_LOCK_RESOURCE(ext, flag) ossw_spin_lock_resource(ext, &flag)
+#define OSSW_SPIN_UNLOCK_RESOURCE(ext, flag) ossw_spin_unlock_resource(ext, &flag)
+#define OSSW_SPIN_LOCK_WAIT_QUEUE(ext, flag) ossw_spin_lock_wait_queue(ext, &flag)
+#define OSSW_SPIN_UNLOCK_WAIT_QUEUE(ext, flag) ossw_spin_unlock_wait_queue(ext, &flag)
+#define OSSW_SPIN_LOCK_COMPL_QUEUE(ext, flag) ossw_spin_lock_compl_queue(ext, &flag)
+#define OSSW_SPIN_UNLOCK_COMPL_QUEUE(ext, flag) ossw_spin_unlock_compl_queue(ext, &flag)
+#define OSSW_SPIN_LOCK_CORE_QUEUE(ext, flag) ossw_spin_lock_core_queue(ext, &flag)
+#define OSSW_SPIN_UNLOCK_CORE_QUEUE(ext, flag) ossw_spin_unlock_core_queue(ext, &flag)
+#define OSSW_SPIN_LOCK_ROOT(ext, flag, root_id) ossw_spin_lock_root(ext, &flag, root_id)
+#define OSSW_SPIN_UNLOCK_ROOT(ext, flag, root_id) ossw_spin_unlock_root(ext, &flag, root_id)
+#define OSSW_SPIN_LOCK_HW_QUEUE(ext, flag, queue_id) ossw_spin_lock_hw_queue(ext, &flag, queue_id)
+#define OSSW_SPIN_UNLOCK_HW_QUEUE(ext, flag, queue_id) ossw_spin_unlock_hw_queue(ext, &flag, queue_id)
+#define OSSW_SPIN_LOCK_CORE(ext, flag) ossw_spin_lock_core(ext, &flag)
+//#define OSSW_SPIN_TRYLOCK_CORE(ext, flag) ossw_spin_trylock_core(ext, &flag)
+#define OSSW_SPIN_UNLOCK_CORE(ext, flag) ossw_spin_unlock_core(ext, &flag)
+#define OSSW_SPIN_LOCK_HW_WQ(ext, flag, queue_id) ossw_spin_lock_hw_wq(ext, &flag, queue_id)
+#define OSSW_SPIN_UNLOCK_HW_WQ(ext, flag, queue_id) ossw_spin_unlock_hw_wq(ext, &flag, queue_id)
+#define OSSW_SPIN_LOCK_HW_CQ(ext, flag, queue_id) ossw_spin_lock_hw_cq(ext, &flag, queue_id)
+#define OSSW_SPIN_UNLOCK_HW_CQ(ext, flag, queue_id) ossw_spin_unlock_hw_cq(ext, &flag, queue_id)
+
+#ifdef SUPPORT_STAGGERED_SPIN_UP
+#define OSSW_SPIN_LOCK_IRQSAVE_SPIN_UP(ext, flag)          ossw_spin_lock_irq_save_spin_up(ext, &flag)
+#define OSSW_SPIN_UNLOCK_IRQRESTORE_SPIN_UP(ext, flag)           ossw_spin_unlock_irq_restore_spin_up(ext, &flag)
+#endif
+/* Delayed Execution Services */
+#define OSSW_INIT_TIMER(ptimer) ossw_init_timer(ptimer)
+
+#else /* For Windows */
+
+#define hba_local_irq_disable()
+#define hba_local_irq_enable()
+#define hba_local_irq_save(flag) 
+#define hba_local_irq_restore(flag) 
+
+/* expect pointers */
+#define OSSW_LOCAL_IRQ_SAVE(flag)
+#define OSSW_LOCAL_IRQ_RESTORE(flag)
+#define OSSW_INIT_SPIN_LOCK(plock) 
+#define OSSW_SPIN_LOCK(plock)           
+#define OSSW_SPIN_UNLOCK(plock)           
+#define OSSW_SPIN_LOCK_IRQ(plock)
+#define OSSW_SPIN_UNLOCK_IRQ(plock)
+#define OSSW_SPIN_LOCK_IRQSAVE(plock, flag)          
+#define OSSW_SPIN_UNLOCK_IRQRESTORE(plock, flag)
+#define OSSW_GET_CPU_NUM() (16)
+#define OSSW_SPIN_LOCK_HBA(ext, flag)
+#define OSSW_SPIN_UNLOCK_HBA(ext, flag)
+#define OSSW_SPIN_LOCK_RESOURCE(ext, flag)
+#define OSSW_SPIN_UNLOCK_RESOURCE(ext, flag)
+#define OSSW_SPIN_LOCK_WAIT_QUEUE(ext, flag)
+#define OSSW_SPIN_UNLOCK_WAIT_QUEUE(ext, flag)
+#define OSSW_SPIN_LOCK_COMPL_QUEUE(ext, flag)
+#define OSSW_SPIN_UNLOCK_COMPL_QUEUE(ext, flag)
+#define OSSW_SPIN_LOCK_CORE_QUEUE(ext, flag)
+#define OSSW_SPIN_UNLOCK_CORE_QUEUE(ext, flag)
+#define OSSW_SPIN_LOCK_ROOT(ext, flag, root_id) 
+#define OSSW_SPIN_UNLOCK_ROOT(ext, flag, root_id)
+#define OSSW_SPIN_LOCK_HW_QUEUE(ext, flag, queue_id)
+#define OSSW_SPIN_UNLOCK_HW_QUEUE(ext, flag, queue_id)
+#define OSSW_SPIN_LOCK_CORE(ext, flag) 
+//#define OSSW_SPIN_TRYLOCK_CORE(ext, flag) 
+#define OSSW_SPIN_UNLOCK_CORE(ext, flag)
+#define OSSW_SPIN_LOCK_HW_WQ(ext, flag, queue_id)
+#define OSSW_SPIN_UNLOCK_HW_WQ(ext, flag, queue_id)
+#define OSSW_SPIN_LOCK_HW_CQ(ext, flag, queue_id)
+#define OSSW_SPIN_UNLOCK_HW_CQ(ext, flag, queue_id)
+#ifdef SUPPORT_STAGGERED_SPIN_UP
+#define OSSW_SPIN_LOCK_IRQSAVE_SPIN_UP(plock, flag)
+#define OSSW_SPIN_UNLOCK_IRQRESTORE_SPIN_UP(plock, flag)
+#endif
+
+/* Delayed Execution Services */
+#define OSSW_INIT_TIMER(ptimer) 
+
+#endif
+
+
+#if !defined( likely )
+#if defined( SUPPORT_ROC )&&defined( _OS_FIRMWARE )
+#define likely(x)		__builtin_expect((x),1)
+#define unlikely(x)		__builtin_expect((x),0)
+#else
+#define likely(x)		(x)
+#define unlikely(x)		(x)
+#endif
+#endif
+
+#if defined( SUPPORT_ROC )&&defined( _OS_FIRMWARE )
+#define MV_GO_SECT(class, grp)		__attribute__((section(".cold_rain_"#grp)))
+#else
+#define MV_GO_SECT(class, grp)
+#endif
+
+#if defined(_OS_LINUX)
+
+#if defined(SUPPORT_CHANGE_DEBUG_MODE)
+#define GENERAL_DEBUG_INFO	MV_BIT(0)	/*For MV_DPRINT*/
+#define CORE_DEBUG_INFO		MV_BIT(1)	/*Core debug info: CORE_PRINT, CORE_EH_PRINT*/
+#define RAID_DEBUG_INFO		MV_BIT(2)	/*Raid debug info*/
+#define CACHE_DEBUG_INFO	MV_BIT(3)	/*Cache debug info*/
+#define LL_DEBUG_INFO	MV_BIT(4)	/*LowLevel debug info*/
+#define CORE_FULL_DEBUG_INFO	(CORE_DEBUG_INFO | \
+							GENERAL_DEBUG_INFO) /*CORE_DPRINT, CORE_EH_PRINT, CORE_EVENT_PRINT*/
+#define RAID_FULL_DEBUG_INFO	(RAID_DEBUG_INFO | \
+							GENERAL_DEBUG_INFO) 
+#define CACHE_FULL_DEBUG_INFO	(CACHE_DEBUG_INFO | \
+							GENERAL_DEBUG_INFO) 
+#endif /*SUPPORT_CHANGE_DEBUG_MODE*/
+
+#define sg_map(x)	hba_map_sg_to_buffer(x)
+#define sg_unmap(x)	hba_unmap_sg_to_buffer(x)
+
+#define time_is_expired(x) 	ossw_time_expired(x)
+#define EVENT_SET_DELAY_TIME(x, y) ((x) = ossw_set_expired_time(y))
+
+#define msi_enabled(x)	hba_msi_enabled(x)
+#ifdef SUPPORT_MSIX_INT
+#define msix_enabled(x)	hba_msix_enabled(x)
+#else
+#define msix_enabled(x)   MV_FALSE
+#endif
+#define test_enabled(x) hba_test_enabled(x)
+#else
+#define sg_map(x)
+#define sg_unmap(x)
+
+#define time_is_expired(x)	MV_TRUE	
+#define EVENT_SET_DELAY_TIME(x, y)
+#ifdef SUPPORT_MSI
+#define msi_enabled(x)	hba_msi_enabled(x)
+#else
+#define msi_enabled(x)	MV_FALSE
+#endif
+#ifdef SUPPORT_MSIX_INT
+#define msix_enabled(x)	hba_msix_enabled(x)
+#else
+#define msix_enabled(x) MV_FALSE
+#endif
+#ifdef SUPPORT_INEJECT_ERROR
+#define test_enabled(x) MV_TRUE
+#else
+#define test_enabled(x) MV_FALSE
+#endif
+#ifndef MV_API_EXPORTS
+
+#if defined(_OS_BIOS)||defined(SUPPORT_ROC)
+static inline MV_BOOLEAN __is_scsi_cmd_simulated(MV_U8 cmd_type){return MV_FALSE;};
+#endif
+
+#endif
+
+#endif
+
+#endif /* COM_DEFINE_H */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_diagnostic.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_diagnostic.h
--- linux-3.10.69/drivers/scsi/mv/include/com_diagnostic.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_diagnostic.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,64 @@
+#ifndef __MV_COM_DIAGNOSTIC_H__
+#define __MV_COM_DIAGNOSTIC_H__
+#ifndef COM_DEFINE_H //for magni not use include com_define to define MV_U32
+#include "com_define.h"
+#endif
+
+typedef struct _SendDiaCDB
+{
+	MV_U8 OperationCode;
+	MV_U8 UnitOffL:1;
+	MV_U8 DevOffL:1;
+	MV_U8 SelfTest:1;
+	MV_U8 Reserved:1;
+	MV_U8 PF:1;
+	MV_U8 SelfTestCode:3;
+	MV_U8 Reserved2;
+	MV_U8 ParamLength[2];
+	MV_U8 Control;
+}SendDiaCDB;
+
+typedef struct _ReceiveDiaCDB
+{
+	MV_U8 OperationCode;
+	MV_U8 PCV:1;
+	MV_U8 Reserved:7;
+	MV_U8 PageCode;
+	MV_U8 AllocationLength[2];
+	MV_U8 Control;
+}ReceiveDiaCDB;
+
+typedef struct _DianosticPage
+{
+	MV_U8    PageCode;
+	MV_U8    PageCodeSpec;
+	MV_U8    PageLength[2];
+	MV_U8    Parameters[1];
+}DianosticPage, *PDianosticPage;
+
+#define MV_DIAGNOSTIC_CDB_LENGTH   12
+#define MV_DIANOSTICPAGE_NONE_DATA  0
+
+#define SCSI_CMD_RECEIVE_DIAGNOSTIC_RESULTS   0x1c  //spc3r23 p97
+#define SCSI_CMD_SEND_DIAGNOSTIC              0x1d  //spc3r23 p97
+
+typedef struct _MVATAPIDiagnosticParameters
+{
+	MV_U8    cdbOffset;
+	MV_U8    senseOffset;
+	MV_U8    dataOffset;
+	MV_U8	 reserved;
+	MV_U8    cdb[16];
+	MV_U8    senseBuffer[32];
+	MV_U32   dataLength;
+	MV_U8    Data[1];
+}MVATAPIDiagParas, *PMVATAPIDiagParas;
+
+#define MV_API_SEND_PAGE                      0xe0
+#define MV_API_RECEV_PAGE                     0xe1
+
+typedef MVATAPIDiagParas send_diagnostic_page;
+typedef DianosticPage diagnostic_page;
+typedef MVATAPIDiagParas recv_diagnostic_page;
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_enc_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_enc_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_enc_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_enc_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,376 @@
+#ifndef __MV_COM_ENC_STRUCT_H__
+#define __MV_COM_ENC_STRUCT_H__
+#include "com_physical_link.h"
+
+#ifndef _OS_BIOS
+#define MAX_ENCLOSURE_API      32
+#endif
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+// light types
+#define SGPIO_LED_ACTIVITY                      0
+#define SGPIO_LED_LOCATE                        1
+#define SGPIO_LED_ERROR                         2
+#define SGPIO_LED_REBUILD						3		/* for Supermicro backplanes */
+#define SGPIO_LED_HOT_SPARE                     4
+#define SGPIO_LED_REBUILD_MASK                  0x00000080
+#define SGPIO_LED_ERROR_MASK                    0x00000040
+#define SGPIO_LED_ALL                           0xff
+// light status - the following values are set according to hardware
+//       values, do not change unless necessary
+#define SGPIO_LED_LOW                           0
+#define SGPIO_LED_HIGH                          1
+#define SGPIO_LED_BLINK_A                       2
+#define SGPIO_LED_BLINK_INVRT_A                 3
+#define SGPIO_LED_BLINK_SOF                     4
+#define SGPIO_LED_BLINK_EOF                     5
+#define SGPIO_LED_BLINK_B                       6
+#define SGPIO_LED_BLINK_INVRT_B                 7
+// pre-set flags for RAID module to use
+#define LED_FLAG_REBUILD                      1
+#define LED_FLAG_HOT_SPARE                    2
+#define LED_FLAG_FAIL_DRIVE                   3
+#define LED_FLAG_FAIL_VD                   0x5a
+#define LED_FLAG_HOT_SPARE_OFF                0x12
+#define LED_FLAG_OFF_ALL                      0xff
+#define LED_FLAG_ACT					4
+
+#define LED_FLAG_WORKING_CHECK                0x10
+#define LED_FLAG_REBUILD_OFF                  0x11
+#define LED_FLAG_FAIL_DRIVE_OFF               0x13
+
+
+//add as enclosure
+
+#define ENC_STATUS_NOT_EXIST        0
+#define ENC_STATUS_OK               1
+#define ENC_STATUS_UNSTABLE         2
+
+typedef struct _Enclosure_Info
+{
+	Link_Entity     Link;
+	MV_U8           AdapterID;
+	MV_U8           Status;           // Refer to ENC_STATUS_XXX
+	MV_U8           reserved1[2];
+	MV_U8           LogicalID[8+1];
+	MV_U8           VendorID[8+1];
+	MV_U8           ProductID[16+1];
+	MV_U8           RevisionLevel[4+1];
+	MV_U8			reserved2[3];
+	// If ExpanderCount > 0, the enclosure might have more than one parant, in this case
+	// Link.Parent.DevType will be set to DEVICE_TYPE_NONE and all other Parent fields are meaningless.
+	// To get all its parent info, use each of ExpanderIDs[] to find out its individual parent.
+	MV_U8			ExpanderCount;
+	MV_U16			ExpanderIDs[8];
+	MV_U8           path;
+	MV_U8           target;
+	MV_U8           lun;
+	MV_U8           slice;
+	MV_U8           reserved3[20];
+}Enclosure_Info, *PEnclosure_Info;
+
+#define MAX_ENCELEMENT      512
+#define ENC_COOLING_STOP 0
+
+typedef struct _EncCooling_Element
+{
+	MV_U16     curSpeed;
+	MV_U8      curSpeedcode;
+	MV_U8      reserved[5];
+} EncCooling_Element;
+
+typedef struct _EncPower_Element
+{
+	MV_U8      DCOverVoltage:1;
+	MV_U8      DCUnderVoltage:1;
+	MV_U8      DCOverCurrent:1;
+	MV_U8      hotSwap:1;
+	MV_U8      tempWarn:1;
+	MV_U8      reservedbit:3;
+	MV_U8      reserved[7];
+} EncPower_Element;
+
+typedef struct _EncTemperatureSensor_Element
+{
+	MV_U8      temperature;
+	MV_U8      OTFailure:1;
+	MV_U8      OTWarning:1;
+	MV_U8      UTFailure:1;
+	MV_U8      UTWarning:1;
+	MV_U8      reservedbit:4;
+	MV_U8      reserved[6];
+} EncTemperatureSensor_Element;
+
+typedef struct _EncDoorLock_Element
+{
+	MV_BOOLEAN       unlocked;
+	MV_U8            reserved[7];
+} EncDoorLock_Element;
+
+typedef struct _EncAudibleAlarm_Element
+{
+	MV_U8      mute:1;
+	MV_U8      remind:1;
+	MV_U8      reservedbit:6;
+	MV_U8      reserved[7];
+} EncAudibleAlarm_Element;
+
+#define ENC_DISPLAY_NOCHANGE            0
+#define ENC_DISPLAY_ENCCONTROL          1
+#define ENC_DISPLAY_CLIENT              2
+
+typedef struct _EncDisplay_Element
+{
+	MV_U8       character1;
+	MV_U8       character2;
+	MV_U8       mode;
+	MV_U8       reserved[5];
+} EncDisplay_Element;
+
+typedef struct _EncVoltageSensor_Element
+{
+	MV_U16     voltage;
+	MV_U8      warnOver:1;
+	MV_U8      warnUnder:1;
+	MV_U8      critOver:1;
+	MV_U8      critUnder:1;
+	MV_U8      reservedbit:4;
+	MV_U8      reserved[5];
+} EncVoltageSensor_Element;
+
+typedef struct _EncDevice_Element
+{
+	MV_U8      SlotAddress;
+	MV_U8      Report:1;
+	MV_U8      Ident:1;
+	MV_U8      Rmv:1;
+	MV_U8      ReadyToInst:1;
+	MV_U8      EncBypassedB:1;
+	MV_U8      EncBypassedA:1;
+	MV_U8      DoNotRemove:1;
+	MV_U8      AppClientBypassedA:1;
+
+	MV_U8      DeviceBypassedB:1;
+	MV_U8      DeviceBypassedA:1;
+	MV_U8      ByPassedB:1;
+	MV_U8      ByPassedA:1;
+	MV_U8      DeviceOff:1;
+	MV_U8      FaultReqstd:1;
+	MV_U8      FaultSensed:1;
+	MV_U8      AppClientBypassedB:1;
+	MV_U8      reserved[5];
+} EncDevice_Element;
+
+typedef struct _EncArrayDevice_Element
+	{
+	MV_U8      RrAbort:1;	         // Rebuild or Remap Abort
+	MV_U8      RebuildRemap:1;		// Rebuild or Remap
+	MV_U8      InFailedArray:1;
+	MV_U8      InCritArray:1;
+	MV_U8      ConsChk:1;
+	MV_U8      HotSpare:1;
+	MV_U8      RsvdDevice:1;
+	MV_U8      Ok:1;
+
+	MV_U8      Report:1;
+	MV_U8      Ident:1;
+	MV_U8      Rmv:1;
+	MV_U8      ReadyToInst:1;
+	MV_U8      EncBypassedB:1;
+	MV_U8      EncBypassedA:1;
+	MV_U8      DoNotRemove:1;
+	MV_U8      AppClientBypassedA:1;
+
+	MV_U8      DeviceBypassedB:1;
+	MV_U8      DeviceBypassedA:1;
+	MV_U8      ByPassedB:1;
+	MV_U8      ByPassedA:1;
+	MV_U8      DeviceOff:1;
+	MV_U8      FaultReqstd:1;
+	MV_U8      FaultSensed:1;
+	MV_U8      AppClientBypassedB:1;
+
+	MV_U8      reserved[5];
+} EncArrayDevice_Element;
+
+#define ENC_ELEMENTTYPE_UNKNOWN             0
+#define ENC_ELEMENTTYPE_DEVICE              1
+#define ENC_ELEMENTTYPE_POWERSUPPLY         2
+#define ENC_ELEMENTTYPE_COOLING             3
+#define ENC_ELEMENTTYPE_TEMPERATURE         4
+#define ENC_ELEMENTTYPE_DOORLOCK            5
+#define ENC_ELEMENTTYPE_AUDIBLEALARM        6
+#define ENC_ELEMENTTYPE_ENCSERVICE          7
+#define ENC_ELEMENTTYPE_SCCCONTROLLER       8
+#define ENC_ELEMENTTYPE_NONVOLATILECACHE    9
+#define ENC_ELEMENTTYPE_INVALIDOPERATION    10
+#define ENC_ELEMENTTYPE_UNINTERRPOWER       11
+#define ENC_ELEMENTTYPE_DISPLAY             12
+#define ENC_ELEMENTTYPE_KEYPAD              13
+#define ENC_ELEMENTTYPE_ENC                 14
+#define ENC_ELEMENTTYPE_SCSIPORT            15
+#define ENC_ELEMENTTYPE_LANGUAGE            16
+#define ENC_ELEMENTTYPE_COMMUNICATIONPORT   17
+#define ENC_ELEMENTTYPE_VOLTAGESENSOR       18
+#define ENC_ELEMENTTYPE_CURRENTSENSOR       19
+#define ENC_ELEMENTTYPE_SCSITARGETPORT      20
+#define ENC_ELEMENTTYPE_SCSIINITIATORPORT   21
+#define ENC_ELEMENTTYPE_SIMPLESUBENC        22
+#define ENC_ELEMENTTYPE_ARRAYDEVICE         23
+#define ENC_ELEMENTTYPE_SASEXP              24
+#define ENC_ELEMENTTYPE_SASCONNECTOR        25
+
+#define MV_SUPPORT_STATUS_ELEMENT_TYPE(type)	((type==ENC_ELEMENTTYPE_COOLING)||	\
+						(type==ENC_ELEMENTTYPE_DEVICE) || \
+						(type==ENC_ELEMENTTYPE_ARRAYDEVICE) || \
+						(type==ENC_ELEMENTTYPE_POWERSUPPLY) || \
+						(type==ENC_ELEMENTTYPE_TEMPERATURE) || \
+						(type==ENC_ELEMENTTYPE_DOORLOCK) || \
+						(type==ENC_ELEMENTTYPE_AUDIBLEALARM) || \
+						(type==ENC_ELEMENTTYPE_VOLTAGESENSOR) || \
+						(type==ENC_ELEMENTTYPE_ARRAYDEVICE) || \
+						(type==ENC_ELEMENTTYPE_DISPLAY))
+
+typedef struct _EncElementType_Info
+{
+	MV_U16                          enclosureID;
+	MV_U16                          magicID;
+	MV_U8                           type;
+	MV_U8		                    status;
+	MV_U8	                        elementID;
+	MV_U8                           reserved;
+	union {
+		EncDevice_Element               device;
+		EncArrayDevice_Element          arrayDevice;
+		EncCooling_Element              fan;
+		EncPower_Element                power;
+		EncTemperatureSensor_Element    temperatureSensor;
+		EncDoorLock_Element             doorLock;
+		EncAudibleAlarm_Element         alarm;
+		EncDisplay_Element              display;
+		EncVoltageSensor_Element        voltageSensor;
+		MV_U8                           unCode[8];
+	};
+} EncElementType_Info, *PEncElementType_Info;
+
+#define MV_SUPPORT_CONTROL_ELEMENT_TYPE(type)	((type==ENC_ELEMENTTYPE_COOLING)||	\
+									(type==ENC_ELEMENTTYPE_ARRAYDEVICE) || \
+									(type==ENC_ELEMENTTYPE_DEVICE))
+
+typedef struct _EncCooling_Control
+{
+	MV_U8   speedcode;
+	MV_U8   reserved[7];
+}EncCooling_Control,*PEncCooling_Control;
+
+typedef struct _EncDevice_Control
+{
+	MV_U8   LedOn;
+	MV_U8   reserved[7];
+}EncDevice_Control,*PEncDevice_Control;
+
+typedef struct _EncArrayDevice_Control
+{
+	MV_U8   LedOn;
+	MV_U8   reserved[7];
+}EncArrayDevice_Control,*PEncArrayDevice_Control;
+
+typedef struct _EncElementType_Control
+{
+	MV_U16                          enclosureID;
+	MV_U8                           type;
+	MV_U16                          magicID;
+	MV_U8                           control;
+	MV_U8	                        elementID;
+	MV_U8                           reserved;
+	union {
+		EncCooling_Control              fan;
+		EncDevice_Control               device;
+		EncArrayDevice_Control          arrayDevice;
+		MV_U8                           unCode[8];
+	};
+} EncElementType_Control, *PEncElementType_Control;
+
+typedef struct _DevElementStatusDescriptorEIP0
+{
+	MV_U8 config;
+	MV_U8 length;
+	MV_U8 infomantion[2];
+} DevElementStatusDescriptorEIP0, *PDevElementStatusDescriptorEIP0;
+
+typedef struct _DevElementStatusDescriptorEIP1
+{
+	MV_U8 config;
+	MV_U8 length;
+	MV_U8 reserved;
+	MV_U8 elementIndex;
+	MV_U8 infomantion[4];
+} DevElementStatusDescriptorEIP1, *PDevElementStatusDescriptorEIP1;
+
+typedef union
+{
+	DevElementStatusDescriptorEIP0 EIP0;
+	DevElementStatusDescriptorEIP1 EIP1;
+}DevElementStatusDescriptor, *PDevElementStatusDescriptor;
+
+typedef struct _DevElementStatusPage
+{
+	MV_U8                      PageCode;
+	MV_U8                      Reserved;
+	MV_U16                     PageLength;
+	MV_U8                      GenerationCode[4];
+	DevElementStatusDescriptor DeviceElementStatusDescriptor;
+	MV_U8                      Data[2032];
+} DevElementStatusPage, *PDevElementStatusPage;
+
+typedef struct _SasPhyDescriptor
+{
+	MV_U8 Reserved1:4;
+	MV_U8 DeviceType:3;
+	MV_U8 Reserved2:1;
+	MV_U8 Reserved3;
+	MV_U8 Reserved4:1;
+	MV_U8 SMPInitiatorPort:1;
+	MV_U8 STPInitiatorPort:1;
+	MV_U8 SSPInitiatorPort:1;
+	MV_U8 Reserved5:4;
+	MV_U8 Reserved6:1;
+	MV_U8 SMPTargetPort:1;
+	MV_U8 STPTargetPort:1;
+	MV_U8 SSPTargetPort:1;
+	MV_U8 Reserved7:4;
+	MV_U8 AttachedSASAddress[8];
+	MV_U8 SASAddress[8];
+	MV_U8 PhyIdentifier;
+	MV_U8 Reserved8[7];
+} SasPhyDescriptor, *PSasPhyDescriptor;
+
+#define HIGH_CRITICAL_THRESHOLD MV_BIT(0)
+#define HIGH_WARNING_THRESHOLD MV_BIT(1)
+#define LOW_CRITICAL_THRESHOLD MV_BIT(2)
+#define LOW_WARNING_THRESHOLD   MV_BIT(3)
+
+#define MV_ELEMENTTHRESHOLD_TYPE(type)	((type==ENC_ELEMENTTYPE_TEMPERATURE)||	\
+						(type==ENC_ELEMENTTYPE_VOLTAGESENSOR))
+
+typedef struct _EncElement_Config
+{
+	MV_U16    enclosureID;
+	MV_U16    magicID;
+	MV_U8     type;
+	MV_U8     status;
+	MV_U8	  elementID;
+	MV_U8     highCriticalThreshold;
+	MV_U8     highWarningThreshold;
+	MV_U8     lowCriticalThreshold;
+	MV_U8     lowWarningThreshold;
+	MV_U8	  reserved[5];
+} EncElement_Config, *PEncElement_Config;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_entries_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_entries_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_entries_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_entries_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,20 @@
+#ifndef __MV_COM_ENTRIES_STRUCT_H__
+#define __MV_COM_ENTRIES_STRUCT_H__
+
+typedef struct _Hypper_LBAEntry
+{
+	MV_U64    lba;
+	MV_U32    length;
+	MV_U32    reserved;
+}Hypper_LBAEntry,*PHypper_LBAEntry;
+
+#define EMPTY_ENTIES                              0x0
+
+typedef struct _Hypper_Entry_Table
+{
+	MV_U16   TotalCount;
+	MV_U16   RemainCount;
+	MV_U8    reserved[36];
+}Hypper_Entry_Table,*PHypper_Entry_Table;
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_error.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_error.h
--- linux-3.10.69/drivers/scsi/mv/include/com_error.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_error.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,128 @@
+#ifndef __COM_ERROR_H__
+#define __COM_ERROR_H__
+
+#define ERR_GENERIC                              2
+#define ERR_RAID                                 50
+#define ERR_CORE                                 100
+#define ERR_API                                  150
+#define ERR_FLO									200
+#define ERR_AES                                 240
+#define ERR_NONE                                 0
+#define ERR_FAIL                                 1
+/* generic error */
+#define ERR_UNKNOWN                              (ERR_GENERIC + 1)
+#define ERR_NO_RESOURCE                          (ERR_GENERIC + 2)
+#define ERR_REQ_OUT_OF_RANGE                     (ERR_GENERIC + 3)
+#define ERR_INVALID_REQUEST                      (ERR_GENERIC + 4)
+#define ERR_INVALID_PARAMETER                    (ERR_GENERIC + 5)
+#define ERR_INVALID_LD_ID                        (ERR_GENERIC + 6)
+#define ERR_INVALID_HD_ID                        (ERR_GENERIC + 7)
+#define ERR_INVALID_EXP_ID                       (ERR_GENERIC + 8)
+#define ERR_INVALID_PM_ID                        (ERR_GENERIC + 9)
+#define ERR_INVALID_BLOCK_ID                     (ERR_GENERIC + 10)
+#define ERR_INVALID_ADAPTER_ID                   (ERR_GENERIC + 11)
+#define ERR_INVALID_RAID_MODE                    (ERR_GENERIC + 12)
+#define ERR_INVALID_ENC_ID                       (ERR_GENERIC + 13)
+#define ERR_INVALID_BU_ID                        (ERR_GENERIC + 14)
+#define ERR_INVALID_DG_ID                        (ERR_GENERIC + 15)
+#define ERR_INVALID_ENC_ELEMENT_ID               (ERR_GENERIC + 16)
+#define ERR_NOT_SUPPORTED                        (ERR_GENERIC + 17)
+#define ERR_DRIVER_SENSOR                        (ERR_GENERIC + 18)
+#define ERR_INVALID_KEY_PRESENT                  (ERR_GENERIC + 19)	// can not add key due to key present
+#define ERR_INVALID_KEY_ABSENT                   (ERR_GENERIC + 20)	// can not enable due to key absent
+#define ERR_COMMAND_PHASE_ERROR                  (ERR_GENERIC + 21) // Davinci diagnostic command phase error
+#define ERR_DATA_PHASE_ERROR                     (ERR_GENERIC + 22) // Davinci diagnostic data phase error
+#define ERR_STATUS_PHASE_ERROR                   (ERR_GENERIC + 23) // Davinci diagnostic status phase error
+#define ERR_STATUS_PHASE_PHASE_ERROR             (ERR_GENERIC + 24) // Davinci diagnostic status phase returns phase error
+#define ERR_STATUS_PHASE_CMD_ERROR               (ERR_GENERIC + 25) // Davinci diagnostic status phase returns command error
+#define ERR_INVALID_SSD_NUM                      (ERR_GENERIC + 26) // HyperHDD
+#define ERR_INVALID_ERASE_HDD                    (ERR_GENERIC + 27) // HyperHDD
+#define ERR_REGISTER_WRITING                     (ERR_GENERIC + 28) // dirty data protection
+
+#ifndef _MARVELL_SDK_PACKAGE_NONRAID
+/* RAID errors */
+#define ERR_TARGET_IN_LD_FUNCTIONAL              (ERR_RAID + 1)
+#define ERR_TARGET_NO_ENOUGH_SPACE               (ERR_RAID + 2)
+#define ERR_HD_IS_NOT_SPARE                      (ERR_RAID + 3)
+#define ERR_HD_IS_SPARE                          (ERR_RAID + 4)
+#define ERR_HD_NOT_EXIST                         (ERR_RAID + 5)
+#define ERR_HD_IS_ASSIGNED_ALREADY               (ERR_RAID + 6)
+#define ERR_INVALID_HD_COUNT                     (ERR_RAID + 7)
+#define ERR_LD_NOT_READY                         (ERR_RAID + 8)
+#define ERR_LD_NOT_EXIST                         (ERR_RAID + 9)
+#define ERR_LD_IS_FUNCTIONAL                     (ERR_RAID + 10)
+#define ERR_HAS_BGA_IN_VD                        (ERR_RAID + 11)
+#define ERR_NO_BGA_ACTIVITY                      (ERR_RAID + 12)
+#define ERR_BGA_RUNNING                          (ERR_RAID + 13)
+#define ERR_RAID_NO_AVAILABLE_ID                 (ERR_RAID + 14)
+#define ERR_LD_NO_ATAPI                          (ERR_RAID + 15)
+#define ERR_INVALID_RAID6_PARITY_DISK_COUNT      (ERR_RAID + 16)
+#define ERR_INVALID_BLOCK_SIZE                   (ERR_RAID + 17)
+#define ERR_MIGRATION_NOT_NEED                   (ERR_RAID + 18)
+#define ERR_STRIPE_BLOCK_SIZE_MISMATCH           (ERR_RAID + 19)
+#define ERR_MIGRATION_NOT_SUPPORT                (ERR_RAID + 20)
+#define ERR_LD_NOT_FULLY_INITED                  (ERR_RAID + 21)
+#define ERR_LD_NAME_INVALID	                     (ERR_RAID + 22)
+#define ERR_HD_TYPE_MISMATCH                     (ERR_RAID + 23)
+#define ERR_HD_SECTOR_SIZE_MISMATCH              (ERR_RAID + 24)
+#define ERR_NO_LD_IN_DG                          (ERR_RAID + 25)
+#define ERR_HAS_LD_IN_DG                         (ERR_RAID + 26)
+#define ERR_NO_ROOM_FOR_SPARE					 (ERR_RAID + 27)
+#define ERR_SPARE_IS_IN_MULTI_DG				 (ERR_RAID + 28)
+#define ERR_DG_HAS_MISSING_PD					 (ERR_RAID + 29)
+#define ERR_LD_NOT_IMPORTABLE                    (ERR_RAID + 30)
+#define ERR_HAS_MIGRATION_ON_DG					 (ERR_RAID + 31)
+#define ERR_HAS_BGA_IN_DG				         (ERR_RAID + 32)
+#define ERR_HD_CANNOT_SET_DOWN                   (ERR_RAID + 33)
+#define ERR_HD_NOT_OFFLINE					     (ERR_RAID + 34)
+#define ERR_LD_STATUS_WRONG     			     (ERR_RAID + 35)
+#define ERR_LD_NOT_REPORTABLE                    (ERR_RAID + 36)
+#define ERR_RAID_NOT_REDUNDANT                   (ERR_RAID + 37)
+#define ERR_MP_RUNNING                           (ERR_RAID + 38)
+#define ERR_SPARE_IS_IN_USED                      (ERR_RAID + 39)
+#endif
+//_MARVELL_SDK_PACKAGE_NONRAID
+
+/* API errors */
+#define ERR_INVALID_MATCH_ID                     (ERR_API + 1)
+#define ERR_INVALID_HDCOUNT                      (ERR_API + 2)
+#define ERR_INVALID_BGA_ACTION                   (ERR_API + 3)
+#define ERR_HD_IN_DIFF_CARD                      (ERR_API + 4)
+#define ERR_INVALID_FLASH_TYPE                   (ERR_API + 5)
+#define ERR_INVALID_FLASH_ACTION                 (ERR_API + 6)
+#define ERR_TOO_FEW_EVENT                        (ERR_API + 7)
+#define ERR_VD_HAS_RUNNING_OS                    (ERR_API + 8)
+#define ERR_DISK_HAS_RUNNING_OS                  (ERR_API + 9)
+#define ERR_COMMAND_NOT_SUPPORTED                (ERR_API + 10)
+#define ERR_MIGRATION_LIMIT	                     (ERR_API + 11)  // not used
+#define ERR_SGPIO_CONTROL_NOT_SUPPORTED			 (ERR_API + 12)
+#define ERR_COUNT_OUT_OF_RANGE      			 (ERR_API + 13)	 // internal error
+#define ERR_IOCTL_NO_RESOURCE                    (ERR_API + 14)
+#define ERR_INVALID_FILE                         (ERR_API + 15)
+#define ERR_INVALID_MICROCODE                    (ERR_API + 16)
+#define ERR_USER_NOT_FOUND 				         (ERR_API+17)
+#define ERR_USER_NOT_INUSE   			         (ERR_API+18)
+#define ERR_USER_INUSE		 			         (ERR_API+19)
+#define ERR_DEVICE_IS_BUSY				         (ERR_API+31)
+#define ERR_SHELL_CMD_FAIL				         (ERR_API+32)
+#define ERR_LOAD_LOKI_API_FAIL			         (ERR_API+33)
+#define ERR_INVALID_FLASH_DATA			         (ERR_API+34)
+#define ERR_INVALID_FLASH_DESCRIPTOR	         (ERR_API+35)
+#define ERR_NEED_RESCAN                          (ERR_API+36)
+#define ERR_RESCANING                            (ERR_API+37)
+#define ERR_NOT_SUPPORT_MIGRATE                  (ERR_API+38)
+#define ERR_OUT_OF_MEMORY                        (ERR_API+39)
+
+/* AES error */
+#define ERR_ENTRY_OUT_OF_RANGE                  (ERR_AES + 1)
+#define ERR_PORT_OUT_OF_RANGE                   (ERR_AES + 2)
+#define ERR_INVALID_NUM_REQUESTED               (ERR_AES + 3)
+#define ERR_INVALID_REQUEST_TYPE                (ERR_AES + 4)
+#define ERR_INVALID_KEY_LENGTH                  (ERR_AES + 5)
+#define ERR_NOT_OFFLINE_DISK                    (ERR_AES + 6)
+#define ERR_KEY_MISMATCH                        (ERR_AES + 7)
+#define ERR_PASSWORD_MISMATCH                   (ERR_AES + 8)
+#define ERR_PORT_ID_NOT_FOUND                   (ERR_AES + 9)
+#define ERR_ENTRY_NO_KEY                        (ERR_AES + 10) // the specified entry has no key.
+
+#endif /*  __COM_ERROR_H__ */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_event_define_ext.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_event_define_ext.h
--- linux-3.10.69/drivers/scsi/mv/include/com_event_define_ext.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_event_define_ext.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,491 @@
+#ifndef COM_EVENT_DEFINE_EXT_H
+#define COM_EVENT_DEFINE_EXT_H
+
+//===================================================================================
+//===================================================================================
+//        All these events are new ones but which are listed in LSI product.
+//    Pay attention: All suggested display messages are from from LSI event list.
+//  We may make some little change later, especially for new events in Loki.
+//===================================================================================
+//===================================================================================
+
+//=======================================
+//=======================================
+//                Event Classes
+//=======================================
+//=======================================
+
+#define    EVT_CLASS_SAS                7        // SAS, mainly for SAS topology
+#define    EVT_CLASS_ENCL               8        // Enclosure
+#define    EVT_CLASS_BAT                9       // Battery
+#define    EVT_CLASS_FLASH              10      // Flash memory
+#define    EVT_CLASS_CACHE              11      // Cache related
+#define    EVT_CLASS_MISC               12      // For other miscellenous events
+#define    EVT_CLASS_ARRAY              13      // Array
+#define    EVT_CLASS_SSD                14      // SSD
+#define    EVT_CLASS_OEM                15      // OEM event
+
+//=============================================================
+//                    Event Codes 
+//
+//    !!!  When adding an EVT_ID, Please put its severity level
+//  !!!  and suggested mesage string as comments.  This is the 
+//  !!!  only place to document how 'Params' in 'DriverEvent' 
+//  !!!  structure is to be used.
+//  !!!  Please refer to the EventMessages.doc to get details.
+//=============================================================
+
+//
+// Event code for EVT_CLASS_SAS (sas)
+//
+
+#define EVT_CODE_SAS_LOOP_DETECTED                0  //SAS Topology error: Loop detected
+#define EVT_CODE_SAS_UNADDR_DEVICE                1  //SAS Topology error: Unaddressable device
+#define EVT_CODE_SAS_MULTIPORT_SAME_ADDR          2  //SAS Topology error: Multiple ports to the same SAS address
+#define EVT_CODE_SAS_EXPANDER_ERR                 3  //SAS Topology error: Expander error
+#define EVT_CODE_SAS_SMP_TIMEOUT                  4  //SAS Topology error: SMP timeout
+#define EVT_CODE_SAS_OUT_OF_ROUTE_ENTRIES         5  //SAS Topology error: Out of route entries
+#define EVT_CODE_SAS_INDEX_NOT_FOUND              6  //SAS Topology error: Index not found
+#define EVT_CODE_SAS_SMP_FUNC_FAILED              7  //SAS Topology error: SMP function failed    
+#define EVT_CODE_SAS_SMP_CRC_ERR                  8  //SAS Topology error: SMP CRC error
+#define EVT_CODE_SAS_MULTI_SUBTRACTIVE            9  //SAS Topology error: Multiple subtractive
+#define EVT_CODE_SAS_TABEL_TO_TABLE               10 //SAS Topology error: Table to Table
+#define EVT_CODE_SAS_MULTI_PATHS                  11 //SAS Topology error: Multiple paths
+#define EVT_CODE_SAS_WIDE_PORT_LOST_LINK_ON_PHY   12 //SAS wide port %d lost link on PHY %d 
+#define EVT_CODE_SAS_WIDE_PORT_REST_LINK_ON_PHY   13 //SAS wide port %d restored link on PHY %d 
+#define EVT_CODE_SAS_PHY_EXCEED_ERR_RATE          14 //SAS port %d, PHY %d has exceeded the allowed error rate
+#define EVT_CODE_SAS_SATA_MIX_NOT_SUPPORTED       15 //SAS/SATA mixing not supported in enclosure: PD %d disabled
+
+//
+// Event code for EVT_CLASS_ENCL (enclosure)
+//
+
+#define    EVT_CODE_ENCL_SES_DISCOVERED            0   // Enclosure(SES) discovered on %d
+#define    EVT_CODE_ENCL_SAFTE_DISCOVERED          1   // Enclosure(SAFTE) discovered on %d
+#define    EVT_CODE_ENCL_COMMUNICATION_LOST        2   // Enclosure %d communication lost
+#define    EVT_CODE_ENCL_COMMUNICATION_RESTORED    3   // Enclosure %d communication restored
+#define    EVT_CODE_ENCL_FAN_FAILED                4   // Enclosure %d fan %d failed
+#define    EVT_CODE_ENCL_FAN_INSERTED              5   // Enclosure %d fan %d inserted
+#define    EVT_CODE_ENCL_FAN_REMOVED               6   // Enclosure %d fan %d removed
+#define    EVT_CODE_ENCL_PS_FAILED                 7   // Enclosure %d power supply %d failed
+#define    EVT_CODE_ENCL_PS_INSERTED               8   // Enclosure %d power supply %d inserted
+#define    EVT_CODE_ENCL_PS_REMOVED                9   // Enclosure %d power supply %d removed
+#define    EVT_CODE_ENCL_SIM_FAILED                10  // Enclosure %d SIM %d failed
+#define    EVT_CODE_ENCL_SIM_INSERTED              11  // Enclosure %d SIM %d inserted
+#define    EVT_CODE_ENCL_SIM_REMOVED               12  // Enclosure %d SIM %d removed
+#define    EVT_CODE_ENCL_TEMP_SENSOR_BELOW_WARNING 13  // Enclosure %d temperature sensor %d below warning threshold
+#define    EVT_CODE_ENCL_TEMP_SENSOR_BELOW_ERR     14  // Enclosure %d temperature sensor %d below error threshold
+#define    EVT_CODE_ENCL_TEMP_SENSOR_ABOVE_WARNING 15  // Enclosure %d temperature sensor %d above warning threshold
+#define    EVT_CODE_ENCL_TEMP_SENSOR_ABOVE_ERR     16  // Enclosure %d temperature sensor %d above error threshold 
+#define EVT_CODE_ENCL_SHUTDOWN                     17  // Enclosure %d shutdown
+#define EVT_CODE_ENCL_NOT_SUPPORTED                18  // Enclosure %d not supported; too many enclosures connected to port
+#define    EVT_CODE_ENCL_FW_MISMATCH               19  // Enclosure %d firmware mismatch 
+#define    EVT_CODE_ENCL_SENSOR_BAD                20  // Enclosure %d sensor %d bad
+#define    EVT_CODE_ENCL_PHY_BAD                   21  // Enclosure %d phy %d bad
+#define    EVT_CODE_ENCL_IS_UNSTABLE               22  // Enclosure %d is unstable
+#define    EVT_CODE_ENCL_HW_ERR                    23  // Enclosure %d hardware error
+#define    EVT_CODE_ENCL_NOT_RESPONDING            24  // Enclosure %d not responding
+#define    EVT_CODE_ENCL_HOTPLUG_DETECTED          25  // Enclosure(SES) hotplug on %d was detected, but is not supported 
+#define    EVT_CODE_ENCL_PS_SWITCHED_OFF           26  // Enclosure %d Power supply %d switched off
+#define    EVT_CODE_ENCL_PS_SWITCHED_ON            27  // Enclosure %d Power supply %d switched on
+#define    EVT_CODE_ENCL_PS_CABLE_REMOVED          28  // Enclosure %d Power supply %d cable removed
+#define    EVT_CODE_ENCL_PS_CABLE_INSERTED         29  // Enclosure %d Power supply %d cable inserted
+#define    EVT_CODE_ENCL_FAN_RETURN_TO_NORMAL      30  // Enclosure %d Fan %d returned to normal
+#define    EVT_CODE_ENCL_TEMP_RETURN_TO_NORMAL     31  // Enclosure %d Temperature %d returned to normal
+#define    EVT_CODE_ENCL_FW_DWLD_IN_PRGS           32  // Enclosure %d Firmware download in progress
+#define    EVT_CODE_ENCL_FW_DWLD_FAILED            33  // Enclosure %d Firmware download failed
+#define    EVT_CODE_ENCL_TEMP_SENSOR_DIFF_DETECTED 34  // Enclosure %d Temperature sensor %d differential detected
+#define    EVT_CODE_ENCL_FAN_SPEED_CHANGED         35  // Enclosure %d fan %d speed changed
+
+
+//
+// Event code for EVT_CLASS_BAT
+//
+
+#define EVT_CODE_BAT_PRESENT                                0   // Battery present
+#define EVT_CODE_BAT_NOT_PRESENT                            1   // Battery not present
+#define EVT_CODE_BAT_NEW_BAT_DETECTED                       2   // New battery detected
+#define EVT_CODE_BAT_NEED_REPLACE                           3   // Battery needs to be replaced
+#define EVT_CODE_BAT_REPLACED                               4   // Battery has been replaced 
+#define EVT_CODE_BAT_REMOVED                                5   // Battery is removed
+#define EVT_CODE_BAT_RELEARN_STARTED                        6   // Battery relearn started
+#define EVT_CODE_BAT_RELEARN_IN_PGRS                        7   // Battery relearn in progress
+#define EVT_CODE_BAT_RELEARN_COMPLETED                      8   // Battery relearn completed
+#define EVT_CODE_BAT_RELEARN_TIMED_OUT                      9   // Battery relearn timed out
+#define EVT_CODE_BAT_RELEARN_PENDING                        10  // Battery relearn pending: Battery is under charge
+#define EVT_CODE_BAT_RELEARN_POSTPONED                      11  // Battery relearn postponed
+#define EVT_CODE_BAT_START_IN_4_DAYS                        12  // Battery relearn will start in 4 days
+#define EVT_CODE_BAT_START_IN_2_DAYS                        13  // Battery relearn will start in 2 days
+#define EVT_CODE_BAT_START_IN_1_DAY                         14  // Battery relearn will start in 1 days
+#define EVT_CODE_BAT_START_IN_5_HOURS                       15  // Battery relearn will start in 5 hours
+#define EVT_CODE_BAT_DISCHARGING                            16  // Battery is discharging
+#define EVT_CODE_BAT_STARTED_CHARGING                       17  // Battery started charging
+#define EVT_CODE_BAT_CHARGE_CMPLT                           18  // Battery completed charging
+#define EVT_CODE_BAT_CHARGER_PROBLEM_DETECTED               19  // Battery/charger problems detected
+#define EVT_CODE_BAT_CAPACITY_BELOW_THRESHOLD               20  // Battery capacity is below threshold 
+#define EVT_CODE_BAT_CAPACITY_ABOVE_THRESHOLD               21  // Battery capacity is above threshold
+#define EVT_CODE_BAT_TEMP_IS_LOW                            22  // Battery temperature is low
+#define EVT_CODE_BAT_TEMP_IS_NORMAL                         23  // Battery temperature back to normal
+#define EVT_CODE_BAT_TEMP_IS_HIGH                           24  // Battery temperature is high
+#define EVT_CODE_BAT_VOLTAGE_LOW                            25  // Battery voltage is low
+#define EVT_CODE_BAT_VOLTAGE_NORMAL                         26  // Battery voltage back to normal
+#define EVT_CODE_BAT_VOLTAGE_HIGH                           27  // Battery voltage is high
+#define EVT_CODE_BAT_FORCE_WRITE_THROUGH                    28  // Battery capacity is too low, force all VD to use write through mode
+#define EVT_CODE_BAT_SAFE_TO_USE_WRITE_BACK                 29  // Battery capacity back to normal, VD is safe to use write back mode.
+#define EVT_CODE_BAT_STOP_CHARGING                          30  // Battery stop charging.
+#define EVT_CODE_BAT_STOP_DISCHARGING                       31  // Battery stop discharging.
+#define EVT_CODE_BAT_CHANGE_CHARGE_THRESHOLD                32  // Battery change charge threshold.
+#define EVT_CODE_BAT_CHANGE_VOLTAGE_WARNING_THRESHOLD       33  // Battery change voltage warning threshold.
+#define EVT_CODE_BAT_CHANGE_TEMPERATURE_WARNING_THRESHOLD   34  // Battery change temperature warning threshold.
+
+
+//
+// Event code for EVT_CLASS_FLASH
+//
+
+#define EVT_CODE_FLASH_DWLDED_IMAGE_CORRUPTED       0    // Flash downloaded image corrupt
+#define EVT_CODE_FLASH_ERASE_ERR                    1   // Flash erase error
+#define EVT_CODE_FLASH_ERASE_TIMEOUT                2   // Flash timeout during erase
+#define EVT_CODE_FLASH_FLASH_ERR                    3    // Flash error
+#define EVT_CODE_FLASHING_IMAGE                     4    // Flashing image: %d
+#define EVT_CODE_FLASHING_NEW_IMAGE_DONE            5   // Flash of new firmware images complete
+#define EVT_CODE_FLASH_PROGRAMMING_ERR              6   // Flash programming error
+#define EVT_CODE_FLASH_PROGRAMMING_TIMEOUT          7   // Flash timeout during programming
+#define EVT_CODE_FLASH_UNKNOWN_CHIP_TYPE            8   // Flash chip type unknown 
+#define EVT_CODE_FLASH_UNKNOWN_CMD_SET              9   // Flash command set unknown
+#define EVT_CODE_FLASH_VERIFY_FAILURE               10  // Flash verify failure
+#define EVT_CODE_NVRAM_CORRUPT                      11    // NVRAM is corrupt; reinitializing
+#define EVT_CODE_NVRAM_MISMACTH_OCCURED             12  // NVRAM mismatch occured
+#define EVT_CODE_NVRAM_RECONSTRUCTION_STARTED       13  // NVRAM reconstruction started    (for vili)
+#define EVT_CODE_NVRAM_RECONSTRUCTION_DONE          14  // NVRAM reconstruction done    (for vili)
+
+//
+// Event code for new Flash command (Loki and Frey)
+//
+#define EVT_CODE_FLASH_WRITE_ERR                    15 // Flash operation failed (for Loki and Frey)
+#define EVT_CODE_FLASH_READ_ERR                     16 // Flash operation failed (for Loki and Frey)
+#define EVT_CODE_FLASH_WRITE_IMAGE_SUCCEEDED        17
+#define EVT_CODE_FLASH_READ_IMAGE_SUCCEEDED         18
+#define EVT_CODE_FLASH_WRITE_IMAGE_FAILED           19
+#define EVT_CODE_FLASH_READ_IMAGE_FAILED            20
+#define EVT_CODE_FLASH_GENERATION_ERR               21 // generation error (for Loki and Frey)
+#define  EVT_CODE_FLASH_FATAL_GENERATION_ERR        22
+#define EVT_CODE_FLASH_HEADER_ERR                   23 // Header error in flash (for Loki and Frey)
+#define EVT_CODE_FLASH_DATA_ERR                     24 // Header error in flash (for Loki and Frey)
+#define EVT_CODE_FLASH_DATA_AND_HEADER_ERR          25 // Header error in flash (for Loki and Frey)
+
+//
+// Event code for EVT_CLASS_CACHE(Cache)
+//
+
+#define EVT_CODE_CACHE_NOT_RECV_FROM_TBBU           0    // Unable to recover cache data from TBBU
+#define EVT_CODE_CACHE_RECVD_FROM_TBBU              1   // Cache data recovered from TBBU successfully
+#define EVT_CODE_CACHE_CTRLER_CACHE_DISCARDED       2   // Controller cache discarded due to memory/battery problems
+#define EVT_CODE_CACHE_FAIL_RECV_DUETO_MISMATCH     3   // Unable to recover cache data due to configuration mismatch 
+#define EVT_CODE_CACHE_DIRTY_DATA_DISCARDED         4    // Dirty cache data discarded by user
+#define EVT_CODE_CACHE_FLUSH_RATE_CHANGED           5   // Flush rate changed to %d seconds.
+
+
+//
+// Event code for EVT_CLASS_MISC
+//
+
+#define EVT_CODE_MISC_CONFIG_CLEARED                0    // Configuration cleared
+#define EVT_CODE_MISC_CHANGE_BACK_ACTIVITY_RATE     1    // Background activity rate changed to %d%%
+#define EVT_CODE_MISC_FATAL_FW_ERR                  2   // Fatal firmware error: %d
+#define EVT_CODE_MISC_FACTORY_DEFAULTS_RESTORED     3   // Factory defaults restored
+#define EVT_CODE_MISC_GET_HIBER_CMD                 4   // Hibernation command received from host
+#define EVT_CODE_MISC_MUTLI_BIT_ECC_ERR             5    // Multi-bit ECC error: count = %d, address = 0x%X, module ID = %d
+#define EVT_CODE_MISC_SINGLE_BIT_ECC_ERR            6   // Single-bit ECC error: count = %d
+#define EVT_CODE_MISC_GET_SHUTDOWN_CMD              7    // Shutdown command received from host
+#define EVT_CODE_MISC_TIME_ESTABLISHED              8    // Time established as %d; (%d seconds since power on)
+#define EVT_CODE_MISC_USER_ENTERED_DEBUGGER         9   // User entered firmware debugger
+#define EVT_CODE_MISC_FORMAT_COMPLETE               10    // Format complete on %d
+#define EVT_CODE_MISC_FORMAT_STARTED                11    // Format started on %d 
+#define EVT_CODE_MISC_REASSIGN_WRITE_OP             12    // Reassign write operation on %d is %d
+#define EVT_CODE_MISC_UNEXPECTED_SENSE              13    // Unexpected sense: %d, CDB%d, Sense: %d
+#define EVT_CODE_MISC_REPLACED_MISSING              14    // Replaced missing as %d on array %d row %d
+#define EVT_CODE_MISC_NOT_A_CERTIFIED_DRIVE         15  // %d is not a certificated derive
+
+/* May put into other group???*/
+#define EVT_CODE_MISC_PD_MISSING_FROM_CONFIG_AT_BOOT    16    // PDs missing from configuration on boot    
+#define EVT_CODE_MISC_VD_MISSING_DRIVES                 17  // VDs missing drives and will go offline at boot: %d
+#define EVT_CODE_MISC_VD_MISSING_AT_BOOT                18  // VDs missing at boot: %d
+#define EVT_CODE_MISC_PREVIOUS_CONFIG_MISSING_AT_BOOT   19  // Previous configuration completely missing at boot
+#define EVT_CODE_MISC_PD_TOO_SMALL_FOR_AUTOREBUILD      20  // PD too small to be used for auto-rebuild on %d.
+#define EVT_CODE_MISC_PD_TOO_SMALL_FOR_COPYBACK         21
+#define EVT_CODE_MISC_CHANGE_SYNC_RATE                  22    // Synchronize rate changed to %d%%
+#define EVT_CODE_MISC_CHANGE_INIT_RATE                  23    // Init rate changed to %d%%
+#define EVT_CODE_MISC_CHANGE_REBUILD_RATE               24    // Rebuild rate changed to %d%%
+#define EVT_CODE_MISC_CHANGE_MIGRATION_RATE             25    // Migration rate changed to %d%%
+#define EVT_CODE_MISC_CHANGE_COPYBACK_RATE              26    // Copyback rate changed to %d%%
+#define EVT_CODE_MISC_CHANGE_MP_RATE                    27    // Media Patrol rate changed to %d%%
+#define EVT_CODE_MISC_ALARM_MUTE                        28    // Adapter alarm set to mute
+//
+// Event code for EVT_CLASS_ARRAY
+//
+
+#define EVT_CODE_ARRAY_CREATE                            0
+#define EVT_CODE_ARRAY_DELETE                            1
+
+//
+// Event code for EVT_CLASS_OEM
+//
+
+#define _CLASS_OEM(x)                (EVT_CLASS_OEM << 16 | (x))
+
+#define EVT_CODE_ADAPTER_TEMP_OPTIMAL                   0  // temperature check pass
+#define EVT_CODE_ADAPTER_TEMP_WARN                      1  // adapter is high temperature
+#define EVT_CODE_ADAPTER_TEMP_CRITICAL                  2  // adapter is critical temperature, immediate action requested
+#define EVT_CODE_ADAPTER_FAN_OPTIMAL                    3  // fan check pass
+#define EVT_CODE_ADAPTER_FAN_FAILURE                    4  // defective fan %d found
+#define EVT_CODE_ADAPTER_FAN_ABSENT                     5  // absent fan %d found
+#define EVT_CODE_ADAPTER_PSU_ALERT                      6  // power supply alert
+#define EVT_CODE_ADAPTER_PSU_OPTIMAL                    7  // power supply is optimal
+#define EVT_CODE_ADAPTER_MUTE_PRESS                     8  // mute is pressed
+#define EVT_CODE_ADAPTER_IDENTFICATION_PRESS            9  // identification is pressed
+#define EVT_CODE_ADAPTER_IDENTFICATION_ON               10 // identification is pressed
+#define EVT_CODE_ADAPTER_IDENTFICATION_OFF              11 // identification is pressed
+#define EVT_CODE_ADAPTER_INTRUSION_OPEN                 12 // intrusion is open
+#define EVT_CODE_ADAPTER_INTRUSION_CLOSE                13 // intrusion is close
+#define EVT_CODE_ADAPTER_STATUS_LOW_POWER               14 // adapter become low power status
+#define EVT_CODE_ADAPTER_STATUS_IDLE                    15 // adapter become idle status
+
+//=======================================
+//=======================================
+//                Event IDs
+//=======================================
+//=======================================
+
+//
+// Event id for EVT_CLASS_SAS
+//
+
+#define _CLASS_SAS(x)                (EVT_CLASS_SAS << 16 | (x))
+
+#define EVT_ID_SAS_LOOP_DETECTED                       _CLASS_SAS(EVT_CODESAS_LOOP_DETECTED)
+#define EVT_ID_SAS_UNADDR_DEVICE                       _CLASS_SAS(EVT_CODESAS_UNADDR_DEVICE)            
+#define EVT_ID_SAS_MULTIPORT_SAME_ADDR                 _CLASS_SAS(EVT_CODESAS_MULTIPORT_SAME_ADDR)
+#define EVT_ID_SAS_EXPANDER_ERR                        _CLASS_SAS(EVT_CODESAS_EXPANDER_ERR)
+#define EVT_ID_SAS_SMP_TIMEOUT                         _CLASS_SAS(EVT_CODESAS_SMP_TIMEOUT)
+#define EVT_ID_SAS_OUT_OF_ROUTE_ENTRIES                _CLASS_SAS(EVT_CODESAS_OUT_OF_ROUTE_ENTRIES)
+#define EVT_ID_SAS_INDEX_NOT_FOUND                     _CLASS_SAS(EVT_CODESAS_INDEX_NOT_FOUND)
+#define EVT_ID_SAS_SMP_FUNC_FAILED                     _CLASS_SAS(EVT_CODESAS_SMP_FUNC_FAILED)
+#define EVT_ID_SAS_SMP_CRC_ERR                         _CLASS_SAS(EVT_CODESAS_SMP_CRC_ERR)
+#define EVT_ID_SAS_MULTI_SUBTRACTIVE                   _CLASS_SAS(EVT_CODESAS_MULTI_SUBTRACTIVE)
+#define EVT_ID_SAS_TABEL_TO_TABLE                      _CLASS_SAS(EVT_CODESAS_TABEL_TO_TABLE)
+#define EVT_ID_SAS_MULTI_PATHS                         _CLASS_SAS(EVT_CODESAS_MULTI_PATHS)
+#define EVT_ID_SAS_WIDE_PORT_LOST_LINK_ON_PHY          _CLASS_SAS(EVT_CODESAS_WIDE_PORT_LOST_LINK_ON_PHY)
+#define EVT_ID_SAS_WIDE_PORT_REST_LINK_ON_PHY          _CLASS_SAS(EVT_CODESAS_WIDE_PORT_REST_LINK_ON_PHY)
+#define EVT_ID_SAS_PHY_EXCEED_ERR_RATE                 _CLASS_SAS(EVT_CODESAS_PHY_EXCEED_ERR_RATE)
+#define EVT_ID_SAS_SATA_MIX_NOT_SUPPORTED              _CLASS_SAS(EVT_CODESAS_SATA_MIX_NOT_SUPPORTED)
+
+//
+// Event id for EVT_CLASS_ENCL (enclosure)
+//
+
+#define _CLASS_ENCL(x)                (EVT_CLASS_ENCL << 16 | (x))
+
+#define    EVT_ID_ENCL_SES_DISCOVERED                   _CLASS_ENCL(EVT_CODE_ENCL_SES_DISCOVERED)                
+#define    EVT_ID_ENCL_SAFTE_DISCOVERED                 _CLASS_ENCL(EVT_CODE_ENCL_SAFTE_DISCOVERED)
+#define    EVT_ID_ENCL_COMMUNICATION_LOST               _CLASS_ENCL(EVT_CODE_ENCL_COMMUNICATION_LOST)
+#define    EVT_ID_ENCL_COMMUNICATION_RESTORED           _CLASS_ENCL(EVT_CODE_ENCL_COMMUNICATION_RESTORED)
+#define    EVT_ID_ENCL_FAN_FAILED                       _CLASS_ENCL(EVT_CODE_ENCL_FAN_FAILED)
+#define    EVT_ID_ENCL_FAN_INSERTED                     _CLASS_ENCL(EVT_CODE_ENCL_FAN_INSERTED)
+#define    EVT_ID_ENCL_FAN_REMOVED                      _CLASS_ENCL(EVT_CODE_ENCL_FAN_REMOVED)
+#define    EVT_ID_ENCL_PS_FAILED                        _CLASS_ENCL(EVT_CODE_ENCL_PS_FAILED)
+#define    EVT_ID_ENCL_PS_INSERTED                      _CLASS_ENCL(EVT_CODE_ENCL_PS_INSERTED)
+#define    EVT_ID_ENCL_PS_REMOVED                       _CLASS_ENCL(EVT_CODE_ENCL_PS_REMOVED)
+#define    EVT_ID_ENCL_SIM_FAILED                       _CLASS_ENCL(EVT_CODE_ENCL_SIM_FAILED)
+#define    EVT_ID_ENCL_SIM_INSERTED                     _CLASS_ENCL(EVT_CODE_ENCL_SIM_INSERTED)
+#define    EVT_ID_ENCL_SIM_REMOVED                      _CLASS_ENCL(EVT_CODE_ENCL_SIM_REMOVED)
+#define    EVT_ID_ENCL_TEMP_SENSOR_BELOW_WARNING        _CLASS_ENCL(EVT_CODE_ENCL_TEMP_SENSOR_BELOW_WARNING)
+#define    EVT_ID_ENCL_TEMP_SENSOR_BELOW_ERR            _CLASS_ENCL(EVT_CODE_ENCL_TEMP_SENSOR_BELOW_ERR)
+#define    EVT_ID_ENCL_TEMP_SENSOR_ABOVE_WARNING        _CLASS_ENCL(EVT_CODE_ENCL_TEMP_SENSOR_ABOVE_WARNING)
+#define    EVT_ID_ENCL_TEMP_SENSOR_ABOVE_ERR            _CLASS_ENCL(EVT_CODE_ENCL_TEMP_SENSOR_ABOVE_ERR)
+#define    EVT_ID_ENCL_SHUTDOWN                         _CLASS_ENCL(EVT_CODE_ENCL_SHUTDOWN)
+#define    EVT_ID_ENCL_NOT_SUPPORTED                    _CLASS_ENCL(EVT_CODE_ENCL_NOT_SUPPORTED)
+#define    EVT_ID_ENCL_FW_MISMATCH                      _CLASS_ENCL(EVT_CODE_ENCL_FW_MISMATCH)
+#define    EVT_ID_ENCL_SENSOR_BAD                       _CLASS_ENCL(EVT_CODE_ENCL_SENSOR_BAD)
+#define    EVT_ID_ENCL_PHY_BAD                          _CLASS_ENCL(EVT_CODE_ENCL_PHY_BAD)
+#define    EVT_ID_ENCL_IS_UNSTABLE                      _CLASS_ENCL(EVT_CODE_ENCL_IS_UNSTABLE)
+#define    EVT_ID_ENCL_HW_ERR                           _CLASS_ENCL(EVT_CODE_ENCL_HW_ERR)
+#define    EVT_ID_ENCL_NOT_RESPONDING                   _CLASS_ENCL(EVT_CODE_ENCL_NOT_RESPONDING)
+#define    EVT_ID_ENCL_HOTPLUG_DETECTED                 _CLASS_ENCL(EVT_CODE_ENCL_HOTPLUG_DETECTED)
+#define    EVT_ID_ENCL_PS_SWITCHED_OFF                  _CLASS_ENCL(EVT_CODE_ENCL_PS_SWITCHED_OFF    )    
+#define    EVT_ID_ENCL_PS_SWITCHED_ON                   _CLASS_ENCL(EVT_CODE_ENCL_PS_SWITCHED_ON)
+#define    EVT_ID_ENCL_PS_CABLE_REMOVED                 _CLASS_ENCL(EVT_CODE_ENCL_PS_CABLE_REMOVED)
+#define    EVT_ID_ENCL_PS_CABLE_INSERTED                _CLASS_ENCL(EVT_CODE_ENCL_PS_CABLE_INSERTED)
+#define    EVT_ID_ENCL_FAN_RETURN_TO_NORMAL             _CLASS_ENCL(EVT_CODE_ENCL_FAN_RETURN_TO_NORMAL)    
+#define    EVT_ID_ENCL_TEMP_RETURN_TO_NORMAL            _CLASS_ENCL(EVT_CODE_ENCL_TEMP_RETURN_TO_NORMAL)        
+#define    EVT_ID_ENCL_FW_DWLD_IN_PRGS                  _CLASS_ENCL(EVT_CODE_ENCL_FW_DWLD_IN_PRGS    )
+#define    EVT_ID_ENCL_FW_DWLD_FAILED                   _CLASS_ENCL(EVT_CODE_ENCL_FW_DWLD_FAILED)    
+#define    EVT_ID_ENCL_TEMP_SENSOR_DIFF_DETECTED        _CLASS_ENCL(EVT_CODE_ENCL_TEMP_SENSOR_DIFF_DETECTED)
+#define    EVT_ID_ENCL_FAN_SPEED_CHANGED                _CLASS_ENCL(EVT_CODE_ENCL_FAN_SPEED_CHANGED)
+
+//
+// Event id for EVT_CLASS_BAT
+//
+
+#define _CLASS_BAT(x)                (EVT_CLASS_BAT << 16 | (x))
+
+#define EVT_ID_BAT_PRESENT                               _CLASS_BAT(EVT_CODE_BAT_PRESENT)
+#define EVT_ID_BAT_NOT_PRESENT                           _CLASS_BAT(EVT_CODE_BAT_NOT_PRESENT)
+#define EVT_ID_BAT_NEW_BAT_DETECTED                      _CLASS_BAT(EVT_CODE_BAT_NEW_BAT_DETECTED)
+#define EVT_ID_BAT_REPLACED                              _CLASS_BAT(EVT_CODE_BAT_REPLACED)
+#define EVT_ID_BAT_TEMP_IS_HIGH                          _CLASS_BAT(EVT_CODE_BAT_TEMP_IS_HIGH)
+#define EVT_ID_BAT_VOLTAGE_LOW                           _CLASS_BAT(EVT_CODE_BAT_VOLTAGE_LOW)
+#define EVT_ID_BAT_STARTED_CHARGING                      _CLASS_BAT(EVT_CODE_BAT_STARTED_CHARGING)
+#define EVT_ID_BAT_DISCHARGING                           _CLASS_BAT(EVT_CODE_BAT_DISCHARGING)
+#define EVT_ID_BAT_TEMP_IS_NORMAL                        _CLASS_BAT(EVT_CODE_BAT_TEMP_IS_NORMAL)
+#define EVT_ID_BAT_NEED_REPLACE                          _CLASS_BAT(EVT_CODE_BAT_NEED_REPLACE)
+#define EVT_ID_BAT_RELEARN_STARTED                       _CLASS_BAT(EVT_CODE_BAT_RELEARN_STARTED)
+#define EVT_ID_BAT_RELEARN_IN_PGRS                       _CLASS_BAT(EVT_CODE_BAT_RELEARN_IN_PGRS)
+#define EVT_ID_BAT_RELEARN_COMPLETED                     _CLASS_BAT(EVT_CODE_BAT_RELEARN_COMPLETED)
+#define EVT_ID_BAT_RELEARN_TIMED_OUT                     _CLASS_BAT(EVT_CODE_BAT_RELEARN_TIMED_OUT)
+#define EVT_ID_BAT_RELEARN_PENDING                       _CLASS_BAT(EVT_CODE_BAT_RELEARN_PENDING)
+#define EVT_ID_BAT_RELEARN_POSTPONED                     _CLASS_BAT(EVT_CODE_BAT_RELEARN_POSTPONED)
+#define EVT_ID_BAT_START_IN_4_DAYS                       _CLASS_BAT(EVT_CODE_BAT_START_IN_4_DAYS)
+#define EVT_ID_BAT_START_IN_2_DAYS                       _CLASS_BAT(EVT_CODE_BAT_START_IN_2_DAYS)
+#define EVT_ID_BAT_START_IN_1_DAY                        _CLASS_BAT(EVT_CODE_BAT_START_IN_1_DAY)
+#define EVT_ID_BAT_START_IN_5_HOURS                      _CLASS_BAT(EVT_CODE_BAT_START_IN_5_HOURS)
+#define EVT_ID_BAT_REMOVED                               _CLASS_BAT(EVT_CODE_BAT_REMOVED)
+#define EVT_ID_BAT_CHARGE_CMPLT                          _CLASS_BAT(EVT_CODE_BAT_CHARGE_CMPLT)
+#define EVT_ID_BAT_CHARGER_PROBLEM_DETECTED              _CLASS_BAT(EVT_CODE_BAT_CHARGER_PROBLEM_DETECTED)
+#define EVT_ID_BAT_CAPACITY_BELOW_THRESHOLD              _CLASS_BAT(EVT_CODE_BAT_CAPACITY_BELOW_THRESHOLD)
+#define EVT_ID_BAT_CAPACITY_ABOVE_THRESHOLD              _CLASS_BAT(EVT_CODE_BAT_CAPACITY_ABOVE_THRESHOLD)
+#define EVT_ID_BAT_TEMP_IS_LOW                           _CLASS_BAT(EVT_CODE_BAT_TEMP_IS_LOW)
+#define EVT_ID_BAT_TEMP_IS_NORMAL                        _CLASS_BAT(EVT_CODE_BAT_TEMP_IS_NORMAL)
+#define EVT_ID_BAT_TEMP_IS_HIGH                          _CLASS_BAT(EVT_CODE_BAT_TEMP_IS_HIGH)
+#define EVT_ID_BAT_VOLTAGE_LOW                           _CLASS_BAT(EVT_CODE_BAT_VOLTAGE_LOW)
+#define EVT_ID_BAT_VOLTAGE_NORMAL                        _CLASS_BAT(EVT_CODE_BAT_VOLTAGE_NORMAL)
+#define EVT_ID_BAT_VOLTAGE_HIGH                          _CLASS_BAT(EVT_CODE_BAT_VOLTAGE_HIGH)
+#define EVT_ID_BAT_FORCE_WRITE_THROUGH                   _CLASS_BAT(EVT_CODE_BAT_FORCE_WRITE_THROUGH)
+#define EVT_ID_BAT_SAFE_TO_USE_WRITE_BACK                _CLASS_BAT(EVT_CODE_BAT_SAFE_TO_USE_WRITE_BACK)
+#define EVT_ID_BAT_STOP_CHARGING                         _CLASS_BAT(EVT_CODE_BAT_STOP_CHARGING)
+#define EVT_ID_BAT_STOP_DISCHARGING                      _CLASS_BAT(EVT_CODE_BAT_STOP_DISCHARGING)
+#define EVT_ID_BAT_CHANGE_CHARGE_THRESHOLD               _CLASS_BAT(EVT_CODE_BAT_CHANGE_CHARGE_THRESHOLD)
+#define EVT_ID_BAT_CHANGE_VOLTAGE_WARNING_THRESHOLD      _CLASS_BAT(EVT_CODE_BAT_CHANGE_VOLTAGE_WARNING_THRESHOLD)
+#define EVT_ID_BAT_CHANGE_TEMPERATURE_WARNING_THRESHOLD  _CLASS_BAT(EVT_CODE_BAT_CHANGE_TEMPERATURE_WARNING_THRESHOLD)
+
+//
+// Event id for EVT_CLASS_FLASH
+//
+#define _CLASS_FLASH(x)                (EVT_CLASS_FLASH << 16 | (x))
+
+#define EVT_ID_FLASH_DWLDED_IMAGE_CORRUPTED            _CLASS_FLASH(EVT_CODE_FLASH_DWLDED_IMAGE_CORRUPTED)
+#define EVT_ID_FLASH_ERASE_ERR                         _CLASS_FLASH(EVT_CODE_FLASH_ERASE_ERR)
+#define EVT_ID_FLASH_ERASE_TIMEOUT                     _CLASS_FLASH(EVT_CODE_FLASH_ERASE_TIMEOUT)         
+#define EVT_ID_FLASH_FLASH_ERR                         _CLASS_FLASH(EVT_CODE_FLASH_FLASH_ERR)             
+#define EVT_ID_FLASHING_IMAGE                          _CLASS_FLASH(EVT_CODE_FLASHING_IMAGE)              
+#define EVT_ID_FLASHING_NEW_IMAGE_DONE                 _CLASS_FLASH(EVT_CODE_FLASHING_NEW_IMAGE_DONE)     
+#define EVT_ID_FLASH_PROGRAMMING_ERR                   _CLASS_FLASH(EVT_CODE_FLASH_PROGRAMMING_ERR)       
+#define EVT_ID_FLASH_PROGRAMMING_TIMEOUT               _CLASS_FLASH(EVT_CODE_FLASH_PROGRAMMING_TIMEOUT)   
+#define EVT_ID_FLASH_UNKNOWN_CHIP_TYPE                 _CLASS_FLASH(EVT_CODE_FLASH_UNKNOWN_CHIP_TYPE)     
+#define EVT_ID_FLASH_UNKNOWN_CMD_SET                   _CLASS_FLASH(EVT_CODE_FLASH_UNKNOWN_CMD_SET)       
+#define EVT_ID_FLASH_VERIFY_FAILURE                    _CLASS_FLASH(EVT_CODE_FLASH_VERIFY_FAILURE)        
+#define EVT_ID_NVRAM_CORRUPT                           _CLASS_FLASH(EVT_CODE_NVRAM_CORRUPT)               
+#define EVT_ID_NVRAM_MISMACTH_OCCURED                  _CLASS_FLASH(EVT_CODE_NVRAM_MISMACTH_OCCURED)      
+#define EVT_ID_NVRAM_RECONSTRUCTION_STARTED            _CLASS_FLASH(EVT_CODE_NVRAM_RECONSTRUCTION_STARTED)
+#define EVT_ID_NVRAM_RECONSTRUCTION_DONE               _CLASS_FLASH(EVT_CODE_NVRAM_RECONSTRUCTION_DONE)     
+
+//
+// Event code for new Flash command (Loki and Frey)
+//
+#define EVT_ID_FLASH_WRITE_ERR                         _CLASS_FLASH(EVT_CODE_FLASH_WRITE_ERR)
+#define EVT_ID_FLASH_READ_ERR                          _CLASS_FLASH(EVT_CODE_FLASH_READ_ERR)     
+#define EVT_ID_FLASH_WRITE_IMAGE_SUCCEEDED             _CLASS_FLASH(EVT_CODE_FLASH_WRITE_IMAGE_SUCCEEDED)
+#define EVT_ID_FLASH_READ_IMAGE_SUCCEEDED              _CLASS_FLASH(EVT_CODE_FLASH_READ_IMAGE_SUCCEEDED)
+#define EVT_ID_FLASH_WRITE_IMAGE_FAILED                _CLASS_FLASH(EVT_CODE_FLASH_WRITE_IMAGE_FAILED)
+#define EVT_ID_FLASH_READ_IMAGE_FAILED                 _CLASS_FLASH(EVT_CODE_FLASH_READ_IMAGE_FAILED)
+#define EVT_ID_FLASH_GENERATION_ERR                    _CLASS_FLASH(EVT_CODE_FLASH_GENERATION_ERR)
+#define EVT_ID_FLASH_FATAL_GENERATION_ERR              _CLASS_FLASH(EVT_CODE_FLASH_FATAL_GENERATION_ERR)
+#define EVT_ID_FLASH_HEADER_ERR                        _CLASS_FLASH(EVT_CODE_FLASH_HEADER_ERR)   
+#define EVT_ID_FLASH_DATA_ERR                          _CLASS_FLASH(EVT_CODE_FLASH_DATA_ERR)     
+#define EVT_ID_FLASH_DATA_AND_HEADER_ERR               _CLASS_FLASH(EVT_CODE_FLASH_DATA_AND_HEADER_ERR)
+
+// Event code for EVT_CLASS_CACHE(Cache)
+//
+
+#define _CLASS_CACHE(x)                (EVT_CLASS_CACHE << 16 | (x))
+
+#define EVT_ID_CACHE_NOT_RECV_FROM_TBBU            _CLASS_CACHE(EVT_CODE_CACHE_NOT_RECV_FROM_TBBU)
+#define EVT_ID_CACHE_RECVD_FROM_TBBU               _CLASS_CACHE(EVT_CODE_CACHE_RECVD_FROM_TBBU)
+#define EVT_ID_CACHE_CTRLER_CACHE_DISCARDED        _CLASS_CACHE(EVT_CODE_CACHE_CTRLER_CACHE_DISCARDED)
+#define EVT_ID_CACHE_FAIL_RECV_DUETO_MISMATCH      _CLASS_CACHE(EVT_CODE_CACHE_FAIL_RECV_DUETO_MISMATCH)
+#define EVT_ID_CACHE_DIRTY_DATA_DISCARDED          _CLASS_CACHE(EVT_CODE_CACHE_DIRTY_DATA_DISCARDED)
+#define EVT_ID_CACHE_FLUSH_RATE_CHANGED            _CLASS_CACHE(EVT_CODE_CACHE_FLUSH_RATE_CHANGED)
+
+
+//
+// Event code for EVT_CLASS_MISC
+//
+
+#define _CLASS_MISC(x)                (EVT_CLASS_MISC << 16 | (x))
+
+#define EVT_ID_MISC_CONFIG_CLEARED                   _CLASS_MISC(EVT_CODE_MISC_CONFIG_CLEARED)        
+#define EVT_ID_MISC_CHANGE_BACK_ACTIVITY_RATE        _CLASS_MISC(EVT_CODE_MISC_CHANGE_BACK_ACTIVITY_RATE)
+#define EVT_ID_MISC_FATAL_FW_ERR                     _CLASS_MISC(EVT_CODE_MISC_FATAL_FW_ERR)
+#define EVT_ID_MISC_FACTORY_DEFAULTS_RESTORED        _CLASS_MISC(EVT_CODE_MISC_FACTORY_DEFAULTS_RESTORED)
+#define EVT_ID_MISC_GET_HIBER_CMD                    _CLASS_MISC(EVT_CODE_MISC_GET_HIBER_CMD)
+#define EVT_ID_MISC_MUTLI_BIT_ECC_ERR                _CLASS_MISC(EVT_CODE_MISC_MUTLI_BIT_ECC_ERR)
+#define EVT_ID_MISC_SINGLE_BIT_ECC_ERR               _CLASS_MISC(EVT_CODE_MISC_SINGLE_BIT_ECC_ERR)
+#define EVT_ID_MISC_GET_SHUTDOWN_CMD                 _CLASS_MISC(EVT_CODE_MISC_GET_SHUTDOWN_CMD)
+#define EVT_ID_MISC_TIME_ESTABLISHED                 _CLASS_MISC(EVT_CODE_MISC_TIME_ESTABLISHED)
+#define EVT_ID_MISC_USER_ENTERED_DEBUGGER            _CLASS_MISC(EVT_CODE_MISC_USER_ENTERED_DEBUGGER)
+#define EVT_ID_MISC_FORMAT_COMPLETE                  _CLASS_MISC(EVT_CODE_MISC_FORMAT_COMPLETE)
+#define EVT_ID_MISC_FORMAT_STARTED                   _CLASS_MISC(EVT_CODE_MISC_FORMAT_STARTED)
+#define EVT_ID_MISC_REASSIGN_WRITE_OP                _CLASS_MISC(EVT_CODE_MISC_REASSIGN_WRITE_OP)
+#define EVT_ID_MISC_UNEXPECTED_SENSE                 _CLASS_MISC(EVT_CODE_MISC_UNEXPECTED_SENSE)
+#define EVT_ID_MISC_REPLACED_MISSING                 _CLASS_MISC(EVT_CODE_MISC_REPLACED_MISSING)
+#define EVT_ID_MISC_NOT_A_CERTIFIED_DRIVE            _CLASS_MISC(EVT_CODE_MISC_NOT_A_CERTIFIED_DRIVE)
+
+/* May put into other group???*/
+#define EVT_ID_MISC_PD_MISSING_FROM_CONFIG_AT_BOOT   _CLASS_MISC(EVT_CODE_MISC_PD_MISSING_FROM_CONFIG_AT_BOOT)
+#define EVT_ID_MISC_VD_MISSING_DRIVES                _CLASS_MISC(EVT_CODE_MISC_VD_MISSING_DRIVES)
+#define EVT_ID_MISC_VD_MISSING_AT_BOOT               _CLASS_MISC(EVT_CODE_MISC_VD_MISSING_AT_BOOT)
+#define EVT_ID_MISC_PREVIOUS_CONFIG_MISSING_AT_BOOT  _CLASS_MISC(EVT_CODE_MISC_PREVIOUS_CONFIG_MISSING_AT_BOOT)
+#define EVT_ID_MISC_PD_TOO_SMALL_FOR_AUTOREBUILD     _CLASS_MISC(EVT_CODE_MISC_PD_TOO_SMALL_FOR_AUTOREBUILD)
+#define EVT_ID_MISC_PD_TOO_SMALL_FOR_COPYBACK        _CLASS_MISC(EVT_CODE_MISC_PD_TOO_SMALL_FOR_COPYBACK)
+
+#define EVT_ID_MISC_CHANGE_SYNC_RATE                 _CLASS_MISC(EVT_CODE_MISC_CHANGE_SYNC_RATE)
+#define EVT_ID_MISC_CHANGE_INIT_RATE                 _CLASS_MISC(EVT_CODE_MISC_CHANGE_INIT_RATE)
+#define EVT_ID_MISC_CHANGE_REBUILD_RATE              _CLASS_MISC(EVT_CODE_MISC_CHANGE_REBUILD_RATE)
+#define EVT_ID_MISC_CHANGE_MIGRATION_RATE            _CLASS_MISC(EVT_CODE_MISC_CHANGE_MIGRATION_RATE)
+#define EVT_ID_MISC_CHANGE_COPYBACK_RATE             _CLASS_MISC(EVT_CODE_MISC_CHANGE_COPYBACK_RATE)
+#define EVT_ID_MISC_CHANGE_MP_RATE                   _CLASS_MISC(EVT_CODE_MISC_CHANGE_MP_RATE)
+#define EVT_ID_MISC_ALARM_MUTE                       _CLASS_MISC(EVT_CODE_MISC_ALARM_MUTE)
+
+#ifndef _MARVELL_SDK_PACKAGE_NONRAID
+//
+// Event code for EVT_CLASS_ARRAY
+//
+
+#define _CLASS_ARRAY(x)                (EVT_CLASS_ARRAY << 16 | (x))
+
+#define EVT_ID_ARRAY_CREATE                    _CLASS_ARRAY(EVT_CODE_ARRAY_CREATE)        
+#define EVT_ID_ARRAY_DELETE                    _CLASS_ARRAY(EVT_CODE_ARRAY_DELETE)
+
+#define EVT_ID_ADAPTER_TEMP_OPTIMAL            _CLASS_OEM(EVT_CODE_ADAPTER_TEMP_OPTIMAL)
+#define EVT_ID_ADAPTER_TEMP_WARN               _CLASS_OEM(EVT_CODE_ADAPTER_TEMP_WARN)
+#define EVT_ID_ADAPTER_TEMP_CRITICAL           _CLASS_OEM(EVT_CODE_ADAPTER_TEMP_CRITICAL)
+#define EVT_ID_ADAPTER_FAN_OPTIMAL             _CLASS_OEM(EVT_CODE_ADAPTER_FAN_OPTIMAL)
+#define EVT_ID_ADAPTER_FAN_FAILURE             _CLASS_OEM(EVT_CODE_ADAPTER_FAN_FAILURE)
+#define EVT_ID_ADAPTER_FAN_ABSENT              _CLASS_OEM(EVT_CODE_ADAPTER_FAN_ABSENT)
+#define EVT_ID_ADAPTER_PSU_ALERT               _CLASS_OEM(EVT_CODE_ADAPTER_PSU_ALERT)
+#define EVT_ID_ADAPTER_PSU_OPTIMAL             _CLASS_OEM(EVT_CODE_ADAPTER_PSU_OPTIMAL)
+#define EVT_ID_ADAPTER_MUTE_PRESS              _CLASS_OEM(EVT_CODE_ADAPTER_MUTE_PRESS)
+#define EVT_ID_ADAPTER_IDENTFICATION_PRESS     _CLASS_OEM(EVT_CODE_ADAPTER_IDENTFICATION_PRESS)
+#define EVT_ID_ADAPTER_IDENTFICATION_ON        _CLASS_OEM(EVT_CODE_ADAPTER_IDENTFICATION_ON)
+#define EVT_ID_ADAPTER_IDENTFICATION_OFF       _CLASS_OEM(EVT_CODE_ADAPTER_IDENTFICATION_OFF)
+#define EVT_ID_ADAPTER_INTRUSION_OPEN          _CLASS_OEM(EVT_CODE_ADAPTER_INTRUSION_OPEN)
+#define EVT_ID_ADAPTER_INTRUSION_CLOSE         _CLASS_OEM(EVT_CODE_ADAPTER_INTRUSION_CLOSE)
+#define EVT_ID_ADAPTER_STATUS_LOW_POWER        _CLASS_OEM(EVT_CODE_ADAPTER_STATUS_LOW_POWER)
+#define EVT_ID_ADAPTER_STATUS_IDLE             _CLASS_OEM(EVT_CODE_ADAPTER_STATUS_IDLE)
+
+#endif
+// _MARVELL_SDK_PACKAGE_NONRAID
+
+#endif
+
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_event_define.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_event_define.h
--- linux-3.10.69/drivers/scsi/mv/include/com_event_define.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_event_define.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,492 @@
+#ifndef COM_EVENT_DEFINE_H
+#define COM_EVENT_DEFINE_H
+
+/****************************************
+ *         Perceived Severity
+ ****************************************/
+
+#define SEVERITY_UNKNOWN    0
+#define SEVERITY_OTHER      1
+#define SEVERITY_INFO       2
+#define SEVERITY_WARNING    3  /* used when its appropriate to let the 
+				  user decide if action is needed */
+#define SEVERITY_MINOR      4  /* indicate action is needed, but the 
+				  situation is not serious at this time */  
+#define SEVERITY_MAJOR      5  /* indicate action is needed NOW */
+#define SEVERITY_CRITICAL   6  /* indicate action is needed NOW and the 
+				  scope is broad */
+#define SEVERITY_FATAL      7  /* indicate an error occurred, but it's too
+				  late to take remedial action */
+
+/****************************************
+ *             Event Classes
+ ****************************************/
+#define EVT_CLASS_ADAPTER   0
+#define EVT_CLASS_LD        1  /* Logical Drive */
+#define EVT_CLASS_HD        2  /* Hard Drive */
+#define EVT_CLASS_PM        3  /* Port Multplier */
+#define EVT_CLASS_EXPANDER  4
+#define EVT_CLASS_MDD       5 
+#define EVT_CLASS_BSL       6  /* Bad Sector Lock */
+
+/********************************************************
+ *                 Event Codes 
+ *
+ *  !!!  When adding an EVT_CODE, Please put its severity level
+ *  !!!  and suggested mesage string as comments.  This is the 
+ *  !!!  only place to document how 'Params' in 'DriverEvent' 
+ *  !!!  structure is to be used.
+ *
+ ********************************************************/
+#ifndef _MARVELL_SDK_PACKAGE_NONRAID
+/* Event code for EVT_CLASS_LD (Logical Drive) */
+#define EVT_CODE_LD_OFFLINE                0
+#define EVT_CODE_LD_ONLINE                 1
+#define EVT_CODE_LD_CREATE                 2
+#define EVT_CODE_LD_DELETE                 3
+#define EVT_CODE_LD_DEGRADE                4
+#define EVT_CODE_LD_PARTIALLYOPTIMAL       5
+#define EVT_CODE_LD_CACHE_MODE_CHANGE      6
+#define EVT_CODE_LD_FIXED                  7
+#define EVT_CODE_LD_FOUND_ERROR            8
+#define EVT_CODE_LD_IMPORTED               9
+#define EVT_CODE_LD_REPORTED                10
+#define EVT_CODE_LD_CONFLICTED              11
+#define EVT_CODE_LD_RESERVED4              12
+#define EVT_CODE_LD_RESERVED5              13
+#define EVT_CODE_LD_RESERVED6              14
+#define EVT_CODE_LD_RESERVED7              15
+#define EVT_CODE_LD_RESERVED8              16
+#define EVT_CODE_LD_RESERVED9              17
+#define EVT_CODE_LD_RESERVED10             18
+#define EVT_CODE_LD_RESERVED11             19
+/*
+ *  NOTE: Don't change the following event code order in each event group! 
+ *      See raid_get_bga_event_id() for detail. 
+ */
+#define EVT_CODE_LD_CHECK_START            20 
+#define EVT_CODE_LD_CHECK_RESTART          21 
+#define EVT_CODE_LD_CHECK_PAUSE            22 
+#define EVT_CODE_LD_CHECK_RESUME           23 
+#define EVT_CODE_LD_CHECK_ABORT            24 
+#define EVT_CODE_LD_CHECK_COMPLETE         25 
+#define EVT_CODE_LD_CHECK_PROGRESS         26  
+#define EVT_CODE_LD_CHECK_ERROR            27 
+#define EVT_CODE_LD_CHECK_AUTO_PAUSED      28 
+#define EVT_CODE_LD_CHECK_AUTO_RESUME      29 
+
+#define EVT_CODE_LD_FIX_START              30 
+#define EVT_CODE_LD_FIX_RESTART            31 
+#define EVT_CODE_LD_FIX_PAUSE              32 
+#define EVT_CODE_LD_FIX_RESUME             33 
+#define EVT_CODE_LD_FIX_ABORT              34 
+#define EVT_CODE_LD_FIX_COMPLETE           35 
+#define EVT_CODE_LD_FIX_PROGRESS           36 
+#define EVT_CODE_LD_FIX_ERROR              37
+#define EVT_CODE_LD_FIX_AUTO_PAUSED        38 
+#define EVT_CODE_LD_FIX_AUTO_RESUME        39 
+
+#define EVT_CODE_LD_INIT_QUICK_START       40
+#define EVT_CODE_LD_INIT_QUICK_RESTART     41    
+#define EVT_CODE_LD_INIT_QUICK_PAUSE       42    
+#define EVT_CODE_LD_INIT_QUICK_RESUME      43    
+#define EVT_CODE_LD_INIT_QUICK_ABORT       44    
+#define EVT_CODE_LD_INIT_QUICK_COMPLETE    45    
+#define EVT_CODE_LD_INIT_QUICK_PROGRESS    46  
+#define EVT_CODE_LD_INIT_QUICK_ERROR       47   
+#define EVT_CODE_LD_INIT_QUICK_AUTO_PAUSED 48
+#define EVT_CODE_LD_INIT_QUICK_AUTO_RESUME 49 
+
+#define EVT_CODE_LD_INIT_BACK_START        50
+#define EVT_CODE_LD_INIT_BACK_RESTART      51
+#define EVT_CODE_LD_INIT_BACK_PAUSE        52
+#define EVT_CODE_LD_INIT_BACK_RESUME       53
+#define EVT_CODE_LD_INIT_BACK_ABORT        54
+#define EVT_CODE_LD_INIT_BACK_COMPLETE     55
+#define EVT_CODE_LD_INIT_BACK_PROGRESS     56
+#define EVT_CODE_LD_INIT_BACK_ERROR        57
+#define EVT_CODE_LD_INIT_BACK_AUTO_PAUSED  58  
+#define EVT_CODE_LD_INIT_BACK_AUTO_RESUME  59 
+
+#define EVT_CODE_LD_INIT_FORE_START        60
+#define EVT_CODE_LD_INIT_FORE_RESTART      61  
+#define EVT_CODE_LD_INIT_FORE_PAUSE        62
+#define EVT_CODE_LD_INIT_FORE_RESUME       63   
+#define EVT_CODE_LD_INIT_FORE_ABORT        64
+#define EVT_CODE_LD_INIT_FORE_COMPLETE     65 
+#define EVT_CODE_LD_INIT_FORE_PROGRESS     66 
+#define EVT_CODE_LD_INIT_FORE_ERROR        67
+#define EVT_CODE_LD_INIT_FORE_AUTO_PAUSED  68 
+#define EVT_CODE_LD_INIT_FORE_AUTO_RESUME  69 
+
+
+#define EVT_CODE_LD_REBUILD_START          70 
+#define EVT_CODE_LD_REBUILD_RESTART        71 
+#define EVT_CODE_LD_REBUILD_PAUSE          72 
+#define EVT_CODE_LD_REBUILD_RESUME         73 
+#define EVT_CODE_LD_REBUILD_ABORT          74 
+#define EVT_CODE_LD_REBUILD_COMPLETE       75 
+#define EVT_CODE_LD_REBUILD_PROGRESS       76 
+#define EVT_CODE_LD_REBUILD_ERROR          77 
+#define EVT_CODE_LD_REBUILD_AUTO_PAUSED    78 
+#define EVT_CODE_LD_REBUILD_AUTO_RESUME	   79 
+
+#define EVT_CODE_LD_MIGRATION_START        80 
+#define EVT_CODE_LD_MIGRATION_RESTART      81 
+#define EVT_CODE_LD_MIGRATION_PAUSE        82 
+#define EVT_CODE_LD_MIGRATION_RESUME       83 
+#define EVT_CODE_LD_MIGRATION_ABORT        84 
+#define EVT_CODE_LD_MIGRATION_COMPLETE     85 
+#define EVT_CODE_LD_MIGRATION_PROGRESS     86
+#define EVT_CODE_LD_MIGRATION_ERROR        87 
+#define EVT_CODE_LD_MIGRATION_AUTO_PAUSED  88 
+#define EVT_CODE_LD_MIGRATION_AUTO_RESUME  89 
+
+#define EVT_CODE_LD_COPYBACK_START          90 
+#define EVT_CODE_LD_COPYBACK_RESTART        91 
+#define EVT_CODE_LD_COPYBACK_PAUSE          92 
+#define EVT_CODE_LD_COPYBACK_RESUME         93 
+#define EVT_CODE_LD_COPYBACK_ABORT          94 
+#define EVT_CODE_LD_COPYBACK_COMPLETE       95 
+#define EVT_CODE_LD_COPYBACK_PROGRESS       96 
+#define EVT_CODE_LD_COPYBACK_ERROR          97 
+#define EVT_CODE_LD_COPYBACK_AUTO_PAUSED    98 
+#define EVT_CODE_LD_COPYBACK_AUTO_RESUME	99 
+
+
+/* event code for logging inconsistent LBA found in consistency check or synchronization fix */
+#define EVT_CODE_LD_INCONSISTENT_LBA       100
+#endif
+// _MARVELL_SDK_PACKAGE_NONRAID
+/* only used in application */
+#define EVT_CODE_EVT_ERR                   0xffff
+#define EVT_CODE_SMART_FROM_OFF_TO_ON	   0  // SMART setting is changed from OFF-->ON
+#define EVT_CODE_SMART_FROM_ON_TO_OFF	   1  // SMART setting is changed from ON-->OFF
+#define EVT_CODE_ALARM_TURN_ON			   2			 
+#define EVT_CODE_ALARM_TURN_OFF			   3
+#define EVT_CODE_AUTO_REBUILD_ON		   4	
+#define EVT_CODE_AUTO_REBUILD_OFF		   5 
+#define EVT_CODE_HD_MP_RATE_CHANGE		   6
+#define EVT_CODE_COPY_BACK_ON			   7
+#define EVT_CODE_COPY_BACK_OFF			   8
+#define EVT_CODE_ADAPTER_FOUND			   9
+#define EVT_CODE_BBU_ECCERROR			   10
+#define EVT_CODE_ADAPTER_BBU_COUNT		   11
+#define EVT_CODE_ADAPTER_BBU_START		   12
+#define EVT_CODE_ADAPTER_BBU_FINISH		   13
+#define EVT_CODE_PAGE_ECC_ERROR			   14
+#define EVT_CODE_ADAPTER_MEMORY_SIZE_LACK	   15
+#define EVT_CODE_ADAPTER_REMOVED			   16
+#define EVT_CODE_ADAPTER_DETECTED			   17
+
+/*
+ * Event code for EVT_CLASS_HD (Hard Disk)
+ */
+#define EVT_CODE_HD_OFFLINE                0
+#define EVT_CODE_HD_ONLINE                 1 
+#define EVT_CODE_HD_SETDOWN                2
+#define EVT_CODE_HD_TIMEOUT                3
+#define EVT_CODE_HD_RW_ERROR               4
+#define EVT_CODE_HD_SMART                  5
+#define EVT_CODE_HD_ERROR_FIXED            6
+#define EVT_CODE_HD_PLUG_IN                7
+#define EVT_CODE_HD_PLUG_OUT               8
+#define EVT_CODE_HD_ASSIGN_SPARE           9
+#define EVT_CODE_HD_REMOVE_SPARE           10
+#define EVT_CODE_HD_SMART_THRESHOLD_OVER   11
+/*New events added in March 2007 from LSI event list.*/
+#define EVT_CODE_HD_SMART_POLLING_FAIL	   12  // SMART polling failed on %s (Error %02x)
+#define EVT_CODE_BAD_BLOCK_TBL_80_FULL	   13  // Bad block table on PD %s is 80% full
+#define EVT_CODE_BAD_BLOCK_TBL_FULL	       14  // Bad block table on PD %s is full; Unable to log block %x
+#define EVT_CODE_BAD_BLOCK_REASSIGNED	   15  // Bad block reassigned on %s at %lx to %lx
+#define EVT_CODE_HD_CACHE_MODE_CHANGE	   16
+/*New event for HD media patrol.*/
+#define EVT_CODE_HD_MP_START			   17 
+#define EVT_CODE_HD_MP_RESTART			   18
+#define EVT_CODE_HD_MP_PAUSE			   19
+#define EVT_CODE_HD_MP_RESUME              20 
+#define EVT_CODE_HD_MP_ABORT               21
+#define EVT_CODE_HD_MP_COMPLETE            22
+#define EVT_CODE_HD_MP_PROGRESS            23
+#define EVT_CODE_HD_MP_ERROR               24
+#define EVT_CODE_HD_MP_AUTO_PAUSED         25
+#define EVT_CODE_HD_MP_AUTO_RESUME         26
+
+/*New event for HD (spare) data scrubbing.*/
+#define EVT_CODE_HD_DS_START			   27 
+#define EVT_CODE_HD_DS_RESTART	           28
+#define EVT_CODE_HD_DS_PAUSE	           29
+#define EVT_CODE_HD_DS_RESUME              30 
+#define EVT_CODE_HD_DS_ABORT               31
+#define EVT_CODE_HD_DS_COMPLETE            32
+#define EVT_CODE_HD_DS_PROGRESS            33
+#define EVT_CODE_HD_DS_AUTO_PAUSED		   34
+#define EVT_CODE_HD_DS_TERMINATE_IMMEDIATE 35
+
+/*event for sense code*/
+#define EVT_CODE_HD_SC_ERROR			36
+
+#define EVT_CODE_HD_RCT_ADD					37
+#define EVT_CODE_HD_RCT_REMOVE				38
+
+
+#define EVT_CODE_HD_SC_RECOVERED_ERROR   40
+#define EVT_CODE_HD_SC_NOT_READY   41
+#define EVT_CODE_HD_SC_MEDIUM_ERROR   42
+#define EVT_CODE_HD_SC_NO_SENSE   43
+#define EVT_CODE_HD_SC_ILLEGAL_REQUEST   44
+#define EVT_CODE_HD_SC_UNIT_ATTENTION    45
+#define EVT_CODE_HD_SC_DATA_PROTECT   46
+#define EVT_CODE_HD_SC_BLANK_CHECK   47
+#define EVT_CODE_HD_SC_COPY_ABORTED   48
+#define EVT_CODE_HD_SC_ABORTED_COMMAND   49
+#define EVT_CODE_HD_SC_VOLUME_OVERFLOW   50
+#define EVT_CODE_HD_SC_MISCOMPARE   51
+#define EVT_CODE_HD_SC_HARDWARE_ERROR 52
+#define EVT_CODE_HD_SC_VENDOR_SPECIFIC  53
+#define EVT_CODE_HD_SETFREE				54
+#define EVT_CODE_HD_OFF_PLAIN_DISK		55        // disk offline caused by plain disk on AES enabled port
+#define EVT_CODE_HD_OFF_CRYPTO_DISK		56        // disk offline caused by crypto disk on AES disable port
+#define EVT_CODE_HD_OFF_CIPHER_MISMATCH	57       // disk offline caused by cipher is mismatch between disk and port.
+#define EVT_CODE_HD_SPARE_DISK_WARNING	59       // Params[0] is spare disk id.| (1 << 16) Params[1] is disk array id.
+
+
+/*
+ * code for EVT_CLASS_MDD
+ */
+#define EVT_CODE_MDD_ERROR                 0
+
+/*
+ * Event code for EVT_CLASS_EXPANDER
+ */
+#define EVT_CODE_EXPANDER_PLUG_IN        0
+#define EVT_CODE_EXPANDER_PLUG_OUT       1
+
+/**********************************
+ *                Event IDs
+ **********************************/
+
+#ifndef _MARVELL_SDK_PACKAGE_NONRAID
+/*
+ * Event Id for EVT_CLASS_LD
+ */
+#define _CLASS_LD(x)                (EVT_CLASS_LD << 16 | (x))
+
+#define EVT_ID_LD_OFFLINE            _CLASS_LD(EVT_CODE_LD_OFFLINE)
+#define EVT_ID_LD_ONLINE             _CLASS_LD(EVT_CODE_LD_ONLINE) 
+#define EVT_ID_LD_CREATE             _CLASS_LD(EVT_CODE_LD_CREATE)
+#define EVT_ID_LD_DELETE             _CLASS_LD(EVT_CODE_LD_DELETE)
+#define EVT_ID_LD_DEGRADE            _CLASS_LD(EVT_CODE_LD_DEGRADE)
+#define EVT_ID_LD_PARTIALLYOPTIMAL   _CLASS_LD(EVT_CODE_LD_PARTIALLYOPTIMAL)
+#define EVT_ID_LD_CACHE_MODE_CHANGE  _CLASS_LD(EVT_CODE_LD_CACHE_MODE_CHANGE)
+#define EVT_ID_LD_FIXED              _CLASS_LD(EVT_CODE_LD_FIXED)
+#define EVT_ID_LD_FOUND_ERROR        _CLASS_LD(EVT_CODE_LD_FOUND_ERROR)
+#define EVT_ID_LD_IMPORTED	     _CLASS_LD(EVT_CODE_LD_IMPORTED)
+#define EVT_ID_LD_REPORTED	     _CLASS_LD(EVT_CODE_LD_REPORTED)
+#define EVT_ID_LD_CONFLICTED	     _CLASS_LD(EVT_CODE_LD_CONFLICTED)
+
+#define EVT_ID_LD_CHECK_START        _CLASS_LD(EVT_CODE_LD_CHECK_START)
+#define EVT_ID_LD_CHECK_RESTART      _CLASS_LD(EVT_CODE_LD_CHECK_RESTART)
+#define EVT_ID_LD_CHECK_PAUSE        _CLASS_LD(EVT_CODE_LD_CHECK_PAUSE)
+#define EVT_ID_LD_CHECK_RESUME       _CLASS_LD(EVT_CODE_LD_CHECK_RESUME)
+#define EVT_ID_LD_CHECK_ABORT        _CLASS_LD(EVT_CODE_LD_CHECK_ABORT)
+#define EVT_ID_LD_CHECK_COMPLETE     _CLASS_LD(EVT_CODE_LD_CHECK_COMPLETE)
+#define EVT_ID_LD_CHECK_PROGRESS     _CLASS_LD(EVT_CODE_LD_CHECK_PROGRESS)
+#define EVT_ID_LD_CHECK_ERROR        _CLASS_LD(EVT_CODE_LD_CHECK_ERROR)
+#define EVT_ID_LD_CHECK_AUTO_PAUSED  _CLASS_LD(EVT_CODE_LD_CHECK_AUTO_PAUSED)
+#define EVT_ID_LD_CHECK_AUTO_RESUME  _CLASS_LD(EVT_CODE_LD_CHECK_AUTO_RESUME)
+
+#define EVT_ID_LD_FIXED_START        _CLASS_LD(EVT_CODE_LD_FIX_START)
+#define EVT_ID_LD_FIXED_RESTART      _CLASS_LD(EVT_CODE_LD_FIX_RESTART)
+#define EVT_ID_LD_FIXED_PAUSE        _CLASS_LD(EVT_CODE_LD_FIX_PAUSE)
+#define EVT_ID_LD_FIXED_RESUME       _CLASS_LD(EVT_CODE_LD_FIX_RESUME)
+#define EVT_ID_LD_FIXED_ABORT        _CLASS_LD(EVT_CODE_LD_FIX_ABORT)
+#define EVT_ID_LD_FIXED_COMPLETE     _CLASS_LD(EVT_CODE_LD_FIX_COMPLETE)
+#define EVT_ID_LD_FIXED_PROGRESS     _CLASS_LD(EVT_CODE_LD_FIX_PROGRESS)
+#define EVT_ID_LD_FIXED_ERROR        _CLASS_LD(EVT_CODE_LD_FIX_ERROR)
+#define EVT_ID_LD_FIXED_AUTO_PAUSED  _CLASS_LD(EVT_CODE_LD_FIX_AUTO_PAUSED)
+#define EVT_ID_LD_FIXED_AUTO_RESUME  _CLASS_LD(EVT_CODE_LD_FIX_AUTO_RESUME)
+
+#define EVT_ID_LD_INIT_QUICK_START   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_START)
+#define EVT_ID_LD_INIT_QUICK_RESTART _CLASS_LD(EVT_CODE_LD_INIT_QUICK_RESTART)
+#define EVT_ID_LD_INIT_QUICK_PAUSE   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_PAUSE)
+#define EVT_ID_LD_INIT_QUICK_RESUME  _CLASS_LD(EVT_CODE_LD_INIT_QUICK_RESUME)
+#define EVT_ID_LD_INIT_QUICK_ABORT   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_ABORT)
+#define EVT_ID_LD_INIT_QUICK_COMPLETE _CLASS_LD(EVT_CODE_LD_INIT_QUICK_COMPLETE)
+#define EVT_ID_LD_INIT_QUICK_PROGRESS _CLASS_LD(EVT_CODE_LD_INIT_QUICK_PROGRESS)
+#define EVT_ID_LD_INIT_QUICK_ERROR   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_ERROR)
+#define EVT_ID_LD_INIT_QUICK_AUTO_PAUSED   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_AUTO_PAUSED)
+#define EVT_ID_LD_INIT_QUICK_AUTO_RESUME   _CLASS_LD(EVT_CODE_LD_INIT_QUICK_AUTO_RESUME)
+
+#define EVT_ID_LD_INIT_BACK_START    _CLASS_LD(EVT_CODE_LD_INIT_BACK_START)
+#define EVT_ID_LD_INIT_BACK_RESTART  _CLASS_LD(EVT_CODE_LD_INIT_BACK_RESTART)
+#define EVT_ID_LD_INIT_BACK_PAUSE    _CLASS_LD(EVT_CODE_LD_INIT_BACK_PAUSE)
+#define EVT_ID_LD_INIT_BACK_RESUME   _CLASS_LD(EVT_CODE_LD_INIT_BACK_RESUME)
+#define EVT_ID_LD_INIT_BACK_ABORT    _CLASS_LD(EVT_CODE_LD_INIT_BACK_ABORT)
+#define EVT_ID_LD_INIT_BACK_COMPLETE _CLASS_LD(EVT_CODE_LD_INIT_BACK_COMPLETE)
+#define EVT_ID_LD_INIT_BACK_PROGRESS _CLASS_LD(EVT_CODE_LD_INIT_BACK_PROGRESS)
+#define EVT_ID_LD_INIT_BACK_ERROR    _CLASS_LD(EVT_CODE_LD_INIT_BACK_ERROR)
+#define EVT_ID_LD_INIT_BACK_AUTO_PAUSED   _CLASS_LD(EVT_CODE_LD_INIT_BACK_AUTO_PAUSED)
+#define EVT_ID_LD_INIT_BACK_AUTO_RESUME   _CLASS_LD(EVT_CODE_LD_INIT_BACK_AUTO_RESUME)
+
+
+#define EVT_ID_LD_INIT_FORE_START    _CLASS_LD(EVT_CODE_LD_INIT_FORE_START)
+#define EVT_ID_LD_INIT_FORE_RESTART  _CLASS_LD(EVT_CODE_LD_INIT_FORE_RESTART)
+#define EVT_ID_LD_INIT_FORE_PAUSE    _CLASS_LD(EVT_CODE_LD_INIT_FORE_PAUSE)
+#define EVT_ID_LD_INIT_FORE_RESUME   _CLASS_LD(EVT_CODE_LD_INIT_FORE_RESUME)
+#define EVT_ID_LD_INIT_FORE_ABORT    _CLASS_LD(EVT_CODE_LD_INIT_FORE_ABORT)
+#define EVT_ID_LD_INIT_FORE_COMPLETE _CLASS_LD(EVT_CODE_LD_INIT_FORE_COMPLETE)
+#define EVT_ID_LD_INIT_FORE_PROGRESS _CLASS_LD(EVT_CODE_LD_INIT_FORE_PROGRESS)
+#define EVT_ID_LD_INIT_FORE_ERROR    _CLASS_LD(EVT_CODE_LD_INIT_FORE_ERROR)
+#define EVT_ID_LD_INIT_FORE_AUTO_PAUSED  _CLASS_LD(EVT_CODE_LD_INIT_FORE_AUTO_PAUSED)
+#define EVT_ID_LD_INIT_FORE_AUTO_RESUME  _CLASS_LD(EVT_CODE_LD_INIT_FORE_AUTO_RESUME)
+
+#define EVT_ID_LD_REBUILD_START      _CLASS_LD(EVT_CODE_LD_REBUILD_START)
+#define EVT_ID_LD_REBUILD_RESTART    _CLASS_LD(EVT_CODE_LD_REBUILD_RESTART)
+#define EVT_ID_LD_REBUILD_PAUSE      _CLASS_LD(EVT_CODE_LD_REBUILD_PAUSE)
+#define EVT_ID_LD_REBUILD_RESUME     _CLASS_LD(EVT_CODE_LD_REBUILD_RESUME)
+#define EVT_ID_LD_REBUILD_ABORT      _CLASS_LD(EVT_CODE_LD_REBUILD_ABORT)
+#define EVT_ID_LD_REBUILD_COMPLETE   _CLASS_LD(EVT_CODE_LD_REBUILD_COMPLETE)
+#define EVT_ID_LD_REBUILD_PROGRESS   _CLASS_LD(EVT_CODE_LD_REBUILD_PROGRESS)
+#define EVT_ID_LD_REBUILD_ERROR      _CLASS_LD(EVT_CODE_LD_REBUILD_ERROR)
+#define EVT_ID_LD_REBUILD_AUTO_PAUSED _CLASS_LD(EVT_CODE_LD_REBUILD_AUTO_PAUSED)
+#define EVT_ID_LD_REBUILD_AUTO_RESUME _CLASS_LD(EVT_CODE_LD_REBUILD_AUTO_RESUME)
+
+#define EVT_ID_LD_MIGRATION_START    _CLASS_LD(EVT_CODE_LD_MIGRATION_START)
+#define EVT_ID_LD_MIGRATION_RESTART  _CLASS_LD(EVT_CODE_LD_MIGRATION_RESTART)
+#define EVT_ID_LD_MIGRATION_PAUSE    _CLASS_LD(EVT_CODE_LD_MIGRATION_PAUSE)
+#define EVT_ID_LD_MIGRATION_RESUME   _CLASS_LD(EVT_CODE_LD_MIGRATION_RESUME)
+#define EVT_ID_LD_MIGRATION_ABORT    _CLASS_LD(EVT_CODE_LD_MIGRATION_ABORT)
+#define EVT_ID_LD_MIGRATION_COMPLETE _CLASS_LD(EVT_CODE_LD_MIGRATION_COMPLETE)
+#define EVT_ID_LD_MIGRATION_PROGRESS _CLASS_LD(EVT_CODE_LD_MIGRATION_PROGRESS)
+#define EVT_ID_LD_MIGRATION_ERROR    _CLASS_LD(EVT_CODE_LD_MIGRATION_ERROR)
+#define EVT_ID_LD_MIGRATION_AUTO_PAUSED    _CLASS_LD(EVT_CODE_LD_MIGRATION_AUTO_PAUSED)
+#define EVT_ID_LD_MIGRATION_AUTO_RESUME    _CLASS_LD(EVT_CODE_LD_MIGRATION_AUTO_RESUME)
+
+#define EVT_ID_LD_COPYBACK_START      _CLASS_LD(EVT_CODE_LD_COPYBACK_START)
+#define EVT_ID_LD_COPYBACK_RESTART    _CLASS_LD(EVT_CODE_LD_COPYBACK_RESTART)
+#define EVT_ID_LD_COPYBACK_PAUSE      _CLASS_LD(EVT_CODE_LD_COPYBACK_PAUSE)
+#define EVT_ID_LD_COPYBACK_RESUME     _CLASS_LD(EVT_CODE_LD_COPYBACK_RESUME)
+#define EVT_ID_LD_COPYBACK_ABORT      _CLASS_LD(EVT_CODE_LD_COPYBACK_ABORT)
+#define EVT_ID_LD_COPYBACK_COMPLETE   _CLASS_LD(EVT_CODE_LD_COPYBACK_COMPLETE)
+#define EVT_ID_LD_COPYBACK_PROGRESS   _CLASS_LD(EVT_CODE_LD_COPYBACK_PROGRESS)
+#define EVT_ID_LD_COPYBACK_ERROR      _CLASS_LD(EVT_CODE_LD_COPYBACK_ERROR)
+#define EVT_ID_LD_COPYBACK_AUTO_PAUSED _CLASS_LD(EVT_CODE_LD_COPYBACK_AUTO_PAUSED)
+#define EVT_ID_LD_COPYBACK_AUTO_RESUME _CLASS_LD(EVT_CODE_LD_COPYBACK_AUTO_RESUME)
+
+
+#define EVT_ID_LD_INCONSISTENT_LBA   _CLASS_LD(EVT_CODE_LD_INCONSISTENT_LBA)
+#endif
+// _MARVELL_SDK_PACKAGE_NONRAID
+/*
+ * Event Id for EVT_CLASS_HD
+ */
+#define _CLASS_HD(x)                    (EVT_CLASS_HD << 16 | (x))
+
+#define EVT_ID_HD_OFFLINE               _CLASS_HD(EVT_CODE_HD_OFFLINE)
+#define EVT_ID_HD_ONLINE                _CLASS_HD(EVT_CODE_HD_ONLINE)
+#define EVT_ID_HD_SETDOWN               _CLASS_HD(EVT_CODE_HD_SETDOWN)
+#define EVT_ID_HD_TIMEOUT               _CLASS_HD(EVT_CODE_HD_TIMEOUT)
+#define EVT_ID_HD_RW_ERROR              _CLASS_HD(EVT_CODE_HD_RW_ERROR)
+#define EVT_ID_HD_SMART                 _CLASS_HD(EVT_CODE_HD_SMART)
+#define EVT_ID_HD_ERROR_FIXED           _CLASS_HD(EVT_CODE_HD_ERROR_FIXED)
+#define EVT_ID_HD_PLUG_IN               _CLASS_HD(EVT_CODE_HD_PLUG_IN)
+#define EVT_ID_HD_PLUG_OUT              _CLASS_HD(EVT_CODE_HD_PLUG_OUT)
+#define EVT_ID_HD_ASSIGN_SPARE          _CLASS_HD(EVT_CODE_HD_ASSIGN_SPARE)
+#define EVT_ID_HD_REMOVE_SPARE          _CLASS_HD(EVT_CODE_HD_REMOVE_SPARE)
+#define EVT_ID_HD_SMART_THRESHOLD_OVER  _CLASS_HD(EVT_CODE_HD_SMART_THRESHOLD_OVER)
+#define EVT_ID_HD_SMART_POLLING_FAIL    _CLASS_HD(EVT_CODE_HD_SMART_POLLING_FAIL)		
+#define EVT_ID_BAD_BLOCK_TBL_80_FULL    _CLASS_HD(EVT_CODE_BAD_BLOCK_TBL_80_FULL)
+#define EVT_ID_BAD_BLOCK_TBL_FULL       _CLASS_HD(EVT_CODE_BAD_BLOCK_TBL_FULL)
+#define EVT_ID_BAD_BLOCK_REASSIGNED     _CLASS_HD(EVT_CODE_BAD_BLOCK_REASSIGNED)
+#define EVT_ID_HD_CACHE_MODE_CHANGE		_CLASS_HD(EVT_CODE_HD_CACHE_MODE_CHANGE)
+
+#define EVT_ID_HD_MP_START				_CLASS_HD(EVT_CODE_HD_MP_START)
+#define EVT_ID_HD_MP_RESTART			_CLASS_HD(EVT_CODE_HD_MP_RESTART)
+#define EVT_ID_HD_MP_PAUSE				_CLASS_HD(EVT_CODE_HD_MP_PAUSE)
+#define EVT_ID_HD_MP_RESUME				_CLASS_HD(EVT_CODE_HD_MP_RESUME)
+#define EVT_ID_HD_MP_ABORT				_CLASS_HD(EVT_CODE_HD_MP_ABORT)
+#define EVT_ID_HD_MP_COMPLETE			_CLASS_HD(EVT_CODE_HD_MP_COMPLETE)
+#define EVT_ID_HD_MP_PROGRESS			_CLASS_HD(EVT_CODE_HD_MP_PROGRESS)
+#define EVT_ID_HD_MP_ERROR				_CLASS_HD(EVT_CODE_HD_MP_ERROR)
+#define EVT_ID_HD_MP_AUTO_PAUSED		_CLASS_HD(EVT_CODE_HD_MP_AUTO_PAUSED)
+#define EVT_ID_HD_MP_AUTO_RESUME		_CLASS_HD(EVT_CODE_HD_MP_AUTO_RESUME)
+
+/* Event Id for Data Scrub */
+#define EVT_ID_HD_DS_START				 _CLASS_HD(EVT_CODE_HD_DS_START)
+#define EVT_ID_HD_DS_RESTART			 _CLASS_HD(EVT_CODE_HD_DS_RESTART)
+#define EVT_ID_HD_DS_PAUSE				 _CLASS_HD(EVT_CODE_HD_DS_PAUSE)
+#define EVT_ID_HD_DS_RESUME				 _CLASS_HD(EVT_CODE_HD_DS_RESUME)
+#define EVT_ID_HD_DS_ABORT				 _CLASS_HD(EVT_CODE_HD_DS_ABORT)
+#define EVT_ID_HD_DS_COMPLETE			 _CLASS_HD(EVT_CODE_HD_DS_COMPLETE)
+#define EVT_ID_HD_DS_PROGRESS			 _CLASS_HD(EVT_CODE_HD_DS_PROGRESS)
+#define EVT_ID_HD_DS_AUTO_PAUSED		 _CLASS_HD(EVT_CODE_HD_DS_AUTO_PAUSED)
+#define EVT_ID_HD_DS_TERMINATE_IMMEDIATE _CLASS_HD(EVT_CODE_HD_DS_TERMINATE_IMMEDIATE)
+
+/* Event ID for sense code*/
+#define EVT_ID_HD_SC_ERROR				_CLASS_HD(EVT_CODE_HD_SC_ERROR)
+
+#define EVT_ID_HD_RCT_ADD				_CLASS_HD(EVT_CODE_HD_RCT_ADD)
+#define EVT_ID_HD_RCT_REMOVE			_CLASS_HD(EVT_CODE_HD_RCT_REMOVE)
+
+#define EVT_ID_HD_SC_NO_SENSE                   	  _CLASS_HD(EVT_CODE_HD_SC_NO_SENSE)
+#define EVT_ID_HD_SC_RECOVERED_ERROR  	 	_CLASS_HD(EVT_CODE_HD_SC_RECOVERED_ERROR)
+#define EVT_ID_HD_SC_NOT_READY   			_CLASS_HD(EVT_CODE_HD_SC_NOT_READY)
+#define EVT_ID_HD_SC_MEDIUM_ERROR  		 _CLASS_HD(EVT_CODE_HD_SC_MEDIUM_ERROR)
+#define EVT_ID_HD_SC_ILLEGAL_REQUEST   	_CLASS_HD(EVT_CODE_HD_SC_ILLEGAL_REQUEST)
+#define EVT_ID_HD_SC_UNIT_ATTENTION   	_CLASS_HD(EVT_CODE_HD_SC_UNIT_ATTENTION)
+#define EVT_ID_HD_SC_DATA_PROTECT  	 	_CLASS_HD(EVT_CODE_HD_SC_DATA_PROTECT)
+#define EVT_ID_HD_SC_BLANK_CHECK   		_CLASS_HD(EVT_CODE_HD_SC_BLANK_CHECK)
+#define EVT_ID_HD_SC_COPY_ABORTED   	_CLASS_HD(EVT_CODE_HD_SC_COPY_ABORTED)
+#define EVT_ID_HD_SC_ABORTED_COMMAND   _CLASS_HD(EVT_CODE_HD_SC_ABORTED_COMMAND)
+#define EVT_ID_HD_SC_VOLUME_OVERFLOW  _CLASS_HD(EVT_CODE_HD_SC_VOLUME_OVERFLOW)
+#define EVT_ID_HD_SC_MISCOMPARE  		 _CLASS_HD(EVT_CODE_HD_SC_MISCOMPARE)
+#define EVT_ID_HD_SC_HARDWARE_ERROR 		_CLASS_HD(EVT_CODE_HD_SC_HARDWARE_ERROR)
+#define EVT_ID_HD_SC_VENDOR_SPECIFIC  		_CLASS_HD(EVT_CODE_HD_SC_VENDOR_SPECIFIC)
+#define EVT_ID_HD_SETFREE					_CLASS_HD(EVT_CODE_HD_SETFREE)
+#define EVT_ID_HD_OFF_PLAIN_DISK					_CLASS_HD(EVT_CODE_HD_OFF_PLAIN_DISK)
+#define EVT_ID_HD_OFF_CRYPTO_DISK					_CLASS_HD(EVT_CODE_HD_OFF_CRYPTO_DISK)
+#define EVT_ID_HD_OFF_CIPHER_MISMATCH					_CLASS_HD(EVT_CODE_HD_OFF_CIPHER_MISMATCH)
+#define EVT_ID_HD_SPARE_DISK_WARNING					_CLASS_HD(EVT_CODE_HD_SPARE_DISK_WARNING)
+
+/*
+ * Id for EVT_CLASS_MDD
+ */
+
+#define _CLASS_MDD(x)                    (EVT_CLASS_MDD << 16 | (x))
+#define EVT_ID_MDD_ERROR                 _CLASS_MDD(EVT_CODE_MDD_ERROR)
+
+/*
+ * Event Id for EVT_CLASS_EXPANDER
+ */
+#define _CLASS_EXPANDER(x)               (EVT_CLASS_EXPANDER << 16 | (x))
+
+#define EVT_ID_EXPANDER_PLUG_IN          _CLASS_EXPANDER(EVT_CODE_EXPANDER_PLUG_IN)
+#define EVT_ID_EXPANDER_PLUG_OUT         _CLASS_EXPANDER(EVT_CODE_EXPANDER_PLUG_OUT)
+
+
+/*
+ * Id for EVT_CLASS_ADAPTER
+ */
+
+#define _CLASS_ADPT(x)                   (EVT_CLASS_ADAPTER << 16 | (x))
+#define EVT_ID_EVT_LOST                  _CLASS_ADPT(EVT_CODE_EVT_ERR)
+#define EVT_ID_SMART_FROM_OFF_TO_ON		 _CLASS_ADPT(EVT_CODE_SMART_FROM_OFF_TO_ON)
+#define EVT_ID_SMART_FROM_ON_TO_OFF		 _CLASS_ADPT(EVT_CODE_SMART_FROM_ON_TO_OFF)
+#define EVT_ID_ALARM_TURN_ON			 _CLASS_ADPT(EVT_CODE_ALARM_TURN_ON)
+#define EVT_ID_ALARM_TURN_OFF		     _CLASS_ADPT(EVT_CODE_ALARM_TURN_OFF)
+#define EVT_ID_AUTO_REBUILD_ON		     _CLASS_ADPT(EVT_CODE_AUTO_REBUILD_ON)
+#define EVT_ID_AUTO_REBUILD_OFF		     _CLASS_ADPT(EVT_CODE_AUTO_REBUILD_OFF)
+#define EVT_ID_HD_MP_RATE_CHANGE		 _CLASS_ADPT(EVT_CODE_HD_MP_RATE_CHANGE)
+#define EVT_ID_COPY_BACK_ON			     _CLASS_ADPT(EVT_CODE_COPY_BACK_ON)
+#define EVT_ID_COPY_BACK_OFF		     _CLASS_ADPT(EVT_CODE_COPY_BACK_OFF)
+#define EVT_ID_ADAPTER_FOUND			 _CLASS_ADPT(EVT_CODE_ADAPTER_FOUND)
+#define EVT_ID_ADAPTER_ECC_ERROR			 _CLASS_ADPT(EVT_CODE_BBU_ECCERROR)
+#define EVT_ID_ADAPTER_BBU_COUNT			 _CLASS_ADPT(EVT_CODE_ADAPTER_BBU_COUNT)
+#define EVT_ID_ADAPTER_BBU_START			 _CLASS_ADPT(EVT_CODE_ADAPTER_BBU_START)
+#define EVT_ID_ADAPTER_BBU_FINISH			 _CLASS_ADPT(EVT_CODE_ADAPTER_BBU_FINISH)
+#define EVT_ID_ADAPTER_PAGE_ECC_ERROR			 _CLASS_ADPT(EVT_CODE_PAGE_ECC_ERROR)
+#define EVT_ID_ADAPTER_MEMORY_SIZE_LACK		 _CLASS_ADPT(EVT_CODE_ADAPTER_MEMORY_SIZE_LACK)
+#define EVT_ID_ADAPTER_REMOVED			_CLASS_ADPT(EVT_CODE_ADAPTER_REMOVED)
+#define EVT_ID_ADAPTER_DETECTED			_CLASS_ADPT(EVT_CODE_ADAPTER_DETECTED)
+#endif /*  COM_EVENT_DEFINE_H */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_event_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_event_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_event_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_event_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,105 @@
+#ifndef COM_EVENT_DRIVER_H
+#define COM_EVENT_DRIVER_H
+
+#ifndef COM_DEFINE_H //for magni not use include com_define to define MV_U32
+#include "com_define.h"
+#endif
+
+#define MAX_EVENTS                      20
+#define MAX_EVENTS_WAITED	  	16
+#define MAX_EVENT_PARAMS                4
+#define MAX_EVENTS_RETURNED             6
+#define MAX_EVENT_SENSE_DATA_COUNT	30
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /*  _OS_BIOS */
+
+#if defined(_OS_FIRMWARE)
+typedef struct _HotPlugEvent
+{
+	MV_U16	size;
+	MV_U8	dummy[2];
+	MV_U8	bitmap[0];
+}HotPlugEvent;
+#endif
+
+typedef struct _DriverEvent
+{
+	MV_U32  TimeStamp;
+	MV_U32  SequenceNo; /* (contiguous in a single adapter) */
+	MV_U32  EventID;    /* 1st 16 bits - Event class */
+                        /* last 16 bits - Event code of this particula Event class */
+	MV_U8   Severity;
+	MV_U8   AdapterID; /*For LokiPlus, the byte will use to check whether event is vaild or not. If yes, it will be added to systme event log.*/
+	MV_U16  DeviceID;   /* Device ID relate to the event class (HD ID, LD ID etc) */
+	MV_U32  Params[MAX_EVENT_PARAMS]; /* Additional information if ABSOLUTELY necessary. */
+} DriverEvent, * PDriverEvent;
+
+typedef struct _EventRequest
+{
+	MV_U8        Count; /* [OUT] # of actual events returned */
+	MV_U8        Reserved[3];
+	DriverEvent  Events[MAX_EVENTS_RETURNED];
+} EventRequest, * PEventRequest;
+
+// Event support sense code
+typedef struct _DriverEvent_V2
+{
+    DriverEvent  Event;                /* same as the current one */
+    MV_U8        SenseDataLength;      /* actual length of SenseData.  Driver set it to 0 if no SenseData */
+    MV_U8        accurated;
+    MV_U8        SenseData[30];        /* (24+6) just for making this structure on 64-bits boundary */
+} DriverEvent_V2, * PDriverEvent_V2;
+
+typedef struct _EventRequest_V2
+{
+    MV_U8           Count; /* [OUT] # of actual events returned */
+    MV_U8           Reserved[3];
+    DriverEvent_V2  Events[MAX_EVENTS_RETURNED];
+} EventRequest_V2, * PEventRequest_V2;
+
+
+#define EVENTL0G_HEAD_SIGNATURE                "TLEM"
+#define EVENTLOG_HEAD_RESERVED_BYTES      16
+#define EVENTLOG_ENTRY_VALID                        0x00000001L
+
+#if defined(SUPPORT_NVRAM) && defined(_OS_FIRMWARE)
+#define NVRAM_START_OFFSET			0
+
+struct nvram_event_log_head
+{
+	MV_U8	signature[4];
+	MV_U32	next_tbl_off;
+	MV_U16	version;
+	MV_U16  	nr_max_entries;
+	MV_U32  	crc;
+	MV_U8  	reserved[EVENTLOG_HEAD_RESERVED_BYTES];
+};
+
+struct nvram_event_log
+{
+	struct nvram_event_log_head head;
+	MV_U32	sequence_no;
+	MV_U16	valid_slot_start;
+	MV_U16	valid_slot_end;
+	MV_U32	reserved;
+	MV_U32 	log_crc;
+};
+
+struct nvram_normal_head
+{
+	MV_U8	signature[4];
+	MV_U32	next_tbl_off;
+	MV_U16	version;
+	MV_U16  	nr_max_entries;
+	MV_U32  	crc;
+	MV_U8  	reserved[16];
+};
+#endif /*SUPPORT_NVRAM*/
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /*  _OS_BIOS */
+
+#endif /*  COM_EVENT_DRIVER_H */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_extern.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_extern.h
--- linux-3.10.69/drivers/scsi/mv/include/com_extern.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_extern.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,39 @@
+#ifndef  __MV_COM_EXTERN_H__
+#define  __MV_COM_EXTERN_H__
+
+#include "com_define.h"
+/* Target device type */
+#define TARGET_TYPE_LD                          	0
+#define TARGET_TYPE_FREE_PD                 	1
+
+#define DISK_TYPE_RAID					0
+#define DISK_TYPE_SATA					1
+#define DISK_TYPE_SAS					2
+
+/*TCQ queue types*/		
+#define TCQ_QUEUE_TYPE_SIMPLE			0x00
+#define TCQ_QUEUE_TYPE_HDOFQUEUE		0x01
+#define TCQ_QUEUE_TYPE_ORDERED			0x02
+#define TCQ_QUEUE_TYPE_ACA				0x04
+
+// Giving TargetID and LUN, returns it Type and DeviceID.  If returned Type or DeviceID is 0xFF, not found.
+typedef struct    _TargetLunType
+{
+ MV_U8            AdapterID;
+ MV_U8            TargetID;
+ MV_U8            Lun;
+ MV_U8            Type;            // TARGET_TYPE_LD or TARGET_TYPE_FREE_PD
+ MV_U16           DeviceID;        // LD ID or PD ID depends on Type
+ MV_U8            Reserved[34];
+}TargetLunType, * PTargetLunType;
+
+typedef struct	_OS_disk_info
+{
+	MV_U8 		ataper_id;	/* ataper disk locates */
+	MV_U8 		disk_type;	/* RAID disk, SATA disk or SAS disk */
+	MV_U8		queue_type; /*tcq queue types*/
+	MV_U16		device_id;	/* contain target id and lun */
+	MV_U16		queue_depth;	/* queue depth support this disk */
+}OS_disk_info, *POS_disk_info;
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_flash.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_flash.h
--- linux-3.10.69/drivers/scsi/mv/include/com_flash.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_flash.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,226 @@
+#ifndef __MV_COM_FLASH_H__
+#define __MV_COM_FLASH_H__
+
+#include "com_define.h"
+#include "com_event_struct.h"
+
+#define DRIVER_LENGTH                      1024*16
+
+#ifdef   SUPPORT_CONFIG_FILE
+#define   AUTOLOAD_FLASH_OFFSET			0x38
+#ifdef SUPPORT_ATHENA
+#define   AUTOLOAD_FLASH_LENGTH			1024
+#else
+#define   AUTOLOAD_FLASH_LENGTH			0x108
+#endif
+#define	RAID_BIOS_ROM_SIZE				(64*1024L)
+#define   RELOCATE_ROM_SIZE					0x1000
+#define   ROM_IMAGE_4K_CHECKSUM 			0x36  //byte
+#endif
+
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _Flash_DriverData
+{
+	MV_U16            Size;
+	MV_U8             PageNumber;
+	MV_BOOLEAN        isLastPage;
+	MV_U16            Reserved[2];
+	MV_U8             Data[DRIVER_LENGTH];
+}
+Flash_DriveData, *PFlash_DriveData;
+
+#if defined(SAVE_EVENTS_TO_FLASH)
+//#define EVENT_FLASH_SECTOR_SIZE (128 * 1024)
+#define EVENT_FLASH_SECTOR_SIZE (MX29LV640_MAIN_SECTOR_SIZE)
+#define MAX_FLASH_EVENT_PER_BLOCK	(EVENT_FLASH_SECTOR_SIZE / sizeof(struct flash_event_log_entry))
+
+#define MAX_FLASH_EVENT_LOG_ENTRY	(((EVENT_FLASH_SECTOR_SIZE * 2) / sizeof(struct flash_event_log_entry)) - 2) /*A block is 128K in Flash. Event Log will use 2 blocks. two will be to use the event log header(first and last, they will in different block)*/
+#define EVENT_LOG_VERSION 0x000010C
+
+/*The size of flash_event_log_entry equal to flash_event_log_head*/
+struct flash_event_log_entry
+{
+#if defined(ROC_V2_EVENT_SUPPORT)
+ 	DriverEvent_V2 event;
+#else
+	DriverEvent event;
+#endif
+	MV_U32 crc;
+
+	MV_U8    valid;
+	MV_U8    reserved0[7];
+
+#if defined(ROC_V2_EVENT_SUPPORT)
+	MV_U8  	reserved1[52]; 
+#else
+	MV_U8  	reserved1[84]; 
+#endif
+       /*please to keep total is 128 bytes.*/
+};
+
+struct flash_event_log_head
+{
+	MV_U8	signature[4];
+	MV_U32	next_tbl_off;
+	MV_U16	version;
+	MV_U16  	nr_max_entries;
+	MV_U32  	crc;
+	MV_U8  	reserved[112];
+       /*please to keep total is 128 bytes.*/
+};
+#endif /*SAVE_EVENTS_TO_FLASH*/
+
+#if defined(ADDING_FLASH_LAYOUT_DESC)
+struct flash_layout_item
+{
+        MV_U16    module_type;
+        MV_U16    id;
+
+        MV_U32    reserved0[1];
+        MV_U32    start_address;
+        MV_U32    size;
+};
+
+
+struct flash_layout_head
+{
+        MV_U8      signature[8];
+
+        MV_U32    next_tbl_off;
+
+        MV_U16    version;
+        MV_U16    reserved0[1];
+
+        MV_U32    length;
+
+        MV_U32    crc;
+
+        MV_U32    reserved1[2];
+
+        struct flash_layout_item item[1];
+};
+#define FLASH_LAYOUT_SIGN "MRVL_MAP"
+#define FLASH_LAYOUT_SIGN_LENGTH MV_StrLen(FLASH_LAYOUT_SIGN)
+//#define FLASH_LAYOUT_OFFSET	return_image_place_on_flash(FLASH_IMAGE_LAYOUTDESC , 0, FLASH_IMAGE_RETURN_ADDRESS)
+#define FLASH_LAYOUT_SIZE		0x00400000
+#define FLASH_LAYOUT_START_ADDR	0x00000000
+#define FLASH_LAYOUT_OFFSET		0x00100000
+
+/*The u-boot Start address to be decide by Flash Size(Please check Flash Library).
+   To got the SingleBlock and FlashSize by the Flash Library(if have any concern, please check Flash Library).*/
+
+/* Note : all images in description layout must be 32k multiplied, if using the image update or backup feature*/
+/*Note 1: The Layout String had been removed. Now it will be put by MVFlash or Windows Loader.*/
+#if 0
+#define FLASH_LAYOUT_DESC 	"Loki(NOR FLASH Layout) 1 BLOCK = 128K\
+			\n{\"BIOS\",0,[0x00000000],[32k],[1 Block]},\
+			\n{\"HBA.txt\",0,[0x000020000],[32k],[1 Block]},\
+			\n{\"HBA_Info\",0,[0x00040000],[32k],[1 Block]},\
+			\n{\"PD_Page\",0,[0x00060000],[128k],[1 Block]},\
+			\n{\"Event_Log\",0,[0x00080000],[256k],[2 Blocks]},\
+			\n{\"Desc.txt\",0,[0x000c0000],[32k],[1 Block]},\
+			\n{\"HBA_Info\",1,[0x000e0000],[32k],[1 Block]},\
+			\n{\"Firmware\",0,[0x00100000],[1024k],[4 Blocks]},\
+			\n{\"Firmware\",1,[0x00200000],[1024k],[4 Blocks]},\
+			\n{\"u-boot\",0,[0x00ff0000],[192k],[2 Block]},\
+			\n{\"SingleBlock\",0,[0xffffffff],[128k],[1 Block]},\
+			\n{\"FlashSize\",0,[0xffffffff],[16M],[128 Blocks]};"
+#endif
+
+enum {
+    FLASH_IMAGE_CONFIG = 0x000000000, /*The config had merged the HBA.txt and Layout Description */
+    FLASH_IMAGE_HBAINFO,
+    FLASH_IMAGE_FMLOADER,
+    FLASH_IMAGE_FIRMWARE,
+    FLASH_IMAGE_BIOS,
+    FLASH_IMAGE_EVENTLOG,
+    FLASH_IMAGE_PDINFOPAGE,
+    FLASH_IMAGE_SINGLEBLOCK,
+    FLASH_IMAGE_FLASHSIZE,
+    FLASH_IMAGE_RAW,
+    FLASH_IMAGE_MAX
+};
+
+#define FLASH_IMAGE_RETURN_ADDRESS 0
+#define FLASH_IMAGE_RETURN_SIZE    1
+
+/*
+	BIOS,     			[0x00000000],[128k]
+	HBA.txt, 			[0x000020000],[128k]
+	HBA_Info Primary,	[0x00040000],[128k]
+	PD Page,			[0x00060000],[128k]
+	Event Log,		[0x00080000],[256k]
+	Desc.txt,			[0x000C0000],[128k]
+	HBA_Info Secondary[0x000e0000],[128k]
+	Firmware Secondary[0x00100000],[1024k]
+	Firmware,			[0x00220000],[1024k]
+	u-boot,			[0x00FD0000],[128k]
+
+*/
+
+#define FLASH_BOOTLOADER_ADDR           0x00010000
+#define FLASH_BOOTLOADER_SIZE           0x00010000
+#define FLASH_PROD_STS_ADDR             0x00030000
+#define FLASH_PROD_STS_SIZE             0x00010000
+#define FLASH_BIOS_ADDR                 0x00040000
+#define FLASH_BIOS_SIZE                 0x00020000
+#define FLASH_FIRMWARE_ADDR             0x00100000
+#define FLASH_FIRMWARE_SECOND_ADDR      0x00200000
+#define FLASH_FIRMWARE_SIZE				0x00100000
+#define FLASH_HBA_CONFIG_ADDR			0x003E0000
+#define FLASH_HBA_CONFIG_SECOND_ADDR    0x003F0000
+#define FLASH_HBA_CONFIG_SIZE           0x00010000
+#define FLASH_RAW_IMAGE_ADDR            0x00000000
+#define FLASH_RAW_IMAGE_SIZE            0x00800000
+
+#define IMAGE_UPDATE	FLASH_UPLOAD
+#define IMAGE_BACKUP	FLASH_DOWNLOAD
+
+#ifdef SCSI_RW_BUFFER_CMD
+#define GENERATION_SIZE	8
+#define IMAGE_CRC_SIZE	4
+
+/* flash operation error type define
+0: FLASH_NONE_ERR
+1: FLASH_WRITE_ERR
+2: FLASH_READ_ERR
+3: GENERATION_ERR
+4: FATAL_GENERATION_ERR
+5: IMAGE_DATA_ERR
+6: IMAGE_HEADER_ERR
+7: IMAGE_HEADER_AND_DATA_ERR
+*/
+#define    FLASH_NONE_ERR					0
+#define    FLASH_WRITE_ERR					1
+#define    FLASH_READ_ERR					2
+#define    GENERATION_ERR					3
+#define    FATAL_GENERATION_ERR			4 // dual image's genreation all crashed
+#define    IMAGE_DATA_ERR					5 // single image's generation crashed
+#define    IMAGE_HEADER_ERR					6
+#define    IMAGE_HEADER_AND_DATA_ERR		7
+
+#define FLASH_DPRINT	 FM_PRINT
+
+#define RESTORE_GENERATION(gen)	do{gen.parts.high = 0xFFFFFFFF; gen.parts.low = 0xFFFFFFFF;}while(0)
+
+#ifdef FLASH_IMAGE_HEADER_CHECK
+static MV_U32	global_header_check = 1;
+#else
+static MV_U32	global_header_check = 0;
+#endif
+void flash_err_event_generate(MV_VOID * p_core, MV_U8 err_type);
+#endif
+
+MV_U32 return_image_place_on_flash(MV_U32 component_type, MV_U16 component_number, MV_U16 component_return_type);
+
+#endif
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+#endif /* __MV_COM_FLASH_H__ */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_flash_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_flash_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_flash_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_flash_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,32 @@
+#ifndef __MV_COM_FLASH_STRUCT_H__
+#define __MV_COM_FLASH_STRUCT_H__
+
+#include "com_define.h"
+
+#define 	 FLASH_DOWNLOAD                 0xf0
+#define	 FLASH_UPLOAD                       0xf
+
+//for read/write flash test command
+#define  FLASH_BYTE_WRITE           0
+#define  FLASH_BYTE_READ            1
+
+#define    FLASH_TYPE_CONFIG           0
+#define    FLASH_TYPE_BIN              1
+#define    FLASH_TYPE_BIOS             2
+#define    FLASH_TYPE_FIRMWARE         3
+#define    FLASH_TYPE_AUTOLOAD         4	
+#define    FLASH_TYPE_NVSRAM           5
+#define    FLASH_TYPE_RAW              6 // the data is an image with header. as same as firmware. design for autoload,configure. oem only
+
+
+#define 	FLASH_ERASE_PAGE                      0x1  //Erase bios or PD page or hba info page
+#define	FLASH_PD_PAGE					1	// Erase PD page in flash memory but not in-uses PD id 
+#define	FLASH_PD_PAGE_FORCE			254	// Force to erase the whole PD page even PD id is in-use. Used by manufacturing only!
+
+typedef struct _MV_FLASH_PER_DATA{
+	MV_U8    image_type;
+	MV_U8    reserved[3];
+	MV_U32   image_size;
+} MV_FLASH_PER_DATA, *PMV_FLASH_PER_DATA;
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_ioctl.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_ioctl.h
--- linux-3.10.69/drivers/scsi/mv/include/com_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_ioctl.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,106 @@
+#ifndef __MV_COM_IOCTL_H__
+#define __MV_COM_IOCTL_H__
+
+#if defined(_OS_WINDOWS) && !defined(_OS_FIRMWARE)
+#include <ntddscsi.h>
+#elif defined(_OS_LINUX)
+
+#endif /* _OS_WINDOWS */
+
+/* private IOCTL commands */
+#define MV_IOCTL_CHECK_DRIVER                                \
+	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
+                     0x900, METHOD_BUFFERED,                 \
+                     FILE_READ_ACCESS | FILE_WRITE_ACCESS)	
+
+/*
+ * MV_IOCTL_LEAVING_S0 is a notification when the system is going 
+ * to leaving S0. This gives the driver a chance to do some house
+ * keeping work before system really going to sleep.
+ *
+ * The MV_IOCTL_LEAVING_S0 will be translated to APICDB0_ADAPTER/
+ * APICDB1_ADAPTER_POWER_STATE_CHANGE and passed down along the
+ * module stack. A module shall handle this request if necessary.
+ *
+ * Upon this request, usually the Cache module shall flush all
+ * cached data. And the RAID module shall auto-pause all background
+ * activities.
+ */
+#define MV_IOCTL_LEAVING_S0                                \
+	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
+                     0x901, METHOD_BUFFERED,                 \
+                     FILE_READ_ACCESS | FILE_WRITE_ACCESS)	
+
+/*
+ * MV_IOCTL_REENTER_S0 is a notification when the system is going 
+ * to re-entering S0. This gives the driver a chance to resume
+ * something when system wakes up.
+ *
+ * The MV_IOCTL_REENTER_S0 will be translated to APICDB0_ADAPTER/
+ * APICDB1_ADAPTER_POWER_STATE_CHANGE (CDB2 is 1) and passed down 
+ * along the module stack. 
+ * A module shall handle this request if necessary.
+ */
+#define MV_IOCTL_REENTER_S0                                \
+	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
+                     0x902, METHOD_BUFFERED,                 \
+                     FILE_READ_ACCESS | FILE_WRITE_ACCESS)	
+
+/* Used for notifying shutdown from dispatch */
+#define MV_IOCTL_SHUTDOWN                               \
+	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
+                     0x903, METHOD_BUFFERED,                 \
+                     FILE_READ_ACCESS | FILE_WRITE_ACCESS)	
+// private ioctrl for scsi trim
+#define MV_IOCTL_TRIM_SCSI                               \
+	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
+                     0x905, METHOD_BUFFERED,                 \
+                     FILE_WRITE_ACCESS)	
+
+/* IOCTL signature */
+#define MV_IOCTL_DRIVER_SIGNATURE                "mv61xxsg"
+#define MV_IOCTL_DRIVER_SIGNATURE_LENGTH         8
+
+/* IOCTL command status */
+#define IOCTL_STATUS_SUCCESS                     0
+#define IOCTL_STATUS_INVALID_REQUEST             1
+#define IOCTL_STATUS_ERROR                       2
+
+
+/*IOCTL code on linux*/
+#ifdef _OS_LINUX
+#define API_BLOCK_IOCTL_DEFAULT_FUN	0x1981
+#define API_IOCTL_DEFAULT_FUN			0x00
+#define	API_IOCTL_GET_VIRTURL_ID		(API_IOCTL_DEFAULT_FUN + 1)
+#define	API_IOCTL_GET_HBA_COUNT		(API_IOCTL_DEFAULT_FUN + 2)
+#define	API_IOCTL_LOOKUP_DEV			(API_IOCTL_DEFAULT_FUN + 3)
+#define  API_IOCTL_CHECK_VIRT_DEV           (API_IOCTL_DEFAULT_FUN + 4)
+#define  API_IOCTL_GET_ENC_ID               	(API_IOCTL_DEFAULT_FUN + 5)
+#define  API_IOCTL_MAX                      		(API_IOCTL_DEFAULT_FUN + 6)
+#endif
+
+
+#if defined(SUPPORT_ESATA) || defined(SUPPORT_DRIVER_FEATURE)
+#define MV_IOCTL_CHECK_DEVICE                                \
+	    CTL_CODE(FILE_DEVICE_CONTROLLER,                 \
+                     0x904, METHOD_BUFFERED,                 \
+                     FILE_READ_ACCESS | FILE_WRITE_ACCESS)	
+#endif
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif  /* _OS_BIOS */
+
+typedef struct _MV_IOCTL_BUFFER
+{
+#if defined(_OS_WINDOWS) && !defined(_OS_FIRMWARE)
+	SRB_IO_CONTROL Srb_Ctrl;
+#endif /* _OS_WINDOWS */
+	MV_U8          Data_Buffer[32];
+} MV_IOCTL_BUFFER, *PMV_IOCTL_BUFFER;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+#endif /* __MV_COM_IOCTL_H__ */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_list.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_list.c
--- linux-3.10.69/drivers/scsi/mv/include/com_list.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_list.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,370 @@
+#include "com_define.h"
+#include "com_list.h"
+#include "com_dbg.h"
+/*
+ * Insert a new entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static MV_INLINE void __List_Add(List_Head *new_one,
+			      List_Head *prev,
+			      List_Head *next)
+{
+#ifdef MV_DEBUG
+	if (unlikely(next->prev != prev)) {
+			MV_DPRINT(( "list_add corruption. next->prev should be "
+				"prev (0x%p), but was 0x%p. (next=0x%p).\n",
+				prev, next->prev, next));
+
+			MV_DPRINT(( "prev=0x%p, prev->next=0x%p,  prev->prev=0x%p"
+				"next=0x%p, next->next=0x%p, next->prev=0x%p.\n",
+				prev, prev->next, prev->prev, next, next->next, next->prev));
+
+		}
+		if (unlikely(prev->next != next)) {
+			MV_DPRINT(( "list_add corruption. prev->next should be "
+				"next (0x%p), but was 0x%p. (prev=0x%p).\n",
+				next, prev->next, prev));
+
+			MV_DPRINT(( "prev=0x%p, prev->next=0x%p,  prev->prev=0x%p,"
+				"next=0x%p, next->next=0x%p, next->prev=0x%p.\n",
+				prev, prev->next, prev->prev, next, next->next, next->prev));
+
+		}
+#endif
+
+	next->prev = new_one;
+	new_one->next = next;
+	new_one->prev = prev;
+	prev->next = new_one;
+}
+
+/**
+ * List_Add - add a new entry
+ * @new_one: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static MV_INLINE void List_Add(List_Head *new_one, List_Head *head)
+{
+	__List_Add(new_one, head, head->next);
+}
+
+static MV_INLINE void Counted_List_Add(List_Head *new_one, Counted_List_Head *head)
+{
+	List_Add(new_one, (List_Head *)head);
+	head->node_count++;
+}
+
+/**
+ * List_AddTail - add a new entry
+ * @new_one: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static MV_INLINE void List_AddTail(List_Head *new_one, List_Head *head)
+{
+	__List_Add(new_one, head->prev, head);
+}
+
+static MV_INLINE void Counted_List_AddTail(List_Head *new_one, Counted_List_Head *head)
+{
+	List_AddTail(new_one, (List_Head *) head);
+	head->node_count++;
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static MV_INLINE void __List_Del(List_Head * prev, List_Head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * List_Del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: List_Empty on entry does not return true after this, the entry is
+ * in an undefined state.
+ */
+#ifdef MV_DEBUG
+static void List_Del(List_Head *entry)
+#else
+static MV_INLINE void List_Del(List_Head *entry)
+#endif
+{
+#ifdef MV_DEBUG
+	if (entry->prev) {
+		if (unlikely(entry->prev->next != entry)) {
+                        MV_DASSERT(MV_FALSE);
+			MV_DPRINT(("list_del corruption. prev->next should be %p, "
+					"but was %p\n", entry, entry->prev->next));
+			MV_DPRINT(( "entry->next=%p, entry->next->next=%p,	entry->next->prev=%p.\n"
+					"entry->prev=%p, entry->prev->next=%p, entry->prev->prev=%p.\n",
+				entry->prev, entry->next->next, entry->next->prev, entry->prev, entry->prev->next, entry->prev->prev));
+
+		}
+		if (unlikely(entry->next->prev != entry)) {
+                        MV_DASSERT(MV_FALSE);
+			MV_DPRINT(( "list_del corruption. next->prev should be %p, "
+					"but was %p\n", entry, entry->next->prev));
+
+			MV_DPRINT(("entry->next=%p, entry->next->next=%p,  entry->next->prev=%p.\n"
+					"entry->prev=%p, entry->prev->next=%p, entry->prev->prev=%p.\n",
+				entry->next, entry->next->next, entry->next->prev, entry->prev, entry->prev->next, entry->prev->prev));
+
+		}
+	}
+#endif
+
+	__List_Del(entry->prev, entry->next);
+	entry->next = NULL;
+	entry->prev = NULL;
+}
+
+static MV_INLINE void Counted_List_Del(List_Head *entry, Counted_List_Head *head)
+{
+	List_Del(entry);
+	head->node_count--;
+}
+
+
+/**
+ * List_DelInit - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static MV_INLINE void List_DelInit(List_Head *entry)
+{
+	__List_Del(entry->prev, entry->next);
+	MV_LIST_HEAD_INIT(entry);
+}
+
+/**
+ * List_Move - delete from one list and add as another's head
+ * @list: the entry to move
+ * @head: the head that will precede our entry
+ */
+static MV_INLINE void List_Move(List_Head *list, List_Head *head)
+{
+        __List_Del(list->prev, list->next);
+        List_Add(list, head);
+}
+
+/**
+ * List_MoveTail - delete from one list and add as another's tail
+ * @list: the entry to move
+ * @head: the head that will follow our entry
+ */
+static MV_INLINE void List_MoveTail(List_Head *list,
+				  List_Head *head)
+{
+        __List_Del(list->prev, list->next);
+        List_AddTail(list, head);
+}
+
+/**
+ * List_Empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static MV_INLINE int List_Empty(const List_Head *head)
+{
+	return head->next == head;
+}
+
+static MV_INLINE int Counted_List_Empty(const Counted_List_Head *head)
+{
+	return (head->node_count == 0);
+}
+
+static MV_INLINE int List_GetCount(const List_Head *head)
+{
+	int i=0;
+	List_Head *pos;
+	LIST_FOR_EACH(pos, head) {
+		i++;
+	}
+	return i;
+}
+
+static MV_INLINE int Counted_List_GetCount(const Counted_List_Head *head, const MV_BOOLEAN traverse_list)
+{
+	int i=0;
+	List_Head *pos;
+
+	if (traverse_list) {
+		LIST_FOR_EACH(pos, head) {
+			i++;
+		}
+		return i;
+	}
+	else {
+		return head->node_count;
+	}
+}
+
+static MV_INLINE List_Head* List_GetFirst(List_Head *head)
+{
+	List_Head * one = NULL;
+	if ( List_Empty(head) ) return NULL;
+
+	one = head->next;
+	List_Del(one);
+	return one;
+}
+
+static MV_INLINE List_Head* Counted_List_GetFirst(Counted_List_Head *head)
+{
+	List_Head *one = NULL;
+	if ( Counted_List_Empty(head) ) return NULL;
+	one = head->next;
+	Counted_List_Del(one, head);
+	return one;
+}
+
+static MV_INLINE List_Head* List_GetLast(List_Head *head)
+{
+	List_Head * one = NULL;
+	if ( List_Empty(head) ) return NULL;
+
+	one = head->prev;
+	List_Del(one);
+	return one;
+}
+
+static MV_INLINE List_Head* Counted_List_GetLast(Counted_List_Head *head)
+{
+	List_Head * one = NULL;
+	if ( Counted_List_Empty(head) ) return NULL;
+
+	one = head->prev;
+	Counted_List_Del(one, head);
+	return one;
+}
+
+static MV_INLINE void __List_Splice(List_Head *list,
+	List_Head *head)
+{
+	List_Head *first = list->next;
+	List_Head *last = list->prev;
+	List_Head *at = head->next;
+
+	first->prev = head;
+	head->next = first;
+
+	last->next = at;
+	at->prev = last;
+}
+
+static MV_INLINE void __List_SpliceTail(List_Head *list,
+	List_Head *head)
+{
+	List_Head *first = list->next;
+	List_Head *last = list->prev;
+	List_Head *at = head->prev;
+
+	first->prev = at;
+	at->next = first;
+
+	last->next = head;
+	head->prev = last;
+}
+
+/**
+ * List_Splice - join two lists
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ */
+static MV_INLINE void List_Splice(List_Head *list, List_Head *head)
+{
+	if (!List_Empty(list))
+		__List_Splice(list, head);
+}
+
+/**
+ * List_AddList - join two lists and reinitialise the emptied list.
+ * @list: the new list to add.
+ * @head: the place to add it in the first list.
+ *
+ * The list at @list is reinitialised
+ */
+
+static MV_INLINE void List_AddList(List_Head *list,
+				 List_Head *head)
+{
+	if (!List_Empty(list)) {
+		__List_Splice(list, head);
+		MV_LIST_HEAD_INIT( list );
+	}
+}
+
+static MV_INLINE void List_AddCountedList(Counted_List_Head *list, List_Head *head)
+{
+	if (!Counted_List_Empty(list)) {
+		__List_Splice((List_Head *)list, head);
+		MV_COUNTED_LIST_HEAD_INIT( list );
+	}
+
+}
+
+static MV_INLINE void Counted_List_AddList(List_Head *list, Counted_List_Head *head)
+{
+	if (!List_Empty(list)) {
+		head->node_count += List_GetCount(list);
+		__List_Splice(list, (List_Head *) head);
+		MV_LIST_HEAD_INIT( list );
+	}
+}
+
+static MV_INLINE void Counted_List_AddCountedList(Counted_List_Head *list, Counted_List_Head *head)
+{
+	if (!Counted_List_Empty(list)) {
+		head->node_count += list->node_count;
+		__List_Splice((List_Head *)list, (List_Head *) head);
+		MV_COUNTED_LIST_HEAD_INIT( list );
+	}
+}
+
+static MV_INLINE void List_AddListTail(List_Head *list, List_Head *head)
+{
+	if (!List_Empty(list)) {
+		__List_SpliceTail(list, head);
+		MV_LIST_HEAD_INIT( list );
+	}
+}
+
+static MV_INLINE void List_AddCountedList_Tail(Counted_List_Head *list, List_Head *head)
+{
+	if (!Counted_List_Empty(list)) {
+		__List_SpliceTail((List_Head *) list, head);
+		MV_COUNTED_LIST_HEAD_INIT(list);
+	}
+}
+
+static MV_INLINE void Counted_List_AddList_Tail(List_Head *list, Counted_List_Head *head)
+{
+	if (!List_Empty(list)) {
+		head->node_count += List_GetCount(list);
+		__List_SpliceTail(list, (List_Head *) head);
+		MV_LIST_HEAD_INIT(list);
+	}
+}
+
+static MV_INLINE void Counted_List_AddCountedList_Tail(Counted_List_Head *list, Counted_List_Head *head)
+{
+	if (!Counted_List_Empty(list)) {
+		head->node_count += list->node_count;
+		__List_SpliceTail((List_Head *) list, (List_Head *) head);
+		MV_COUNTED_LIST_HEAD_INIT(list);
+	}
+}
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_list.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_list.h
--- linux-3.10.69/drivers/scsi/mv/include/com_list.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_list.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,299 @@
+#if !defined(COMMON_LIST_H)
+#define COMMON_LIST_H
+
+#include "com_define.h"
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+
+/*
+ *
+ *
+ * Data Structure
+ *
+ *
+ */
+typedef struct _List_Head {
+	struct _List_Head *prev, *next;
+} List_Head, * PList_Head;
+
+typedef struct _Counted_List_Head {
+	struct _List_Head *prev, *next;
+	MV_U32 node_count;
+} Counted_List_Head, * PCounted_List_Head;
+
+/*
+ *
+ *
+ * Exposed Functions
+ *
+ *
+ */
+ 
+#define MV_LIST_HEAD(name) \
+	List_Head name = { &(name), &(name) }
+
+#define MV_LIST_HEAD_INIT(ptr) do { \
+	(ptr)->next = (ptr)->prev = (ptr); \
+} while (0)
+
+#define MV_COUNTED_LIST_HEAD_INIT(ptr) do { \
+	(ptr)->next = (ptr)->prev = (List_Head *)(ptr); \
+	(ptr)->node_count = 0; \
+} while (0)
+
+
+#if defined( SUPPORT_ROC )&&defined( MV_ROC_IOP_TUNED )
+#define MV_ROC_LIST_MUST_BE_MACRO								0
+
+#if (MV_ROC_LIST_MUST_BE_MACRO==0)
+static MV_INLINE void List_Add(List_Head *new_one, List_Head *head);
+
+static MV_INLINE void List_AddTail(List_Head *new_one, List_Head *head);
+
+static MV_INLINE void List_Del(List_Head *entry);
+
+static MV_INLINE void List_DelInit(List_Head *entry);
+
+static MV_INLINE void List_Move(List_Head *list, List_Head *head);
+
+static MV_INLINE void List_MoveTail(List_Head *list,
+				  List_Head *head);
+
+static MV_INLINE int List_Empty(const List_Head *head);
+#endif
+
+
+#if (MV_ROC_LIST_MUST_BE_MACRO==1)
+#define List_Empty(head)	(((head)->next)==(head))
+#define __List_Add(new_one_,prev_,next_)							\
+({                                                             \
+	(next_)->prev = (new_one_);                                     \
+	(new_one_)->next = (next_);                                     \
+	(new_one_)->prev = (prev_);                                     \
+	(prev_)->next = (new_one_);                                     \
+})
+                                                                
+#define List_Add(new_one, head)                                 \
+({                                                             \
+	register List_Head *a = ((head)->next);					\
+	__List_Add((new_one), (head), a);    					\
+})
+                                                                
+#define List_AddTail(new_one, head)                             \
+({                                                             \
+	register List_Head *a = ((head)->prev);					\
+	__List_Add((new_one), a, (head));    		\
+})
+                                                                
+#define __List_Del( prev_,  next_)                              \
+({                                                             \
+	(next_)->prev = (prev_);                                      \
+	(prev_)->next = (next_);                                      \
+})                                          
+                                                                
+#define List_Del(entry)                                         \
+({                                                             \
+	__List_Del(((entry)->prev), ((entry)->next));                   \
+	(entry)->next = (entry)->prev = NULL;                       \
+})                                                   
+#define List_DelInit(entry)                                    	\
+({                                                             \
+	List_Del(entry);											\
+	MV_LIST_HEAD_INIT(entry);                                   \
+})
+                                                                
+#define List_Move(list, head)                                   \
+({                                                             \
+	List_Del(entry);											\
+    List_Add(list, head);                                   \
+})                                                      
+                                                                
+#define List_MoveTail(list, head)                               \
+({                                                             \
+	List_Del(entry);											\
+    List_AddTail(list, head);                               \
+})                                                      
+#define List_GetCount(head)               		                 \
+({                                                              \
+	register List_Head *pos;                                    \
+	register int i=0;                                           \
+	LIST_FOR_EACH(pos, head) {                                  \
+		i++;                                                    \
+	}                                                           \
+	(i);                                                          \
+})             
+                                                                
+#define List_GetFirst(head)                          			\
+({                                                              \
+	register List_Head *one = NULL;		                            \
+	if ( !List_Empty(head) ) {			                        \
+		one = (head)->next;                                     \
+		List_Del(one);                                          \
+	}											\
+	(one);                                                        \
+})                                                              
+                                                                
+#define List_GetLast(head)                           			\
+({                                                              \
+	register List_Head *one = NULL;      			                    \
+	if ( !List_Empty(head) ) {                        			\
+		one = (head)->prev;                                     \
+		List_Del(one);                                          \
+	}											\
+	(one);                                                        \
+})
+
+static MV_INLINE void List_AddList(List_Head *list,
+				 List_Head *head)
+{
+	if (!List_Empty(list)) {
+		List_Head *first = list->next;
+		List_Head *last = list->prev;
+		List_Head *at = head->next;
+
+		first->prev = head;
+		head->next = first;
+
+		last->next = at;
+		at->prev = last;
+		MV_LIST_HEAD_INIT( list );
+	}
+}
+
+static MV_INLINE void List_AddListTail(List_Head *list, List_Head *head)
+{
+	if (!List_Empty(list)) {
+		List_Head *first = list->next;
+		List_Head *last = list->prev;
+		List_Head *at = head->prev;
+
+		first->prev = at;
+		at->next = first;
+
+		last->next = head;
+		head->prev = last;
+		MV_LIST_HEAD_INIT( list );
+	}
+}
+#endif
+#endif
+
+/**
+ * LIST_ENTRY - get the struct for this entry
+ * @ptr:	the &List_Head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+//TBD
+/*#define CONTAINER_OF(ptr, type, member) ({			\
+*        const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
+*        (type *)( (char *)__mptr - OFFSET_OF(type,member) );})
+*/
+
+#define CONTAINER_OF(ptr, type, member) 			\
+        ( (type *)( (char *)(ptr) - OFFSET_OF(type,member) ) )
+
+#define LIST_ENTRY(ptr, type, member) \
+	CONTAINER_OF(ptr, type, member)
+
+
+/**
+ * LIST_FOR_EACH	-	iterate over a list
+ * @pos:	the &List_Head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define LIST_FOR_EACH(pos, head) \
+	for (pos = (head)->next; pos != (List_Head *)(head); pos = pos->next)
+
+/**
+ * LIST_FOR_EACH_PREV	-	iterate over a list backwards
+ * @pos:	the &List_Head to use as a loop counter.
+ * @head:	the head for your list.
+ */
+#define LIST_FOR_EACH_PREV(pos, head) \
+	for (pos = (head)->prev; pos != (List_Head *)(head); pos = pos->prev)
+
+/**
+ * LIST_FOR_EACH_ENTRY	-	iterate over list of given type
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define LIST_FOR_EACH_ENTRY(pos, head, member)				\
+	for (pos = LIST_ENTRY((head)->next, typeof(*pos), member);	\
+	     &pos->member != (List_Head *)(head); 	\
+	     pos = LIST_ENTRY(pos->member.next, typeof(*pos), member))
+
+/**
+ * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * @pos:	the type * to use as a loop cursor.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member: the name of the list_struct within the struct.
+ */
+#define LIST_FOR_EACH_ENTRY_SAFE(pos, n, head, member)			\
+			for (pos = LIST_ENTRY((head)->next, typeof(*pos), member),	\
+				n = LIST_ENTRY(pos->member.next, typeof(*pos), member); \
+				 &pos->member != (List_Head *) (head);					\
+				 pos = n, n = LIST_ENTRY(n->member.next, typeof(*n), member))
+	
+
+
+/**
+ * LIST_FOR_EACH_ENTRY_TYPE	-	iterate over list of given type
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ * @type:	the type of the struct this is embedded in.
+*/
+#define LIST_FOR_EACH_ENTRY_TYPE(pos, head, type, member)       \
+	for (pos = LIST_ENTRY((head)->next, type, member);	\
+	     &pos->member != (List_Head *) (head); 	                        \
+	     pos = LIST_ENTRY(pos->member.next, type, member))
+
+/**
+ * LIST_FOR_EACH_ENTRY_PREV - iterate backwards over list of given type.
+ * @pos:	the type * to use as a loop counter.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define LIST_FOR_EACH_ENTRY_PREV(pos, head, member)			\
+	for (pos = LIST_ENTRY((head)->prev, typeof(*pos), member);	\
+	     &pos->member != (List_Head *)(head); 	\
+	     pos = LIST_ENTRY(pos->member.prev, typeof(*pos), member))
+
+
+
+#if !defined(SUPPORT_ROC)
+	#if !defined( _OS_BIOS )
+	#include "com_list.c"
+	#endif
+#else
+	#if (MV_ROC_LIST_MUST_BE_MACRO==0)
+       #include "com_list.c"
+	#endif
+#endif
+
+
+#define List_GetFirstEntry(head, type, member)	\
+	LIST_ENTRY(List_GetFirst(head), type, member)
+
+#define Counted_List_GetFirstEntry(head, type, member) \
+	LIST_ENTRY(Counted_List_GetFirst(head), type, member)
+
+#define List_GetLastEntry(head, type, member)	\
+	LIST_ENTRY(List_GetLast(head), type, member)
+
+#define Counted_List_GetLastEntry(head, type, member) \
+	LIST_ENTRY(Counted_List_GetLast(head), type, member)
+
+#endif /* COMMON_LIST_H */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_mod_mgmt.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_mod_mgmt.h
--- linux-3.10.69/drivers/scsi/mv/include/com_mod_mgmt.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_mod_mgmt.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,98 @@
+#ifndef __MV_MODULE_MGMT__
+#define __MV_MODULE_MGMT__
+
+#include "com_define.h"
+#include "com_type.h"
+#include "com_util.h"
+
+enum {
+	/* module status (module_descriptor) */
+	MV_MOD_VOID   = 0,
+	MV_MOD_UNINIT,
+	MV_MOD_REGISTERED,  /* module ops pointer registered */
+	MV_MOD_INITED,      /* resource assigned */ 
+	MV_MOD_FUNCTIONAL,
+	MV_MOD_STARTED,
+	MV_MOD_DEINIT,      /* extension released, be gone soon */
+	MV_MOD_GONE,
+};
+
+
+
+struct mv_mod_desc;
+
+
+struct mv_mod_res {
+	List_Head      res_entry;
+	MV_PHYSICAL_ADDR       bus_addr;
+	MV_PVOID               virt_addr;
+	
+	MV_U32                 size;
+	
+	MV_U16                 type;          /* enum Resource_Type */
+	MV_U16                 align;
+};
+
+typedef struct _Module_Interface
+{
+	MV_U8      module_id;
+	MV_U32     (*get_res_desc)(enum Resource_Type type, MV_U16 maxIo);
+	MV_VOID    (*module_initialize)(MV_PVOID extension,
+					MV_U32   size,
+					MV_U16   max_io);
+	MV_VOID    (*module_start)(MV_PVOID extension);
+	MV_VOID    (*module_stop)(MV_PVOID extension);
+	MV_VOID    (*module_notification)(MV_PVOID extension, 
+					  enum Module_Event event, 
+					  struct mod_notif_param *param);
+	MV_VOID    (*module_sendrequest)(MV_PVOID extension, 
+					 PMV_Request pReq);
+	MV_VOID    (*module_reset)(MV_PVOID extension);
+	MV_VOID    (*module_monitor)(MV_PVOID extension);
+	MV_BOOLEAN (*module_service_isr)(MV_PVOID extension);
+#ifdef RAID_DRIVER
+	MV_VOID    (*module_send_xor_request)(MV_PVOID This, 
+					      PMV_XOR_Request pXORReq);
+#endif /* RAID_DRIVER */
+} Module_Interface, *PModule_Interface;
+
+#define mv_module_ops _Module_Interface
+
+#define mv_set_mod_ops(_ops, _id, _get_res_desc, _init, _start,            \
+		       _stop, _send, _reset, _mon, _send_eh, _isr, _xor)   \
+           {                                                               \
+		   _ops->id                      = id;                     \
+		   _ops->get_res_desc            = _get_res_desc;          \
+		   _ops->module_initialize       = _init;                  \
+		   _ops->module_start            = _start;                 \
+		   _ops->module_stop             = _stop;                  \
+		   _ops->module_sendrequest      = _send;                  \
+		   _ops->module_reset            = _reset;                 \
+		   _ops->module_monitor          = _mon;                   \
+		   _ops->module_send_eh_request  = _send_eh;               \
+		   _ops->module_service_isr      = _isr;                   \
+		   _ops->module_send_xor_request = _xor;                   \
+	   }
+
+
+/* module descriptor */
+struct mv_mod_desc {
+	List_Head          mod_entry;      /* kept in a list */
+	
+	struct mv_mod_desc         *parent;
+	struct mv_mod_desc         *child;
+
+	MV_U32                     extension_size;
+	MV_U8                      status;
+	MV_U8                      ref_count;
+	MV_U8                      module_id;
+	MV_U8                      res_entry;
+
+	MV_PVOID                   extension;      /* module extention */
+	struct mv_module_ops       *ops;           /* interface operations */
+
+	struct mv_adp_desc         *hba_desc;
+	List_Head           res_list;
+};
+
+#endif /* __MV_MODULE_MGMT__ */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_nvram.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_nvram.h
--- linux-3.10.69/drivers/scsi/mv/include/com_nvram.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_nvram.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,686 @@
+#if !defined(COM_NVRAM_H)
+#define COM_NVRAM_H
+#include "mv_config.h"
+#ifdef SUPPORT_ATHENA
+#include "core_hal.h"
+#endif
+typedef union {
+    struct {
+        MV_U32 low;
+        MV_U32 high;
+    } parts;
+    MV_U8       b[8];
+    MV_U16      w[4];
+    MV_U32      d[2];        
+} SAS_ADDR, *PSAS_ADDR;
+
+/* Generate  PHY tunning parameters */
+typedef struct _PHY_TUNING {
+#ifndef SUPPORT_BALDUR
+	MV_U8	AMP:4;						  	/* 4 bits,  amplitude  */
+	MV_U8	Pre_Emphasis:3;				 	/* 3 bits,  pre-emphasis */
+	MV_U8	Reserved_1bit_1:1;				/* 1 bit,   reserved space */
+         MV_U8	Drive_En:6;						/* 6 bits,	drive enable */
+	MV_U8	Pre_Half_En:1;					/* 1 bit,	Half Pre-emphasis Enable*/
+	MV_U8	Reserved_1bit_2:1;				/* 1 bit, 	reserved space */
+	MV_U8	Reserved[2];						/* 2 bytes, reserved space */
+#else
+#ifdef SUPPORT_ATHENA
+	MV_U8	Trans_Emphasis_En:1;			/* 1 bit,  transmitter emphasis enable	*/
+	MV_U8	Trans_Emphasis_Amp:4;			/* 4 bits, transmitter emphasis amplitude */
+	MV_U8	Reserved_2bit_1:3;				/* 3 bits, reserved space */
+	MV_U8	Trans_Amp_Adjust:1;				/* 1 bits, transmitter amplitude adjust */
+	MV_U8	Trans_Amp:5;					/* 5 bits, transmitter amplitude */
+	MV_U8	Reserved_2bit_2:2;				/* 2 bits,	reserved space */
+	MV_U8	Reserved[2];					/* 2 bytes, reserved space */
+#else
+	MV_U8	Trans_Emphasis_En:1;			/* 1 bit,  transmitter emphasis enable  */
+	MV_U8	Trans_Emphasis_Amp:4;		    	/* 4 bits, transmitter emphasis amplitude */
+	MV_U8	Reserved_2bit_1:3;				/* 3 bits, reserved space */
+       MV_U8	Trans_Amp:5;					/* 5 bits, transmitter amplitude */
+	MV_U8	Trans_Amp_Adjust:2;			/* 2 bits, transmitter amplitude adjust */
+	MV_U8	Reserved_2bit_2:1;				/* 1 bit, 	reserved space */
+	MV_U8	Reserved[2];						/* 2 bytes, reserved space */
+#endif
+#endif
+} PHY_TUNING, *PPHY_TUNING;
+
+typedef struct _FFE_CONTROL {
+	MV_U8	FFE_Capacitor_Select:4;			/* 4 bits,  FFE Capacitor Select  (value range 0~F)  */
+	MV_U8	FFE_Resistor_Select	:3;		    /* 3 bits,  FFE Resistor Select (value range 0~7) */
+   	MV_U8	Reserved			:1;			/* 1 bit reserve*/
+} FFE_CONTROL, *pFFE_CONTROL;
+
+typedef struct _Mv_Phy_Status{
+	MV_U32	phy_id;
+	MV_U32	subtractive;
+	MV_U8	sas_address[8];
+	MV_U32	device_type;	//sata or sas
+	MV_U32	link_rate;
+}Mv_Phy_Status, *pMv_Phy_Status;
+
+
+/* HBA_FLAG_XX */
+#define HBA_FLAG_INT13_ENABLE				MV_BIT(0)	//int 13h enable/disable
+#define HBA_FLAG_SILENT_MODE_ENABLE			MV_BIT(1)	//silent mode enable/disable
+#define HBA_FLAG_ERROR_STOP					MV_BIT(2)	//if error then stop
+#define HBA_FLAG_OPTIMIZE_CPU_EFFICIENCY	MV_BIT(3)	//if 1, enable interrupt coalescing, optimize CPU efficiency
+#define HBA_FLAG_AUTO_REBUILD_ON            MV_BIT(4) // auto rebuild on/off                                                   //XIN
+#ifdef _BGA_COPY_BACK
+#define HBA_FLAG_COPY_BACK_ON               MV_BIT(5) // copy back on/off
+#endif
+#define HBA_FLAG_SMART_ON					MV_BIT(6) // smart on/off
+#define HBA_FLAG_DISABLE_MOD_CONSOLIDATE	MV_BIT(7)	//if 1, disable module consolidation
+#define HBA_FLAG_ENABLE_BUZZER			    MV_BIT(8)
+#define HBA_FLAG_SERIAL_CONSOLE_ENABLE		MV_BIT(9) //Bios enable or disable console redirection feature
+#define HBA_FLAG_ENABLE_SGPIO               MV_BIT(10) //HBA support SGPIO backplane
+#ifdef SUPPORT_ATHENA
+#define HBA_FLAG_SATA_SSU_MODE				MV_BIT(11) //HBA support sata ssu spin up mode, if 1,ssu mode, if 0, puis mode
+#endif
+#define HBA_FLAG_FIXED_PORT_MAPPING         MV_BIT(12) //Force PD ID = Port ID
+#define HBA_FLAG_DISABLE_TWSI_I2C           MV_BIT(13) //To disable TWSI I2C
+
+#define NVRAM_DATA_MAJOR_VERSION		0
+#define NVRAM_DATA_MINOR_VERSION		1
+
+/* for RAID_Feature */
+#define RAID_FEATURE_DISABLE_RAID5			MV_BIT(0)
+#define RAID_FEATURE_ENABLE_RAID			MV_BIT(1)
+
+#if defined(SUPPORT_ROC)
+#define Max_SpinUpDisk 	8
+#define Max_SpinUpTime	8
+#endif
+
+#if defined(_OS_FIRMWARE)
+typedef struct _boot_dev_struct
+{
+	MV_U32   WWN_CRC;
+} boot_dev_info_t;
+#endif
+
+#ifdef SUPPORT_ATHENA
+#define PAGE_HEADER_MAJOR_VER  0x01
+#define PAGE_HEADER_MINOR_VER  0x01
+#endif
+
+typedef struct _page_header{
+    // Dword 0
+    MV_U8	signature[4];		/* 4 bytes, structure signature,should be "MRVL" at first initial */
+    // Dword 1
+    MV_U8	page_code;		/* 1 byte, page code , here should be 0x01  for PD info Page */
+    MV_U8	check_sum;		/* 1 byte,   checksum for this structure,Satisfy sum of every 8-bit value of this structure */
+    MV_U16	data_length; 		/* 2 byte, data length, indicates the size of invalid data besides page header */
+    // Dword 2
+    MV_U16	next_page;		/* 2 byte, next page. Bit0: 0:=>Address Increase, 1:=>Address Decrease */
+    MV_U8   major_ver;  /*1 byte, major version of page header.*/
+    MV_U8   minor_ver;  /*1 byte, minor version of page header.*/
+}page_header, *p_page_header;
+
+/* 
+	HBA_Info_Page is saved in Flash/NVRAM, total 256 bytes.
+	The data area is valid only Signature="MRVL".
+	If any member fills with 0xFF, the member is invalid.
+*/
+/*
+    After spec. BIOS_HBA_page_v1.8, the first 3 DWORD shall be replaced by page_header structure.
+*/
+typedef struct _HBA_Info_Page{
+#ifdef SUPPORT_ATHENA
+	page_header header;
+#else
+	// Dword 0
+	MV_U8     	Signature[4];                 	/* 4 bytes, structure signature,should be "MRVL" at first initial */
+
+	// Dword 1
+	MV_U8     	MinorRev;                 		/* 2 bytes, NVRAM data structure version */
+	MV_U8		MajorRev;
+	MV_U16    	Next_Page;					  	/* 2 bytes, For future data structure expansion, 0 is for NULL pointer and current page is the last page. */
+
+	// Dword 2
+	MV_U8     	Major;                   		/* 1 byte,  BIOS major version */
+	MV_U8     	Minor;                  		/* 1 byte,	BIOS minor version */
+	MV_U8     	OEM_Num;                     	/* 1 byte,  OEM number */
+	MV_U8     	Build_Num;                    	/* 1 byte,  Build number */
+#endif
+
+	// Dword 3
+#ifdef SUPPORT_ATHENA
+	MV_U8 		Reserved1;
+#else
+	MV_U8     	Page_Code;					  	/* 1 byte,  eg. 0 for the 1st page  */
+#endif
+	MV_U8     	Max_PHY_Num;				  	/* 1 byte,   maximum PHY number */
+	MV_U8		RAID_Feature;					/* 1 byte,  RAID settings (see RAID_FEATURE_XX)
+															bit 0 - disable RAID 5 (default 1 = disabled)
+												*/
+	MV_U8		Reserved2;
+
+	// Dword 4
+	MV_U32     	HBA_Flag;                     	/* 4 bytes, should be 0x0000,0000 at first initial
+													HBA flag:  refers to HBA_FLAG_XX
+												*/
+	// Dword 5	                                              
+	MV_U32     	Boot_Device;					/* 4 bytes, select boot device */
+												/* for ata device, it is CRC of the serial number + model number. */
+												/* for sas device, it is CRC of sas address */
+												/* for VD, it is VD GUI */
+
+	// Dword 6-8	
+	MV_U8		DSpinUpGroup;				/* spin up group */
+	MV_U8		DSpinUpTimer;				/* spin up timer */
+	MV_U8		Delay_Time;					/* delay time, default value = 5 second */
+       MV_U8           bbu_charge_threshold;
+       MV_U8           bbu_temp_lowerbound;
+       MV_U8           bbu_temp_upperbound;
+       MV_U16          bbu_volt_lowerbound;
+       MV_U16          bbu_volt_upperbound;
+	MV_U8		Reserved3[2];				  	/* 4 bytes, reserved	*/
+
+	// Dword 9-13
+	MV_U8     	Serial_Num[20];				  	/* 20 bytes, controller serial number */
+
+	// Dword 14-29
+#ifdef SUPPORT_ATHENA
+	//SAS_ADDR	SAS_Address[MAX_NUMBER_IO_CHIP*MAX_PORT_PER_PL];               /* 64 bytes, SAS address for each port */
+	MV_U8   		Reserved21[64];				/* sas addr move to the phy info page */
+#else
+	SAS_ADDR	SAS_Address[8];                                     /* 64 bytes, SAS address for each port */
+#endif
+#if defined(_OS_FIRMWARE)
+	//Dword 30-37
+	boot_dev_info_t	device[8];			/* 32 bytes, record boot devices information.*/
+
+	//Dword 38-39
+	FFE_CONTROL  FFE_Control[8];	
+	//Dword 40-43
+	MV_U8     	Reserved4[16];                  /* 24bytes, reserve space for future,initial as 0xFF */   
+#else // defined(_OS_FIRMWARE)
+
+#if defined(SUPPORT_MITAC)  //odin bios&mdu for mitac support
+	//Dword 30
+	MV_U32			Bios_Flag;					/*4 bytes should be 0xffff_ffff at first inital, 0 means enable
+																					bit0	---	MITAC_BIOS
+																					.
+																					.
+																					etc
+																	 */
+	//Dword31-38
+	MV_U16			Port[8];					/*port for group member, 'NA' means no group*/
+	//Dword 39-43
+	MV_U8			Reserved4[36];		/* 52 bytes, reserve space for future,initial as 0xFF */ 
+#else //support_mitac
+
+#ifdef SUPPORT_ATHENA
+	MV_U8 			Reserved31[8]; 		/*ffe_control move to the phy info page */
+#else
+	// Dword 30-31
+	FFE_CONTROL  FFE_Control[8];			/* 8 bytes for vanir 8 port PHY FFE seeting
+										BIT 0~3 : FFE Capacitor select(value range 0~F)
+										BIT 4~6 : FFE Resistor select(value range 0~7)
+										BIT 7: reserve. */
+#endif
+#ifdef VANIR_BIOS
+	//Dword 32 -38
+   	MV_U8		 Reserved4[28];			/* 28 bytes, reserve space for future,initial as 0xFF */
+#else
+	//Dword 32 -33
+	MV_U8		Product_ID[8];			/* 8 bytes for vanir bios to differentiate VA6800m HBA and VA6400m HBA */
+
+	//Dword 34 -38
+	MV_U8		Reserved4[20];			/* 20 bytes, reserve space for future,initial as 0xFF */
+#endif
+
+ 	//Dword 39 -43
+	MV_U8		  model_number[20];		 /* 20 bytes, Florence model name */
+#endif //defined(SUPPORT_MITAC)
+
+#endif //defined(_OS_FIRMWARE)
+
+#ifdef SUPPORT_ATHENA
+	// Dword 44-45
+	MV_U8 Reserved41[8]; /*phy_rate move to the phy info page*/
+	// Dword 46-53
+	MV_U8 Reserved51[32]; /*phy_tuning move to the phy info page */	
+#else
+	// Dword 44-45
+	MV_U8     	PHY_Rate[8];                  	/* 8 bytes,  0:  1.5G, 1: 3.0G, should be 0x01 at first initial */
+
+	// Dword 46-53
+	PHY_TUNING   PHY_Tuning[8];				/* 32 bytes, PHY tuning parameters for each PHY*/
+#endif
+
+	// Dword 54-62
+	MV_U32     	Reserved5[7];                 	/* 9 dword, reserve space for future,initial as 0xFF */
+	MV_U8  		BGA_Rate;
+	MV_U8  		Sync_Rate;
+	MV_U8 		Init_Rate;
+	MV_U8  		Rebuild_Rate;
+	MV_U8  		Migration_Rate;
+	MV_U8  		Copyback_Rate;
+	MV_U8  		MP_Rate;
+	MV_U8     	Reserved7; 
+	// Dword 63
+	MV_U8     	Reserved6[3];                 	/* 3 bytes, reserve space for future,initial as 0xFF */
+	MV_U8     	Check_Sum;                    	/* 1 byte,   checksum for this structure,Satisfy sum of every 8-bit value of this structure */
+}HBA_Info_Page, *pHBA_Info_Page;			/* total 256 bytes */
+
+/*
+    After spec. BIOS_HBA_page_v1.8, the first 3 DWORD shall be replaced by page_header structure.
+*/
+#if defined(_OS_FIRMWARE)
+typedef struct _hba_info_Page{
+	// Dword 0 - 2
+	page_header header;
+
+	// Dword 3
+	MV_U8     	Max_PHY_Num;				  	/* 1 byte,   maximum PHY number */
+	MV_U8		RAID_Feature;					/* 1 byte,  RAID settings (see RAID_FEATURE_XX)
+															bit 0 - disable RAID 5 (default 1 = disabled)
+												*/
+    MV_U8       Reserved1[2];
+
+	// Dword 4
+	MV_U32     	HBA_Flag;                     	/* 4 bytes, should be 0x0000,0000 at first initial
+													HBA flag:  refers to HBA_FLAG_XX
+												*/
+	// Dword 5	                                              
+	MV_U32     	Boot_Device;					/* 4 bytes, select boot device */
+												/* for ata device, it is CRC of the serial number + model number. */
+												/* for sas device, it is CRC of sas address */
+												/* for VD, it is VD GUI */
+
+	// Dword 6
+    MV_U8       DSpinUpGroup;				/* spin up group */
+    MV_U8       DSpinUpTimer;				/* spin up timer */
+    MV_U8       Delay_Time;					/* delay time, default value = 5 second */
+    MV_U8       Reserved2;
+    
+	// Dword 7
+    MV_U16      bbu_volt_lowerbound;
+    MV_U16      bbu_volt_upperbound;
+
+	// Dword 8
+    MV_U8       bbu_charge_threshold;
+    MV_U8       bbu_temp_lowerbound;
+    MV_U8       bbu_temp_upperbound;
+    MV_U8       Reserved3;
+
+	// Dword 9-13
+	MV_U8     	Serial_Num[20];				  	/* 20 bytes, controller serial number */
+
+	// Dword 14-29
+#ifdef SUPPORT_ATHENA
+	SAS_ADDR	SAS_Address[MAX_NUMBER_IO_CHIP*MAX_PORT_PER_PL];               /* 64 bytes, SAS address for each port */
+#else
+	SAS_ADDR	SAS_Address[8];                                     /* 64 bytes, SAS address for each port */
+#endif
+	//Dword 30-37
+	boot_dev_info_t	device[8];			/* 32 bytes, record boot devices information.*/
+
+    //Dword 38   
+	MV_U8  		BGA_Rate;
+	MV_U8  		Sync_Rate;
+	MV_U8 		Init_Rate;
+	MV_U8  		Rebuild_Rate;
+
+    //Dword 39
+	MV_U8  		Migration_Rate;
+	MV_U8  		Copyback_Rate;
+	MV_U8  		MP_Rate;
+	MV_U8     	Reserved4;
+
+    //Dword 40 - 63
+	MV_U8     	Reserved5[96];
+}hba_info_page, *phba_info_page;			/* total 256 bytes */
+#endif
+
+
+#ifdef SUPPORT_ROC
+#define PHY_INFO_PAGE_MAJOR_VER 1
+#define PHY_INFO_PAGE_MINOR_VER 0
+#endif
+
+#ifdef SUPPORT_ATHENA
+typedef struct _Phy_Info_Page{
+	//Dword 0-2
+	page_header header;  /* refer to  HBA information page header */
+
+	//Dword 3-34
+	SAS_ADDR SAS_Address[16]; /*128bytes, SAS address for each port */
+	
+	//Dword 35-50
+	MV_U8		Reserved1[64];
+
+	// Dword 51-54
+	MV_U8    		PHY_Rate[16];	/* 16 bytes, support phy rate 0: 1.5G, 1: 1.5G and 3.0G,  2: 1.5G, 3.0G and 6.0G*/
+	// Dword 55-58
+	FFE_CONTROL  FFE_Control[16];		/* 16 bytes for 16 PHY FFE seeting
+							BIT 0~3 : FFE Capacitor select(value range 0~F)
+							BIT 4~6 : FFE Resistor select(value range 0~7)
+							BIT 7: reserve. */ 
+
+	// Dword 59-74
+	PHY_TUNING   PHY_Tuning[16];	/* 64 bytes, PHY tuning parameters for each PHY*/
+
+	//Dword 75-126
+	MV_U8		Reserved2[208];
+
+	//Dword 127
+	MV_U8		Reserved3[3];
+	MV_U8		check_sum; /* checksum of data part of phy info structure (exclude header) */
+}Phy_Info_Page, *pPhy_Info_Page;
+#else
+typedef struct _phy_info_page{
+    // DWORD 0 - 2
+    page_header header; /* refer to 3.1 HBA information page header */
+
+    // DWORD 3
+    MV_U8 reserved_1[4];
+    
+    // DWORD 4 - 11
+    PHY_TUNING  phy_tuning_1[8];    //PHY tuning parameters for each PHY for gen 1.
+    // DWORD 12 - 19
+    MV_U32      reserved_2[8];      //Reserved for another 8 port in the future.
+    // DWORD 20 - 27
+    PHY_TUNING  phy_tuning_2[8];    //PHY tuning parameters for each PHY for gen 2.
+    // DWORD 28 - 35
+    MV_U32      reserved_3[8];      //Reserved for another 8 port in the future.
+    // DWORD 36 - 43
+    PHY_TUNING  phy_tuning_3[8];    //PHY tuning parameters for each PHY for gen 3.
+    // DWORD 44 - 51
+    MV_U32      reserved_4[8];      //Reserved for another 8 port in the future.
+
+    //DWORD 52 - 53
+	FFE_CONTROL  FFE_Control[8];
+    //DWORD 54 - 55
+    MV_U8       reserved_5[8];      //Reserved for another 8 port in the future.
+    // DWORD 56 - 57
+	MV_U8     	PHY_Rate[8];        //0:  1.5G, 1: 3.0G, 2: 6.0G
+    // DWORD 58 - 59
+    MV_U8       reserved_6[8];      //Reserved for another 8 port in the future.
+    // DWORD 60 - 63
+    MV_U8       reserved_7[16];
+} phy_info_page, *pphy_info_page;
+#endif
+
+#define FLASH_PARAM_SIZE 	(sizeof(HBA_Info_Page))
+#define HBA_INFO_PAGE_SIZE 	(sizeof(hba_info_page))
+#define PHY_INFO_PAGE_SIZE 	(sizeof(phy_info_page))
+#define NEXT_PAGE_OFFSET    0x2000                  //8KB
+#ifdef SUPPORT_ATHENA
+#define ATHENA_FLASH_SIZE	0x100000L					//1024K bytes
+#define PARAM_OFFSET		ATHENA_FLASH_SIZE - 0x100	//255k bytes
+#else
+#define ODIN_FLASH_SIZE		0x40000  				//.256k bytes
+#define PARAM_OFFSET		ODIN_FLASH_SIZE - 0x100 //.255k bytes
+#endif
+#ifdef SCSI_ID_MAP
+#define FLASH_TABLE_SIZE     (MV_MAX_TARGET_NUMBER * 8 * sizeof(MV_U64))
+#define PD_INFO_PAGE_OFFSET  (FLASH_PARAM_SIZE + 0x100)
+#endif
+#if defined(_OS_FIRMWARE)
+#if defined(ADDING_FLASH_LAYOUT_DESC)
+#include "com_flash.h"
+#define HBA_INFO_PRIMARY_OFFSET           return_image_place_on_flash(FLASH_IMAGE_HBAINFO, 0, FLASH_IMAGE_RETURN_ADDRESS)
+#define HBA_INFO_SECONDARY_OFFSET	return_image_place_on_flash(FLASH_IMAGE_HBAINFO, 1, FLASH_IMAGE_RETURN_ADDRESS)
+#define HBA_INFO_OFFSET				HBA_INFO_PRIMARY_OFFSET
+
+#define FLASH_PDINFOPAGE_SIZE			return_image_place_on_flash(FLASH_IMAGE_PDINFOPAGE, 0, FLASH_IMAGE_RETURN_SIZE)
+#define FLASH_PDINFOPAGE_OFFSET		0x00020000
+#define FLASH_PDINFOPAGE_ADDR			return_image_place_on_flash(FLASH_IMAGE_PDINFOPAGE, 0, FLASH_IMAGE_RETURN_ADDRESS)
+
+#if defined(SAVE_EVENTS_TO_FLASH)
+#define EVENT_LOG_HEADER_OFFSET		return_image_place_on_flash(FLASH_IMAGE_EVENTLOG, 0, FLASH_IMAGE_RETURN_ADDRESS)
+#define EVENT_LOG_ENTRY_OFFSET(slot)	(event_log_header_offset + sizeof(struct flash_event_log_head) + (sizeof(struct flash_event_log_entry) * slot))
+#endif	
+#define MAX_HBA_INFO_PAGE_SIZE      0x10000
+#else
+#	if defined(SUPPORT_BALDUR)
+#define HBA_INFO_PRIMARY_OFFSET		0x3F0000	/*Refer to Flash Layout*/
+#define HBA_INFO_SECONDARY_OFFSET	(HBA_INFO_PRIMARY_OFFSET + 0x2000)
+#define HBA_INFO_OFFSET				HBA_INFO_PRIMARY_OFFSET
+#define FLASH_PDINFOPAGE_SIZE			0x00020000
+#define FLASH_PDINFOPAGE_OFFSET		0x00020000
+#define FLASH_PDINFOPAGE_ADDR			0x00060000
+#		if defined(SAVE_EVENTS_TO_FLASH)
+#define EVENT_LOG_HEADER_OFFSET		0x00080000
+#define EVENT_LOG_ENTRY_OFFSET(slot)	(EVENT_LOG_HEADER_OFFSET + sizeof(struct flash_event_log_head) + (sizeof(struct flash_event_log_entry) * slot))
+#		endif
+#	else
+#define HBA_INFO_PRIMARY_OFFSET		0x00040000	/*Refer to Flash Layout*/
+#define HBA_INFO_SECONDARY_OFFSET	0x000e0000
+#define HBA_INFO_OFFSET				HBA_INFO_PRIMARY_OFFSET
+#define FLASH_PDINFOPAGE_SIZE			0x00020000
+#define FLASH_PDINFOPAGE_OFFSET		0x00020000
+#define FLASH_PDINFOPAGE_ADDR			0x00060000
+#		if defined(SAVE_EVENTS_TO_FLASH)
+#define EVENT_LOG_HEADER_OFFSET		0x00080000
+#define EVENT_LOG_ENTRY_OFFSET(slot)	(EVENT_LOG_HEADER_OFFSET + sizeof(struct flash_event_log_head) + (sizeof(struct flash_event_log_entry) * slot))
+#		endif	
+#	endif
+#endif
+#endif
+
+// PD infomation Page
+#define FLASH_PD_INFO_PAGE_SIZE 	(sizeof(pd_info_page))
+#define PAGE_INTERVAL_DISTANCE		0x100
+
+#define PD_PAGE_PD_ID_INAVAILABLE 	0
+#define PD_PAGE_PD_ID_AVAILABLE 	1
+
+#define IS_PD_PAGE_PD_ID_AVAILABLE(flag) ((flag)==PD_PAGE_PD_ID_AVAILABLE)
+
+#define PAGE_CODE_HBA_INFO	0
+#define PAGE_CODE_PD_INFO	1
+#define PAGE_CODE_AES_INFO	2
+#define PAGE_CODE_EVT_INFO	3
+#define PAGE_CODE_CRYPTO_PD     4
+#ifdef SUPPORT_ATHENA
+#define PAGE_CODE_PHY_INFO			0x05
+#define PAGE_CODE_NULL_PAGE			0xFF
+#define PAGE_CODE_TAIL_PAGE			PAGE_CODE_NULL_PAGE
+#define SEARCH_ADDR_DECREASE		MV_TRUE
+#else
+#define PAGE_CODE_PHY_TUNING    5
+#endif
+#define PAGE_CODE_OEM_CFG         6
+
+
+#define PD_PAGE_PD_STATE_OFFLINE 0
+#define PD_PAGE_PD_STATE_ONLINE 1
+
+#ifdef MULTI_PD_PAGE_SUPPORT
+#define MAX_NUM_PD_PAGE	2
+#else
+#define MAX_NUM_PD_PAGE	1
+#endif
+
+#ifdef MULTI_PD_PAGE_SUPPORT
+#ifdef SUPPORT_ROC
+#define MULTI_PD_PAGE_BUFFER_SIZE  (MAX_NUM_PD_PAGE*(FLASH_PD_INFO_PAGE_SIZE+PAGE_INTERVAL_DISTANCE))// 
+#endif
+#define PAGE_BUFFER_SIZE  (MAX_NUM_PD_PAGE*(FLASH_PD_INFO_PAGE_SIZE+PAGE_INTERVAL_DISTANCE)+FLASH_PARAM_SIZE)
+#else
+#define PAGE_BUFFER_SIZE  (FLASH_PD_INFO_PAGE_SIZE+PAGE_INTERVAL_DISTANCE+FLASH_PARAM_SIZE)// total 0x1240 bytes(128 PDs); 0x2240 bytes(256 PDs)
+#endif
+
+/* This number may not equal to MAX_DEVICE_SUPPORTED_PERFORMANCE */
+#define MAX_PD_IN_PD_PAGE_FLASH	128 // currently every PD page support 128 PD entry
+#define MAX_PD_IN_TOTAL_PD_PAGE		(MAX_PD_IN_PD_PAGE_FLASH * MAX_NUM_PD_PAGE)
+/* 
+	PD_Info_Page is saved in Flash/NVRAM, currently total size is 0x1040 bytes.
+	The data area is valid only Signature="MRVL".
+	If any member fills with 0xFF, the member is invalid.
+*/
+
+typedef struct _Device_Index {
+	MV_U16	index;
+	MV_U16	device_id;
+	MV_BOOLEAN end;
+}Device_Index,*PDevice_Index;
+
+typedef void(*get_device_id) (MV_PVOID, MV_U16,PDevice_Index);
+
+typedef struct _pd_status_info {
+	MV_U16	pd_id;
+	MV_U8	status;
+	MV_U8	reserved;
+}pd_status_info,*p_pd_status_info;
+
+struct _pd_info {
+	// Dword 0-1
+	MV_U64	pd_guid;
+
+	// Dword 2
+	MV_U16	pd_id;
+	MV_U16	pd_scsi_id;
+
+	// Dword 3
+	MV_U8	status;
+	MV_U8	type;
+	MV_U8	cache_policy;
+	MV_U8	reserved1;
+	
+	// Dword 4-7
+	MV_U8	reserved2[16];
+};
+
+
+struct _pd_info_page{
+
+	page_header header;
+
+	MV_U8	reserved2[52];		/* 52 byte,   reserve space for future,initial as 0xFF */
+
+	struct _pd_info pd_info_data[MAX_PD_IN_PD_PAGE_FLASH]; /* MAX_PD_IN_PD_PAGE_FLASH*32 bytes, could save 128 PD data in flash */
+};
+
+typedef struct _pci_auto_load_config
+{
+    MV_U8        signature[4];
+    MV_U32      data[1];
+} pci_auto_load_config;
+
+typedef struct _pd_info pd_info, *p_pd_info;
+typedef struct _pd_info_page pd_info_page, *p_pd_info_page;
+
+#if defined(ENABLE_PHYTUNING)
+#define PHY_INFO_PAGE_MAJOR_VER 1
+#define PHY_INFO_PAGE_MINOR_VER 1
+
+typedef struct _phy_info_page_st{
+    // DWORD 0 - 2
+    page_header    header; /* refer to 3.1 HBA information page header */
+    // DWORD 3
+    MV_U8 major_ver;	/* major version of this page.*/
+    MV_U8 minor_ver;	/* minor version of this page.*/
+    MV_U8 reserved_1[2];
+    // DWORD 4 - 11
+    MV_U32          phy_tuning_1[8];   //PHY tuning parameters for each PHY for gen 1.
+    // DWORD 12 - 19
+    MV_U32          phy_tuning_2[8];   //PHY tuning parameters for each PHY for gen 2.
+    // DWORD 20 - 27
+    MV_U32          phy_tuning_3[8];   //PHY tuning parameters for each PHY for gen 3.
+    // DWORD 28 - 63
+    MV_U8	        reserved_2[143];
+    MV_U8           page_checksum;  /* checksum of data part of phy info structure (exclude header)*/
+}phy_info_page_t;
+
+//typedef _phy_info_page_st phy_info_page_t,*p_phy_info_page_t;
+#endif
+
+#if defined(ENABLE_RAID_OEM_CFG_PAGE_INFO)
+#define MODIFYING_RAID_OEM_CONFIG_PAGE_MAJOR_VER 1
+#define MODIFYING_RAID_OEM_CONFIG_PAGE_MINOR_VER 2
+
+typedef struct _raid_oem_config_page_st{
+    // DWORD 0 - 2
+    page_header    header;
+    // DWORD 3 - 12
+    MV_U8             vd_name[40];
+    // DWORD 13
+    MV_U32           feature_set_low;
+    // DWORD 14
+    MV_U32           feature_set_high;
+    // DWORD 15 - 63
+    MV_U32           reserved_u32[49];
+} raid_oem_config_page_t;
+
+typedef struct _raid_oem_config_cell_st{
+    MV_U16           size;
+    MV_U16           type;
+} raid_oem_config_cell_t;
+
+#define ENABLE_OEM_FEATURE(x, bit) ((bit >= 32) ? ((x)->feature_set_high |= (1L << (bit - 32))) : ((x)->feature_set_low |= (1L << bit)))
+#define DISABLE_OEM_FEATURE(x, bit) ((bit >= 32) ? ((x)->feature_set_high &= ~(1L << (bit - 32))) : ((x)->feature_set_low &= ~(1L << bit)))
+#define CHECK_OEM_FEATURE(x, bit) ((bit >= 32) ? ((x)->feature_set_high & (1L << (bit - 32))) : ((x)->feature_set_low & (1L << bit)))
+
+#define GET_OEM_CFG_CELL_SIZE(x) (x->size)
+#define GET_OEM_CFG_CELL_TYPE(x) (x->type)
+#define GET_OEM_CFG_CELL_HEADER(x) ((u8 *)x - x->size)
+
+#define OEM_CFG_MODIFIED_VDNAME_DISABLE                          0
+#define OEM_CFG_PNP_AUTO_REBUILD_DISABLE                         1
+#define OEM_CFG_UPGRADED_FW_DISABLE                                 2
+#define OEM_CFG_RAID_CONFIG_DISABLE                                   3
+#define OEM_CFG_BUZZER_DISABLE                                             4
+#define OEM_CFG_BIOS_POST_SHOWING_TIME_DISABLE            5
+#define OEM_CFG_BIOS_SCANING_DIRECTION                             6
+#define OEM_CFG_BIOS_INITIALING_STRING                               7
+#define OEM_CFG_AES_OS_BOOTING                                            8
+#define OEM_CFG_SMART_CHECK                                                  9
+#define OEM_CFG_HALT_ON_ERROR                                              10
+#define OEM_CFG_RAID0_MIGRATE_RAID1                                   11
+#define OEM_CFG_FRONTEND_PORT_SETTING                              12
+#endif
+
+#if defined(ADDING_FLASH_LAYOUT_DESC)
+MV_VOID initial_flash_layout(void);
+#endif
+
+#if defined(SAVE_EVENTS_TO_FLASH)
+#include "com_event_struct.h"
+#if defined(SUPPORT_NVRAM)
+MV_PVOID finding_hander_from_nvram(MV_PU8 signature);
+MV_PVOID gotting_free_space_from_nvram(void);
+MV_BOOLEAN wipe_out_header_in_nvram(MV_PU8 signature);
+#endif /*SUPPORT_NVRAM*/
+void initial_flash_eventlog(MV_PVOID This);
+MV_U16 check_remaining_events_in_flash(MV_PVOID This);
+
+MV_BOOLEAN add_event_to_flash( 
+	MV_PVOID This,
+#if defined(ROC_V2_EVENT_SUPPORT)
+	PDriverEvent_V2 ptr_driver_event
+#else
+	PDriverEvent ptr_driver_event
+#endif
+    );
+#endif /*SAVE_EVENTS_TO_FLASH*/
+ 
+extern MV_BOOLEAN mv_page_signature_check( MV_PU8 Signature );
+
+//extern MV_U8 mvui_init_param(MV_PVOID This, pHBA_Info_Page pHBAInfo);//get initial data from flash
+//extern MV_BOOLEAN mvuiHBA_init_param( MV_PVOID This, pHBA_Info_Page pHBA_Info_Param);
+#ifdef SUPPORT_ROC
+MV_BOOLEAN mv_nvram_init_param(MV_PVOID This, phba_info_page pHBA_Info_Param);
+MV_VOID fill_default_hba_info(MV_PVOID this, phba_info_page pHBA_Info_Param);
+extern MV_BOOLEAN mvuiHBA_modify_param( MV_PVOID This, phba_info_page pHBA_Info_Param);
+#else
+#ifdef SUPPORT_ATHENA
+MV_BOOLEAN mv_nvram_init_phy_param(MV_PVOID This, pPhy_Info_Page pPhy_Info_Param);
+#endif
+MV_BOOLEAN mv_nvram_init_param(MV_PVOID This, pHBA_Info_Page pHBA_Info_Param);
+extern MV_BOOLEAN mvuiHBA_modify_param( MV_PVOID This, pHBA_Info_Page pHBA_Info_Param);
+#endif
+MV_BOOLEAN mv_nvram_moddesc_init_param( MV_PVOID This, pHBA_Info_Page pHBA_Info_Param);
+
+MV_BOOLEAN mv_read_hba_info( MV_PVOID This, char *pBuffer, MV_U16 buf_len, int *offset);
+MV_BOOLEAN mv_read_autoload_data( MV_PVOID This, char *pBuffer, MV_U16 buf_len, int *offset);
+/* Caution: Calling this function, please do Read-Modify-Write. 
+ * Please call to get the original data first, then modify corresponding field,
+ * Then you can call this function. */
+extern MV_U8	mvCalculateChecksum(MV_PU8	Address, MV_U32 Size);
+extern MV_U8	mvVerifyChecksum(MV_PU8	Address, MV_U32 Size);
+#endif		/* COM_NVRAM_H */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_passthrough_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_passthrough_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_passthrough_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_passthrough_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,47 @@
+#ifndef __MV_COM_PASS_THROUGH_H__
+#define __MV_COM_PASS_THROUGH_H__
+#include "com_define.h"
+#define PASSTHROUGH_ECC_WRITE	1
+#define PASSTHROUGH_ECC_SIZE	2
+
+#define SECTOR_LENGTH                           512
+#define SECTOR_WRITE                            0
+#define SECTOR_READ                             1
+
+#define MAX_PASS_THRU_DATA_BUFFER_SIZE (SECTOR_LENGTH+128)
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct {
+ // We put Data_Buffer[] at the very beginning of this structure because SCSI commander did so.
+ MV_U8    Data_Buffer[MAX_PASS_THRU_DATA_BUFFER_SIZE];  // set by driver if read, by application if write
+ MV_U8    Reserved1[128];
+ MV_U32   Data_Length; // set by driver if read, by application if write 
+ MV_U16   DevId;       // PD ID (used by application only)
+ MV_U8    CDB_Type;    // define a CDB type for each CDB category (used by application only)
+ MV_U8    Reserved2;
+ MV_U32   lba;
+ MV_U8    Reserved3[64];
+} PassThrough_Config, * PPassThorugh_Config;
+
+typedef struct {
+ // The data structure is used in conjunction with APICDB0_PASS_THRU_CMD_SCSI_16 (see com_api.h)
+ // when CDB[16] is required.
+ MV_U8    CDB[16];	// CDB is embedded in data buffer
+ MV_U32    buf[1];	// actually input/output data buffer
+} PassThrough_Config_16, * PPassThorugh_Config_16;
+
+typedef struct _Pass_Through_Cmd
+{
+	MV_U8 	cdb[16];
+	MV_U16 	data_length;
+	MV_U8	Reserved[2];	// pad 2 bytes for DWORD alignment.
+	MV_U8 	data[1];
+}Pass_Through_Cmd,*PPass_Through_Cmd;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_pd_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_pd_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_pd_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_pd_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,315 @@
+#ifndef __MV_COM_PD_STRUCT_H__
+#define __MV_COM_PD_STRUCT_H__
+
+#include "com_physical_link.h"
+
+//PD
+#ifndef _OS_BIOS
+#define MAX_HD_SUPPORTED_API                    128
+#define MAX_BLOCK_PER_HD_SUPPORTED_API          16
+#endif
+
+// Macros used for error injection. 
+// Error status that should be returned upon encountering the specified LBA
+#define REQ_STATUS_MEDIA_ERROR                  0x2
+#define REQ_STATUS_HAS_SENSE                    0x7
+#define REQ_STATUS_ERROR                        0x8
+
+#define PD_INIT_STATUS_OK						0
+#define PD_INIT_STATUS_ERROR					MV_BIT(0) // for HD_Info InitStatus, set if there was ever a failure during init
+
+// Definition used for old driver.
+#define HD_TYPE_SATA                            MV_BIT(0)
+#define HD_TYPE_PATA                            MV_BIT(1)
+#define HD_TYPE_SAS                             MV_BIT(2)
+#define HD_TYPE_ATAPI                           MV_BIT(3)
+#define HD_TYPE_TAPE                            MV_BIT(4)
+#define HD_TYPE_SES                             MV_BIT(5)
+
+// Definition used for PD interface type as defined in DDF spec
+#define PD_INTERFACE_TYPE_UNKNOWN               0x0000
+#define PD_INTERFACE_TYPE_SCSI                  0x1000
+#define PD_INTERFACE_TYPE_SAS                   0x2000
+#define PD_INTERFACE_TYPE_SATA                  0x3000
+#define PD_INTERFACE_TYPE_FC                    0x4000
+
+// PD's Protocol/Connection type (used by new driver)
+#define DC_ATA                                  MV_BIT(0)
+#define DC_SCSI                                 MV_BIT(1)
+#define DC_SERIAL                               MV_BIT(2)
+#define DC_PARALLEL                             MV_BIT(3)
+#define DC_ATAPI                                MV_BIT(4)  // used by core driver to prepare FIS
+#define DC_SGPIO                                MV_BIT(5)
+
+// PD's Device type defined in SCSI-III specification (used by new driver)
+#define DT_DIRECT_ACCESS_BLOCK                  0x00
+#define DT_SEQ_ACCESS                           0x01
+#define DT_PRINTER                              0x02
+#define DT_PROCESSOR                            0x03
+#define DT_WRITE_ONCE                           0x04
+#define DT_CD_DVD                               0x05
+#define DT_OPTICAL_MEMORY                       0x07
+#define DT_MEDIA_CHANGER                        0x08
+#define DT_STORAGE_ARRAY_CTRL                   0x0C
+#define DT_ENCLOSURE                            0x0D
+// The following are defined by Marvell
+#define DT_EXPANDER                             0x20
+#define DT_PM                                   0x21
+
+#define HD_FEATURE_NCQ                          MV_BIT(0)
+#define HD_FEATURE_TCQ                          MV_BIT(1)
+#define HD_FEATURE_1_5G                         MV_BIT(2)
+#define HD_FEATURE_3G                           MV_BIT(3)
+#define HD_FEATURE_WRITE_CACHE                  MV_BIT(4)
+#define HD_FEATURE_48BITS                       MV_BIT(5)
+#define HD_FEATURE_SMART                        MV_BIT(6)
+#define HD_FEATURE_6G                           MV_BIT(7)
+#define HD_FEATURE_CRYPTO                       MV_BIT(8)
+#define HD_FEATURE_TRIM                       MV_BIT(9)
+#define HD_FEATURE_12G                        MV_BIT(10)
+#ifdef MAGNI_BIOS
+#define HD_FEATURE_PATA_MASTER		MV_BIT(31)
+#endif
+
+#define HD_SPEED_1_5G                           1  
+#define HD_SPEED_3G                             2
+#define HD_SPEED_6G                             3
+#define HD_SPEED_12G                            4
+
+#define HD_AES_CRYPTO_DISK                      MV_BIT(0)
+#define HD_AES_KEY_MATCHED                      MV_BIT(1)
+
+#define HD_WIPE_MDD                             0
+#define HD_WIPE_FORCE                           1
+
+#define HD_DMA_NONE                             0
+#define HD_DMA_1                                1
+#define HD_DMA_2                                2
+#define HD_DMA_3                                3
+#define HD_DMA_4                                4
+#define HD_DMA_5                                5
+#define HD_DMA_6                                6
+#define HD_DMA_7                                7
+#define HD_DMA_8                                8
+#define HD_DMA_9                                9
+
+#define HD_PIO_NONE                             0
+#define HD_PIO_1                                1
+#define HD_PIO_2                                2
+#define HD_PIO_3                                3
+#define HD_PIO_4                                4
+#define HD_PIO_5                                5
+
+#define HD_XCQ_OFF                              0
+#define HD_NCQ_ON                               1
+#define HD_TCQ_ON                               2
+
+#define HD_SSD_TYPE_NOT_SSD                     0
+#define HD_SSD_TYPE_UNKNOWN_SSD                 1
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _HD_Info
+{
+ Link_Entity     Link;             /* Including self DevID & DevType */
+ MV_U8           AdapterID;
+ MV_U8           InitStatus;       /* Refer to PD_INIT_STATUS_XXX */
+ MV_U8           HDType;           /* HD_Type_xxx, replaced by new driver with ConnectionType & DeviceType */
+ MV_U8           PIOMode;          /* Max PIO mode */
+ MV_U8           MDMAMode;         /* Max MDMA mode */
+ MV_U8           UDMAMode;         /* Max UDMA mode */
+ MV_U8           ConnectionType;   /* DC_XXX, ConnectionType & DeviceType in new driver to replace HDType above */
+ MV_U8           DeviceType;       /* DT_XXX */
+
+ MV_U32          FeatureSupport;   /* Support 1.5G, 3G, TCQ, NCQ, and etc, MV_BIT related */
+ MV_U8           Model[40];
+ MV_U8           SerialNo[20];
+ MV_U8           FWVersion[8];
+ MV_U64          Size;             /* In unit of BlockSize between API and driver */
+ MV_U8           WWN[8];           /* ATA/ATAPI-8 has such definitions for the identify buffer */
+ MV_U8           CurrentPIOMode;   /* Current PIO mode */
+ MV_U8           CurrentMDMAMode;  /* Current MDMA mode */
+ MV_U8           CurrentUDMAMode;  /* Current UDMA mode */
+ MV_U8           ElementIdx;       /* corresponding element index in enclosure */
+ MV_U32          BlockSize;        /* Bytes in one sector/block, if 0, set it to be 512 */
+
+ MV_U8           ActivityLEDStatus;
+ MV_U8           LocateLEDStatus;
+ MV_U8           ErrorLEDStatus;
+ MV_U8           SesDeviceType;	   /* ENC_ELEMENTTYPE_DEVICE or ENC_ELEMENTTYPE_ARRAYDEVICE */
+#ifndef _OS_BIOS
+ MV_U32		 sata_signature;
+ MV_U8           Reserved4[8];
+ MV_U8			 HD_SSD_Type;
+ MV_U8			 Reserved1[63];
+#else
+MV_U8			ID;
+MV_U8			DeviceID;	/* only used show in BIOS setup */
+MV_U16			PortID;		//Point to Port, PM or Expander ID
+MV_U8 			SAS_Address[8];
+#ifdef SUPPORT_FLORENCE
+MV_U8			HD_SSD_Type;
+MV_U8			HD_SSD_Operation_Mode;
+MV_U8			Reserve1[2];
+#endif
+//
+#ifdef SUPPORT_MUL_LUN
+MV_U8    multi_lun;
+MV_U16    lun_id;
+#endif
+
+#endif
+}HD_Info, *PHD_Info;
+
+typedef struct _HD_MBR_Info
+{
+ MV_U8           HDCount;
+ MV_U8           Reserved[7];
+ MV_U16          HDIDs[MAX_HD_SUPPORTED_API];    
+ MV_BOOLEAN      hasMBR[MAX_HD_SUPPORTED_API];
+} HD_MBR_Info, *PHD_MBR_Info;
+
+
+typedef struct _HD_FreeSpaceInfo
+{
+ MV_U16          ID;               /* ID should be unique*/
+ MV_U8           AdapterID;
+ MV_U8           reserved1;
+ MV_U16          BlockSize;        /* Bytes in one sector/block, if 0, set it to be 512 */
+ MV_U8           reserved2;
+ MV_BOOLEAN      isFixed;
+
+ MV_U64          Size;             /* In unit of BlockSize between API and driver */
+}HD_FreeSpaceInfo, *PHD_FreeSpaceInfo;
+
+typedef struct _HD_Block_Info
+{
+ MV_U16          ID;               /* ID in the HD_Info*/
+ MV_U8           Type;             /* Refer to DEVICE_TYPE_xxx */
+ MV_U8           BlkCount;         /* The valid entry count of BlockIDs */
+                                   /* This field is added for supporting large block count */
+                                   /* If BlkCount==0, "0x00FF" means invalid entry of BlockIDs */
+ MV_U8           Reserved1[4];
+
+ /* Free is 0xff */
+ MV_U16          BlockIDs[MAX_BLOCK_PER_HD_SUPPORTED_API];  
+}HD_Block_Info, *PHD_Block_Info;
+
+
+typedef struct _HD_CONFIG
+{
+ MV_BOOLEAN        WriteCacheOn; // 1: enable write cache 
+ MV_BOOLEAN        SMARTOn;      // 1: enable S.M.A.R.T
+ MV_BOOLEAN        Online;       // 1: to set HD online
+ MV_U8             DriveSpeed;   // For SATA & SAS.  HD_SPEED_1_5G, HD_SPEED_3G etc
+ MV_U8             crypto;
+ MV_U8             AESPercentage;
+ MV_U16            HDID;   
+}HD_Config, *PHD_Config;
+
+typedef struct  _HD_SMART_STATUS
+{
+ MV_BOOLEAN        SmartThresholdExceeded;        
+ MV_U8             Reserved1;
+ MV_U16            HDID;
+ MV_U8             Reserved2[4];
+}HD_SMART_Status, *PHD_SMART_Status;
+
+typedef struct _HD_BGA_STATUS
+{
+ MV_U16            HDID;
+ MV_U16            Percentage;      /* xx% */
+ MV_U8             Bga;             /* Refer to HD_BGA_TYPE_xxx */
+ MV_U8             Status;          /* not used */
+ MV_U8             BgaStatus;       /* Refer to HD_BGA_STATE_xxx */
+ MV_U8             Reserved[57];  
+}HD_BGA_Status, *PHD_BGA_Status;
+
+/* 
+ * RCT entry flag 
+ */
+/* request type related */
+#define EH_READ_VERIFY_REQ_ERROR                MV_BIT(0) /* Read or Read Verify request is failed. */
+#define EH_WRITE_REQ_ERROR                      MV_BIT(1) /* Write request is failed */
+/* error type related */
+#define EH_MEDIA_ERROR                          MV_BIT(3) /* Media Error or timeout */
+#define EH_LOGICAL_ERROR                        MV_BIT(4) /* Logical Error because of BGA activity. */
+/* other flag */
+#define EH_FIX_FAILURE                          MV_BIT(5) /* Ever tried to fix this error but failed */
+/* extra flag */
+#define EH_TEMPORARY_ERROR                      MV_BIT(7) /* Temporary error. Used when BGA rebuild write mark target disk up. */
+
+
+typedef struct _RCT_Record{
+ MV_LBA  lba;
+ MV_U32  sec;                       //sector count
+ MV_U8   flag;
+ MV_U8   rev[3];
+}RCT_Record, *PRCT_Record;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+//PM
+#ifndef _OS_BIOS
+#define MAX_PM_SUPPORTED_API                    8
+#endif
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef  struct _PM_Info{
+ Link_Entity       Link;           /* Including self DevID & DevType */
+ MV_U8             AdapterID;
+ MV_U8             ProductRevision;
+ MV_U8             PMSpecRevision; /* 10 means 1.0, 11 means 1.1 */
+ MV_U8             NumberOfPorts;
+ MV_U16            VendorId;
+ MV_U16            DeviceId;
+ MV_U8             Reserved1[8];
+}PM_Info, *PPM_Info;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+
+#ifndef _OS_BIOS
+#define MAX_EXPANDER_SUPPORTED_API              16
+#endif
+
+#define EXP_SSP                                 MV_BIT(0)
+#define EXP_STP                                 MV_BIT(1)
+#define EXP_SMP                                 MV_BIT(2)
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _Exp_Info
+{
+ Link_Entity       Link;            /* Including self DevID & DevType */
+ MV_U8             AdapterID;
+ MV_BOOLEAN        Configuring;      
+ MV_BOOLEAN        RouteTableConfigurable;
+ MV_U8             PhyCount;
+ MV_U16            ExpChangeCount;
+ MV_U16            MaxRouteIndexes;
+ MV_U8             VendorID[8+1];
+ MV_U8             ProductID[16+1];
+ MV_U8             ProductRev[4+1];
+ MV_U8             ComponentVendorID[8+1];
+ MV_U16            ComponentID;
+ MV_U8             ComponentRevisionID;
+ MV_U8             Reserved1[17];
+}Exp_Info, * PExp_Info;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_physical_link.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_physical_link.h
--- linux-3.10.69/drivers/scsi/mv/include/com_physical_link.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_physical_link.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,51 @@
+#ifndef __MV_COM_PHYSICAL_LINK_H__
+#define __MV_COM_PHYSICAL_LINK_H__
+
+#include "com_define.h"
+
+//Physical Link
+#define DEVICE_TYPE_NONE                        0
+#define DEVICE_TYPE_HD                          1       //  DT_DIRECT_ACCESS_BLOCK
+#define DEVICE_TYPE_PM                          2
+#define DEVICE_TYPE_EXPANDER                    3		// DT_EXPANDER
+#ifndef _OS_BIOS
+#define DEVICE_TYPE_TAPE						4		// DT_SEQ_ACCESS
+#endif
+#define DEVICE_TYPE_PRINTER						5		// DT_PRINTER
+#define DEVICE_TYPE_PROCESSOR					6		// DT_PROCESSOR
+#define DEVICE_TYPE_WRITE_ONCE					7 		// DT_WRITE_ONCE
+#define DEVICE_TYPE_CD_DVD						8		// DT_CD_DVD
+#define DEVICE_TYPE_OPTICAL_MEMORY				9 		// DT_OPTICAL_MEMORY
+#define DEVICE_TYPE_MEDIA_CHANGER				10		// DT_MEDIA_CHANGER
+#define DEVICE_TYPE_ENCLOSURE					11		// DT_ENCLOSURE
+#define DEVICE_TYPE_I2C_ENCLOSURE				12		
+#define DEVICE_TYPE_PORT                        0xFF	// DT_STORAGE_ARRAY_CTRL
+
+#define MAX_WIDEPORT_PHYS                       8
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+typedef struct _Link_Endpoint 
+{
+ MV_U16      DevID;
+ MV_U8       DevType;         /* Refer to DEVICE_TYPE_xxx */
+ MV_U8       PhyCnt;          /* Number of PHYs for this endpoint. Greater than 1 if it is wide port. */
+ MV_U8       PhyID[MAX_WIDEPORT_PHYS];    /* Assuming wide port has max of 8 PHYs. */
+ MV_U8       SAS_Address[8];  /* Filled with 0 if not SAS device. */
+ MV_U16      EnclosureID;     // enclosure ID of this device if available, otherwise 0xFFFF
+ MV_U8       Reserved[6];
+} Link_Endpoint, * PLink_Endpoint;
+
+typedef struct _Link_Entity 
+{
+ Link_Endpoint    Parent;
+ MV_U8            Reserved[8];
+ Link_Endpoint    Self;
+} Link_Entity,  *PLink_Entity;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_phy_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_phy_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_phy_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_phy_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,49 @@
+#ifndef __MV_COM_PHY_STRUCT_H__
+#define __MV_COM_PHY_STRUCT_H__
+
+#include "com_define.h"
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _NEW_PHY_TUNING {
+         MV_U8    Trans_Emphasis_En:1;                    /* 1 bit,  transmitter emphasis enable  */
+         MV_U8    Reserved_bit_1:3;                       /* 3 bits, reserved space */
+         MV_U8    Trans_Emphasis_Amp:4;                   /* 4 bits, transmitter emphasis amplitude */
+
+         MV_U8    Trans_Amp:5;                            /* 5 bits, transmitter amplitude */
+         MV_U8    Reserved_bit_2:3;                       /* 3 bits, reserved space */
+
+         MV_U8    Trans_Amp_Adjust:2;                     /* 2 bits, transmitter amplitude adjust */
+         MV_U8    Reserved_bit_3:6;                       /* 6 bit,    reserved space */
+         
+         MV_U8    Reserved;                               /* 1 bytes, reserved space */
+} NEW_PHY_TUNING, *PNEW_PHY_TUNING;
+
+typedef struct _PHY_TUNING_CONFIG {
+         NEW_PHY_TUNING Value;
+         MV_U8    Gen_Speed;                              /* 1: Gen1; 2:Gen2; 3: Gen3 */
+         MV_U8    reserved[3];
+} MV_PHY_TUNING_CONFIG;
+
+typedef union {
+    struct {
+        MV_U32 low;
+        MV_U32 high;
+    } parts;
+    MV_U8       b[8];
+    MV_U16      w[4];
+    MV_U32      d[2];        
+} MV_SAS_ADDR;
+
+typedef union {
+    MV_PHY_TUNING_CONFIG tuning;
+    MV_SAS_ADDR          sas; 
+} PHY_CONFIG, *PPHY_CONFIG;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_product.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_product.h
--- linux-3.10.69/drivers/scsi/mv/include/com_product.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_product.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,154 @@
+#ifndef COM_PRODUCT_H
+#define COM_PRODUCT_H
+/* Product device id */
+#define VENDOR_ID					        0x11AB
+#define VENDOR_ID_EXT                       0x1B4B
+#define DEVICE_ID_ODIN                      0x6400
+#define DEVICE_ID_THORLITE_2S1P				0x6121
+#define DEVICE_ID_THORLITE_0S1P				0x6101
+#define DEVICE_ID_THORLITE_1S1P				0x6111
+#define DEVICE_ID_THOR_4S1P				    0x6141
+#define DEVICE_ID_THOR_4S1P_NEW				0x6145
+/* Revision ID starts from B1 */
+#define DEVICE_ID_THORLITE_2S1P_WITH_FLASH              0x6122
+
+ /* Odin lite version */
+#define DEVICE_ID_6320					0x6320
+#define DEVICE_ID_6340					0x6340 
+
+/* mule-board */
+#define DEVICE_ID_6440					0x6440
+
+/* Non-RAID Odin */
+#define DEVICE_ID_6445					0x6445
+
+/* mule-board */
+#define DEVICE_ID_6480					0x6480
+#define DEVICE_ID_6485					0x6485
+
+
+#define DEVICE_ID_8180					0x8180
+#define DEVICE_ID_8440					0x8440
+#define DEVICE_ID_8480					0x8480
+#define DEVICE_ID_8110					0x8110
+#define DEVICE_ID_8120					0x8120
+
+/* Magni B0 */
+#define DEVICE_ID_9123					0x9123
+#define DEVICE_ID_9122					0x9122
+#define DEVICE_ID_914D					0x914D
+
+/* Magni lite */
+#define DEVICE_ID_9182					0x9182
+#define DEVICE_ID_9186					0x9186
+#define DEVICE_ID_9172					0x9172
+#define DEVICE_ID_9170					0x9170
+#define DEVICE_ID_9181					0x9181
+#define DEVICE_ID_9171					0x9171
+#define DEVICE_ID_9192					0x9192
+#define DEVICE_ID_91A1					0x91A1
+#define DEVICE_ID_9179					0x9179
+#define DEVICE_ID_917A					0x917A
+#define DEVICE_ID_918A					0x918A
+#define DEVICE_ID_918E					0x918E
+#define DEVICE_ID_91A6					0x91A6
+
+/* Magni Lite 9152/9183 (same as MagniLite (9182) and backend is Monet(NAND))*/
+#define DEVICE_ID_9152					0x9152
+#define DEVICE_ID_9183					0x9183
+
+
+/* Magni B1 */
+#define DEVICE_ID_9023					0x9023
+#define DEVICE_ID_90A3					0x90A3
+#define DEVICE_ID_9110					0x9110
+#define DEVICE_ID_9190					0x9190
+#define DEVICE_ID_9111					0x9111
+#define DEVICE_ID_9191					0x9191
+#define DEVICE_ID_9120					0x9120
+#define DEVICE_ID_91A0					0x91A0
+#define DEVICE_ID_9122					0x9122
+#define DEVICE_ID_91A2					0x91A2
+#define DEVICE_ID_9128					0x9128
+#define DEVICE_ID_91A8					0x91A8
+#define DEVICE_ID_9028					0x9028
+#define DEVICE_ID_90A8					0x90A8
+#define DEVICE_ID_91A3					0x91A3
+#define DEVICE_ID_9130					0x9130
+#define DEVICE_ID_91B0					0x91B0
+#define DEVICE_ID_9125					0x9125
+
+/* Magni-plus*/
+#define DEVICE_ID_9200					0x9200
+// 2 sata port
+#define DEVICE_ID_9220					0x9220
+// 4 sata port
+#define DEVICE_ID_9230					0x9230
+#define DEVICE_ID_9235					0x9235
+#define DEVICE_ID_9215					0x9215
+
+
+
+/* Plato */
+#define DEVICE_ID_91F3					0x91F3
+
+/* Vanir */
+#define DEVICE_ID_9480					0x9480
+#define DEVICE_ID_9485					0x9485
+
+/* Vanir Lite */
+#define DEVICE_ID_9440					0x9440
+#define DEVICE_ID_9445					0x9445
+
+/* Vanir LiteS */
+#define DEVICE_ID_9340					0x9340
+#define DEVICE_ID_9345					0x9345
+
+/* Frey B1*/
+#define DEVICE_ID_9580                              0x9580
+
+/* Frey Lite */
+#define DEVICE_ID_9548					0x9548
+
+/* For LaCie */
+#define VENDOR_ID_LACIE				0x1C19
+#define DEVICE_ID_LACIE_8BIG		0x0001
+#define DEVICE_ID_LACIE_5BIG        0x0002
+
+/* Frey Plus */
+#define DEVICE_ID_9588                              0x9588
+
+/* Athena */
+#define DEVICE_ID_ATHENA_1480                         0x1480
+#define DEVICE_ID_ATHENA_1580                         0x1580
+#define DEVICE_ID_ATHENA_1485                         0x1485
+#define DEVICE_ID_ATHENA_1495                         0x1495
+#define DEVICE_ID_ATHENA_1496                         0x1496
+#define DEVICE_ID_ATHENA_FPGA              0x0000
+
+#define IS_VANIR_CORE(core)  ((core->device_id == DEVICE_ID_9580) || (core->device_id == DEVICE_ID_9588)	\
+||(core->device_id == DEVICE_ID_9548) ||(core->vendor_id == VENDOR_ID_LACIE))
+
+#define IS_VANIR_934X(core)  ((core->device_id == DEVICE_ID_9340)||(core->device_id == DEVICE_ID_9345))
+#define IS_VANIR_944X(core)  ((core->device_id == DEVICE_ID_9440)||(core->device_id == DEVICE_ID_9445))
+#define IS_VANIR_948X(core)  ((core->device_id == DEVICE_ID_9480)||(core->device_id == DEVICE_ID_9485))
+
+#define IS_VANIR_94X0(core)  ((core->device_id == DEVICE_ID_9480)||(core->device_id == DEVICE_ID_9440))
+#define IS_VANIR_94X5(core)  ((core->device_id == DEVICE_ID_9485)||(core->device_id == DEVICE_ID_9445))
+#define IS_VANIR(core)  ( IS_VANIR_934X(core)|| IS_VANIR_944X(core)|| IS_VANIR_948X(core) || IS_VANIR_CORE(core))
+#define IS_ATHENA_CORE(core)  ((core->device_id == DEVICE_ID_ATHENA_1480)||(core->device_id == DEVICE_ID_ATHENA_FPGA)\
+||(core->device_id == DEVICE_ID_ATHENA_1485) ||(core->device_id == DEVICE_ID_ATHENA_1495)||(core->device_id == DEVICE_ID_ATHENA_1496))
+
+
+
+/* Florence */
+#define DEVICE_ID_948F					0x948F
+        
+#define DEVICE_ID_UNKNOWN				0xFFFF
+
+/*for magni*/
+#define MAGNI_VENDORID                "Marvell"
+#define MAGNI_PRODUCTID               "9123-1b4b"
+#define MAGNI_PRODUCTID_II		      "91xx Config"
+#define MAGNI_PLUS_PRODUCTID		  "92xx Config"
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_raid_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_raid_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_raid_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_raid_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,216 @@
+#ifndef __MV_COM_RAID_STRUCT_H__
+#define __MV_COM_RAID_STRUCT_H__
+
+#if !defined(_MARVELL_SDK_PACKAGE_NONRAID)
+
+#include "com_define.h"
+#include "com_pd_struct.h"
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#define MAX_SPARE_PD_SUPPORTED_API				8
+#define MAX_BLOCK_SUPPORTED_API                 512
+#endif
+
+#define MAX_BGA_RATE                            0xFA
+#define MAX_MEDIAPATROL_RATE                    0xFF
+
+#define CACHE_WRITEBACK_ENABLE                  0
+#define CACHE_WRITETHRU_ENABLE                  1
+#define CACHE_ADAPTIVE_ENABLE                   2
+#define CACHE_AUTO_ENABLE                       MV_BIT(3)
+#define CACHE_WRITE_POLICY_FILTER               (CACHE_WRITEBACK_ENABLE | \
+       CACHE_WRITETHRU_ENABLE | \
+       CACHE_ADAPTIVE_ENABLE | \
+       CACHE_AUTO_ENABLE)
+#define CACHE_LOOKAHEAD_ENABLE                  MV_BIT(2)
+
+
+/* Definition for MV_LD_State */
+#define LD_BGA_NONE                             0
+#define LD_BGA_REBUILD                          MV_BIT(0)
+#define LD_BGA_CONSISTENCY_FIX                  MV_BIT(1)
+#define LD_BGA_CONSISTENCY_CHECK                MV_BIT(2)
+#define LD_BGA_INIT_QUICK                       MV_BIT(3)
+#define LD_BGA_INIT_BACK                        MV_BIT(4)
+#define LD_BGA_MIGRATION                        MV_BIT(5)
+#define LD_BGA_INIT_FORE                        MV_BIT(6)
+#define LD_BGA_COPYBACK                         MV_BIT(7)
+#define LD_BGA_DEFECT_FIXING                    MV_BIT(8)        /* Don't need save to DDF */
+#define LD_BGA_MEDIA_PATROL                     MV_BIT(9)
+#define LD_BGA_MIGRATION_EXT                    MV_BIT(10)       /* Free -> RAID0 */
+
+#define LD_BGA_STATE_NONE                       0
+#define LD_BGA_STATE_RUNNING                    1
+#define LD_BGA_STATE_ABORTED                    2
+#define LD_BGA_STATE_PAUSED                     3
+#define LD_BGA_STATE_AUTOPAUSED                 4
+#define LD_BGA_STATE_INTERRUPTED                5
+#define LD_BGA_STATE_DDF_PENDING                MV_BIT(7)
+
+#define LD_MODE_FREE                            0x66
+#define LD_MODE_RAID0                           0x0
+#define LD_MODE_RAID1                           0x1
+#define LD_MODE_RAID5                           0x5
+#define LD_MODE_RAID6                           0x6
+#define LD_MODE_JBOD                            0x0f
+#define LD_MODE_RAID10                          0x10
+#define LD_MODE_RAID1E                          0x11
+#define LD_MODE_RAID50                          0x50
+#define LD_MODE_RAID60                          0x60
+#define LD_MODE_RAID_CROSS                      0x0a
+#define LD_MODE_RAID_HDD_MIRROR		            0x0b
+#define LD_MODE_RAID_HDD_MIRROR_HYBRID          0x0c
+#define LD_MODE_UNKNOWN                         0xFF
+
+#define LD_IS_HYPER_HDD(raid_mode)	\
+	((raid_mode == LD_MODE_RAID_CROSS) || (raid_mode == LD_MODE_RAID_HDD_MIRROR) || (raid_mode == LD_MODE_RAID_HDD_MIRROR_HYBRID))
+
+#define REBUILD_VD 1
+#define REBUILD_DG 2
+
+typedef struct _Rebuild_Param
+{
+    MV_U16     ID;
+    MV_U8      RebuildType;   // REBUILD_VD or REBUILD_DG
+    MV_U8      PDCount;
+    MV_U8      Reserved1[4];
+    MV_U16     PDIDs[MAX_HD_SUPPORTED_API]; // Target PD
+    MV_U8      Reserved2[64];
+} Rebuild_Param, * PRebuild_Param;
+
+typedef struct  _HD_RAID_STATUS
+{
+ MV_U16            HDID;
+ MV_U16            DGID;
+ MV_U8             Status;         /* HD_STATUS_SPARE */
+ MV_U8             Reserved[3];
+}HD_RAID_Status, *PHD_RAID_Status;
+
+typedef struct  _BSL{
+ MV_U64            LBA;            /* Bad sector LBA for the HD. */
+
+ MV_U32            Count;          /* How many serial bad sectors */
+ MV_BOOLEAN        Flag;           /* Fake bad sector or not. */
+ MV_U8             Reserved[3];
+}BSL,*PBSL;
+
+typedef struct _BLOCK_INFO
+{
+ MV_U16            ID;
+ MV_U16            HDID;           /* ID in the HD_Info */
+ MV_U16            Flags;          /* Refer to BLOCK_XXX definition */
+ MV_U16            LDID;           /* Belong to which LD */
+
+ MV_U8             Status;         /* Refer to BLOCK_STATUS_XXX*/
+ MV_U8             Reserved;
+ MV_U16            BlockSize;      /* in bytes. if 0, BlockSize is 512 */
+ MV_U32            ReservedSpaceForMigration; /* Space reserved for migration */
+
+ MV_U64            StartLBA;       /* unit: 512 bytes */
+ MV_U64            Size;           /* In unit of BlockSize between API and driver, including ReservedSpaceForMigration */
+}Block_Info, *PBlock_Info;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+#define CONSISTENCYCHECK_ONLY                   0
+#define CONSISTENCYCHECK_FIX                    1
+
+#define INIT_QUICK                              0    //Just initialize first part size of LD
+#define INIT_FULLFOREGROUND                     1    //Initialize full LD size
+#define INIT_FULLBACKGROUND                     2    //Initialize full LD size background
+#define INIT_NONE                               3
+#define INIT_HYPERDUO_NONE                      INIT_NONE
+#define INIT_HYPERDUO_HDD_TO_SSD                INIT_QUICK
+#define INIT_HYPERDUO_SSD_TO_HDD                4
+#define INIT_HYPERDUO_INTELLIGENT               5
+
+#define INIT_QUICK_WITHOUT_EVENT                0xf  // Used for QUICK INIT but set cdb[5]to 0xf so driver won't send event.
+
+#define BGA_CONTROL_START                       0
+#define BGA_CONTROL_RESTART                     1
+#define BGA_CONTROL_PAUSE                       2
+#define BGA_CONTROL_RESUME                      3
+#define BGA_CONTROL_ABORT                       4
+#define BGA_CONTROL_COMPLETE                    5
+#define BGA_CONTROL_IN_PROCESS                  6
+#define BGA_CONTROL_TERMINATE_IMMEDIATE         7
+#define BGA_CONTROL_AUTO_PAUSE                  8
+#define BGA_CONTROL_CONTINUE					9
+
+#define ROUNDING_SCHEME_NONE                    0     /* no rounding */
+#define ROUNDING_SCHEME_1GB                     1     /* 1 GB rounding */
+#define ROUNDING_SCHEME_10GB                    2     /* 10 GB rounding */
+
+
+#define HD_STATUS_FREE                          MV_BIT(0)
+#define HD_STATUS_ASSIGNED                      MV_BIT(1)
+#define HD_STATUS_SPARE                         MV_BIT(2)
+#define HD_STATUS_OFFLINE                       MV_BIT(3)
+#define HD_STATUS_SMARTCHECKING                 MV_BIT(4)
+#define HD_STATUS_MP                            MV_BIT(5)
+#define HD_STATUS_DEDICATED_SPARE               MV_BIT(6)
+#define HD_STATUS_FOREIGN						MV_BIT(7)
+
+#define HD_BGA_STATE_NONE                       LD_BGA_STATE_NONE
+#define HD_BGA_STATE_RUNNING                    LD_BGA_STATE_RUNNING
+#define HD_BGA_STATE_ABORTED                    LD_BGA_STATE_ABORTED
+#define HD_BGA_STATE_PAUSED                     LD_BGA_STATE_PAUSED
+#define HD_BGA_STATE_AUTOPAUSED                 LD_BGA_STATE_AUTOPAUSED
+#define HD_BGA_STATE_PART_COMPLETE				6
+
+#define HD_BGA_TYPE_NONE                        0
+#define HD_BGA_TYPE_MP                          1
+#define HD_BGA_TYPE_DATASCRUB                   2
+
+#define PD_TYPE_PD_IN_VD                        MV_BIT(1)
+#define GLOBAL_SPARE_DISK                       MV_BIT(2)
+#define DEDICATED_SPARE_DISK                    MV_BIT(3)
+#define PD_TYPE_FOREIGN							MV_BIT(4)
+#define PD_TYPE_ENCLOSURE						MV_BIT(7)
+#define PD_TYPE_SSD								MV_BIT(6)
+
+
+#define PD_DDF_VALID                            MV_BIT(0)
+#define PD_DISK_VALID                           MV_BIT(1)
+#define PD_DDF_CLEAN                            MV_BIT(2)
+#define PD_NEED_UPDATE                          MV_BIT(3)
+#define PD_MBR_VALID                            MV_BIT(4)
+#define PD_NEED_FLUSH                           MV_BIT(5)
+#define PD_CLEAR_MBR                            MV_BIT(6)
+#define PD_RCT_NEED_UPDATE                      MV_BIT(7)
+#define PD_INIT_DDF_PROCESSING					MV_BIT(8)
+#define PD_NEED_UPDATE_DELETE_LD				MV_BIT(9)
+#define PD_NEED_SPIN_DOWN                       MV_BIT(10)
+#define PD_NEED_SPIN_UP		                    MV_BIT(11)
+
+#define PD_STATE_ONLINE                         MV_BIT(0)
+#define PD_STATE_FAILED                         MV_BIT(1)
+#define PD_STATE_REBUILDING                     MV_BIT(2)
+#define PD_STATE_TRANSITION                     MV_BIT(3)
+#define PD_STATE_SMART_ERROR                    MV_BIT(4)
+#define PD_STATE_READ_ERROR                     MV_BIT(5)
+#define PD_STATE_MISSING                        MV_BIT(6)
+#define PD_STATE_SPIN_DOWN						MV_BIT(7)
+#ifdef DDF_ERROR_HANDLE
+// Stands for DDF write error status
+#define PD_STATE_UNRECOVERABLE_DDF              MV_BIT(8)
+#endif
+
+#define HD_STATUS_SETONLINE                     0	// for testing only.
+#define HD_STATUS_SETOFFLINE                    1	// for testing only. Return error if it will cause VD to go offline
+#define HD_STATUS_FORCESETOFFLINE				2	// for testing only.
+#define HD_STATUS_SETFREE						3
+#define HD_STATUS_INVALID                       0xFF
+
+#define BLOCK_INVALID                           0
+#define BLOCK_VALID                             MV_BIT(0)
+#define BLOCK_ASSIGNED                          MV_BIT(1)
+#define BLOCK_FLAG_REBUILDING                   MV_BIT(2)
+#define BLOCK_FLAG_TEMP_ASSIGN                  MV_BIT(3)
+
+#endif
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_request_detail.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_request_detail.h
--- linux-3.10.69/drivers/scsi/mv/include/com_request_detail.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_request_detail.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,143 @@
+#ifndef __MV_COM_REQUEST_DETAIL_H__
+#define __MV_COM_REQUEST_DETAIL_H__
+
+//request related each structure, remove these in the future.
+//deprecated.
+#include "com_pd_struct.h"
+#include "com_enc_struct.h"
+#include "com_vd_struct.h"
+#include "com_raid_struct.h"
+#include "com_array_struct.h"
+#include "com_adapter_struct.h"
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _HD_Info_Request
+{
+    RequestHeader header;
+    HD_Info  hdInfo[1];			// Application need to allocate enough space based on numRequested?in the header.
+								// For example, if numRequested?is 3, application should allocate 
+								// (sizeof(HD_Info_Request) + (3-1) * sizeof(HD_Info)) of space
+								// for HD_Info_Request.  Driver can fill max of 3 entries starting from hdInfo[0].
+} HD_Info_Request, *PHD_Info_Request;
+
+typedef struct _HD_FreeSpaceInfo_Request
+{
+    RequestHeader header;
+    HD_FreeSpaceInfo  hdFreeSpaceInfo[1];
+} HD_FreeSpaceInfo_Request, *PHD_FreeSpaceInfo_Request;
+
+typedef struct _HD_Config_Request
+{
+    RequestHeader header;
+    HD_Config  hdConfig[1];
+} HD_Config_Request, *PHD_Config_Request;
+
+typedef struct _HD_SMART_Status_Request
+{
+    RequestHeader header;
+    HD_SMART_Status  hdSmartStatus[1];
+} HD_SMART_Status_Request, *PHD_SMART_Status_Request;
+
+typedef struct _HD_Block_Info_Request
+{
+    RequestHeader header;
+    HD_Block_Info  hdBlockInfo[1];
+} HD_Block_Info_Request, *PHD_Block_Info_Request;
+
+#ifndef _MARVELL_SDK_PACKAGE_NONRAID
+
+typedef struct _HD_RAID_Status_Request
+{
+    RequestHeader header;
+    HD_RAID_Status  hdRaidStatus[1];
+} HD_RAID_Status_Request, *PHD_RAID_Status_Request;
+
+typedef struct _HD_BGA_Status_Request
+{
+    RequestHeader header;
+    HD_BGA_Status  hdBgaStatus[1];
+} HD_BGA_Status_Request, *PHD_BGA_Status_Request;
+
+typedef struct _Block_Info_Request
+{
+    RequestHeader header;
+    Block_Info  blockInfo[1];
+} Block_Info_Request, *PBlock_Info_Request;
+
+typedef struct _LD_Info_Request
+{
+    RequestHeader header;
+    LD_Info  ldInfo[1];
+} LD_Info_Request, *PLD_Info_Request;
+
+typedef struct _LD_Status_Request
+{
+    RequestHeader header;
+    LD_Status  ldStatus[1];
+} LD_Status_Request, *PLD_Status_Request;
+
+typedef struct _LD_Config_Request
+{
+    RequestHeader header;
+    LD_Config  ldConfig[1];
+} LD_Config_Request, *PLD_Config_Request;
+
+typedef struct _DG_Info_Request
+{
+    RequestHeader header;
+    DG_Info  dgInfo[1];
+} DG_Info_Request, *PDG_Info_Request;
+
+typedef struct _DG_Config_Request
+{
+    RequestHeader header;
+    DG_Config  dgConfig[1];
+} DG_Config_Request, *PDG_Config_Request;
+
+typedef struct _RCT_Record_Request
+{
+    RequestHeader header;
+    RCT_Record  rctRecord[1];
+} RCT_Record_Request, *PRCT_Record_Request;
+#endif
+//_MARVELL_SDK_PACKAGE_NONRAID
+
+// Port Multiplexier 
+typedef struct _PM_Info_Request
+{
+    RequestHeader header;
+    PM_Info  pmInfo[1];
+} PM_Info_Request, *PPM_Info_Request;
+
+// Expander 
+typedef struct _Exp_Info_Request
+{
+    RequestHeader header;
+    Exp_Info  expInfo[1];
+} Exp_Info_Request, *PExp_Info_Request;
+
+typedef struct _Enclosure_Info_Request
+{
+    RequestHeader header;
+    Enclosure_Info  encInfo[1];
+} Enclosure_Info_Request, *PEnclosure_Info_Request;
+
+typedef struct _EncElementType_Info_Request
+{
+    RequestHeader header;
+    EncElementType_Info  encEleTypeInfo[1];
+} EncElementType_Info_Request, *PEncElementType_Info_Request;
+
+typedef struct _EncElement_Config_Request
+{
+    RequestHeader header;
+    EncElement_Config  encEleConfig[1];
+} EncElement_Config_Request, *PEncElement_Config_Request;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_request_header.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_request_header.h
--- linux-3.10.69/drivers/scsi/mv/include/com_request_header.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_request_header.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,69 @@
+#ifndef __MV_COM_REQUEST_HEADER_H__
+#define __MV_COM_REQUEST_HEADER_H__
+
+#define NO_MORE_DATA                            0xFFFF
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+#ifndef _OS_LINUX
+#include "string.h"
+#endif
+
+//
+// Start of variable size data request structures
+//
+
+#define REQUEST_BY_RANGE	1	// get a range of data by a given starting index and total number desired
+#define REQUEST_BY_ID		2	// get specific data by a given device ID
+
+typedef struct _RequestHeader
+{
+    MV_U8  version;				// Request header version; 0 for now.
+    MV_U8  requestType;			// REQUEST_BY_ID or REQUEST_BY_RANGE
+    MV_U16 startingIndexOrId;	// Starting index (in driver) of the data to be retrieved if requestType is REQUEST_BY_RANGE; 
+								// otherwise this is the device ID of which its data is to be retrieved. 
+    MV_U16 numRequested;		// Max number of data entries application expected driver to return starting from 
+								// startingIndexOrId, Application based on this value to allocate data space. 
+								// If requestType is REQUEST_BY_ID, numRequested should set to 1.
+    MV_U16 numReturned;			// Actual number of data entries returned by driver. API might reduce this number 
+								// by filtering out un-wanted entries.
+    MV_U16 nextStartingIndex;	// Driver suggested next starting index.  If requestType is REQUEST_BY_RANGE and  
+								// if there is no more data available after this one, set it to NO_MORE_DATA. 
+								// If requestType is REQUEST_BY_ID, always set it to NO_MORE_DATA.
+    MV_U8  reserved1[6];
+} RequestHeader, *PRequestHeader;
+
+typedef struct _Info_Request
+{
+    RequestHeader header;
+    MV_U8	      data[1];
+} Info_Request, *PInfo_Request;
+/*
+void  FillRequestHeader(PRequestHeader pReq, MV_U8 requestType, MV_U16 startingIndexOrId,  MV_U16 numRequested) ;
+
+ void inline  FillRequestHeader(PRequestHeader pReq, MV_U8 requestType, MV_U16 startingIndexOrId,  MV_U16 numRequested) 
+{ 
+	memset(pReq, 0,sizeof(RequestHeader));  
+	pReq->requestType = (requestType);   
+	pReq->startingIndexOrId= (startingIndexOrId);  
+	pReq->numRequested = (numRequested);  
+}
+*/
+
+
+#define FillRequestHeader( pReq,  m_requestType,  m_startingIndexOrId,  m_numRequested)  \
+do \
+{  \
+	memset((pReq), 0,sizeof(RequestHeader));  \
+	(pReq)->requestType = (m_requestType);   \
+	(pReq)->startingIndexOrId= (m_startingIndexOrId);  \
+	(pReq)->numRequested = (m_numRequested);  \
+}while(0)
+
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_roll.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_roll.h
--- linux-3.10.69/drivers/scsi/mv/include/com_roll.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_roll.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,136 @@
+#ifndef COM_ROLL_H
+#define COM_ROLL_H
+
+#ifdef RAID_ERROR_HANDLING
+
+#define ROLL_RESOURCE_TYPE_CONTEXT		MV_BIT(0)
+#define ROLL_RESOURCE_TYPE_RANGE		MV_BIT(1)
+#define ROLL_RESOURCE_TYPE_SGTABLE		MV_BIT(2)
+
+typedef struct _EH_RANGE
+{
+	struct _EH_RANGE	*next;
+	MV_LBA				Bad_Lba;
+	MV_U32				Bad_Sectors;
+}EH_RANGE, *PEH_RANGE;
+
+/* The original data saved during the rollover. */
+typedef struct _ROLL_ORG
+{
+	struct _ROLL_ORG	*next;
+	MV_SG_Table			SG_Table;			/* Original SG Table */
+	MV_LBA				Org_LBA;
+	MV_U32				Org_Sector;
+	MV_U8				Org_Cdb;			/* Original Cdb [0] */
+	MV_U8				reserved[3];
+}ROLL_ORG, *PROLL_ORG;
+
+/* Resource management function:
+ * context is the module extension.
+ * pResource is valid if allocate = MV_FALSE.
+ * resourceType is defined as ROLL_RESOURCE_TYPE_XXX
+ * allocate is a MV_BOOLEAN variable. 
+ * When it is MV_TRUE, the function is called to allocate resource. 
+ * When it is MV_FALSE, the function is called to release the resource specified by pResource. */
+typedef MV_PVOID (*Roll_ResourceManager) (MV_PVOID context, MV_PVOID pResource, MV_U8 resourceType, MV_BOOLEAN allocate);
+
+#define ROLL_FLAG_NONE					0
+#define ROLL_FLAG_VALID_ORG_DATA		MV_BIT(0)
+#define ROLL_FLAG_SHRINK_SIZE			MV_BIT(1)
+
+typedef struct _ROLL_CTX
+{
+	List_Head			Queue_Pointer;
+
+	/* Fixed variables */	
+	MV_PVOID			Module_Ext;			/* Module Extension */
+	MV_U32				Completed_Sector;	/* Completed Sector Count */
+	MV_U8				Flag;				/* ROLL_FLAG_XXX */
+	MV_U8				Reserved0[3];
+
+	/* Resource will be allocated on demand */
+	PROLL_ORG			pRoll_Org;			/* MV_Request Original Variables */
+	PEH_RANGE			pEH_Range;			/* Error Ranges have been hit */
+
+	/* Function Tables */
+	Roll_ResourceManager	pFResourceManager;	/* Function used to allocate and release resource. */
+}ROLL_CTX, * PROLL_CTX;
+
+typedef enum _ROLL_ACTION{
+	ROLL_ACTION_ADJUST_SIZE	= 0,	/* Won't roll the request. Just adjust request size. 
+									 * After that, the following rollover will try the whole left size. */
+	ROLL_ACTION_SKIP		= 1,	/* Skip the current range and record error. Then continue the left range. */
+	ROLL_ACTION_CONTINUE	= 2,	/* Continue the left range */
+	ROLL_ACTION_CHANGE_CDB	= 3,	/* Change CDB code. So far just supports from R/W to Verify. */
+	ROLL_ACTION_SHRINK_SIZE = 4		/* Won't roll the request. Just adjust request size. 
+									 * After that, the following rollover will try the size less/equal to this size. */
+
+} ROLL_ACTION;
+
+
+/* Initialize the rollover request. */
+MV_VOID Rollover_Init(
+	PMV_Request pMvReq,
+	MV_PVOID pModuleExt,
+	Roll_ResourceManager pFResource
+	);
+
+/* Cleanup the rollover request. */
+MV_VOID Rollover_Cleanup(
+	PMV_Request pMvReq
+	);
+
+/* Four actions.	
+ * ROLL_ACTION_ADJUST_SIZE and ROLL_ACTION_SHRINK_SIZE: Won't roll the request. Just adjust request size.
+ * The difference between them is the following ROLL_ACTION_CONTINUE.
+ * For ROLL_ACTION_ADJUST_SIZE, continue will try the whole left size.
+ * For ROLL_SHRINK_SIZE, continue will try size less or equal to the adjusted size.
+ * ROLL_ACTION_SKIP:Skip the current range and record error. Then continue the left range.
+ * ROLL_ACTION_CONTINUE: Continue the left range
+ * pMvReq and action must be specified for all actions.
+ * size is only used for ROLL_ACTION_ADJUST_SIZE and ROLL_ACTION_SHRINK_SIZE.
+ * isFinished indicated whether the request is already finished.
+ * MV_TRUE means this time, no access range is left to handle.
+ */
+MV_VOID Rollover_Roll(
+	PMV_Request pMvReq,
+	ROLL_ACTION action,
+	MV_U32		size,
+	MV_BOOLEAN  *isFinished
+	);
+
+/* Whether ever did Rollover_Roll three actions before. */
+MV_BOOLEAN Rollover_HasRolled(
+	PMV_Request pMvReq
+	);
+
+/* Whether has skipped ranges. */
+#define Rollover_HasEHRange(pMvReq)	\
+((pMvReq)->Roll_CTX!=NULL) ? ((PROLL_CTX)((pMvReq)->Roll_CTX))->pEH_Range!=NULL?MV_TRUE:MV_FALSE : MV_FALSE
+
+/* Copy the EH Range. */
+MV_VOID Rollover_CopyEHRange(
+	PMV_Request pDestReq,
+	PMV_Request pSourceReq
+	);
+
+MV_VOID Rollover_CleanEHRange(
+	PMV_Request pMvReq
+	);
+
+MV_VOID Rollover_AddEHRange(
+	PMV_Request	pMvReq,
+	MV_LBA		lba,
+	MV_U32		sector
+	);
+
+/* Returned the skipped ranges.*/
+#define Rollover_GetEHRange(pMvReq) ((pMvReq)->Roll_CTX!=NULL)?((PROLL_CTX)((pMvReq)->Roll_CTX))->pEH_Range:NULL
+
+MV_U8 Rollover_GetOriginalCDB(
+	PMV_Request pMvReq
+	);
+
+#endif /* RAID_ERROR_HANDLING */
+
+#endif /* COM_ROLL_H */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_scsi.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_scsi.h
--- linux-3.10.69/drivers/scsi/mv/include/com_scsi.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_scsi.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,730 @@
+#ifndef __MV_COM_SCSI_H__
+#define __MV_COM_SCSI_H__
+
+/*
+ * SCSI command
+ */
+#define SCSI_CMD_INQUIRY                        0x12
+#define SCSI_CMD_START_STOP_UNIT                0x1B
+#define SCSI_CMD_TEST_UNIT_READY                0x00
+#define SCSI_CMD_RESERVE_6                      0x16
+#define SCSI_CMD_RELEASE_6                      0x17
+
+#define SCSI_CMD_READ_6                         0x08
+#define SCSI_CMD_READ_10                        0x28
+#define SCSI_CMD_READ_12                        0xA8
+#define SCSI_CMD_READ_16                        0x88
+#define SCSI_CMD_READ_LONG_10					0x3E
+
+#define SCSI_CMD_WRITE_6                        0x0A
+#define SCSI_CMD_WRITE_10                       0x2A
+#define SCSI_CMD_WRITE_12                       0xAA
+#define SCSI_CMD_WRITE_16                       0x8A
+#define SCSI_CMD_WRITE_LONG_10					0x3F
+
+#define SCSI_CMD_READ_CAPACITY_10               0x25
+#define SCSI_CMD_READ_CAPACITY_16               0x9E    /* 9Eh/10h */
+/* values for service action in */
+#define SCSI_CMD_SAI_READ_CAPACITY_16  			0x10
+
+#define SCSI_CMD_VERIFY_10                      0x2F
+#define SCSI_CMD_VERIFY_12                      0xAF
+#define SCSI_CMD_VERIFY_16                      0x8F
+
+#define SCSI_CMD_REQUEST_SENSE                  0x03
+#define SCSI_CMD_MODE_SENSE_6                   0x1A
+#define SCSI_CMD_MODE_SENSE_10                  0x5A
+#define SCSI_CMD_MODE_SELECT_6                  0x15
+#define SCSI_CMD_MODE_SELECT_10                 0x55
+
+#define SCSI_CMD_LOG_SELECT                     0x4C
+#define SCSI_CMD_LOG_SENSE                      0x4D
+
+#define SCSI_CMD_WRITE_VERIFY_10                0x2E
+#define SCSI_CMD_WRITE_VERIFY_12                0xAE
+#define SCSI_CMD_WRITE_VERIFY_16                0x8E
+#define SCSI_CMD_SYNCHRONIZE_CACHE_10           0x35
+#define SCSI_CMD_SYNCHRONIZE_CACHE_16			0x91
+
+#define SCSI_CMD_WRITE_SAME_10                  0x41
+#define SCSI_CMD_WRITE_SAME_16                  0x93
+#define SCSI_CMD_UNMAP                                  0x42
+
+#define SCSI_CMD_XDWRITE_10                     0x50
+#define SCSI_CMD_XPWRITE_10                     0x51
+#define SCSI_CMD_XDREAD_10                      0x52
+#define SCSI_CMD_XDWRITEREAD_10                 0x53
+
+#define SCSI_CMD_FORMAT_UNIT                    0x04
+
+#define SCSI_CMD_SECURITY_PROTOCOL_IN           0xA2
+#define SCSI_CMD_SECURITY_PROTOCOL_OUT          0xB5
+
+#define SCSI_CMD_RCV_DIAG_RSLT                  0x1C
+#define SCSI_CMD_SND_DIAG                       0x1D
+#define SCSI_CMD_READ_DEFECT_DATA_10            0x37
+#define SCSI_CMD_REASSIGN_BLOCKS                0x07
+#define SCSI_CMD_ATA_PASSTHRU_12                0xA1
+#define SCSI_CMD_ATA_PASSTHRU_16                0x85
+#define SCSI_CMD_DEALLOCATED					0xEC
+#define ATA_CMD_PM_CHECK 						0xE5
+#define ATA_CMD_ATA_SLEEP 						0xE6
+
+
+#define IS_ATA_PASSTHRU_CMD(req,cmd)			\
+		(((req->Cdb[0]==SCSI_CMD_ATA_PASSTHRU_16) &&	\
+		(req->Cdb[14]==cmd))||		\
+		((req->Cdb[0]==SCSI_CMD_ATA_PASSTHRU_12) &&	\
+		(req->Cdb[9]==cmd)))
+
+
+#define IS_VU_CMD(req,cmd)			\
+		(((req->Cdb[0]== SCSI_CMD_ATA_PASSTHRU_16) &&	\
+		(req->Cdb[14]== SCSI_CMD_MARVELL_VENDOR_UNIQUE)   &&   \
+		(req->Cdb[4]== cmd))||		\
+		((req->Cdb[0]== SCSI_CMD_ATA_PASSTHRU_12) &&	\
+		(req->Cdb[9]== SCSI_CMD_MARVELL_VENDOR_UNIQUE) && \
+		(req->Cdb[3]== cmd)))
+
+#ifdef MAGNI_BIOS
+#define CDB_BIOS_MODULE				0x10	//;Extended BIOS Interface cdb[1]
+#define BIOS_OPER_CODE_KEYINPUT		0x01	//;Key Input
+#define BIOS_OPER_CODE_INT13H		0x02	//;*INT13h Input
+#define BIOS_OPER_CODE_TERMINAL		0x03	//;BIOS Terminal Enter Leave
+#define BIOS_OPER_CODE_PNP			0x04	//;Get PNP Device Info
+#define BIOS_OPER_CODE_SETDEDRNUM	0x05	//;Set Device Drive Number
+#define BIOS_OPER_CODE_HOSTBUFF		0x06	//;Get Host BUFFER
+#define BIOS_OPER_CODE_GETHBAINFO	0x07	//Get HBA Info
+#define BIOS_OPER_CODE_SENSEPMANDRAID	0x08	/*Sense if PM or RAID exist*/
+#define BIOS_OPER_CODE_FLASHBIOSVERSION	0x09	/*Sense if PM or RAID exist*/
+#define BIOS_OPER_CODE_BIOSSHOWINGTIME	0x0A	/*Get BIOS Showing Time*/
+#define BIOS_OPER_CODE_SMARTREADSTATUS	0x0B	/*SMART Read Status*/
+#define BIOS_OPER_CODE_GETRAIDOEMCFG		0x0C	/*Get RAID OEM CFG*/
+
+#define BIOS_OPER_CODE_PNP_EXT		0x14	//;Get PNP Device Info extend
+
+/*For Time Stamp*/
+#define API_SCSI_CMD_SET_TIMESTAMP	0xA4	//For Time Stamp
+#endif
+
+/*	security commmand */
+#define ATA_CMD_SEC_PASSWORD			0xF1
+#define ATA_CMD_SEC_UNLOCK			0xF2
+#define ATA_CMD_SEC_ERASE_PRE			0xF3
+#define ATA_CMD_SEC_ERASE_UNIT			0xF4
+#define ATA_CMD_SEC_FREEZE_LOCK			0xF5
+#define ATA_CMD_SEC_DISABLE_PASSWORD		0xF6
+
+#define SCSI_CMD_PERSISTENT_RESERVE_IN			0x5E
+#define SCSI_CMD_PERSISTENT_RESERVE_OUT			0x5F
+
+/* MMC */
+#define SCSI_CMD_REPORT_LUN                     0xA0
+#define SCSI_CMD_PREVENT_MEDIUM_REMOVAL         0x1E
+#define SCSI_CMD_READ_SUB_CHANNEL               0x42
+#define SCSI_CMD_READ_TOC                       0x43
+#define SCSI_CMD_READ_DISC_STRUCTURE            0xAD
+#define SCSI_CMD_READ_CD                        0xBE
+#define SCSI_CMD_GET_EVENT_STATUS_NOTIFICATION  0x4A
+#define SCSI_CMD_BLANK                          0xA1
+#define SCSI_CMD_READ_DISC_INFO                 0x51
+
+/* SCSI Read/Write Buffer Command */
+#define SCSI_CMD_READ_BUFFER		0x3C
+#define SCSI_CMD_WRITE_BUFFER		0x3B
+
+#define SCSI_CMD_MAINTENANCE_IN     0xA3
+
+/*hyper IO command*/
+#define SCSI_MARVELL_CMD_RCC_READ_8 0xC9
+#define SCSI_MARVELL_CMD_RCC_WRITE_8 0xCB
+#define SCSI_CMD_PACKET	0xD0
+#define SCSI_CMD_PACKET_READ	0xD1
+#define SCSI_CMD_PACKET_WRITE	0xD2
+#define SCSI_IS_PACKET(cmd)                 \
+           ((cmd) == SCSI_CMD_PACKET)
+#define SCSI_IS_PACKET_RW(cmd)                 \
+           (((cmd) == SCSI_CMD_PACKET_READ) ||    \
+	    ((cmd) == SCSI_CMD_PACKET_WRITE))
+
+
+#ifndef SMART_CMD
+#define SMART_CMD                               0xb0
+#endif /* SMART_CMD */
+
+#define SCSI_IS_RCC_READ(cmd)		\
+	    ((cmd) == SCSI_MARVELL_CMD_RCC_READ_8)
+
+#define SCSI_IS_RCC_WRITE(cmd)		\
+	    ((cmd) == SCSI_MARVELL_CMD_RCC_WRITE_8)
+
+#define SCSI_IS_RCC_CMD(cmd)		\
+	    ( SCSI_IS_RCC_READ(cmd)||SCSI_IS_RCC_WRITE(cmd) )
+
+#define SCSI_IS_READ(cmd)                       \
+           (((cmd) == SCSI_CMD_READ_6) ||       \
+	    ((cmd) == SCSI_CMD_READ_10)  ||     \
+            ((cmd) == SCSI_CMD_READ_12)  ||     \
+	    ((cmd) == SCSI_CMD_READ_16))
+
+#define SCSI_IS_WRITE(cmd)                      \
+           (((cmd) == SCSI_CMD_WRITE_6)  ||     \
+	    ((cmd) == SCSI_CMD_WRITE_10) ||     \
+	    ((cmd) == SCSI_CMD_WRITE_12) ||     \
+	    ((cmd) == SCSI_CMD_WRITE_16))
+
+#define SCSI_IS_MODE_SENSE(cmd)                 \
+           (((cmd) == SCSI_CMD_MODE_SENSE_6) || \
+	    ((cmd) == SCSI_CMD_MODE_SENSE_10))
+
+#define SCSI_IS_REQUEST_SENSE(cmd)              \
+           (((cmd) == SCSI_CMD_REQUEST_SENSE))
+
+#define SCSI_IS_VERIFY(cmd)                     \
+           (((cmd) == SCSI_CMD_VERIFY_10) ||    \
+	    ((cmd) == SCSI_CMD_VERIFY_16))
+
+#define SCSI_IS_READ_WRITE_VERIFY(cmd)			\
+		(SCSI_IS_READ(cmd) || SCSI_IS_WRITE(cmd) || SCSI_IS_VERIFY(cmd))
+
+#define SCSI_IS_COMPACT(cmd)                        \
+        (((cmd) == SCSI_MARVELL_CMD_RCC_READ_8) ||   \
+        ((cmd) == SCSI_MARVELL_CMD_RCC_WRITE_8))
+
+#define SCSI_IS_CDB10(cmd)                      \
+        (((cmd) == SCSI_CMD_READ_10) ||   \
+        ((cmd) == SCSI_CMD_WRITE_10) ||   \
+        ((cmd) == SCSI_CMD_VERIFY_10) ||   \
+        ((cmd) == SCSI_MARVELL_CMD_RCC_READ_8) ||   \
+        ((cmd) == SCSI_MARVELL_CMD_RCC_WRITE_8))
+
+#define SCSI_IS_SECURITY_PROTOCOL(cmd)	\
+		(((cmd) == SCSI_CMD_SECURITY_PROTOCOL_IN) || \
+		((cmd) == SCSI_CMD_SECURITY_PROTOCOL_OUT))
+
+#if defined( MV_ROC_IOP_TUNED )
+extern MV_U8	mv_scsi_cmd_q_chk_tbl[256];
+void mv_scsi_init_q_chk_tbl( void );
+#define MSIQCT_READ			(1<<0)
+#define MSIQCT_WRITE		(1<<1)
+#define MSIQCT_VERIFY		(1<<2)
+#define MSIQCT_CDB6			(0<<3)
+#define MSIQCT_CDB10		(1<<3)
+#define MSIQCT_CDB12		(2<<3)
+#define MSIQCT_CDB16		(3<<3)
+#define MSIQCT_CDB_N(cmd, N)	((mv_scsi_cmd_q_chk_tbl[cmd]&MSIQCT_CDB##N)==MSIQCT_CDB##N)
+#define MSIQCT_RWV			(MSIQCT_READ|MSIQCT_WRITE|MSIQCT_VERIFY)
+#undef SCSI_IS_READ
+#define SCSI_IS_READ(cmd)				(mv_scsi_cmd_q_chk_tbl[cmd]&MSIQCT_READ)
+#undef SCSI_IS_WRITE
+#define SCSI_IS_WRITE(cmd)				(mv_scsi_cmd_q_chk_tbl[cmd]&MSIQCT_WRITE)
+#undef SCSI_IS_READ_WRITE_VERIFY
+#define SCSI_IS_READ_WRITE_VERIFY(cmd)	(mv_scsi_cmd_q_chk_tbl[cmd]&MSIQCT_RWV)
+#define SCSI_IS_RMV_N(cmd, n)			((mv_scsi_cmd_q_chk_tbl[cmd]&MSIQCT_CDB##N)==MSIQCT_CDB##N)&&\
+										 (mv_scsi_cmd_q_chk_tbl[cmd]&MSIQCT_RWV))
+#endif
+
+#ifdef _OS_UKRN
+#   undef SCSI_IS_READ
+#   undef SCSI_IS_WRITE
+#   undef SCSI_IS_VERIFY
+#   undef SCSI_IS_READ_WRITE
+#   undef SCSI_IS_READ_WRITE_VERIFY
+#   undef SCSI_IS_COMPACT
+#   undef SCSI_IS_CDB10
+#   define INCLUDED_FROM_LEGACY
+#   include "scsihelper.h"
+#endif  // _OS_UKRN
+
+#define SMP_CDB_USE_ADDRESS               0x01
+
+#define SCSI_CMD_MARVELL_SPECIFIC               0xE1
+#   define CDB_CORE_MODULE                      0x1
+#      define CDB_CORE_SOFT_RESET_1				0x1
+#      define CDB_CORE_SOFT_RESET_0				0x2
+#      define CDB_CORE_IDENTIFY                 0x3
+#      define CDB_CORE_SET_UDMA_MODE            0x4
+#      define CDB_CORE_SET_PIO_MODE             0x5
+#      define CDB_CORE_ENABLE_WRITE_CACHE       0x6
+#      define CDB_CORE_DISABLE_WRITE_CACHE      0x7
+#      define CDB_CORE_ENABLE_SMART             0x8
+#      define CDB_CORE_DISABLE_SMART            0x9
+#      define CDB_CORE_SMART_RETURN_STATUS      0xA
+#      define CDB_CORE_SHUTDOWN                 0xB
+#      define CDB_CORE_ENABLE_READ_AHEAD        0xC
+#      define CDB_CORE_DISABLE_READ_AHEAD       0xD
+#      define CDB_CORE_READ_LOG_EXT             0xE
+#      define CDB_CORE_TASK_MGMT                0xF
+#      define CDB_CORE_SMP                      0x10
+#      define CDB_CORE_PM_READ_REG				0x11
+#      define CDB_CORE_PM_WRITE_REG				0x12
+#	 define CDB_CORE_RESET_DEVICE				0x13
+#	 define CDB_CORE_RESET_PORT				0x14
+#      define CDB_CORE_OS_SMART_CMD				0x15
+
+#      define   CDB_CORE_ATA_IDENTIFY_ATA                            0x16
+#      define   CDB_CORE_ATA_IDENTIFY_ATAPI                         0x17
+#      define   CDB_CORE_ATA_SMART_READ_VALUES                 0x18
+#      define   CDB_CORE_ATA_SMART_READ_THRESHOLDS         0x19
+#      define   CDB_CORE_ATA_SMART_READ_LOG_SECTOR         0x1A
+#      define   CDB_CORE_ATA_SMART_WRITE_LOG_SECTOR       0x1B
+#      define   CDB_CORE_ATA_SMART_AUTO_OFFLINE                0x1C
+#      define   CDB_CORE_ATA_SMART_AUTOSAVE                       0x1D
+#      define   CDB_CORE_ATA_SMART_IMMEDIATE_OFFLINE      0x1E
+
+#      define  CDB_CORE_ATA_SLEEP                                 0x20
+#      define  CDB_CORE_ATA_IDLE                                   0x21
+#      define  CDB_CORE_ATA_STANDBY                            0x22
+#      define  CDB_CORE_ATA_IDLE_IMMEDIATE               0x23
+#      define  CDB_CORE_ATA_STANDBY_IMMEDIATE        0x24
+#      define  CDB_CORE_ATA_CHECK_POWER_MODE         0x25
+
+#      define CDB_CORE_SMP_VIRTUAL_DISCOVER          0x30
+#      define CDB_CORE_SMP_VIRTUAL_CONFIG_ROUTE      0x31
+#	define CDB_CORE_STP_VIRTUAL_PHY_RESET			0x32
+#	define CDB_CORE_STP_VIRTUAL_REPORT_SATA_PHY		0x33
+#	define CDB_CORE_SSP_VIRTUAL_PHY_RESET			0x34
+#	define CDB_CORE_SSP_VIRTUAL_REPORT_SATA_PHY		0x35
+#	define CDB_CORE_SMP_VIRTUAL_RESET_SATA_PHY		0x36
+#	define CDB_CORE_SMP_VIRTUAL_CLEAR_AFFILIATION_ALL	0x37
+
+#	define CDB_CORE_SET_FEATURE_SPINUP	0x40
+
+#ifdef SUPPORT_SG_RESET
+#      define CDB_HBA_RESET                     0x50
+#         define CDB_HBA_HOST_RESET				0x51
+#         define CDB_HBA_BUS_RESET				0x52
+#         define CDB_HBA_TARGET_RESET			0x53
+#         define CDB_HBA_DEVICE_RESET		    0x54
+#endif
+
+#define SCSI_CMD_MARVELL_VENDOR_UNIQUE         	0xFF
+#   define MARVELL_VU_CMD_CMD_PACKET_PHASE	0xFC
+#   define MARVELL_VU_CMD_DATA_TX_PHASE		0xFD
+#   define MARVELL_VU_CMD_ASYNC_NOTIFY          0xFE
+
+/*
+* General error handler API definition for SCSI mid-layer error handler scheme.
+*/
+#define CDB_EH_MODULE	 0x2
+/* eh_timed_out */
+#define EH_TIMEOUT		0x0
+#define EH_ABORT_TASK	(EH_TIMEOUT + 1)
+#define EH_RESET_DEVICE	(EH_TIMEOUT + 2)
+#define EH_RESET_TARGET	(EH_TIMEOUT + 3)
+#define EH_RESET_BUS	(EH_TIMEOUT + 4)
+#define EH_RESET_FW	(EH_TIMEOUT + 5) /*eh_host_reset_handler as firmware is alive */
+
+
+/* ANSI SCSI-3 Log Pages retrieved by LOG SENSE. */
+#define SUPPORTED_LPAGES                            0x00
+#define BUFFER_OVERRUN_LPAGE                        0x01
+#define WRITE_ERROR_COUNTER_LPAGE                   0x02
+#define READ_ERROR_COUNTER_LPAGE                    0x03
+#define READ_REVERSE_ERROR_COUNTER_LPAGE            0x04
+#define VERIFY_ERROR_COUNTER_LPAGE                  0x05
+#define NON_MEDIUM_ERROR_LPAGE                      0x06
+#define LAST_N_ERROR_LPAGE                          0x07
+#define FORMAT_STATUS_LPAGE                         0x08
+#define TEMPERATURE_LPAGE                           0x0d
+#define STARTSTOP_CYCLE_COUNTER_LPAGE               0x0e
+#define APPLICATION_CLIENT_LPAGE                    0x0f
+#define SELFTEST_RESULTS_LPAGE                      0x10
+#define BACKGROUND_RESULTS_LPAGE                    0x15   /* SBC-3 */
+#define IE_LPAGE                                    0x2f
+
+/* Seagate vendor specific log pages. */
+#define SEAGATE_CACHE_LPAGE                     0x37
+#define SEAGATE_FACTORY_LPAGE                 0x3e
+
+/* make CDB_BIOS_MODULE visible no matter CDB_BIOS_MODULE is defined or not */
+#define CDB_BIOS_MODULE						0x10
+#ifdef TEST_FRONT_END_IO
+#define CDB_TEST_MODULE                                         0x11
+#define TEST_FE_IO_EN                                              0x01
+#define TEST_FE_IO_DIS                                            0x02
+#endif
+
+#ifdef SUPPORT_FW_BIOS
+#		define	BIOS_OPER_CODE_KEYINPUT		0x01	/*Key Input*/
+#		define	BIOS_OPER_CODE_INT13H		0x02	/*INT13h Input*/
+#		define	BIOS_OPER_CODE_TERMINAL		0x03	/*BIOS Terminal Enter Leave*/
+#		define	BIOS_OPER_CODE_PNP			0x04	/*Get PNP Device Info*/
+#		define	BIOS_OPER_CODE_SETDEDRNUM	0x05	/*Set Device Drive Number*/
+
+#		define	BIOS_OPER_CODE_PNP_EXT		0x14	//;Get PNP Device Info extend
+#endif
+
+#define SCSI_IS_INTERNAL(cmd)        ((cmd) == SCSI_CMD_MARVELL_SPECIFIC)
+
+#ifdef SIMULATOR
+#   define SCSI_CMD_READ_SCATTER				0xEE
+#   define SCSI_CMD_WRITE_SCATTER				0xEF
+#endif	// SIMULATOR
+
+/*
+ * SCSI status
+ */
+#define SCSI_STATUS_GOOD                        0x00
+#define SCSI_STATUS_CHECK_CONDITION             0x02
+#define SCSI_STATUS_CONDITION_MET               0x04
+#define SCSI_STATUS_BUSY                        0x08
+#define SCSI_STATUS_INTERMEDIATE                0x10
+#define SCSI_STATUS_INTERMEDIATE_MET            0x14
+#define SCSI_STATUS_RESERVATION_CONFLICT        0x18
+#define SCSI_STATUS_FULL                        0x28
+#define SCSI_STATUS_ACA_ACTIVE                  0x30
+#define SCSI_STATUS_ABORTED                     0x40
+
+/*
+ * SCSI sense key
+ */
+#define SCSI_SK_NO_SENSE                        0x00
+#define SCSI_SK_RECOVERED_ERROR                 0x01
+#define SCSI_SK_NOT_READY                       0x02
+#define SCSI_SK_MEDIUM_ERROR                    0x03
+#define SCSI_SK_HARDWARE_ERROR                  0x04
+#define SCSI_SK_ILLEGAL_REQUEST                 0x05
+#define SCSI_SK_UNIT_ATTENTION                  0x06
+#define SCSI_SK_DATA_PROTECT                    0x07 
+#define SCSI_SK_BLANK_CHECK                     0x08
+#define SCSI_SK_VENDOR_SPECIFIC                 0x09
+#define SCSI_SK_COPY_ABORTED                    0x0A
+#define SCSI_SK_ABORTED_COMMAND                 0x0B
+#define SCSI_SK_VOLUME_OVERFLOW                 0x0D
+#define SCSI_SK_MISCOMPARE                      0x0E
+#ifdef _XOR_DMA
+#define SCSI_SK_DMA					0x0F
+#endif
+
+/*
+ * SCSI additional sense code
+ */
+#define SCSI_ASC_NO_ASC                         0x00
+#define SCSI_ASC_LUN_NOT_READY                  0x04
+#define SCSI_ASC_LOGICAL_UNIT_NOT_RESP_TO_SEL	0x05
+#define SCSI_ASC_ECC_ERROR                      0x10
+#define SCSI_ASC_UNRECOVERED_READ_ERROR         0x11
+#define SCSI_ASC_ID_ADDR_MARK_NOT_FOUND         0x12
+#define SCSI_ASC_RECORD_NOT_FOUND               0x14
+#define SCSI_ASC_PARAMETER_LIST_LENGTH_ERROR	0x1A
+#define SCSI_ASC_INVALID_OPCODE                 0x20
+#define SCSI_ASC_LBA_OUT_OF_RANGE               0x21
+#define SCSI_ASC_INVALID_FEILD_IN_CDB           0x24
+#define SCSI_ASC_LOGICAL_UNIT_NOT_SUPPORTED     0x25
+#define SCSI_ASC_INVALID_FIELD_IN_PARAMETER     0x26
+#define SCSI_ASC_WRITE_PROTECTED                0x27
+#define SCSI_ASC_MEDIA_CHANGED                  0x28
+
+#define SCSI_ASC_CMD_SEQUENCE_ERROR             0x2C
+#define SCSI_ASC_SAVING_PARAMETERS_NOT_SUPPORT  0x39
+#define SCSI_ASC_MEDIUM_NOT_PRESENT             0x3A
+#define SCSI_ASC_LOGICAL_UNIT_FAILURE           0x3E
+#define SCSI_ASC_INTERNAL_TARGET_FAILURE        0x44
+#define SCSI_ASC_SCSI_PARITY_ERROR              0x47
+#define SCSI_ASC_MISCOMPARE_DURING_VERIFY 			 0x1D
+#define SCSI_ASC_MEDIUM_FORMAT_CORRUPTED 	     0x31
+#define SCSI_ASC_MEDIA_LOAD_EJECT_FAILURE       0x53
+#define SCSI_ASC_SYSTEM_RESOURCE_FAILURE        0x55
+#define SCSI_ASC_OPERATOR_MEDIUM_REMOVAL_REQUEST 0x5A
+#define SCSI_ASC_FAILURE_PREDICTION_THRESHOLD_EXCEEDED	0x5D
+#define SCSI_ASC_CONFIGURATION_FAILURE          0x67
+
+
+#ifdef _OS_LINUX	/* below is defined in Windows DDK scsi.h */
+#define SCSI_ADSENSE_NO_SENSE  0x98    //TBD: Definition: Don't use windows
+#define SCSI_ADSENSE_INVALID_CDB 0x99  //TBD: Definition: Don't use windows
+
+#define  SCSI_CMD_READ_DEFECT_DATA_10        0x37
+#endif
+
+#if defined(_OS_FIRMWARE)	/* below is defined in Windows DDK scsi.h */
+#define SCSI_ADSENSE_NO_SENSE  0x98    //TBD: Definition: Don't use windows
+#define SCSI_ADSENSE_INVALID_CDB 0x99  //TBD: Definition: Don't use windows
+#endif
+
+/*
+ * SCSI additional sense code qualifier
+ */
+#define SCSI_ASCQ_NO_ASCQ                       0x00
+#define SCSI_ASCQ_FORMAT_FAILED				0x01  //Format Failed
+#define SCSI_ASCQ_INSUFFICIENT_RESERVATION_RESOURCES 0x02
+#define SCSI_ASCQ_INTERVENTION_REQUIRED         0x03
+#define SCSI_ASCQ_FORMAT_IN_PROGRESS            0x04
+#define SCSI_ASCQ_MAINTENANCE_IN_PROGRESS       0x80
+#define SCSI_ASCQ_HIF_GENERAL_HD_FAILURE		0x10
+#define SCSI_ASCQ_ATA_PASSTHRU_INFO             0x1D
+#define SCSI_ASCQ_INSUFFICIENT_RESERVATION_RESOURCES 0x02
+
+
+
+/* SCSI command CDB helper functions. */
+#ifndef _OS_BIOS
+#define SCSI_CDB10_GET_LBA(cdb)                  \
+           ((MV_U32) (((MV_U32) cdb[2] << 24) |  \
+		      ((MV_U32) cdb[3] << 16) |  \
+		      ((MV_U32) cdb[4] << 8)  |  \
+		      (MV_U32) cdb[5]))
+
+#define SCSI_CDB10_SET_LBA(cdb, lba)             \
+           {                                     \
+              cdb[2] = (MV_U8)(lba >> 24);       \
+              cdb[3] = (MV_U8)(lba >> 16);       \
+              cdb[4] = (MV_U8)(lba >> 8);        \
+              cdb[5] = (MV_U8)lba;               \
+           }
+
+#define SCSI_CDB16_SET_LBA(cdb, lba)             \
+           {                                     \
+              cdb[2] = (MV_U8)(lba >> 56);       \
+              cdb[3] = (MV_U8)(lba >> 48);       \
+              cdb[4] = (MV_U8)(lba >> 40);       \
+              cdb[5] = (MV_U8)(lba >> 32);       \
+			  cdb[6] = (MV_U8)(lba >> 24);       \
+			  cdb[7] = (MV_U8)(lba >> 16);       \
+			  cdb[8] = (MV_U8)(lba >> 8);        \
+			  cdb[9] = (MV_U8)lba;               \
+           }
+
+#define SCSI_CDB10_GET_SECTOR(cdb)    ((cdb[7] << 8) | cdb[8])
+
+#define SCSI_CDB16_GET_SECTOR(cdb)                      \
+           ((MV_U32) (((MV_U32) cdb[10] << 24) |  \
+		      ((MV_U32) cdb[11] << 16) |  \
+		      ((MV_U32) cdb[12] << 8)  |  \
+		      (MV_U32) cdb[13]))
+
+#define SCSI_CDB10_SET_SECTOR(cdb, sector)      \
+           {                                    \
+              cdb[7] = (MV_U8)(sector >> 8);    \
+              cdb[8] = (MV_U8)sector;           \
+           }
+
+#define SCSI_CDB16_SET_SECTOR(cdb, sector)      \
+           {                                    \
+              cdb[10] = (MV_U8)(sector >> 24);  \
+			  cdb[11] = (MV_U8)(sector >> 16);  \
+			  cdb[12] = (MV_U8)(sector >> 8);   \
+			  cdb[13] = (MV_U8)sector;          \
+           }
+
+#else
+/* SCSI command CDB helper functions. */
+#define SCSI_CDB10_GET_LBA(cdb)	
+#define SCSI_CDB10_SET_LBA(cdb, lba)	
+#define SCSI_CDB10_GET_SECTOR(cdb)
+#define SCSI_CDB10_SET_SECTOR(cdb, sector)
+#define SCSI_CDB16_GET_LBA(cdb)	
+#define SCSI_CDB16_SET_LBA(cdb, lba)	
+#define SCSI_CDB16_GET_SECTOR(cdb)
+#define SCSI_CDB16_SET_SECTOR(cdb, sector)
+#endif
+
+#define MV_SCSI_RESPONSE_CODE                   0x70
+#define MV_SCSI_DIRECT_ACCESS_DEVICE            0x00
+
+#if 1
+typedef union {
+    struct {
+        unsigned char Cdb[16];
+    } regular[1];
+    struct {
+        unsigned char  op_code;
+        unsigned char   cdb1;
+        unsigned char   cdb2;
+        unsigned char   control;
+        unsigned char   nof_cmd;
+        unsigned char   cdb5_7[3];
+        unsigned short  len;
+        unsigned char   cdb10[6];
+    } cmd_10[1];
+    struct {
+        unsigned char  op_code;
+        unsigned char   cdb1;
+        unsigned char   cdb2;
+        unsigned char   control;
+        unsigned long  len;
+        unsigned short  nof_cmd;
+        unsigned char   cdb10[6];
+    } cmd_16[1];
+    struct {
+        unsigned short  len;
+        unsigned char   sg_cnt;
+        unsigned char   cdb3;
+        unsigned long  lba;
+    } scatter_8[2];
+    struct {
+        unsigned char   cdb0_2[3];
+        unsigned char   sg_cnt;
+        unsigned long  len;
+        unsigned long  lbal;
+        unsigned long  lbah;
+    } scatter_16[1];
+    unsigned char       b[1];
+    unsigned short      w[1];
+    unsigned long      d[1];
+    unsigned long long      q[1];
+
+} consolidate_rc_cmd_t;
+typedef struct _hyperIO_packet_header
+{
+	unsigned char   pkt_len3;
+	unsigned char   pkt_len2;
+	unsigned char   pkt_len1;
+	unsigned char   pkt_len0;
+
+	unsigned char   sub_cmd_counts_high;
+	unsigned char   sub_cmd_counts_low;
+	
+	unsigned char   rcc_tag_high;
+	unsigned char   rcc_tag_low;
+
+	unsigned char   data_block3;
+	unsigned char   data_block2;
+	unsigned char   data_block1;
+	unsigned char   data_block0;
+
+	unsigned char   reserved[4];
+} hyperIO_packet_header;
+
+#define PACKET_HEADER_SIZE		(sizeof(struct _hyperIO_packet_header))
+
+typedef struct _hyperIO_sub_cmd10
+{
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+	unsigned char   reserved1:7;
+	unsigned char   L_bit:1;
+#else
+	unsigned char   L_bit:1;
+	unsigned char   reserved1:7;
+#endif
+	unsigned char   reserved2;
+	unsigned char   sector1;
+	unsigned char   sector0;
+
+	unsigned char   lba3;
+	unsigned char   lba2;
+	unsigned char   lba1;
+	unsigned char   lba0;
+} hyperIO_sub_cmd10;
+
+typedef struct _hyperIO_sub_cmd16
+{
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+	unsigned char   reserved1:7;
+	unsigned char   L_bit:1;
+#else
+	unsigned char   L_bit:1;
+	unsigned char   reserved1:7;
+#endif
+	unsigned char   reserved2[3];
+	
+	unsigned char   sector3;
+	unsigned char   sector2;
+	unsigned char   sector1;
+	unsigned char   sector0;
+
+	unsigned char   lba7;
+	unsigned char   lba6;
+	unsigned char   lba5;
+	unsigned char   lba4;
+	unsigned char   lba3;
+	unsigned char   lba2;
+	unsigned char   lba1;
+	unsigned char   lba0;
+} hyperIO_sub_cmd16;
+#define MAX_SUB_COMMAND_SIZE	(sizeof(struct _hyperIO_sub_cmd16)) /*or 8 for 8byte command*/	
+#define MAX_PACKETE_COMMAND_NUM		128 /*max 512k, default for 4k*128*/
+#define MAX_PACKET_COMMAND_BUFFER_SIZE	(PACKET_HEADER_SIZE+MAX_SUB_COMMAND_SIZE*MAX_PACKETE_COMMAND_NUM)
+
+typedef struct _mv_hyperIO_subcmd
+{
+	union
+	{
+		hyperIO_sub_cmd10 sub_cmd10;
+		hyperIO_sub_cmd16 sub_cmd16;
+	} cmd;
+} mv_hyperIO_subcmd;
+
+
+#endif
+
+typedef struct _MV_Sense_Data
+{
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+	MV_U8 Valid:1;
+	MV_U8 ErrorCode:7;
+#else
+	MV_U8 ErrorCode:7;
+	MV_U8 Valid:1;
+#endif
+	MV_U8 SegmentNumber;
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+	MV_U8 FileMark:1;
+	MV_U8 EndOfMedia:1;
+	MV_U8 IncorrectLength:1;
+	MV_U8 Reserved:1;
+	MV_U8 SenseKey:4;
+#else
+	MV_U8 SenseKey:4;
+	MV_U8 Reserved:1;
+	MV_U8 IncorrectLength:1;
+	MV_U8 EndOfMedia:1;
+	MV_U8 FileMark:1;
+#endif
+	MV_U8 Information[4];
+	MV_U8 AdditionalSenseLength;
+	MV_U8 CommandSpecificInformation[4];
+	MV_U8 AdditionalSenseCode;
+	MV_U8 AdditionalSenseCodeQualifier;
+	MV_U8 FieldReplaceableUnitCode;
+	MV_U8 SenseKeySpecific[3];
+}MV_Sense_Data, *PMV_Sense_Data;
+
+MV_VOID MV_SetSenseData(
+	IN PMV_Sense_Data pSense,
+	IN MV_U8 SenseKey,
+	IN MV_U8 AdditionalSenseCode,
+	IN MV_U8 ASCQ
+	);
+
+/* Virtual Device Inquiry Related */
+#define VIRTUALD_INQUIRY_DATA_SIZE		36
+#define VPD_PAGE0_VIRTUALD_SIZE			7
+#define VPD_PAGE80_VIRTUALD_SIZE		12
+#define VPD_PAGE83_VIRTUALD_SIZE		24
+
+#ifndef SUPPORT_VIRTUAL_DEVICE
+extern MV_U8 BASEATTR MV_INQUIRY_VIRTUALD_DATA[];
+#define MV_INQUIRY_VPD_PAGE0_VIRTUALD_DATA	MV_INQUIRY_VPD_PAGE0_DEVICE_DATA
+extern MV_U8 BASEATTR MV_INQUIRY_VPD_PAGE80_VIRTUALD_DATA[];
+#define MV_INQUIRY_VPD_PAGE83_VIRTUALD_DATA	MV_INQUIRY_VPD_PAGE83_DEVICE_DATA
+#else
+extern MV_U8 BASEATTR MV_INQUIRY_VIRTUALD_DATA[];
+extern MV_U8 BASEATTR MV_INQUIRY_VPD_PAGE0_VIRTUALD_DATA[];
+extern MV_U8 BASEATTR MV_INQUIRY_VPD_PAGE80_VIRTUALD_DATA[];
+extern MV_U8 BASEATTR MV_INQUIRY_VPD_PAGE83_VIRTUALD_DATA[];
+#endif
+
+enum log_sense_page_code {
+        SUPPORTED_LOG_PAGES_LOG_PAGE            = 0x00,
+        WRITE_ERROR_COUNTER_LOG_PAGE            = 0x02,
+        READ_ERROR_COUNTER_LOG_PAGE             = 0x03,
+        READ_REVERSE_ERROR_COUNTER_LOG_PAGE     = 0x04,
+        VERIFY_ERROR_COUNTER_LOG_PAGE           = 0x05,
+        TEMPERATURE_LOG_PAGE                    = 0x0D,
+        SELF_TEST_RESULTS_LOG_PAGE              = 0x10, 
+        INFORMATIONAL_EXCEPTIONS_LOG_PAGE       = 0x2F,
+};
+
+enum mode_sense_page_code {
+        DIRECT_ACCESS_BLOCK_DEVICE_MODE_PAGE    = 0x00,
+        RW_ERROR_RECOVERY_MODE_PAGE             = 0x01,
+        CACHE_MODE_PAGE                         = 0x08,
+        CONTROL_MODE_PAGE                       = 0x0A,
+        PORT_MODE_PAGE                          = 0x19,
+        INFORMATIONAL_EXCEPTIONS_CONTROL_MODE_PAGE = 0x1C,
+        ALL_MODE_PAGE                           = 0x3F,
+};
+
+#endif /*  __MV_COM_SCSI_H__ */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_sgd.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_sgd.h
--- linux-3.10.69/drivers/scsi/mv/include/com_sgd.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_sgd.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,565 @@
+#ifndef __MV_COM_SGD_H__
+#define __MV_COM_SGD_H__
+
+struct _sgd_tbl_t;
+struct _sgd_t;
+
+#define SGD_DOMAIN_MASK	0xF0000000L
+
+#ifndef HAVE_HW_COMPLIANT_SG
+#define SGD_EOT			(1L<<27)	/* End of table */
+#define SGD_WIDE		(1L<<25)	/* 32 byte SG format */
+#define SGD_X64			(1L<<24)	/* the 2nd part of SGD_WIDE */
+#define SGD_NEXT_TBL	(1L<<23)	/* Next SG table format */
+#define SGD_VIRTUAL		(1L<<22)	/* Virtual SG format, either 32 or 64 bit is determined during compile time. */
+#define SGD_REFTBL		(1L<<21)	/* sg table reference format, either 32 or 64 bit is determined during compile time. */
+#define SGD_REFSGD		(1L<<20)	/* sg item reference format */
+#define SGD_VP			(1L<<19)	/* virtual and physical, not verified yet */
+#define SGD_VWOXCTX		(1L<<18)	/* virtual without translation context */
+#define SGD_PCTX		(1L<<17)	/* sgd_pctx_t, 64 bit only */
+#else
+#define SGD_X64			(0)
+#define SGD_NEXT_TBL	(0)
+#define SGD_VIRTUAL		(1L<<6)
+#define SGD_VP			(1L<<5)
+#define SGD_VWOXCTX		(0)
+#define SGD_PCTX		(1L<<4)
+#define SGD_WIDE		(1L<<3)
+#define SGD_REFTBL		(1L<<2)	/* sg table reference format, either 32 or 64 bit is determined during compile time. */
+#define SGD_REFSGD		(1L<<1)	/* sg item reference format */
+#define SGD_EOT			(1L<<0)	/* End of table */
+#endif
+
+typedef struct _sg_common_t
+{
+	MV_U32	dword1;
+	MV_U32	dword2;
+	MV_U32	dword3;
+	MV_U32	flags;	/* SGD_xxx */
+} sg_common_t;
+
+/*---------------------------------------------------------------------------*/
+
+#ifndef HAVE_HW_COMPLIANT_SG
+typedef struct _sgd_t
+{
+	MV_U64	baseAddr;
+	MV_U32	flags;
+	MV_U32 size ;
+} sgd_t;
+
+typedef struct _sgd_v32_t
+{
+	MV_PVOID	vaddr;
+	MV_PVOID	xctx;
+	MV_U32	flags;
+	MV_U32 size ;
+} sgd_v32_t;
+
+/* sgd_v_t defines 32/64 bit virtual sgd without translation context */
+typedef struct _sgd_v_t
+{
+	union {
+		MV_PVOID	vaddr;
+		MV_U64		dummy;
+	} u;
+
+	MV_U32	flags;
+	MV_U32 size ;
+} sgd_v_t;
+
+typedef struct _sgd_v64_t
+{
+	union {
+		MV_PVOID	vaddr;
+		MV_U64		dummy;
+	} u1;
+
+	MV_U32	flags;
+	MV_U32 size ;
+
+	union {
+		MV_PVOID	xctx;
+		MV_U64		dummy;
+	} u2;
+	MV_U32	flagsEx;
+	MV_U32	rsvd;
+} sgd_v64_t;
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct _sgd_ref32_t
+{
+	MV_PVOID	ref;
+	MV_U32		offset;
+
+	MV_U32	flags;
+	MV_U32 size ;
+} sgd_ref32_t;
+
+typedef struct _sgd_ref64_t
+{
+	union {
+		MV_PVOID	ref;
+		MV_U64		dummy;
+	} u;
+
+	MV_U32	flags;
+	MV_U32 size ;
+
+	MV_U32	offset;
+	MV_U32	rsvd1;
+
+	MV_U32	flagsEx;
+	MV_U32	rsvd2;
+} sgd_ref64_t;
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct _sgd_nt_t
+{
+	union {
+		struct _sgd_tbl_t*	next;
+		MV_U64	dummy;
+	} u;
+	MV_U32	rsvd;
+	MV_U32	flags;	/* SGD_xxx */
+} sgd_nt_t;
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct _sgd_vp_t
+{
+	MV_U64	baseAddr;
+
+	MV_U32	flags;
+	MV_U32 size ;
+	union {
+		MV_PVOID vaddr;
+		MV_U64   dummy;
+	} u;
+
+	MV_U32	flagsEx;	// SGD_X64
+	MV_U32	rsvd;
+} sgd_vp_t;
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct _sgd_pctx_t
+{
+	MV_U64	baseAddr;
+	MV_U32	flags;
+	MV_U32 size ;
+	union {
+		MV_PVOID xctx;
+		MV_U64   dummy;
+	} u;
+
+	MV_U32	flagsEx;	// SGD_X64
+	MV_U32	rsvd;
+} sgd_pctx_t;
+
+#else /* define HAVE_HW_COMPLIANT_SG */
+#pragma pack(4)
+
+typedef struct _sgd_t
+{
+	MV_U64  baseAddr;
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+	MV_U32  flags:10;
+	MV_U32  size:22;
+#else
+	MV_U32  size:22;
+	MV_U32  flags:10;
+#endif
+} sgd_t;
+
+typedef struct _sgd_v_t
+{
+	union {
+		MV_PVOID	vaddr;
+		MV_U64		dummy;
+	} u1;
+
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+	MV_U32  flags:10;
+	MV_U32  size:22;
+#else
+	MV_U32  size:22;
+	MV_U32  flags:10;
+#endif
+
+	union {
+		MV_PVOID	xctx;
+		MV_U64		dummy;
+	} u2;
+	
+	MV_U32	rsvd;
+} sgd_v_t;
+
+/*---------------------------------------------------------------------------*/
+typedef struct _sgd_ref_t
+{
+	union {
+		MV_PVOID	ref;
+		MV_U64		dummy;
+	} u;
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+	MV_U32  flags:10;
+	MV_U32  size:22;
+#else
+	MV_U32  size:22;
+	MV_U32  flags:10;
+#endif
+	
+	MV_U32	offset;
+	MV_U64  rsvd;
+} sgd_ref_t;
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct _sgd_nt_t
+{
+	union {
+		struct _sgd_tbl_t*	next;
+		MV_U64	dummy;
+	} u;
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+	MV_U32  flags:10;
+	MV_U32  size:22;
+#else
+	MV_U32  size:22;
+	MV_U32  flags:10;
+#endif
+} sgd_nt_t;
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct _sgd_vp_t
+{
+	MV_U64	baseAddr;
+
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+	MV_U32  flags:10;
+	MV_U32  size:22;
+#else
+	MV_U32  size:22;
+	MV_U32  flags:10;
+#endif
+	union {
+		MV_PVOID vaddr;
+		MV_U64   dummy;
+	} u;
+
+	MV_U32 rsvd;
+} sgd_vp_t;
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct _sgd_pctx_t
+{
+	MV_U64	baseAddr;
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+	MV_U32  flags:10;
+	MV_U32  size:22;
+#else
+	MV_U32  size:22;
+	MV_U32  flags:10;
+#endif
+	union {
+		MV_PVOID xctx;
+		MV_U64   dummy;
+	} u;
+
+	
+	MV_U32  rsvd;
+} sgd_pctx_t;
+
+#pragma pack(0)
+#endif
+
+/*---------------------------------------------------------------------------*/
+
+#define SGT_FLAG_PRDT_HW_COMPLIANT	(1U << 7)
+#define SGT_FLAG_PRDT_IN_HOST		(1U << 6)
+
+typedef struct _sgd_tbl_t
+{
+	MV_U16 Max_Entry_Count;
+	MV_U16 Valid_Entry_Count;
+	MV_U8 Flag;
+	MV_U16 Occupy_Entry_Count;
+	MV_U32 Byte_Count;
+	sgd_t* Entry_Ptr;
+	MV_U64 prdt_bus_addr;
+} sgd_tbl_t;
+
+#define sgd_table_init(sgdt,maxCnt,entries) do {	\
+	MV_ZeroMemory(sgdt,sizeof(sgd_tbl_t));		\
+	(sgdt)->Max_Entry_Count = (maxCnt);				\
+	(sgdt)->Entry_Ptr = (sgd_t*)(entries);			\
+} while(0)
+
+/*---------------------------------------------------------------------------*/
+
+#ifndef HAVE_HW_COMPLIANT_SG
+#define sgd_inc(sgd) do {	\
+	if( (sgd)->flags & SGD_WIDE )					\
+		sgd = (sgd_t*)(((unsigned char*) (sgd)) + 32);	\
+	else sgd = (sgd_t*)(((unsigned char*) (sgd)) + 16);	\
+} while(0)
+
+#define sgd_get_vaddr(sgd,v) do {				\
+		if( (sgd)->flags & SGD_VIRTUAL ) {			\
+			if( (sgd)->flags & SGD_WIDE )			\
+				(v) = ((sgd_v64_t*)(sgd))->u1.vaddr;\
+			else (v) = ((sgd_v32_t*)(sgd))->vaddr;	\
+		}											\
+		else if( (sgd)->flags & SGD_VWOXCTX )		\
+			(v) = ((sgd_v_t*)sgd)->u.vaddr; 		\
+		else if( (sgd)->flags & SGD_VP )			\
+			(v) = ((sgd_vp_t*)(sgd))->u.vaddr;		\
+		else										\
+			MV_ASSERT(MV_FALSE);					\
+	} while(0)
+	
+#define sgd_get_xctx(sgd,v) do {	\
+		if( (sgd)->flags & SGD_WIDE )	(v) = ((sgd_v64_t*)(sgd))->u2.xctx; \
+		else (v) = ((sgd_v32_t*)(sgd))->xctx;	\
+	} while(0)
+
+#define sgd_get_ref(sgd,_ref) do {	\
+		if( (sgd)->flags & SGD_WIDE ) (_ref) = ((sgd_ref64_t*)(sgd))->u.ref;	\
+		else (_ref) = ((sgd_ref32_t*)(sgd))->ref;	\
+	} while(0)
+	
+#define sgd_set_ref(sgd,_ref) do {	\
+		if( (sgd)->flags & SGD_WIDE ) ((sgd_ref64_t*)(sgd))->u.ref = (_ref);	\
+		else ((sgd_ref32_t*)(sgd))->ref = (_ref);	\
+	} while(0)
+	
+#define sgd_get_reftbl(sgd,reft) do {	\
+		if( (sgd)->flags & SGD_WIDE )		\
+			(reft) = (sgd_tbl_t*) (((sgd_ref64_t*)(sgd))->u.ref);	\
+		else (reft) = (sgd_tbl_t*)(((sgd_ref32_t*)(sgd))->ref); \
+	} while(0)
+	
+#define sgd_get_refsgd(sgd,reft) do {	\
+		if( (sgd)->flags & SGD_WIDE )		\
+			(reft) = (sgd_t*) (((sgd_ref64_t*)(sgd))->u.ref);	\
+		else (reft) = (sgd_t*)(((sgd_ref32_t*)(sgd))->ref); \
+	} while(0)
+	
+#define sgd_get_refoff(sgd,off) do {	\
+		if( (sgd)->flags & SGD_WIDE )	(off) = ((sgd_ref64_t*)(sgd))->offset;	\
+		else (off) = ((sgd_ref32_t*)(sgd))->offset; \
+	} while(0)
+	
+#define sgd_set_refoff(sgd,off) do {	\
+		if( (sgd)->flags & SGD_WIDE )	((sgd_ref64_t*)(sgd))->offset = (off);	\
+		else ((sgd_ref32_t*)(sgd))->offset = (off); \
+	} while(0)
+
+#define sgd_get_nexttbl(sgd,n) do {	\
+		n = ((sgd_nt_t*)(sgd))->u.next; \
+	} while(0)
+
+#define sgd_copy(sgdDst,sgdSrc) do {	\
+	*(sgdDst) = *(sgdSrc);	\
+	if( (sgdSrc)->flags & SGD_WIDE )	\
+		(sgdDst)[1] = (sgdSrc)[1];	\
+} while(0)
+
+#define sgdt_get_lastsgd(sgdt,sgd) do {		\
+		(sgd) = &(sgdt)->Entry_Ptr[(sgdt)->Valid_Entry_Count];	\
+		(sgd)--;								\
+		if( (sgd)->flags & SGD_X64 ) (sgd)--;	\
+	} while(0)
+
+#else
+#define sgd_inc(sgd) do {	\
+	if( (sgd)->flags & (SGD_WIDE) ) \
+		sgd = (sgd_t *)(((unsigned char*) (sgd)) + 2 * sizeof(sgd_t));	\
+	else sgd = (sgd_t *)(((unsigned char*) (sgd)) + sizeof(sgd_t));	\
+} while(0)
+
+#define sgd_get_vaddr(sgd,v) do {				    \
+		if( (sgd)->flags & SGD_VIRTUAL ) {			\
+				(v) = ((sgd_v_t*)(sgd))->u1.vaddr;  \
+		}											\
+		else if( (sgd)->flags & SGD_VP )			\
+			(v) = ((sgd_vp_t*)(sgd))->u.vaddr;		\
+		else										\
+			MV_ASSERT(MV_FALSE);					\
+	} while(0)
+	
+#define sgd_get_xctx(sgd,v) do {	\
+		(v) = ((sgd_v_t*)(sgd))->u2.xctx; \
+	} while(0)
+
+#define sgd_get_ref(sgd,_ref) do {	\
+		 (_ref) = ((sgd_ref_t*)(sgd))->u.ref;	\
+	} while(0)
+	
+#define sgd_set_ref(sgd,_ref) do {	\
+		 ((sgd_ref_t*)(sgd))->u.ref = (_ref);	\
+	} while(0)
+	
+#define sgd_get_reftbl(sgd,reft) do {	\
+		 (reft) = (sgd_tbl_t*)(((sgd_ref_t*)(sgd))->u.ref); \
+	} while(0)
+	
+#define sgd_get_refsgd(sgd,reft) do {	\
+		(reft) = (sgd_t*)(((sgd_ref_t*)(sgd))->u.ref);	\
+	} while(0)
+	
+#define sgd_get_refoff(sgd,off) do {	\
+		(off) = ((sgd_ref_t*)(sgd))->offset;	\
+	} while(0)
+	
+#define sgd_set_refoff(sgd,off) do {	\
+		((sgd_ref_t*)(sgd))->offset = (off);	\
+	} while(0)
+
+#define sgd_copy(sgdDst,sgdSrc) do {	\
+	*(sgdDst) = *(sgdSrc);	\
+	if ((sgdSrc)->flags & (SGD_WIDE) ) \
+		(sgdDst)[1] = (sgdSrc)[1];	\
+} while(0)
+
+#define sgdt_get_lastsgd(sgdt,sgd) do {\
+		if (((sgdt)->Valid_Entry_Count) > 1) {\
+			(sgd) = &(sgdt)->Entry_Ptr[((sgdt)->Valid_Entry_Count) - 2]; \
+			if (!((sgd)->flags & (SGD_WIDE))) (sgd)++; \
+		}\
+		else { \
+			(sgd) = &(sgdt)->Entry_Ptr[(sgdt)->Valid_Entry_Count];\
+			(sgd)--;\
+		}\
+	} while(0)
+
+#endif
+
+#define sgd_mark_eot(sgd) \
+	((sgd)->flags |= SGD_EOT)
+
+#define sgd_clear_eot(sgd) \
+	((sgd)->flags &= ~SGD_EOT)
+
+#define sgd_eot(sgd)	\
+	((sgd)->flags & SGD_EOT)
+
+#define sgd_getsz(sgd,sz) do {				\
+	(sz) = (sgd)->size;				\
+} while(0)
+
+#define sgd_setsz(sgd,sz) do {				\
+	(sgd)->size = (sz);				\
+} while(0)
+
+/*---------------------------------------------------------------------------*/
+
+typedef int (*sgd_visitor_t)(sgd_t* sgd, MV_PVOID pContext);
+
+int sgd_table_walk(
+	sgd_tbl_t*		sgdt,
+	sgd_visitor_t	visitor,
+	MV_PVOID		ctx
+	);
+
+/*---------------------------------------------------------------------------*/
+
+typedef struct _sgd_iter_t
+{
+	sgd_t*	sgd;		/* current SG */
+	MV_U32	offset;		/* offset in the SG */
+	MV_U32	remainCnt;
+} sgd_iter_t;
+
+void  sgd_iter_init(
+	sgd_iter_t*	iter,
+	sgd_t*		sgd,
+	MV_U32		offset,
+	MV_U32		count
+	);
+
+int sgd_iter_get_next(
+	sgd_iter_t*	iter,
+	sgd_t*		sgd
+	);
+
+/*---------------------------------------------------------------------------*/
+
+void sgd_dump(sgd_t* sg, char* prefix);
+void sgdt_dump(sgd_tbl_t *SgTbl, char* prefix);
+
+/*---------------------------------------------------------------------------*/
+
+void sgdt_append(
+	sgd_tbl_t*	sgdt,
+	MV_U32		address,
+	MV_U32		addressHigh,
+	MV_U32		size
+	);
+
+#ifndef HAVE_HW_COMPLIANT_SG
+void sgdt_append_pctx(
+	sgd_tbl_t*	sgdt,
+	MV_U32		address,
+	MV_U32		addressHigh,
+	MV_U32		size,
+	MV_PVOID	xctx
+	);
+#endif
+
+int sgdt_append_virtual(
+	sgd_tbl_t* sgdt,
+	MV_PVOID virtual_address,
+	MV_PVOID translation_ctx,
+	MV_U32 size
+	);
+
+int sgdt_append_ref(
+	sgd_tbl_t*	sgdt,
+	MV_PVOID	ref,
+	MV_U32		offset,
+	MV_U32		size,
+	MV_BOOLEAN	refTbl
+	);
+
+int sgdt_append_vp(
+	sgd_tbl_t*	sgdt,
+	MV_PVOID	virtual_address,
+	MV_U32		size,
+	MV_U32		address,
+	MV_U32		addressHigh
+	);
+
+void
+sgdt_copy_partial(
+	sgd_tbl_t* sgdt,
+	sgd_t**	ppsgd,
+	MV_PU32	poff,
+	MV_U32	size
+	);
+
+void sgdt_append_sgd(
+	sgd_tbl_t*	sgdt,
+	sgd_t*		sgd
+	);
+
+#define sgdt_append_reftbl(sgdt,refSgdt,offset,size)	\
+	sgdt_append_ref(sgdt,refSgdt,offset,size,MV_TRUE)
+
+#define sgdt_append_refsgd(sgdt,refSgd,offset,size)	\
+	sgdt_append_ref(sgdt,refSgd,offset,size,MV_FALSE)
+
+/*---------------------------------------------------------------------------*/
+typedef MV_VOID (*sgd_to_prd_fn)(MV_PVOID prd_ctx, MV_U64 base_addr, MV_U32 size);
+int sgdt_prepare_hwprd(
+	MV_PVOID		pCore,
+	sgd_tbl_t*		pSource,
+	MV_PVOID		prd_ctx,
+	sgd_to_prd_fn		prd_fn
+	);
+#endif	/*__MV_COM_SGD_H__*/
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_smart_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_smart_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_smart_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_smart_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,23 @@
+#ifndef __MV_COM_PD_SMART_STRUCT_H__
+#define __MV_COM_PD_SMART_STRUCT_H__
+
+#include "com_define.h"
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _ATA_SMART
+{
+     MV_U8        drive_regs[7];
+     MV_U8        bReserved;
+     MV_U32       buffer_size;
+     MV_U32       reserved;
+     MV_U8        data[512];
+}ATA_SMART, *PATA_SMART;
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,42 @@
+#ifndef __MV_COM_STRUCT_H__
+#define __MV_COM_STRUCT_H__
+
+#include "com_define.h"
+
+#define GET_ALL                                 0xFF
+#define ID_UNKNOWN                              0x7F
+
+#define INVALID_ID                              0xFF	// For older driver
+#define UNDEFINED_ID                            0xFFFF
+
+//please use MV_Adapter_GetCount instead of MAX_NUM_ADAPTERS
+#define MAX_NUM_ADAPTERS                        8
+
+#ifdef _OS_BIOS
+#define FREE_BLOCK(Flags)                       (Flags&(BLOCK_VALID) == Flags)
+#define ASSIGN_BLOCK(Flags)                     (Flags&(BLOCK_VALID|BLOCK_ASSIGNED) == Flags)
+#define INVALID_BLOCK(Flags)                    (Flags&(BLOCK_VALID|BLOCK_ASSIGNED) == 0) 
+#endif /* _OS_BIOS */
+
+#include "com_adapter_struct.h"
+
+#include "com_pd_struct.h"
+#include "com_enc_struct.h"
+
+#include "com_dbg_struct.h"
+#include "com_bbu_struct.h"
+
+#ifndef _MARVELL_SDK_PACKAGE_NONRAID
+#include "com_vd_struct.h"
+#include "com_array_struct.h"
+#endif
+
+#include "com_passthrough_struct.h"
+#include "com_flash_struct.h"
+#include "com_smart_struct.h"
+
+#include "com_request_header.h"
+#include "com_request_detail.h"
+//#include "com_ata_pass_through.h"
+
+#endif /*  __MV_COM_STRUCT_H__ */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_tag.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_tag.h
--- linux-3.10.69/drivers/scsi/mv/include/com_tag.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_tag.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,78 @@
+#ifndef __MV_COM_TAG_H__
+#define __MV_COM_TAG_H__
+
+#include "com_define.h"
+
+typedef struct _Tag_Stack Tag_Stack, *PTag_Stack;
+
+#define FILO_TAG 0x00
+#define FIFO_TAG 0x01
+
+/* if TagStackType!=FIFO_TAG, use FILO, */
+/* if TagStackType==FIFO_TAG, use FIFO, PtrOut is the next tag to get */
+/*  and Top is the number of available tags in the stack */
+/* when use FIFO, get tag from PtrOut and free tag to (PtrOut+Top)%Size */
+struct _Tag_Stack
+{
+	MV_PU16  Stack;
+	MV_U16   Size;
+	MV_U16   Top;
+	MV_U16   PtrOut;
+	MV_U8    TagStackType;
+#ifndef _OS_BIOS
+	MV_U8    Reserved[1];	
+#endif
+};
+
+MV_VOID Tag_Init(PTag_Stack pTagStack, MV_U16 size);
+#if !defined(MV_ROC_IOP_TUNED)
+MV_VOID Tag_Init_FIFO( PTag_Stack pTagStack, MV_U16 size );
+MV_U16 Tag_GetOne(PTag_Stack pTagStack) ;
+MV_VOID Tag_ReleaseOne(PTag_Stack pTagStack, MV_U16 tag);
+MV_BOOLEAN Tag_IsEmpty(PTag_Stack pTagStack);
+#else
+#define Tag_Init_FIFO( pTagStack, size )			\
+do{													\
+	Tag_Init((pTagStack), (size));					\
+	(pTagStack)->TagStackType = FIFO_TAG; 			\
+}while(0)
+
+#define Tag_GetOne(pTagStack_)						\
+({ register PTag_Stack pTagStack = (pTagStack_);	\
+	MV_U16 nTag;									\
+	MV_U16 i = pTagStack->Top&0x7FFF;				\
+	pTagStack->Top&= 0x8000;						\
+	if (i>0) {										\
+		i--;										\
+	} else {										\
+		i = (pTagStack->Size-1);					\
+		pTagStack->Top^= 0x8000;					\
+	}												\
+	pTagStack->Top|= i;								\
+	nTag = pTagStack->Stack[i];						\
+	(nTag);											\
+})
+
+#define Tag_ReleaseOne( pTagStack_, tag)			\
+do{ register PTag_Stack pTagStack = (pTagStack_);	\
+	if(pTagStack->TagStackType==FIFO_TAG){			\
+		MV_U16 i = pTagStack->PtrOut&0x7FFF;		\
+		pTagStack->PtrOut&= 0x8000;					\
+		if (i>0) {									\
+			i--;									\
+		} else {									\
+			i = (pTagStack->Size-1);				\
+			pTagStack->PtrOut^= 0x8000;				\
+		}											\
+		pTagStack->PtrOut|= i;						\
+		pTagStack->Stack[i] = tag;					\
+	} else {										\
+		pTagStack->Stack[pTagStack->Top++] = tag;	\
+	} 												\
+}while(0)
+
+#define Tag_IsEmpty(pTagStack)	((pTagStack)->PtrOut==(pTagStack)->Top)
+#endif
+
+
+#endif /*  __MV_COM_TAG_H__ */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_time_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_time_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_time_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_time_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,15 @@
+#ifndef __MV_COM_TIME_STRUCT_H__
+#define __MV_COM_TIME_STRUCT_H__
+
+#include "com_raid_struct.h"
+/* the structure, refered from SCSI_SET_TIME_STAMP parameter data */
+typedef struct _tm_stamp
+{
+	MV_U8 reserved[4];
+	MV_U16 hi;
+	MV_U16 mid;
+	MV_U16 lw;
+	MV_U8 reserved1[6];
+}tm_stamp_t,*ptm_stamp_t;
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_type.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_type.h
--- linux-3.10.69/drivers/scsi/mv/include/com_type.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_type.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,612 @@
+#ifndef __MV_COM_TYPE_H__
+#define __MV_COM_TYPE_H__
+
+#include "com_define.h"
+#include "com_list.h"
+
+#include "mv_config.h"	// USE_NEW_SGTABLE is defined in mv_config.h
+
+/*
+ * Data Structure
+ */
+#ifndef SUPPORT_ROC
+#ifdef _OS_BIOS
+#define MAX_CDB_SIZE                            16
+#else
+#define MAX_CDB_SIZE                            32
+#endif
+#else
+#define MAX_CDB_SIZE							16
+#endif
+
+struct _MV_Request;
+typedef struct _MV_Request MV_Request, *PMV_Request;
+
+#if defined(SOFTWARE_XOR) || defined(HARDWARE_XOR)
+typedef struct _MV_XOR_Request MV_XOR_Request, *PMV_XOR_Request;
+#endif
+
+#define REQ_STATUS_SUCCESS                      0x0
+#define REQ_STATUS_NOT_READY                    0x1
+#define REQ_STATUS_MEDIA_ERROR                  0x2
+#define REQ_STATUS_BUSY                         0x3
+#define REQ_STATUS_INVALID_REQUEST              0x4
+#define REQ_STATUS_INVALID_PARAMETER            0x5
+#define REQ_STATUS_NO_DEVICE                    0x6
+/* Sense data structure is the SCSI "Fixed format sense datat" format. */
+#define REQ_STATUS_HAS_SENSE                    0x7
+#define REQ_STATUS_ERROR                        0x8
+#define REQ_STATUS_DPP_ERROR                    0x9
+#define REQ_STATUS_ERROR_WITH_SENSE             0x10
+#define REQ_STATUS_TIMEOUT                      0x11
+#define REQ_STATUS_DIF_GUARD_ERROR		0x12
+#define REQ_STATUS_DIF_REF_TAG_ERROR		0x13
+#define REQ_STATUS_DIF_APP_TAG_ERROR		0x14
+
+/* Request initiator must set the status to REQ_STATUS_PENDING. */
+#define REQ_STATUS_PENDING                      0x80
+#ifndef NEW_CORE_DRIVER
+#define REQ_STATUS_RETRY                        0x81
+#define REQ_STATUS_REQUEST_SENSE                0x82
+#endif
+#define REQ_STATUS_TIME_OUT										 0x83	/* Hardware no trigger interrupt, do not retry */
+
+#ifdef MAGNI_BIOS
+/* HW SG Table and SG Entry */
+typedef struct _MV_HW_SG_Entry
+{
+	MV_U32 Base_Address;
+	MV_U32 Base_Address_High;
+	MV_U32 Reserved0;
+	MV_U32 Size;
+}MV_HW_SG_Entry, *pMV_HW_SG_Entry;
+#endif
+
+/*
+ * Don't change the order here.
+ * Module_StartAll will start from big id to small id.
+ * Make sure module_set setting matches the Module_Id
+ * MODULE_HBA must be the first one. Refer to Module_AssignModuleExtension.
+ * And HBA_GetNextModuleSendFunction has an assumption that the next level
+ * has larger ID.
+ */
+enum Module_Id
+{
+        MODULE_HBA = 0,
+#ifdef CACHE_MODULE_SUPPORT
+        MODULE_CACHE,
+#endif /*  CACHE_MODULE_SUPPORT */
+
+#ifdef SAMPLE_MODULE_SUPPORT
+        MODULE_SAMPLE,
+#endif
+#ifdef RAID_DRIVER
+        MODULE_RAID,
+#endif /*  RAID_DRIVER */
+        MODULE_CORE,
+        MAX_MODULE_NUMBER
+};
+#define MAX_POSSIBLE_MODULE_NUMBER              MAX_MODULE_NUMBER
+
+#ifdef USE_NEW_SGTABLE
+#include "com_sgd.h"
+
+typedef sgd_tbl_t MV_SG_Table, *PMV_SG_Table;
+typedef sgd_t MV_SG_Entry, *PMV_SG_Entry;
+
+#else
+
+struct _MV_SG_Table;
+typedef struct _MV_SG_Table MV_SG_Table, *PMV_SG_Table;
+
+struct _MV_SG_Entry;
+typedef struct _MV_SG_Entry MV_SG_Entry, *PMV_SG_Entry;
+
+
+
+/* SG Table and SG Entry */
+struct _MV_SG_Entry
+{
+	MV_U32 Base_Address;
+	MV_U32 Base_Address_High;
+#if defined(SUPPORT_BALDUR)
+	MV_U32 Size : 22;
+	MV_U32 Reserved0 : 2;
+	MV_U32 Chain : 1;
+	MV_U32 Reserved1 : 3;
+	MV_U32 ifsel:4;
+#else
+	MV_U32 Reserved0;
+	MV_U32 Size;
+#endif
+};
+
+
+#ifndef _OS_BIOS
+struct _MV_SG_Table
+{
+	MV_U16 Max_Entry_Count;
+	MV_U16 Valid_Entry_Count;
+	MV_U16 Flag;
+	MV_U16 Occupy_Entry_Count;
+	MV_U32 Byte_Count;
+	PMV_SG_Entry Entry_Ptr;
+};
+#else
+struct _MV_SG_Table
+{
+	MV_U8 Valid_Entry_Count;
+	MV_U32 Byte_Count;
+	MV_SG_Entry Entry_Ptr[MAX_SG_ENTRY];
+};
+#endif
+
+
+#endif
+
+#ifdef SIMULATOR
+#define	MV_REQ_COMMON_SCSI	          0
+#define	MV_REQ_COMMON_XOR	          1
+#endif	/*SIMULATOR*/
+
+/*
+ * MV_Request is the general request type passed through different modules.
+ * Must be 64 bit aligned.
+ */
+
+/* TBD : REMOVE IT A.S.A.P. */
+#define DEV_ID_TO_TARGET_ID(_dev_id)    ((MV_U8)((_dev_id) & 0x00FF))
+#define DEV_ID_TO_LUN(_dev_id)                ((MV_U8) (((_dev_id) & 0xFF00) >> 8))
+#define __MAKE_DEV_ID(_target_id, _lun)   (((MV_U16)(_target_id)) | (((MV_U16)(_lun)) << 8))
+
+typedef void (*MV_ReqCompletion)(MV_PVOID,PMV_Request);
+
+struct _MV_Request {
+#ifdef SIMULATOR
+	MV_U32 CommonType;	// please keep it as the first field
+#endif	/* SIMULATOR */
+	List_Head pool_entry;     /* don't bother, res_mgmt use only */
+	List_Head Queue_Pointer;
+#ifndef NEW_CORE_DRIVER
+	List_Head Complete_Queue_Pointer;
+#endif
+
+#ifdef DEBUG_TIMEOUT_REQUEST
+	List_Head HBA_Queue_Pointer;
+#endif
+
+#ifdef PCI_POOL_SUPPORT
+	MV_PVOID cmd_table;
+	MV_PVOID sg_table;
+	MV_PHYSICAL_ADDR cmd_table_phy;
+	MV_PHYSICAL_ADDR sg_table_phy;
+#endif
+
+	MV_PVOID Virtual_Buffer;
+	MV_U16 Device_Id;
+
+	MV_U16 Req_Flag;                  /* Check the REQ_FLAG definition */
+	MV_U8 Scsi_Status;
+	MV_U8 Tag;                        /* Request tag */
+
+#ifdef NEW_CORE_DRIVER
+	MV_U16 Req_Type;
+#else
+	MV_U8 Req_Type;                   /* Check the REQ_TYPE definition */
+#ifdef _OS_BIOS
+	MV_U8		OpCode;
+#else
+	MV_U8 Reserved0[1];
+#endif
+#endif
+#ifdef ATHENA_SECTOR_BY_SECTOR
+        MV_U32 sector_offset;
+#endif
+	MV_PVOID Cmd_Initiator;           /* Which module(extension pointer)
+					     creates this request. */					   
+#ifdef SCSI_ID_MAP
+	MV_U8 pass_id; /*pass_id == 1, do not need translate device id*/
+	MV_U8 Reserved5[3];
+#endif
+#ifdef RAID_ERROR_HANDLING
+	MV_U16 PD_Index_In_Raid;
+#else
+	MV_U16 Reserved1;
+#endif		/* RAID_ERROR_HANDLING */
+
+#ifdef SUPPORT_HYPERIO
+	MV_U32	rc_cmd_idx;
+	MV_U32	rc_sgd_idx;
+	MV_U32	subcmd_offset;
+	MV_U32	subcmd_cnt;
+#endif
+
+	MV_U8 Sense_Info_Buffer_Length;
+	MV_U8 NCQ_Tag;
+
+	MV_U32 Data_Transfer_Length;
+#ifdef SUPPORT_MUL_LUN
+	MV_U8 lun[8];
+#endif
+#if defined(SUPPORT_DIF) || defined(SUPPORT_DIX)
+	MV_U16		EEDPFlags;
+    	//MV_U32		EEDPBlockSize;
+    	//MV_U32		SecondaryReferenceTag;
+    	//MV_U16		SecondaryApplicationTag;
+    	//MV_U16		ApplicationTagTranslationMask;
+
+    	//MV_U32		PrimaryReferenceTag;        /* 0x14 */
+    	//MV_U16		PrimaryApplicationTag;      /* 0x18 */
+    	//MV_U16		PrimaryApplicationTagMask;  /* 0x1A */
+    	//MV_U32		TransferLength;             /* 0x1C */
+#endif
+	MV_U8 Cdb[MAX_CDB_SIZE];
+	MV_PVOID Data_Buffer;
+	MV_PVOID Sense_Info_Buffer;
+
+	MV_SG_Table SG_Table;
+
+	MV_PVOID Org_Req;                /* The original request. */
+
+	/* Each module should only use Context to store module information. */
+	MV_PVOID Context[MAX_POSSIBLE_MODULE_NUMBER];
+
+	MV_PVOID Scratch_Buffer;          /* pointer to the scratch buffer
+										 that this request used */
+#ifndef NEW_CORE_DRIVER
+	MV_PVOID SG_Buffer;
+#endif
+	MV_PVOID pRaid_Request;
+
+	MV_LBA LBA;
+	MV_U32 Sector_Count;
+	MV_U32 Cmd_Flag;
+
+	MV_U32 Time_Out;                  /* how many seconds we should wait
+					     before treating request as
+					     timed-out */
+	MV_U32 Splited_Count;
+#ifdef _OS_BIOS
+	MV_U16   SlotNo;
+	MV_U16		Features;
+	MV_U32		BufferAddress;
+#endif
+
+#ifdef RAID_ERROR_HANDLING
+	/* This data structure is defined to roll-over request or split request.
+	 * It's a generic roll-over scheme.
+	 * Can apply to each module or level. */
+	MV_PVOID	Roll_CTX;
+#endif
+
+#ifdef SUPPORT_TRANSACTION_LOG
+	MV_U16 Log_Entry;
+	MV_U8   reserved4[2];
+#endif
+
+#ifdef _OS_LINUX
+ 	MV_PVOID Org_Req_Scmd;                /* The original scmd request from OS*/
+#endif /* _OS_LINUX */
+	MV_ReqCompletion	Completion; /* call back function */
+
+#ifdef HAVE_PRD_SKIP
+	/* For PRD SKIP */
+	MV_U16 init_block_xfer;
+	MV_U16 init_block_skip;
+	MV_U16 sub_block_xfer;
+	MV_U16 sub_block_skip;
+#endif
+#ifdef HAVE_HW_COMPLIANT_SG
+	MV_PHYSICAL_ADDR       bus_addr;
+#endif
+
+#ifdef SPLIT_RCC_CMD
+    MV_U16 target_sent_rcc_cmd_num;
+    MV_U16 target_returned_rcc_cmd_num;
+    MV_U16 reserved[2];
+#endif
+
+#if defined(SUPPORT_MAGNI)
+    MV_PVOID pcmd_header;
+#endif
+};
+
+#define MV_REQUEST_SIZE                   sizeof(MV_Request)
+#define SIMPLE_REQUEST_NUMBER		8192
+#define RCC_DATABUF_SIZE				528
+#define RCC_PAYLOAD_SIZE				2016
+#define OFFSET_SUB_CMD				1008
+#define RCC_PACKET_CMD_OFFSET           992
+#define PACKET_CMD_DATA_SIZE            PACKET_HEADER_SIZE + MAX_RCC_CMD_COUNT * 8;//272B
+
+/*
+ * Request flag is the flag for the MV_Request data structure.
+ */
+#define REQ_FLAG_LBA_VALID                MV_BIT(0)
+#define REQ_FLAG_CMD_FLAG_VALID           MV_BIT(1)
+#define REQ_FLAG_RETRY                    MV_BIT(2)
+#define REQ_FLAG_INTERNAL_SG              MV_BIT(3)
+#ifndef USE_NEW_SGTABLE
+#define REQ_FLAG_USE_PHYSICAL_SG          MV_BIT(4)
+#define REQ_FLAG_USE_LOGICAL_SG           MV_BIT(5)
+#else
+/*temporarily reserve bit 4 & 5 until NEW_SG is enabled fixedly for all OS */
+#endif
+#define REQ_FLAG_FLUSH                    MV_BIT(6)
+#define REQ_FLAG_ALIGN				MV_BIT(7)
+#define REQ_FLAG_CONSOLIDATE			  MV_BIT(8)
+#define REQ_FLAG_NO_CONSOLIDATE           MV_BIT(9)
+#define REQ_FLAG_EXTERNAL				  MV_BIT(10)
+#if !defined(NEW_CORE_DRIVER) || defined(SIMULATOR)
+#define REQ_FLAG_CORE_SUB                 MV_BIT(11)
+#endif
+#define REQ_FLAG_BYPASS_HYBRID            MV_BIT(12)	// hybrid disk simulation
+#define REQ_FLAG_CONTINUE_ON_ERROR        MV_BIT(13)	/* Continue to handle the request even hit error. */
+#define REQ_FLAG_NO_ERROR_RECORD          MV_BIT(14)	/* Needn't record error. */
+#define REQ_FLAG_TRIM_CMD          MV_BIT(15)	/* Trim support by verify. */
+
+/*
+ * Request Type is the type of MV_Request.
+ */
+enum {
+	/* use a value other than 0, and now they're bit-mapped */
+	REQ_TYPE_OS       = 0x01,
+	REQ_TYPE_RAID     = 0x02,
+	REQ_TYPE_CACHE    = 0x04,
+	REQ_TYPE_INTERNAL = 0x08,
+	REQ_TYPE_SUBLD    = 0x10,
+	REQ_TYPE_SUBBGA   = 0x20,
+	REQ_TYPE_MP       = 0x40,
+	REQ_TYPE_DS		  = 0x80,
+	REQ_TYPE_CORE     = 0x100,
+	REQ_TYPE_COPYBACK_CLEAR	= 0x200,
+#ifdef RAID_IO_DEBUG
+	REQ_TYPE_IO_COUNTED	= 0x400,
+#endif
+#ifdef SUPPORT_MODULE_CONSOLIDATE
+	REQ_TYPE_CC = 0x800,
+	REQ_TYPE_GO_THRU_CC = 0x1000,
+#endif
+};
+
+#define CMD_FLAG_NON_DATA                 MV_BIT(0)  /* 1-non data;
+							0-data command */
+#define CMD_FLAG_DMA                      MV_BIT(1)  /* 1-DMA */
+#define CMD_FLAG_PIO			  MV_BIT(2)  /* 1-PIO */
+#define CMD_FLAG_DATA_IN                  MV_BIT(3)  /* 1-host read data */
+#define CMD_FLAG_DATA_OUT                 MV_BIT(4)	 /* 1-host write data */
+
+#define CMD_FLAG_SMART                    MV_BIT(5)  /* 1-SMART command; 0-non SMART command*/
+#define CMD_FLAG_SMART_ATA_12       MV_BIT(6)  /* SMART ATA_12  */
+#define CMD_FLAG_SMART_ATA_16       MV_BIT(7)  /* SMART ATA_16; */
+#define CMD_FLAG_CACHE_OS_DATABUF	 MV_BIT(9)
+
+
+#define CMD_FLAG_CACHE_OS_DATABUF	  MV_BIT(9)
+/*
+ * The last 16 bit only can be set by the target. Only core driver knows
+ * the device characteristic.
+ */
+#define CMD_FLAG_NCQ                      MV_BIT(16)
+#define CMD_FLAG_TCQ                      MV_BIT(17)
+#define CMD_FLAG_48BIT                    MV_BIT(18)
+#define CMD_FLAG_PACKET                   MV_BIT(19)  /* ATAPI packet cmd */
+
+#define CMD_FLAG_SCSI_PASS_THRU           MV_BIT(20)
+#define CMD_FLAG_ATA_PASS_THRU            MV_BIT(21)
+
+#define CMD_FLAG_SOFT_RESET               MV_BIT(22)
+#define CMD_FLAG_PRD_SKIP                 MV_BIT(23)
+#define CMD_FLAG_SECURITY_KEY             MV_BIT(24)
+#define CMD_FLAG_S_KEK_POSITION           MV_BIT(25)
+#define CMD_FLAG_VERIFY_KEY_TAG           MV_BIT(26)
+#define CMD_FLAG_PIR                      MV_BIT(27)
+#ifdef ATHENA_Z1_PM_WA
+#define CMD_FLAG_CMD_CMPL                      MV_BIT(28)
+#endif
+#ifdef SUPPORT_INEJECT_ERROR
+#define CMD_FLAG_INJECT_ERR                     MV_BIT(29)
+#endif
+#if defined(HARDWARE_XOR) || defined(SOFTWARE_XOR)
+/* XOR request types */
+#define    XOR_REQUEST_WRITE              0
+#define    XOR_REQUEST_COMPARE            1
+#define    XOR_REQUEST_DMA                2
+#define    XOR_REQUEST_MEMSET             3
+
+/* XOR request status */
+#define XOR_STATUS_SUCCESS                0
+#define XOR_STATUS_INVALID_REQUEST        1
+#define XOR_STATUS_ERROR                  2
+#define XOR_STATUS_INVALID_PARAMETER      3
+
+#ifdef SUPPORT_LARGE_CONFIG
+#define XOR_SOURCE_SG_COUNT               36  /* TBD support 32 disks RAID5 */
+#else
+#define XOR_SOURCE_SG_COUNT               11  /* TBD support 8 disks RAID5 */
+#endif		/* SUPPORT_LARGE_CONFIG */
+
+#ifdef RAID6_MULTIPLE_PARITY
+#   define XOR_TARGET_SG_COUNT               3   /* TBD */
+#else
+#   define XOR_TARGET_SG_COUNT               1   /* TBD */
+#endif
+
+typedef MV_U8    XOR_COEF, *PXOR_COEF;        /* XOR Coefficient */
+
+struct _MV_XOR_Request {
+#ifdef SIMULATOR
+	MV_U32 CommonType;	// please keep it as the first field
+#endif	/*SIMULATOR*/
+#ifndef NEW_CORE_DRIVER
+	MV_U32	seq_id;
+#endif
+	MV_U32 Error_Offset;                 /* byte, not sector */
+
+	List_Head Queue_Pointer;
+
+	List_Head QP_Cmpl_Seq;
+	MV_U32 Is_Active ;
+
+	MV_U16 Device_Id;
+
+	MV_U8 Request_Type;
+	MV_U8 Request_Status;
+
+	MV_U8 Source_SG_Table_Count;        /* how many items in the
+					       SG_Table_List */
+	MV_U8 Target_SG_Table_Count;
+#ifdef NEW_CORE_DRIVER
+#ifdef SUPPORT_FILL_MEMORY
+	MV_U32 data;
+#endif
+#else
+#ifdef SOFTWARE_XOR
+	MV_U8 Reserved[2];
+#else
+	MV_U16 SlotNo;
+#endif /* SOFTWARE_XOR */
+#endif
+	MV_SG_Table Source_SG_Table_List[XOR_SOURCE_SG_COUNT];
+	MV_SG_Table Target_SG_Table_List[XOR_TARGET_SG_COUNT];
+#ifdef XOR_USE_SG_PTR
+        MV_SG_Table *src_sg_tbl_ptr;
+        MV_SG_Table *tgt_sg_tbl_ptr;
+#endif
+	/* TBD: Use one task or several tasks. */
+	XOR_COEF    Coef[XOR_TARGET_SG_COUNT][XOR_SOURCE_SG_COUNT];
+
+	MV_PVOID Cmd_Initiator;              /* Which module(extension pointer
+						) creates this request. */
+
+	MV_PVOID Context[MAX_POSSIBLE_MODULE_NUMBER];
+
+#ifndef NEW_CORE_DRIVER
+	MV_PVOID SG_Buffer;
+#endif
+	void (*Completion)(MV_PVOID, PMV_XOR_Request);    /* callback */
+};
+#endif
+
+typedef struct _MV_Target_ID_Map
+{
+	MV_U16   Device_Id;
+	MV_U8    Type;                    /* 0:LD, 1:Free Disk */
+	MV_U8    Reserved;
+} MV_Target_ID_Map, *PMV_Target_ID_Map;
+
+/* Resource type */
+enum Resource_Type
+{
+	RESOURCE_CACHED_MEMORY = 0,
+#ifdef SUPPORT_DISCARDABLE_MEM
+	RESOURCE_DISCARDABLE_MEMORY,
+#endif
+	RESOURCE_UNCACHED_MEMORY
+};
+
+/* Module event type */
+enum Module_Event
+{
+	EVENT_MODULE_ALL_STARTED = 0,
+#ifdef CACHE_MODULE_SUPPORT
+	EVENT_DEVICE_CACHE_MODE_CHANGED,
+#endif /* CACHE_MODULE_SUPPORT */
+#ifdef SUPPORT_DISCARDABLE_MEM
+	EVENT_SPECIFY_RUNTIME_DEVICE,
+	EVENT_DISCARD_RESOURCE,
+#endif
+	EVENT_DEVICE_ARRIVAL,
+	EVENT_DEVICE_REMOVAL,
+	EVENT_LOG_GENERATED,
+#if defined(SUPPORT_BBU) && defined(_OS_FIRMWARE)
+       EVENT_BBU_NORMAL,
+       EVENT_BBU_ABNORMAL,
+#endif
+#if defined(LACIE_THUNDERBOLT)
+       EVENT_SHORT_PRESS_START,
+       EVENT_SHORT_PRESS_STOP,
+       EVENT_SHORT_PRESS_CORE_INIT_DONE,
+#endif
+};
+
+/* Error_Handling_State */
+enum EH_State
+{
+	EH_NONE = 0,
+	EH_ABORT_REQUEST,
+	EH_LU_RESET,
+	EH_DEVICE_RESET,
+	EH_PORT_RESET,
+	EH_CHIP_RESET,
+	EH_SET_DISK_DOWN
+};
+
+typedef enum
+{
+	EH_REQ_NOP = 0,
+	EH_REQ_ABORT_REQUEST,
+	EH_REQ_HANDLE_TIMEOUT,
+	EH_REQ_RESET_BUS,
+	EH_REQ_RESET_CHANNEL,
+	EH_REQ_RESET_DEVICE,
+	EH_REQ_RESET_ADAPTER
+}eh_req_type_t;
+
+struct mod_notif_param {
+        MV_PVOID  p_param;
+        MV_U16    hi;
+        MV_U16    lo;
+
+        /* for event processing */
+        MV_U32    event_id;
+        MV_U16    dev_id;
+        MV_U8     severity_lvl;
+        MV_U8     param_count;
+	MV_U8	sense_length;
+	MV_PVOID p_sense;
+	MV_U16	tran_hex_bit;
+};
+
+/*
+ * Exposed Functions
+ */
+
+/*
+ *
+ * Miscellaneous Definitions
+ *
+ */
+/* Rounding */
+
+/* Packed */
+
+#define MV_MAX(x,y)        (((x) > (y)) ? (x) : (y))
+#define MV_MIN(x,y)        (((x) < (y)) ? (x) : (y))
+
+#ifndef _OS_BIOS
+#define MV_MAX_U64(x, y)   ((((x).value) > ((y).value)) ? (x) : (y))
+#define MV_MIN_U64(x, y)   ((((x).value) < ((y).value)) ? (x) : (y))
+#else
+MV_U64 MV_MAX_U64(MV_U64 x, MV_U64 y);
+MV_U64 MV_MIN_U64(MV_U64 x, MV_U64 y);
+#endif
+
+#define MV_MAX_U8          0xFF
+#define MV_MAX_U16         0xFFFF
+#define MV_MAX_U32         0xFFFFFFFFL
+
+#ifdef _OS_LINUX
+#   define ROUNDING_MASK(x, mask)  (((x)+(mask))&~(mask))
+#   define ROUNDING(value, align)  ROUNDING_MASK(value,   \
+						 (typeof(value)) (align-1))
+#   define OFFSET_OF(type, member) offsetof(type, member)
+#else
+#   define ROUNDING(value, align)  ( ((value)+(align)-1)/(align)*(align) )
+#   define OFFSET_OF(type, member)    ((MV_U32)(MV_PTR_INTEGER)&(((type *) 0)->member))
+#   define ALIGN ROUNDING
+#endif /* _OS_LINUX */
+
+#define SIZE_OF_POINTER (sizeof(void*))
+
+#endif /* __MV_COM_TYPE_H__ */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_u64.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_u64.h
--- linux-3.10.69/drivers/scsi/mv/include/com_u64.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_u64.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,97 @@
+#ifndef _U64_H__
+#define _U64_H__
+#define U64_ASSIGN_SAFE(v1, v2)	\
+do{	int i; \
+	for (i=0; i<sizeof((v1)); i++)	\
+		((char*)&v1)[i] = ((char*)(v2))[i];	\
+}while(0)
+#if defined (MV_ROC_IOP_TUNED) ||defined(_OS_UKRN)
+#define U64_LIB_TYPE		0
+#else
+#define U64_LIB_TYPE		2
+#endif
+#if U64_LIB_TYPE==0||U64_LIB_TYPE==1
+#define U64_ADD_U32(v1, v2)											\
+({                                                                      \
+	register MV_U64 a;              					\
+	a.value=(v1).value+(v2); a;                                          \
+})                                                                      
+#define U64_SUBTRACT_U32(v1, v2)                        \
+({                                                                      \
+	register MV_U64 a;              					\
+	a.value=(v1).value-(v2); a;                                                      \
+})                                                                      
+#define U64_ADD_U64(v1, v2)                                \
+({                                                                      \
+	register MV_U64 a;              					\
+	a.value=(v1).value+(v2).value; a;                                                      \
+})                                                                      
+#define U64_SUBTRACT_U64(v1, v2) 	\
+({	\
+	register MV_U64 a;              					\
+	a.value=(v1).value-(v2).value; a;                                                      \
+})
+#define U64_COMPARE_U64_(v1, v2) 	\
+({	\
+	register int r;	\
+	if ((v1)==(v2)) r = 0; else if((v1)>(v2)) r = 1; else r = -1; r;                                                   \
+})
+
+#define U64_COMPARE_U64(v1, v2)     U64_COMPARE_U64_((v1).value, (v2).value)
+#define U64_COMPARE_U32(v1, v2)		U64_COMPARE_U64_((v1).value, (v2))
+#define U64_SET_VALUE(v64, v32)		(v64).value = (_MV_U64)(v32)
+#define U64_SET_MAX_VALUE(v64)		(v64).value = 0xFFFFFFFFFFFFFFFFLL
+#endif
+#if U64_LIB_TYPE==0
+#define U64_MULTIPLY_U32(v1, v2)                         \
+({                                                                      \
+	register MV_U64 a;              					\
+	a.value=(v1).value*(v2); a;                                                      \
+})                                                                      
+#define U64_DIVIDE_U64(v1, v2)                             				\
+({                                                                      \
+	register MV_U32 a;              					\
+	a=(v1).value/(v2).value; a;                                                      \
+})                                                                      
+#define U64_MOD_U32(v1, v2)		\
+({                                                                      \
+	register MV_U32 a;              					\
+	a=(v1).value%(v2); a;                                                      \
+})                                                                      
+#define U64_DIVIDE_U32(v1, v2)                             				\
+({                                                                      \
+	register MV_U64 a;              					\
+	a.value=(v1).value/(v2); a;                                                      \
+})                                                                      
+#elif U64_LIB_TYPE==1
+MV_U64 U64_MULTIPLY_U32(MV_U64 v64, MV_U32 v32);
+MV_U64 U64_DIVIDE_U32(MV_U64 v64, MV_U32 v32);
+MV_U32 U64_MOD_U32(MV_U64 v64, MV_U32 v32);
+MV_U32 U64_DIVIDE_U64(MV_U64 v1, MV_U64 v2);
+#elif U64_LIB_TYPE==2
+MV_U64 U64_ADD_U32(MV_U64 v64, MV_U32 v32);
+MV_U64 U64_SUBTRACT_U32(MV_U64 v64, MV_U32 v32);
+MV_U64 U64_MULTIPLY_U32(MV_U64 v64, MV_U32 v32);
+MV_U64 U64_DIVIDE_U32(MV_U64 v64, MV_U32 v32);
+MV_I32 U64_COMPARE_U32(MV_U64 v64, MV_U32 v32);
+MV_U32 U64_MOD_U32(MV_U64 v64, MV_U32 v32);
+
+MV_U64 U64_ADD_U64(MV_U64 v1, MV_U64 v2);
+MV_U64 U64_SUBTRACT_U64(MV_U64 v1, MV_U64 v2);
+MV_U32 U64_DIVIDE_U64(MV_U64 v1, MV_U64 v2);
+MV_I32 U64_COMPARE_U64(MV_U64 v1, MV_U64 v2);
+
+#ifndef _OS_BIOS
+#define U64_SET_VALUE(v64, v32)	do { v64.value = v32; } while(0)
+#else
+#define U64_SET_VALUE(v64, v32)	do {v64.low = v32;v64.high=0;} while(0)
+MV_U64 U64_SHIFT_LEFTN(MV_U64 v64, MV_U8 num);
+MV_U64 U64_SHIFT_RIGHTN(MV_U64 v64, MV_U8 num);
+#endif
+
+#define U64_SET_MAX_VALUE(v64)	do { v64.parts.low = v64.parts.high = 0xFFFFFFFFL; } while(0);
+
+#endif
+
+#endif
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_util.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_util.h
--- linux-3.10.69/drivers/scsi/mv/include/com_util.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_util.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,452 @@
+#ifndef __MV_COM_UTIL_H__
+#define __MV_COM_UTIL_H__
+
+#include "com_define.h"
+#include "com_type.h"
+
+#ifdef _OS_BIOS
+#include "com_sgd.h"
+void MV_ZeroMemory(MV_PVOID buffer, MV_U32 byte_count);
+void MV_FillMemory(MV_PVOID buffer, MV_U32 byte_count, MV_U8 pattern);
+void MV_CopyMemory(MV_PVOID dest, MV_PVOID source, MV_U32 byte_count);
+MV_BOOLEAN MV_CompareMemory(MV_PVOID buf0, MV_PVOID buf1, MV_U32 len);
+#else //_os_bios
+
+#ifdef _OS_UKRN
+
+    extern void memory_byte_copy(void *dst, const void *src, unsigned int nr_bytes);
+
+#   define MV_ZeroMemory(buf, len)           memset(buf, 0, len)
+#   define MV_FillMemory(buf, len, pattern)  memset(buf, pattern, len)
+
+#   define MV_CopyMemory(dest, source, len)  do {           \
+        if ((unsigned) dest & 0x3 || (unsigned) source & 3) {  \
+            memory_byte_copy(dest, source, len);            \
+        }                                                   \
+        else {                                              \
+            memcpy(dest, source, len);                      \
+        }                                                   \
+    } while (0)
+
+#   define MV_CompareMemory(buf0, buf1, len)  memcmp(buf0, buf1, len)
+
+#   define _rotr(v, i)		( (v>>i) | (v<<(32-i)) )
+
+static __forceinline unsigned int _clz(unsigned int v)
+{
+    __asm { CLZ v, v }
+    return v;
+}
+
+static __forceinline unsigned int  _ctz(unsigned int  v)
+{
+    /*
+     * ~v & (v-1) forms a mask that identifies the trailing 0's, producing
+     * all 1's if v = 0 (e.g., 01011000->00000111)
+     */
+
+    return 32 - _clz(~v & (v-1));
+}
+
+// ffs: find first set, returns the position of the LSB set to 1
+static __inline int ossw_ffs(MV_U32 v)
+{
+    return v ? (int) _ctz(v) : -1;
+}
+
+// ffc: find first clear, returns the position of the LSB set to 0
+#   define ffc(v)  ossw_ffs(~(v))
+#   define fc(v, i) (ossw_ffs(~(_rotr(v, i))) + i)
+
+static __inline int
+ffc64(MV_U64 v)
+{
+    int i;
+
+    if ((i = ffc(v.parts.low)) >= 0) {
+        return i;
+    }
+
+    if ((i = ffc(v.parts.high)) >= 0) {
+        return 32 + i;
+    }
+
+	return -1;
+}
+
+#elif defined( SUPPORT_ROC )
+#if !defined(SUPPORT_BALDUR)
+
+#define MV_ZeroMemory(buf, len)           __builtin_memset((buf), 0, (len))
+#define MV_FillMemory(buf, len, pattern)  __builtin_memset((buf), (pattern), (len))
+//#define MV_CopyMemory(dest, source, len)  __builtin_memcpy((dest), (source), (len))
+#define MV_CopyMemory(dest, source, len)  memcpy(dest, source, len)
+#define MV_CompareMemory(buf0, buf1, len) __builtin_memcmp((buf0), (buf1), (len))
+
+#define ossw_ffs(a)		(__builtin_ffsl(a) - 1)
+#define ffc(v)  ffs(~(v))
+#define ffc64(a)	(__builtin_ffsll(~((a).value)) - 1)
+#define _rotr(v, i)		( (v>>i) | (v<<(32-i)) )
+#define fc(v, i) (ossw_ffs(~(_rotr(v, i)))+ i)
+
+#else //SUPPORT_BALDUR
+
+#define MV_ZeroMemory(buf, len)           memset(buf, 0, len)
+#define MV_FillMemory(buf, len, pattern)  memset(buf, pattern, len)
+#define MV_CopyMemory(dest, source, len)  memcpy(dest, source, len)
+#define MV_CompareMemory(buf0, buf1, len)  memcmp(buf0, buf1, len)
+
+//#define MV_CLZ(a)		__builtin_clzl(a)
+#define ossw_ffs(a)		(__builtin_ffsl(a) - 1)
+#define ffc(v)  ffs(~(v))
+#define ffc64(a)	(__builtin_ffsll(~((a).value)) - 1)
+#define _rotr(v, i)		( (v>>i) | (v<<(32-i)) )
+#define fc(v, i) (ossw_ffs(~(_rotr(v, i)))+ i)
+#endif //SUPPORT_BALDUR
+
+#else //SUPPORT_ROC
+
+
+#ifndef _OS_LINUX
+#define MV_ZeroMemory(buf, len)           memset(buf, 0, len)
+#define MV_FillMemory(buf, len, pattern)  memset(buf, pattern, len)
+#define MV_CopyMemory(dest, source, len)  memcpy(dest, source, len)
+#define MV_CompareMemory(buf0, buf1, len)  memcmp(buf0, buf1, len)
+#else
+#define MV_ZeroMemory(buf, len)           ossw_memset(buf, 0, len)
+#define MV_FillMemory(buf, len, pattern)  ossw_memset(buf, pattern, len)
+#define MV_CopyMemory(dest, source, len)  ossw_memcpy(dest, source, len)
+#define MV_CompareMemory(buf0, buf1, len)  ossw_memcmp(buf0, buf1, len)
+#endif//_OS_LINUX
+
+
+#ifndef SIMULATOR
+#ifndef _OS_LINUX
+/*
+ * _BitScanForward searches the mask data from least significant bit (LSB) to
+ * the most significant bit (MSB) for a set bit (1)
+ */
+#pragma intrinsic(_BitScanForward)
+
+// ffs: find first set, returns the position of the LSB set to 1
+__inline int
+ossw_ffs(MV_U32 v)
+{
+	unsigned long index;
+	return _BitScanForward(&index, v) ? (int) index : -1;
+}
+
+// ffc: find first clear, returns the position of the LSB set to 0
+#define ffc(v)  ossw_ffs(~(v))
+#define fc(v, i) (ossw_ffs(~(_rotr(v, i))) + i)
+#else
+
+ /* ffz - find first zero in word. define in linux kernel bitops.h*/
+#define ffc(v)  ossw_ffz(v) 
+#define _rotr(v, i)		ossw_rotr32(v, i)
+/*ffs - normally return from 1 to MSB, if not find set bit, return 0*/
+#define fc(v, i) (ossw_ffs(~(_rotr(v, i))) + i)
+#endif /*#ifndef _OS_LINUX*/
+
+static __inline int
+ffc64(MV_U64 v)
+{
+    int i;
+
+    if ((i = ffc(v.parts.low)) >= 0) {
+        return i;
+    }
+
+    if ((i = ffc(v.parts.high)) >= 0) {
+        return 32 + i;
+    }
+
+	return -1;
+}
+#endif //#ifndef SIMULATOR
+#endif //SUPPORT_ROC
+#endif //_os_bios
+
+void MV_ZeroMvRequest(PMV_Request pReq);
+void MV_CopySGTable(PMV_SG_Table pTargetSGTable, PMV_SG_Table pSourceSGTable);
+/* offset and size are all byte count. */
+void MV_CopyPartialSGTable(PMV_SG_Table pTargetSGTable, PMV_SG_Table pSourceSGTable, MV_U32 offset, MV_U32 size);
+
+MV_BOOLEAN MV_Equals(MV_PU8 des, MV_PU8 src, MV_U32 len);
+
+#ifndef _OS_BIOS
+#define	U64_ASSIGN(x,y)				  	((x).value = (y))
+#define	U64_ASSIGN_U64(x,y)			  	((x).value = (y).value)
+#define	U64_COMP_U64(x,y)			  	((x) == (y).value)
+#define U64_COMP_U64_VALUE(x,y)			((x).value == (y).value)
+#define U32_ASSIGN_U64(v64, v32)		((v64).value = (v32))
+#define	U64_SHIFT_LEFT(v64, v32)		((v64).value=(v64).value << (v32))
+#define	U64_SHIFT_RIGHT(v64, v32)		((v64).value=(v64).value >> (v32))
+#define U64_ZERO_VALUE(v64)				((v64).value = 0)
+#else
+#define	U64_ASSIGN(x,y)					((x) = (y))
+#define	U64_ASSIGN_U64(x,y)				((x) = (y))
+#define	U64_COMP_U64(x,y)			  	(U64_COMPARE_U64(x, y)==0)
+#define U64_COMP_U64_VALUE(x,y)			(U64_COMPARE_U64(x, y)==0)
+#define U32_ASSIGN_U64(v64, v32)		do { (v64).parts.low = v32; (v64).parts.high = 0; } while(0);
+#define U64_SHIFT_LEFT(v64, v32) 		do {(v64).parts.high = ((v64).parts.high << v32) | ((v64).parts.low >> (32 - v32)); (v64).parts.low = (v64).parts.low << v32; } while(0);
+#define U64_SHIFT_RIGHT(v64, v32) 		do {(v64).parts.low = ((v64).parts.high << (32 - v32)) | ((v64).parts.low >> v32); (v64).parts.high = (v64).parts.high >> v32; } while(0);
+#define U64_ZERO_VALUE(v64)				do { (v64).parts.low = (v64).parts.high = 0; } while(0);
+#endif
+
+#define MV_SWAP_32(x)                             \
+           (((MV_U32)((MV_U8)(x)))<<24 |          \
+            ((MV_U32)((MV_U8)((x)>>8)))<<16 |     \
+            ((MV_U32)((MV_U8)((x)>>16)))<<8 |     \
+            ((MV_U32)((MV_U8)((x)>>24))) )
+#define MV_SWAP_64(x)                             \
+           (((_MV_U64) (MV_SWAP_32((x).parts.low))) << 32 | \
+	    MV_SWAP_32((x).parts.high))
+#define MV_SWAP_16(x)                             \
+           (((MV_U16) ((MV_U8) (x))) << 8 |       \
+	    (MV_U16) ((MV_U8) ((x) >> 8)))
+
+#if !defined(_OS_LINUX) && !defined(__QNXNTO__)
+#   ifndef __MV_BIG_ENDIAN__
+
+#      define MV_CPU_TO_BE32(x)     MV_SWAP_32(x)
+#      define MV_CPU_TO_BE64(x)     MV_SWAP_64(x)
+#      define MV_CPU_TO_BE16(x)     MV_SWAP_16(x)
+#      define MV_BE16_TO_CPU(x)     MV_SWAP_16(x)
+#      define MV_BE32_TO_CPU(x)     MV_SWAP_32(x)
+#      define MV_BE64_TO_CPU(x)     MV_SWAP_64(x)
+
+#      define MV_CPU_TO_LE16(x)     x
+#      define MV_CPU_TO_LE32(x)     x
+#      define MV_CPU_TO_LE64(x)     (x).value
+#      define MV_LE16_TO_CPU(x)     x
+#      define MV_LE32_TO_CPU(x)     x
+#      define MV_LE64_TO_CPU(x)     (x).value
+
+#   else  /* __MV_BIG_ENDIAN__ */
+
+#      define MV_CPU_TO_BE32(x)     x
+#      define MV_CPU_TO_BE64(x)     (x).value
+#      define MV_CPU_TO_BE16(x)     x
+#      define MV_BE16_TO_CPU(x)     x
+#      define MV_BE32_TO_CPU(x)     x
+#      define MV_BE64_TO_CPU(x)     (x).value
+
+#      define MV_CPU_TO_LE16(x)     MV_SWAP_16(x)
+#      define MV_CPU_TO_LE32(x)     MV_SWAP_32(x)
+#      define MV_CPU_TO_LE64(x)     MV_SWAP_64(x)
+#      define MV_LE16_TO_CPU(x)     MV_SWAP_16(x)
+#      define MV_LE32_TO_CPU(x)     MV_SWAP_32(x)
+#      define MV_LE64_TO_CPU(x)     MV_SWAP_64(x)
+
+#   endif /* __MV_BIG_ENDIAN__ */
+
+#else /* !_OS_LINUX */
+
+#define MV_CPU_TO_LE16      ossw_cpu_to_le16
+#define MV_CPU_TO_LE32      ossw_cpu_to_le32
+#define MV_CPU_TO_LE64(x)   ossw_cpu_to_le64((x).value)
+#define MV_CPU_TO_BE16      ossw_cpu_to_be16
+#define MV_CPU_TO_BE32      ossw_cpu_to_be32
+#define MV_CPU_TO_BE64(x)   ossw_cpu_to_be64((x).value)
+
+#define MV_LE16_TO_CPU      ossw_le16_to_cpu
+#define MV_LE32_TO_CPU      ossw_le32_to_cpu
+#define MV_LE64_TO_CPU(x)   ossw_le64_to_cpu((x).value)
+#define MV_BE16_TO_CPU      ossw_be16_to_cpu
+#define MV_BE32_TO_CPU      ossw_be32_to_cpu
+#define MV_BE64_TO_CPU(x)   ossw_be64_to_cpu((x).value)
+
+#endif /* !_OS_LINUX */
+
+/*
+ * big endian bit-field structs that are larger than a single byte
+ * need swapping
+ */
+#ifdef __MV_BIG_ENDIAN__
+#define MV_CPU_TO_LE16_PTR(pu16)        \
+   *((MV_PU16)(pu16)) = MV_CPU_TO_LE16(*(MV_PU16) (pu16))
+#define MV_CPU_TO_LE32_PTR(pu32)        \
+   *((MV_PU32)(pu32)) = MV_CPU_TO_LE32(*(MV_PU32) (pu32))
+
+#define MV_LE16_TO_CPU_PTR(pu16)        \
+   *((MV_PU16)(pu16)) = MV_LE16_TO_CPU(*(MV_PU16) (pu16))
+#define MV_LE32_TO_CPU_PTR(pu32)        \
+   *((MV_PU32)(pu32)) = MV_LE32_TO_CPU(*(MV_PU32) (pu32))
+# else  /* __MV_BIG_ENDIAN__ */
+#define MV_CPU_TO_LE16_PTR(pu16)        /* Nothing */
+#define MV_CPU_TO_LE32_PTR(pu32)        /* Nothing */
+#define MV_LE16_TO_CPU_PTR(pu32)
+#define MV_LE32_TO_CPU_PTR(pu32)
+#endif /* __MV_BIG_ENDIAN__ */
+
+/* definitions - following macro names are used by RAID module
+   must keep consistent */
+#define CPU_TO_BIG_ENDIAN_16(x)        MV_CPU_TO_BE16(x)
+#define CPU_TO_BIG_ENDIAN_32(x)        MV_CPU_TO_BE32(x)
+#ifdef _OS_BIOS
+MV_U64 CPU_TO_BIG_ENDIAN_64(MV_U64 x);
+#else
+#define CPU_TO_BIG_ENDIAN_64(x)        MV_CPU_TO_BE64(x)
+#endif
+
+void SGTable_Init(
+    OUT PMV_SG_Table pSGTable,
+    IN MV_U8 flag
+    );
+
+void sgt_init(
+    IN MV_U16 max_io,
+    OUT PMV_SG_Table pSGTable,
+    IN MV_U8 flag
+    );
+
+#ifndef USE_NEW_SGTABLE
+void SGTable_Append(
+    OUT PMV_SG_Table pSGTable,
+    MV_U32 address,
+    MV_U32 addressHigh,
+    MV_U32 size
+    );
+#else
+#define SGTable_Append sgdt_append
+#endif
+
+MV_BOOLEAN SGTable_Available(
+    IN PMV_SG_Table pSGTable
+    );
+
+void MV_InitializeTargetIDTable(
+    IN PMV_Target_ID_Map pMapTable
+    );
+#if defined(FIX_SCSI_ID_WITH_PHY_ID)
+MV_U16 MV_GetTargetID(
+	IN PMV_Target_ID_Map	
+	pMapTable,IN MV_U8 deviceType
+	);
+#endif
+MV_U16 MV_MapTargetID(
+    IN PMV_Target_ID_Map    pMapTable,
+    IN MV_U16                deviceId,
+    IN MV_U8                deviceType
+    );
+
+MV_U16 MV_MapToSpecificTargetID(
+	IN PMV_Target_ID_Map	pMapTable,
+	IN MV_U16				specificId,
+	IN MV_U16				deviceId,
+	IN MV_U8				deviceType
+	);
+
+MV_U16 MV_RemoveTargetID(
+    IN PMV_Target_ID_Map    pMapTable,
+    IN MV_U16                deviceId,
+    IN MV_U8                deviceType
+    );
+
+MV_U16 MV_GetMappedID(
+	IN PMV_Target_ID_Map	pMapTable,
+	IN MV_U16				deviceId,
+	IN MV_U8				deviceType
+	);
+
+void MV_DecodeReadWriteCDB(
+	IN MV_PU8 Cdb,
+	OUT MV_LBA *pLBA,
+	OUT MV_U32 *pSectorCount);
+
+void MV_CodeReadWriteCDB(
+	OUT MV_PU8	Cdb,
+	IN MV_LBA	lba,
+	IN MV_U32	sector,
+	IN MV_U8	operationCode	/* The CDB[0] */
+	);
+
+#ifdef _OS_BIOS
+void MV_SetLBAandSectorCount(PMV_Request pReq);
+#else
+#define MV_SetLBAandSectorCount(pReq) do {								\
+	MV_DecodeReadWriteCDB(pReq->Cdb, &pReq->LBA, &pReq->Sector_Count);	\
+	pReq->Req_Flag |= REQ_FLAG_LBA_VALID;								\
+} while (0)
+#endif
+
+void MV_DumpRequest(PMV_Request pReq, MV_BOOLEAN detail);
+#if defined(SUPPORT_RAID6) && (defined(HARDWARE_XOR) || defined(SOFTWARE_XOR))
+void MV_DumpXORRequest(PMV_XOR_Request pXORReq, MV_BOOLEAN detail);
+#endif
+void MV_DumpSGTable(PMV_SG_Table pSGTable);
+const char* MV_DumpSenseKey(MV_U8 sense);
+
+MV_U32 MV_CRC(
+	IN MV_PU8  pData,
+	IN MV_U16  len
+);
+MV_U32 MV_CRC_EXT(
+	IN	MV_U32		crc,
+	IN	MV_PU8		pData,
+	IN	MV_U32		len
+);
+
+#define MV_MOD_ADD(value, mod)                    \
+           do {                                   \
+              (value)++;                          \
+              if ((value) >= (mod))               \
+                 (value) = 0;                     \
+           } while (0);
+
+#ifdef MV_DEBUG
+void MV_CHECK_OS_SG_TABLE(
+    IN PMV_SG_Table pSGTable
+    );
+#endif /* MV_DEBUG */
+
+/* used for endian-ness conversion */
+static inline MV_VOID mv_swap_bytes(MV_PVOID buf, MV_U32 len)
+{
+	MV_U32 i;
+	MV_U8  tmp, *p;
+
+	/* we expect len to be in multiples of 2 */
+	if (len & 0x1)
+		return;
+
+	p = (MV_U8 *) buf;
+	for (i = 0; i < len / 2; i++)
+	{
+		tmp = p[i];
+		p[i] = p[len - i - 1];
+		p[len - i - 1] = tmp;
+	}
+}
+
+
+#if defined(RAID_DRIVER)
+typedef struct _xor_strm_t
+{
+        sgd_t           sgd[2];
+        MV_U32          off;
+} xor_strm_t;
+
+/* cache module will use this function which is defined in software XOR */
+void swxor_cpy_sg(PMV_SG_Table srctbl, PMV_SG_Table dsttbl);
+MV_PVOID sgd_kmap(sgd_t  *sg);
+MV_VOID sgd_kunmap(sgd_t  *sg,MV_PVOID mapped_addr);
+MV_PVOID sgd_kmap_sec(sgd_t  *sg);
+MV_VOID sgd_kunmap_sec(sgd_t  *sg,MV_PVOID	mapped_addr);
+#endif /* RAID_DRIVER */
+#ifdef SUPPORT_MUL_LUN
+MV_VOID init_target_id_map(MV_U16 *map_table, MV_U32 size);
+MV_U16 add_target_map(MV_U16 *map_table, MV_U16 device_id,MV_U16 max_id);
+MV_U16 remove_target_map(MV_U16 *map_table, MV_U16 target_id, MV_U16 max_id);
+#endif
+#ifdef CORE_SCSI_ID_MAP_FOR_NONE_RAID
+MV_VOID init_reported_id_map(MV_U16 *map_table, MV_U32 size);
+MV_U16 get_device_id_by_reported_id(MV_U16 *map_table, MV_U16 reported_id, MV_U16 max_id);
+MV_U16 get_reported_id_by_device_id(MV_U16 *map_table, MV_U16 device_id, MV_U16 max_id);
+MV_U16 add_report_map(MV_U16 *map_table, MV_U16 device_id,MV_U16 max_id);
+MV_U16 add_report_map_specific_id(MV_U16 *map_table, MV_U16 device_id, MV_U16 map_id, MV_U16 max_id);
+MV_U16 remove_report_map(MV_U16 *map_table, MV_U16 device_id, MV_U16 max_id);
+#endif
+
+#endif /*  __MV_COM_UTIL_H__ */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/com_vd_struct.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_vd_struct.h
--- linux-3.10.69/drivers/scsi/mv/include/com_vd_struct.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/com_vd_struct.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,184 @@
+#ifndef __MV_COM_VD_STRUCT_H__
+#define __MV_COM_VD_STRUCT_H__
+
+#if !defined(_MARVELL_SDK_PACKAGE_NONRAID)
+
+#include "com_raid_struct.h"
+
+#ifndef _OS_BIOS
+#define MAX_LD_SUPPORTED_API                    32
+#endif
+
+#define LD_MAX_NAME_LENGTH                      16
+
+#define LD_STATUS_FUNCTIONAL                    0
+#define LD_STATUS_DEGRADE                       1
+#define LD_STATUS_DELETED                       2
+#define LD_STATUS_MISSING                       3 /* LD missing in system. */
+#define LD_STATUS_OFFLINE                       4
+#define LD_STATUS_PARTIALLYOPTIMAL              5 /* r6 w/ 2 pd, 1 hd drops */
+#define LD_STATUS_FOREIGN                       6
+#define LD_STATUS_IMPORTABLE                    7
+#define LD_STATUS_NOT_IMPORTABLE                8
+#define LD_STATUS_MIGRATION                     9
+#define LD_STATUS_REBUILDING                    10
+#define LD_STATUS_CONFLICTED                    11
+#define LD_STATUS_DEGRADE_PLUGIN                12 // this specail status only for raid1
+#define LD_STATUS_HYPER_UNINIT                  13 // this specail status only for magni
+#define LD_STATUS_HYPER_USING_TABLE             14 // check the table for read/write SSD or HDD
+#define LD_STATUS_INVALID                       0xFF
+
+#define LD_BGA_EXT_NEED_SYS_VOL_INFO	MV_BIT(7)	//Notify AP that System Volume Info is needed
+
+#ifndef MV_GUID_SIZE
+#define MV_GUID_SIZE                            8
+#endif /* MV_GUID_SIZE */
+
+#ifndef _OS_BIOS
+#pragma pack(8)
+#endif /* _OS_BIOS */
+
+typedef struct _LD_Info
+{
+ MV_U16            ID;
+ MV_U8             Status;         /* Refer to LD_STATUS_xxx */
+ MV_U8             BGAStatus;      /* Refer to LD_BGA_STATE_xxx */
+ MV_U16            StripeBlockSize;/* between RAIDAPI and driver, it is # of BlockSize */
+ MV_U8             RaidMode;            
+ MV_U8             HDCount;
+
+ MV_U8             CacheMode;      /* Default is CacheMode_Default, see above */
+ MV_U8             LD_GUID[MV_GUID_SIZE];
+ MV_U8             SectorCoefficient; /* (sector size) 1=>512 (default), 2=>1024, 4=>2048, 8=>4096 */
+ MV_U8             AdapterID;
+ MV_U8             BlkCount;         /* The valid entry count of BlockIDs */
+                                     /* This field is added for supporting large block count */
+                                     /* If BlkCount==0, "0x00FF" means invalid entry of BlockIDs */
+ MV_U16            time_hi;
+ MV_U16            DGID;       
+
+ MV_U64            Size;           /* In unit of BlockSize between API and driver. */
+
+ MV_U8             Name[LD_MAX_NAME_LENGTH];
+
+ MV_U16            BlockIDs[MAX_HD_SUPPORTED_API];
+/* 
+ * According to BLOCK ID, to get the related HD ID, then WMRU can 
+ * draw the related graph like above.
+ */
+ MV_U8             SubLDCount;     /* for raid 10, 50,60 */
+ MV_U8             NumParityDisk;  /* For RAID 6. */
+ MV_U16            time_low;
+ MV_U32            BlockSize;      /* in bytes. if 0, BlockSize is 512 */
+
+ #ifdef _OS_BIOS
+ MV_U16			Mv_Scsi_ID;
+ MV_U8			Bypass_Flag;
+ MV_U8             Reserved2[1];
+ #endif
+ 
+}LD_Info, *PLD_Info;
+
+typedef struct _Create_LD_Param
+{
+ MV_U8             RaidMode;
+ MV_U8             HDCount;
+ MV_U8             RoundingScheme; /* please refer to the definitions of  ROUNDING_SCHEME_XXX. */
+ MV_U8             SubLDCount;     /* for raid 10,50,60 */
+ MV_U16            StripeBlockSize;/* between API and driver, it is # of BlockSize */
+ MV_U8             NumParityDisk;  /* For RAID 6. */
+ MV_U8             CachePolicy;    /* please refer to the definition of CACHEMODE_XXXX. */
+
+ MV_U8             InitializationOption; /* please refer to the definitions of INIT_XXXX. */
+ MV_U8             SectorCoefficient;    /* (sector size) 1=>512 (default), 2=>1024, 4=>2048, 8=>4096 */
+ MV_U16            LDID;                 /* ID of the LD to be migrated or expanded */
+ MV_U8             SpecifiedBlkSeq;      /* DG slot number, this is only used when DG is enforced */
+ MV_U8             HypperWaterMark;
+ MV_U8             Reserved2[1];
+ MV_U8             ReservedForApp;	/* Reserved for application (CLI) */
+
+ MV_U16            HDIDs[MAX_HD_SUPPORTED_API];    /* 32 */
+ MV_U8             Name[LD_MAX_NAME_LENGTH];
+
+ MV_U64            Size;           /* In unit of BlockSize between API and driver. API need to get the BlockSize for PD first and use it to set 'Size' */
+} Create_LD_Param, *PCreate_LD_Param;
+
+typedef struct _Hyper_Free_Info
+{
+ MV_U16            ID;
+ MV_U8             Reserved[6];
+
+ MV_U64            HyperFreeSize;
+} Hyper_Free_Info, *PHyper_Free_Info;
+
+typedef struct _Hyper_Map_Info
+{
+ MV_U16            VDID;
+ MV_U8             SegmentID;
+ MV_U8             Reserved[5];
+
+ MV_U64            SegmentStartLBA; //start(Bytes) / 512
+ MV_U64            SegmentSize;     //size (Bytes) / 512
+} Hyper_Map_Info, *PHyper_Map_Info;
+
+typedef struct _LD_STATUS
+{
+ MV_U8            Status;          /* Refer to LD_STATUS_xxx */
+ MV_U8            Bga;             /* Refer to LD_BGA_xxx */
+ MV_U16           BgaPercentage;   /* xx% */
+ MV_U8            BgaState;        /* Refer to LD_BGA_STATE_xxx */
+ MV_U8            BgaExt;          /* Not used yet. Extention of Bga. */
+ MV_U16           LDID;
+} LD_Status, *PLD_Status;
+
+#define      LD_CONFIG_MODE_NORMAL_REBUILD         0
+#define      LD_CONFIG_MODE_INTELLIGENT_REBUILD    1
+
+typedef struct    _LD_Config
+{
+ MV_U8            CacheMode;        /* See definition 4.4.1 CacheMode_xxx */
+ MV_U8            HypperWaterMark;        
+ MV_BOOLEAN       AutoRebuildOn;    /* 1- AutoRebuild On */
+ MV_U8            Status;
+ MV_U16           LDID;
+ MV_U8            HyperRebuildMode; // LD_CONFIG_MODE_XXX
+ MV_U8            Reserved2;
+
+ MV_U8            Name[LD_MAX_NAME_LENGTH];
+}LD_Config, * PLD_Config;
+
+typedef struct _VD_HDD_Link
+{
+ MV_U16            VDID;
+ MV_U16            HDD;
+ MV_U8             Reserved[4];
+} VD_HDD_Link, *PVD_HDD_Link;
+
+#if defined(CACHE_MODULE_SUPPORT) || defined(SUPPORT_MODULE_CONSOLIDATE)
+typedef struct _LD_CACHE_STATUS
+{
+ MV_BOOLEAN       IsOnline;
+ MV_U8            CachePolicy;
+ MV_U16           StripeUnitSize;
+ MV_U32           StripeSize;
+ MV_U8            Sector_Coefficient;
+ MV_U8            RAID_Level;
+ MV_U8            IsSSD;
+ MV_U8            Reserved[5];
+ MV_LBA           MAX_LBA;
+#ifdef _DDR_BBU_ENABLE
+ MV_U8    LD_GUID[MV_GUID_SIZE];
+#endif
+#ifdef HAVE_RAID_NATIVE_4K
+ MV_U32           SectorSize;
+#endif
+}
+LD_CACHE_STATUS, *PLD_CACHE_STATUS;
+#endif /* CACHE_MODULE_SUPPORT */
+
+#ifndef _OS_BIOS
+#pragma pack()
+#endif /* _OS_BIOS */
+#endif
+
+#endif
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/csmisas.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/csmisas.h
--- linux-3.10.69/drivers/scsi/mv/include/csmisas.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/csmisas.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,1224 @@
+/**************************************************************************
+
+Module Name:
+
+   CSMISAS.H
+
+
+Abstract:
+
+   This file contains constants and data structure definitions used by drivers
+   that support the Common Storage Management Interface specification for
+   SAS or SATA in either the Windows or Linux.
+
+   This should be considered as a reference implementation only.  Changes may
+   be necessary to accommodate a specific build environment or target OS.
+
+Revision History:
+
+   001  SEF   8/12/03  Initial release.
+   002  SEF   8/20/03  Cleanup to match documentation.
+   003  SEF   9/12/03  Additional cleanup, created combined header
+   004  SEF   9/23/03  Changed base types to match linux defaults
+                       Added RAID signature
+                       Added bControllerFlags to CSMI_SAS_CNTLR_CONFIG
+                       Changed CSMI_SAS_BEGIN_PACK to 8 for common structures
+                       Fixed other typos identified in first compilation test
+   005  SEF  10/03/03  Additions to match first version of CSMI document
+   006  SEF  10/14/03  Fixed typedef struct _CSMI_SAS_SMP_PASSTHRU_BUFFER
+                       Added defines for bConnectionRate
+   007  SEF  10/15/03  Added Firmware Download Control Code and support
+                       Added CSMI revision support
+   008  SEF  10/30/03  No functional change, just updated version to track
+                       spec changes
+   009  SEF  12/09/03  No functional change, just updated version to track
+                       spec changes
+   010  SEF   3/11/04  Fixed typedef struct CSMI_SAS_RAID_DRIVES to include the
+                       bFirmware member that is defined in the spec, but
+                       was missing in this file,
+                       added CC_CSMI_SAS_TASK_MANAGEMENT
+   011  SEF   4/02/04  No functional change, added comment line before
+                       CC_CSMI_SAS_TASK_MANAGEMENT
+   012  SEF   4/16/04  Added IOControllerNumber to linux header,
+                       Modified linux control codes to have upper word of
+                       0xCC77.... to indicate CSMI version 77
+                       Added bSignalClass to CC_CSMI_SET_PHY_INFO
+                       Added CC_CSMI_SAS_PHY_CONTROL support
+   013  SEF   5/14/04  Added CC_CSMI_SAS_GET_CONNECTOR_INFO support
+   014  SEF   5/24/04  No functional change, just updated version to track spec
+                       changes
+   015  SEF   6/16/04  changed bPinout to uPinout to reflect proper size,
+                       changed width of bLocation defines to reflect size
+   016  SEF   6/17/04  changed bLengthOfControls in CSMI_SAS_PHY_CONTROL
+                       to be proper size
+   017  SEF   9/17/04  added CSMI_SAS_SATA_PORT_SELECTOR,
+                       CSMI_SAS_LINK_VIRTUAL, CSMI_SAS_CON_NOT_PRESENT, and
+                       CSMI_SAS_CON_NOT_CONNECTED
+   018  SEF   9/20/04  added CSMI_SAS_PHY_USER_PATTERN,
+                       changed definition of CSMI_SAS_PHY_FIXED_PATTERN to not
+                       conflict with activate definition
+   019  SEF  12/06/04  added CSMI_SAS_GET_LOCATION
+                       added bSSPStatus to CSMI_SAS_SSP_PASSTHRU_STATUS
+                       structure
+
+**************************************************************************/
+
+#ifndef _CSMI_SAS_H_
+#define _CSMI_SAS_H_
+
+// CSMI Specification Revision, the intent is that all versions of the
+// specification will be backward compatible after the 1.00 release.
+// Major revision number, corresponds to xxxx. of CSMI specification
+// Minor revision number, corresponds to .xxxx of CSMI specification
+#define CSMI_MAJOR_REVISION   0
+#define CSMI_MINOR_REVISION   83
+
+/*************************************************************************/
+/* TARGET OS LINUX SPECIFIC CODE                                         */
+/*************************************************************************/
+
+// EDM #ifdef _linux
+#ifdef __KERNEL__
+
+
+// Linux base types
+
+#include <linux/types.h>
+
+// pack definition
+
+// EDM #define CSMI_SAS_BEGIN_PACK(x)    pack(x)
+// EDM #define CSMI_SAS_END_PACK         pack()
+
+// IOCTL Control Codes
+// (IoctlHeader.ControlCode)
+
+// Control Codes prior to 0.77
+
+// Control Codes requiring CSMI_ALL_SIGNATURE
+
+// #define CC_CSMI_SAS_GET_DRIVER_INFO    0x12345678
+// #define CC_CSMI_SAS_GET_CNTLR_CONFIG   0x23456781
+// #define CC_CSMI_SAS_GET_CNTLR_STATUS   0x34567812
+// #define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  0x92345678
+
+// Control Codes requiring CSMI_RAID_SIGNATURE
+
+// #define CC_CSMI_SAS_GET_RAID_INFO      0x45678123
+// #define CC_CSMI_SAS_GET_RAID_CONFIG    0x56781234
+
+// Control Codes requiring CSMI_SAS_SIGNATURE
+
+// #define CC_CSMI_SAS_GET_PHY_INFO       0x67812345
+// #define CC_CSMI_SAS_SET_PHY_INFO       0x78123456
+// #define CC_CSMI_SAS_GET_LINK_ERRORS    0x81234567
+// #define CC_CSMI_SAS_SMP_PASSTHRU       0xA1234567
+// #define CC_CSMI_SAS_SSP_PASSTHRU       0xB1234567
+// #define CC_CSMI_SAS_STP_PASSTHRU       0xC1234567
+// #define CC_CSMI_SAS_GET_SATA_SIGNATURE 0xD1234567
+// #define CC_CSMI_SAS_GET_SCSI_ADDRESS   0xE1234567
+// #define CC_CSMI_SAS_GET_DEVICE_ADDRESS 0xF1234567
+// #define CC_CSMI_SAS_TASK_MANAGEMENT    0xA2345678
+
+// Control Codes for 0.77 and later
+
+// Control Codes requiring CSMI_ALL_SIGNATURE
+
+#define CC_CSMI_SAS_GET_DRIVER_INFO    0xCC770001
+#define CC_CSMI_SAS_GET_CNTLR_CONFIG   0xCC770002
+#define CC_CSMI_SAS_GET_CNTLR_STATUS   0xCC770003
+#define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  0xCC770004
+
+// Control Codes requiring CSMI_RAID_SIGNATURE
+
+#define CC_CSMI_SAS_GET_RAID_INFO      0xCC77000A
+#define CC_CSMI_SAS_GET_RAID_CONFIG    0xCC77000B
+
+// Control Codes requiring CSMI_SAS_SIGNATURE
+
+#define CC_CSMI_SAS_GET_PHY_INFO       0xCC770014
+#define CC_CSMI_SAS_SET_PHY_INFO       0xCC770015
+#define CC_CSMI_SAS_GET_LINK_ERRORS    0xCC770016
+#define CC_CSMI_SAS_SMP_PASSTHRU       0xCC770017
+#define CC_CSMI_SAS_SSP_PASSTHRU       0xCC770018
+#define CC_CSMI_SAS_STP_PASSTHRU       0xCC770019
+#define CC_CSMI_SAS_GET_SATA_SIGNATURE 0xCC770020
+#define CC_CSMI_SAS_GET_SCSI_ADDRESS   0xCC770021
+#define CC_CSMI_SAS_GET_DEVICE_ADDRESS 0xCC770022
+#define CC_CSMI_SAS_TASK_MANAGEMENT    0xCC770023
+#define CC_CSMI_SAS_GET_CONNECTOR_INFO 0xCC770024
+#define CC_CSMI_SAS_GET_LOCATION       0xCC770025
+
+// Control Codes requiring CSMI_PHY_SIGNATURE
+
+#define CC_CSMI_SAS_PHY_CONTROL        0xCC77003C
+
+// EDM #pragma CSMI_SAS_BEGIN_PACK(8)
+#pragma pack(8)
+
+// IOCTL_HEADER
+typedef struct _IOCTL_HEADER {
+	__u32 IOControllerNumber;
+	__u32 Length;
+	__u32 ReturnCode;
+	__u32 Timeout;
+	__u16 Direction;
+} IOCTL_HEADER, *PIOCTL_HEADER;
+
+// EDM #pragma CSMI_SAS_END_PACK
+#pragma pack()
+
+#endif
+
+#define __i8    char
+
+/*************************************************************************/
+/* TARGET OS WINDOWS SPECIFIC CODE                                       */
+/*************************************************************************/
+
+#ifdef _WIN32
+
+// windows IOCTL definitions
+
+#ifndef _NTDDSCSIH_
+#include <ntddscsi.h>
+#endif
+
+// pack definition
+
+#if defined _MSC_VER
+   #define CSMI_SAS_BEGIN_PACK(x)    pack(push,x)
+   #define CSMI_SAS_END_PACK         pack(pop)
+#elif defined __BORLANDC__
+   #define CSMI_SAS_BEGIN_PACK(x)    option -a##x
+   #define CSMI_SAS_END_PACK         option -a.
+#else
+   #error "CSMISAS.H - Must externally define a pack compiler designator."
+#endif
+
+// base types
+
+#define __u8    unsigned char
+#define __u32   unsigned long
+#define __u16   unsigned short
+
+#define __i8    char
+
+// IOCTL Control Codes
+// (IoctlHeader.ControlCode)
+
+// Control Codes requiring CSMI_ALL_SIGNATURE
+
+#define CC_CSMI_SAS_GET_DRIVER_INFO    1
+#define CC_CSMI_SAS_GET_CNTLR_CONFIG   2
+#define CC_CSMI_SAS_GET_CNTLR_STATUS   3
+#define CC_CSMI_SAS_FIRMWARE_DOWNLOAD  4
+
+// Control Codes requiring CSMI_RAID_SIGNATURE
+
+#define CC_CSMI_SAS_GET_RAID_INFO      10
+#define CC_CSMI_SAS_GET_RAID_CONFIG    11
+
+// Control Codes requiring CSMI_SAS_SIGNATURE
+
+#define CC_CSMI_SAS_GET_PHY_INFO       20
+#define CC_CSMI_SAS_SET_PHY_INFO       21
+#define CC_CSMI_SAS_GET_LINK_ERRORS    22
+#define CC_CSMI_SAS_SMP_PASSTHRU       23
+#define CC_CSMI_SAS_SSP_PASSTHRU       24
+#define CC_CSMI_SAS_STP_PASSTHRU       25
+#define CC_CSMI_SAS_GET_SATA_SIGNATURE 26
+#define CC_CSMI_SAS_GET_SCSI_ADDRESS   27
+#define CC_CSMI_SAS_GET_DEVICE_ADDRESS 28
+#define CC_CSMI_SAS_TASK_MANAGEMENT    29
+#define CC_CSMI_SAS_GET_CONNECTOR_INFO 30
+#define CC_CSMI_SAS_GET_LOCATION       31
+
+// Control Codes requiring CSMI_PHY_SIGNATURE
+
+#define CC_CSMI_SAS_PHY_CONTROL        60
+
+#define IOCTL_HEADER SRB_IO_CONTROL
+#define PIOCTL_HEADER PSRB_IO_CONTROL
+
+#else /* _WIN32 */
+#define _WIN32                          0
+#endif /* _WIN32 */
+
+/*************************************************************************/
+/* TARGET OS NOT DEFINED ERROR                                           */
+/*************************************************************************/
+
+// EDM #if (!_WIN32 && !_linux)
+#if (!_WIN32 && !__KERNEL__)
+   #error "Unknown target OS."
+#endif
+
+/*************************************************************************/
+/* OS INDEPENDENT CODE                                                   */
+/*************************************************************************/
+
+/* * * * * * * * * * Class Independent IOCTL Constants * * * * * * * * * */
+
+// Return codes for all IOCTL's regardless of class
+// (IoctlHeader.ReturnCode)
+
+#define CSMI_SAS_STATUS_SUCCESS              0
+#define CSMI_SAS_STATUS_FAILED               1
+#define CSMI_SAS_STATUS_BAD_CNTL_CODE        2
+#define CSMI_SAS_STATUS_INVALID_PARAMETER    3
+#define CSMI_SAS_STATUS_WRITE_ATTEMPTED      4
+
+// Signature value
+// (IoctlHeader.Signature)
+
+#define CSMI_ALL_SIGNATURE    "CSMIALL"
+
+// Timeout value default of 60 seconds
+// (IoctlHeader.Timeout)
+
+#define CSMI_ALL_TIMEOUT      60
+
+//  Direction values for data flow on this IOCTL
+// (IoctlHeader.Direction, Linux only)
+#define CSMI_SAS_DATA_READ    0
+#define CSMI_SAS_DATA_WRITE   1
+
+// I/O Bus Types
+// ISA and EISA bus types are not supported
+// (bIoBusType)
+
+#define CSMI_SAS_BUS_TYPE_PCI       3
+#define CSMI_SAS_BUS_TYPE_PCMCIA    4
+
+// Controller Status
+// (uStatus)
+
+#define CSMI_SAS_CNTLR_STATUS_GOOD     1
+#define CSMI_SAS_CNTLR_STATUS_FAILED   2
+#define CSMI_SAS_CNTLR_STATUS_OFFLINE  3
+#define CSMI_SAS_CNTLR_STATUS_POWEROFF 4
+
+// Offline Status Reason
+// (uOfflineReason)
+
+#define CSMI_SAS_OFFLINE_REASON_NO_REASON             0
+#define CSMI_SAS_OFFLINE_REASON_INITIALIZING          1
+#define CSMI_SAS_OFFLINE_REASON_BACKSIDE_BUS_DEGRADED 2
+#define CSMI_SAS_OFFLINE_REASON_BACKSIDE_BUS_FAILURE  3
+
+// Controller Class
+// (bControllerClass)
+
+#define CSMI_SAS_CNTLR_CLASS_HBA    5
+
+// Controller Flag bits
+// (uControllerFlags)
+
+#define CSMI_SAS_CNTLR_SAS_HBA   0x00000001
+#define CSMI_SAS_CNTLR_SAS_RAID  0x00000002
+#define CSMI_SAS_CNTLR_SATA_HBA  0x00000004
+#define CSMI_SAS_CNTLR_SATA_RAID 0x00000008
+
+// for firmware download
+#define CSMI_SAS_CNTLR_FWD_SUPPORT  0x00010000
+#define CSMI_SAS_CNTLR_FWD_ONLINE   0x00020000
+#define CSMI_SAS_CNTLR_FWD_SRESET   0x00040000
+#define CSMI_SAS_CNTLR_FWD_HRESET   0x00080000
+#define CSMI_SAS_CNTLR_FWD_RROM     0x00100000
+
+// Download Flag bits
+// (uDownloadFlags)
+#define CSMI_SAS_FWD_VALIDATE       0x00000001
+#define CSMI_SAS_FWD_SOFT_RESET     0x00000002
+#define CSMI_SAS_FWD_HARD_RESET     0x00000004
+
+// Firmware Download Status
+// (usStatus)
+#define CSMI_SAS_FWD_SUCCESS        0
+#define CSMI_SAS_FWD_FAILED         1
+#define CSMI_SAS_FWD_USING_RROM     2
+#define CSMI_SAS_FWD_REJECT         3
+#define CSMI_SAS_FWD_DOWNREV        4
+
+// Firmware Download Severity
+// (usSeverity>
+#define CSMI_SAS_FWD_INFORMATION    0
+#define CSMI_SAS_FWD_WARNING        1
+#define CSMI_SAS_FWD_ERROR          2
+#define CSMI_SAS_FWD_FATAL          3
+
+/* * * * * * * * * * SAS RAID Class IOCTL Constants  * * * * * * * * */
+
+// Return codes for the RAID IOCTL's regardless of class
+// (IoctlHeader.ControlCode)
+
+#define CSMI_SAS_RAID_SET_OUT_OF_RANGE       1000
+
+// Signature value
+// (IoctlHeader.Signature)
+
+#define CSMI_RAID_SIGNATURE    "CSMIARY"
+
+// Timeout value default of 60 seconds
+// (IoctlHeader.Timeout)
+
+#define CSMI_RAID_TIMEOUT      60
+
+// RAID Types
+// (bRaidType)
+#define CSMI_SAS_RAID_TYPE_NONE     0
+#define CSMI_SAS_RAID_TYPE_0        1
+#define CSMI_SAS_RAID_TYPE_1        2
+#define CSMI_SAS_RAID_TYPE_10       3
+#define CSMI_SAS_RAID_TYPE_5        4
+#define CSMI_SAS_RAID_TYPE_15       5
+#define CSMI_SAS_RAID_TYPE_OTHER    255
+
+// RAID Status
+// (bStatus)
+#define CSMI_SAS_RAID_SET_STATUS_OK          0
+#define CSMI_SAS_RAID_SET_STATUS_DEGRADED    1
+#define CSMI_SAS_RAID_SET_STATUS_REBUILDING  2
+#define CSMI_SAS_RAID_SET_STATUS_FAILED      3
+#define CSMI_SAS_RAID_SET_STATUS_PARTIALLYOPTIMAL	4
+
+// RAID Drive Status
+// (bDriveStatus)
+#define CSMI_SAS_DRIVE_STATUS_OK          0
+#define CSMI_SAS_DRIVE_STATUS_REBUILDING  1
+#define CSMI_SAS_DRIVE_STATUS_FAILED      2
+#define CSMI_SAS_DRIVE_STATUS_DEGRADED    3
+
+// RAID Drive Usage
+// (bDriveUsage)
+#define CSMI_SAS_DRIVE_CONFIG_NOT_USED 0
+#define CSMI_SAS_DRIVE_CONFIG_MEMBER   1
+#define CSMI_SAS_DRIVE_CONFIG_SPARE    2
+
+/* * * * * * * * * * SAS HBA Class IOCTL Constants * * * * * * * * * */
+
+// Return codes for SAS IOCTL's
+// (IoctlHeader.ReturnCode)
+
+#define CSMI_SAS_PHY_INFO_CHANGED            CSMI_SAS_STATUS_SUCCESS
+#define CSMI_SAS_PHY_INFO_NOT_CHANGEABLE     2000
+#define CSMI_SAS_LINK_RATE_OUT_OF_RANGE      2001
+
+#define CSMI_SAS_PHY_DOES_NOT_EXIST          2002
+#define CSMI_SAS_PHY_DOES_NOT_MATCH_PORT     2003
+#define CSMI_SAS_PHY_CANNOT_BE_SELECTED      2004
+#define CSMI_SAS_SELECT_PHY_OR_PORT          2005
+#define CSMI_SAS_PORT_DOES_NOT_EXIST         2006
+#define CSMI_SAS_PORT_CANNOT_BE_SELECTED     2007
+#define CSMI_SAS_CONNECTION_FAILED           2008
+
+#define CSMI_SAS_NO_SATA_DEVICE              2009
+#define CSMI_SAS_NO_SATA_SIGNATURE           2010
+#define CSMI_SAS_SCSI_EMULATION              2011
+#define CSMI_SAS_NOT_AN_END_DEVICE           2012
+#define CSMI_SAS_NO_SCSI_ADDRESS             2013
+#define CSMI_SAS_NO_DEVICE_ADDRESS           2014
+
+// Signature value
+// (IoctlHeader.Signature)
+
+#define CSMI_SAS_SIGNATURE    "CSMISAS"
+
+// Timeout value default of 60 seconds
+// (IoctlHeader.Timeout)
+
+#define CSMI_SAS_TIMEOUT      60
+
+// Device types
+// (bDeviceType)
+
+#define CSMI_SAS_PHY_UNUSED               0x00
+#define CSMI_SAS_NO_DEVICE_ATTACHED       0x00
+#define CSMI_SAS_END_DEVICE               0x10
+#define CSMI_SAS_EDGE_EXPANDER_DEVICE     0x20
+#define CSMI_SAS_FANOUT_EXPANDER_DEVICE   0x30
+
+// Protocol options
+// (bInitiatorPortProtocol, bTargetPortProtocol)
+
+#define CSMI_SAS_PROTOCOL_SATA   0x01
+#define CSMI_SAS_PROTOCOL_SMP    0x02
+#define CSMI_SAS_PROTOCOL_STP    0x04
+#define CSMI_SAS_PROTOCOL_SSP    0x08
+
+// Negotiated and hardware link rates
+// (bNegotiatedLinkRate, bMinimumLinkRate, bMaximumLinkRate)
+
+#define CSMI_SAS_LINK_RATE_UNKNOWN  0x00
+#define CSMI_SAS_PHY_DISABLED       0x01
+#define CSMI_SAS_LINK_RATE_FAILED   0x02
+#define CSMI_SAS_SATA_SPINUP_HOLD   0x03
+#define CSMI_SAS_SATA_PORT_SELECTOR 0x04
+#define CSMI_SAS_LINK_RATE_1_5_GBPS 0x08
+#define CSMI_SAS_LINK_RATE_3_0_GBPS 0x09
+#define CSMI_SAS_LINK_VIRTUAL       0x10
+
+// Discover state
+// (bAutoDiscover)
+
+#define CSMI_SAS_DISCOVER_NOT_SUPPORTED   0x00
+#define CSMI_SAS_DISCOVER_NOT_STARTED     0x01
+#define CSMI_SAS_DISCOVER_IN_PROGRESS     0x02
+#define CSMI_SAS_DISCOVER_COMPLETE        0x03
+#define CSMI_SAS_DISCOVER_ERROR           0x04
+
+// Programmed link rates
+// (bMinimumLinkRate, bMaximumLinkRate)
+// (bProgrammedMinimumLinkRate, bProgrammedMaximumLinkRate)
+
+#define CSMI_SAS_PROGRAMMED_LINK_RATE_UNCHANGED 0x00
+#define CSMI_SAS_PROGRAMMED_LINK_RATE_1_5_GBPS  0x08
+#define CSMI_SAS_PROGRAMMED_LINK_RATE_3_0_GBPS  0x09
+
+// Link rate
+// (bNegotiatedLinkRate in CSMI_SAS_SET_PHY_INFO)
+
+#define CSMI_SAS_LINK_RATE_NEGOTIATE      0x00
+#define CSMI_SAS_LINK_RATE_PHY_DISABLED   0x01
+
+// Signal class
+// (bSignalClass in CSMI_SAS_SET_PHY_INFO)
+
+#define CSMI_SAS_SIGNAL_CLASS_UNKNOWN     0x00
+#define CSMI_SAS_SIGNAL_CLASS_DIRECT      0x01
+#define CSMI_SAS_SIGNAL_CLASS_SERVER      0x02
+#define CSMI_SAS_SIGNAL_CLASS_ENCLOSURE   0x03
+
+// Link error reset
+// (bResetCounts)
+
+#define CSMI_SAS_LINK_ERROR_DONT_RESET_COUNTS   0x00
+#define CSMI_SAS_LINK_ERROR_RESET_COUNTS        0x01
+
+// Phy identifier
+// (bPhyIdentifier)
+
+#define CSMI_SAS_USE_PORT_IDENTIFIER   0xFF
+
+// Port identifier
+// (bPortIdentifier)
+
+#define CSMI_SAS_IGNORE_PORT           0xFF
+
+// Programmed link rates
+// (bConnectionRate)
+
+#define CSMI_SAS_LINK_RATE_NEGOTIATED  0x00
+#define CSMI_SAS_LINK_RATE_1_5_GBPS    0x08
+#define CSMI_SAS_LINK_RATE_3_0_GBPS    0x09
+
+// Connection status
+// (bConnectionStatus)
+
+#define CSMI_SAS_OPEN_ACCEPT                          0
+#define CSMI_SAS_OPEN_REJECT_BAD_DESTINATION          1
+#define CSMI_SAS_OPEN_REJECT_RATE_NOT_SUPPORTED       2
+#define CSMI_SAS_OPEN_REJECT_NO_DESTINATION           3
+#define CSMI_SAS_OPEN_REJECT_PATHWAY_BLOCKED          4
+#define CSMI_SAS_OPEN_REJECT_PROTOCOL_NOT_SUPPORTED   5
+#define CSMI_SAS_OPEN_REJECT_RESERVE_ABANDON          6
+#define CSMI_SAS_OPEN_REJECT_RESERVE_CONTINUE         7
+#define CSMI_SAS_OPEN_REJECT_RESERVE_INITIALIZE       8
+#define CSMI_SAS_OPEN_REJECT_RESERVE_STOP             9
+#define CSMI_SAS_OPEN_REJECT_RETRY                    10
+#define CSMI_SAS_OPEN_REJECT_STP_RESOURCES_BUSY       11
+#define CSMI_SAS_OPEN_REJECT_WRONG_DESTINATION        12
+
+// SSP Status
+// (bSSPStatus)
+
+#define CSMI_SAS_SSP_STATUS_UNKNOWN     0x00
+#define CSMI_SAS_SSP_STATUS_WAITING     0x01
+#define CSMI_SAS_SSP_STATUS_COMPLETED   0x02
+#define CSMI_SAS_SSP_STATUS_FATAL_ERROR 0x03
+#define CSMI_SAS_SSP_STATUS_RETRY       0x04
+#define CSMI_SAS_SSP_STATUS_NO_TAG      0x05
+
+// SSP Flags
+// (uFlags)
+
+#define CSMI_SAS_SSP_READ           0x00000001
+#define CSMI_SAS_SSP_WRITE          0x00000002
+#define CSMI_SAS_SSP_UNSPECIFIED    0x00000004
+
+#define CSMI_SAS_SSP_TASK_ATTRIBUTE_SIMPLE         0x00000000
+#define CSMI_SAS_SSP_TASK_ATTRIBUTE_HEAD_OF_QUEUE  0x00000010
+#define CSMI_SAS_SSP_TASK_ATTRIBUTE_ORDERED        0x00000020
+#define CSMI_SAS_SSP_TASK_ATTRIBUTE_ACA            0x00000040
+
+// SSP Data present
+// (bDataPresent)
+
+#define CSMI_SAS_SSP_NO_DATA_PRESENT         0x00
+#define CSMI_SAS_SSP_RESPONSE_DATA_PRESENT   0x01
+#define CSMI_SAS_SSP_SENSE_DATA_PRESENT      0x02
+
+// STP Flags
+// (uFlags)
+
+#define CSMI_SAS_STP_READ           0x00000001
+#define CSMI_SAS_STP_WRITE          0x00000002
+#define CSMI_SAS_STP_UNSPECIFIED    0x00000004
+#define CSMI_SAS_STP_PIO            0x00000010
+#define CSMI_SAS_STP_DMA            0x00000020
+#define CSMI_SAS_STP_PACKET         0x00000040
+#define CSMI_SAS_STP_DMA_QUEUED     0x00000080
+#define CSMI_SAS_STP_EXECUTE_DIAG   0x00000100
+#define CSMI_SAS_STP_RESET_DEVICE   0x00000200
+
+// Task Management Flags
+// (uFlags)
+
+#define CSMI_SAS_TASK_IU               0x00000001
+#define CSMI_SAS_HARD_RESET_SEQUENCE   0x00000002
+#define CSMI_SAS_SUPPRESS_RESULT       0x00000004
+
+// Task Management Functions
+// (bTaskManagement)
+
+#define CSMI_SAS_SSP_ABORT_TASK           0x01
+#define CSMI_SAS_SSP_ABORT_TASK_SET       0x02
+#define CSMI_SAS_SSP_CLEAR_TASK_SET       0x04
+#define CSMI_SAS_SSP_LOGICAL_UNIT_RESET   0x08
+#define CSMI_SAS_SSP_CLEAR_ACA            0x40
+#define CSMI_SAS_SSP_QUERY_TASK           0x80
+
+// Task Management Information
+// (uInformation)
+
+#define CSMI_SAS_SSP_TEST           1
+#define CSMI_SAS_SSP_EXCEEDED       2
+#define CSMI_SAS_SSP_DEMAND         3
+#define CSMI_SAS_SSP_TRIGGER        4
+
+// Connector Pinout Information
+// (uPinout)
+
+#define CSMI_SAS_CON_UNKNOWN              0x00000001
+#define CSMI_SAS_CON_SFF_8482             0x00000002
+#define CSMI_SAS_CON_SFF_8470_LANE_1      0x00000100
+#define CSMI_SAS_CON_SFF_8470_LANE_2      0x00000200
+#define CSMI_SAS_CON_SFF_8470_LANE_3      0x00000400
+#define CSMI_SAS_CON_SFF_8470_LANE_4      0x00000800
+#define CSMI_SAS_CON_SFF_8484_LANE_1      0x00010000
+#define CSMI_SAS_CON_SFF_8484_LANE_2      0x00020000
+#define CSMI_SAS_CON_SFF_8484_LANE_3      0x00040000
+#define CSMI_SAS_CON_SFF_8484_LANE_4      0x00080000
+
+// Connector Location Information
+// (bLocation)
+
+// same as uPinout above...
+// #define CSMI_SAS_CON_UNKNOWN              0x01
+#define CSMI_SAS_CON_INTERNAL             0x02
+#define CSMI_SAS_CON_EXTERNAL             0x04
+#define CSMI_SAS_CON_SWITCHABLE           0x08
+#define CSMI_SAS_CON_AUTO                 0x10
+#define CSMI_SAS_CON_NOT_PRESENT          0x20
+#define CSMI_SAS_CON_NOT_CONNECTED        0x80
+
+// Device location identification
+// (bIdentify)
+
+#define CSMI_SAS_LOCATE_UNKNOWN           0x00
+#define CSMI_SAS_LOCATE_FORCE_OFF         0x01
+#define CSMI_SAS_LOCATE_FORCE_ON          0x02
+
+// Location Valid flags
+// (uLocationFlags)
+
+#define CSMI_SAS_LOCATE_SAS_ADDRESS_VALID           0x00000001
+#define CSMI_SAS_LOCATE_SAS_LUN_VALID               0x00000002
+#define CSMI_SAS_LOCATE_ENCLOSURE_IDENTIFIER_VALID  0x00000004
+#define CSMI_SAS_LOCATE_ENCLOSURE_NAME_VALID        0x00000008
+#define CSMI_SAS_LOCATE_BAY_PREFIX_VALID            0x00000010
+#define CSMI_SAS_LOCATE_BAY_IDENTIFIER_VALID        0x00000020
+#define CSMI_SAS_LOCATE_LOCATION_STATE_VALID        0x00000040
+
+/* * * * * * * * SAS Phy Control Class IOCTL Constants * * * * * * * * */
+
+// Return codes for SAS Phy Control IOCTL's
+// (IoctlHeader.ReturnCode)
+
+// Signature value
+// (IoctlHeader.Signature)
+
+#define CSMI_PHY_SIGNATURE    "CSMIPHY"
+
+// Phy Control Functions
+// (bFunction)
+
+// values 0x00 to 0xFF are consistent in definition with the SMP PHY CONTROL
+// function defined in the SAS spec
+#define CSMI_SAS_PC_NOP                   0x00000000
+#define CSMI_SAS_PC_LINK_RESET            0x00000001
+#define CSMI_SAS_PC_HARD_RESET            0x00000002
+#define CSMI_SAS_PC_PHY_DISABLE           0x00000003
+// 0x04 to 0xFF reserved...
+#define CSMI_SAS_PC_GET_PHY_SETTINGS      0x00000100
+
+// Link Flags
+#define CSMI_SAS_PHY_ACTIVATE_CONTROL     0x00000001
+#define CSMI_SAS_PHY_UPDATE_SPINUP_RATE   0x00000002
+#define CSMI_SAS_PHY_AUTO_COMWAKE         0x00000004
+
+// Device Types for Phy Settings
+// (bType)
+#define CSMI_SAS_UNDEFINED 0x00
+#define CSMI_SAS_SATA      0x01
+#define CSMI_SAS_SAS       0x02
+
+// Transmitter Flags
+// (uTransmitterFlags)
+#define CSMI_SAS_PHY_PREEMPHASIS_DISABLED    0x00000001
+
+// Receiver Flags
+// (uReceiverFlags)
+#define CSMI_SAS_PHY_EQUALIZATION_DISABLED   0x00000001
+
+// Pattern Flags
+// (uPatternFlags)
+// #define CSMI_SAS_PHY_ACTIVATE_CONTROL     0x00000001
+#define CSMI_SAS_PHY_DISABLE_SCRAMBLING      0x00000002
+#define CSMI_SAS_PHY_DISABLE_ALIGN           0x00000004
+#define CSMI_SAS_PHY_DISABLE_SSC             0x00000008
+
+#define CSMI_SAS_PHY_FIXED_PATTERN           0x00000010
+#define CSMI_SAS_PHY_USER_PATTERN            0x00000020
+
+// Fixed Patterns
+// (bFixedPattern)
+#define CSMI_SAS_PHY_CJPAT                   0x00000001
+#define CSMI_SAS_PHY_ALIGN                   0x00000002
+
+// Type Flags
+// (bTypeFlags)
+#define CSMI_SAS_PHY_POSITIVE_DISPARITY      0x01
+#define CSMI_SAS_PHY_NEGATIVE_DISPARITY      0x02
+#define CSMI_SAS_PHY_CONTROL_CHARACTER       0x04
+
+// Miscellaneous
+#define SLOT_NUMBER_UNKNOWN   0xFFFF
+
+/*************************************************************************/
+/* DATA STRUCTURES                                                       */
+/*************************************************************************/
+
+/* * * * * * * * * * Class Independent Structures * * * * * * * * * */
+
+// EDM #pragma CSMI_SAS_BEGIN_PACK(8)
+#pragma pack(8)
+
+// CC_CSMI_SAS_DRIVER_INFO
+
+typedef struct _CSMI_SAS_DRIVER_INFO {
+   __u8  szName[81];
+   __u8  szDescription[81];
+   __u16 usMajorRevision;
+   __u16 usMinorRevision;
+   __u16 usBuildRevision;
+   __u16 usReleaseRevision;
+   __u16 usCSMIMajorRevision;
+   __u16 usCSMIMinorRevision;
+} CSMI_SAS_DRIVER_INFO,
+  *PCSMI_SAS_DRIVER_INFO;
+
+typedef struct _CSMI_SAS_DRIVER_INFO_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_DRIVER_INFO Information;
+} CSMI_SAS_DRIVER_INFO_BUFFER,
+  *PCSMI_SAS_DRIVER_INFO_BUFFER;
+
+// CC_CSMI_SAS_CNTLR_CONFIGURATION
+
+typedef struct _CSMI_SAS_PCI_BUS_ADDRESS {
+   __u8  bBusNumber;
+   __u8  bDeviceNumber;
+   __u8  bFunctionNumber;
+   __u8  bReserved;
+} CSMI_SAS_PCI_BUS_ADDRESS,
+  *PCSMI_SAS_PCI_BUS_ADDRESS;
+
+typedef union _CSMI_SAS_IO_BUS_ADDRESS {
+   CSMI_SAS_PCI_BUS_ADDRESS PciAddress;
+   __u8  bReserved[32];
+} CSMI_SAS_IO_BUS_ADDRESS,
+  *PCSMI_SAS_IO_BUS_ADDRESS;
+
+typedef struct _CSMI_SAS_CNTLR_CONFIG {
+   __u32 uBaseIoAddress;
+   struct {
+      __u32 uLowPart;
+      __u32 uHighPart;
+   } BaseMemoryAddress;
+   __u32 uBoardID;
+   __u16 usSlotNumber;
+   __u8  bControllerClass;
+   __u8  bIoBusType;
+   CSMI_SAS_IO_BUS_ADDRESS BusAddress;
+   __u8  szSerialNumber[81];
+   __u16 usMajorRevision;
+   __u16 usMinorRevision;
+   __u16 usBuildRevision;
+   __u16 usReleaseRevision;
+   __u16 usBIOSMajorRevision;
+   __u16 usBIOSMinorRevision;
+   __u16 usBIOSBuildRevision;
+   __u16 usBIOSReleaseRevision;
+   __u32 uControllerFlags;
+   __u16 usRromMajorRevision;
+   __u16 usRromMinorRevision;
+   __u16 usRromBuildRevision;
+   __u16 usRromReleaseRevision;
+   __u16 usRromBIOSMajorRevision;
+   __u16 usRromBIOSMinorRevision;
+   __u16 usRromBIOSBuildRevision;
+   __u16 usRromBIOSReleaseRevision;
+   __u8  bReserved[7];
+} CSMI_SAS_CNTLR_CONFIG,
+  *PCSMI_SAS_CNTLR_CONFIG;
+
+typedef struct _CSMI_SAS_CNTLR_CONFIG_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_CNTLR_CONFIG Configuration;
+} CSMI_SAS_CNTLR_CONFIG_BUFFER,
+  *PCSMI_SAS_CNTLR_CONFIG_BUFFER;
+
+// CC_CSMI_SAS_CNTLR_STATUS
+
+typedef struct _CSMI_SAS_CNTLR_STATUS {
+   __u32 uStatus;
+   __u32 uOfflineReason;
+   __u8  bReserved[28];
+} CSMI_SAS_CNTLR_STATUS,
+  *PCSMI_SAS_CNTLR_STATUS;
+
+typedef struct _CSMI_SAS_CNTLR_STATUS_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_CNTLR_STATUS Status;
+} CSMI_SAS_CNTLR_STATUS_BUFFER,
+  *PCSMI_SAS_CNTLR_STATUS_BUFFER;
+
+// CC_CSMI_SAS_FIRMWARE_DOWNLOAD
+
+typedef struct _CSMI_SAS_FIRMWARE_DOWNLOAD {
+   __u32 uBufferLength;
+   __u32 uDownloadFlags;
+   __u8  bReserved[32];
+   __u16 usStatus;
+   __u16 usSeverity;
+} CSMI_SAS_FIRMWARE_DOWNLOAD,
+  *PCSMI_SAS_FIRMWARE_DOWNLOAD;
+
+typedef struct _CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_FIRMWARE_DOWNLOAD Information;
+   __u8  bDataBuffer[1];
+} CSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER,
+  *PCSMI_SAS_FIRMWARE_DOWNLOAD_BUFFER;
+
+// CC_CSMI_SAS_RAID_INFO
+
+typedef struct _CSMI_SAS_RAID_INFO {
+   __u32 uNumRaidSets;
+   __u32 uMaxDrivesPerSet;
+   __u8  bReserved[92];
+} CSMI_SAS_RAID_INFO,
+  *PCSMI_SAS_RAID_INFO;
+
+typedef struct _CSMI_SAS_RAID_INFO_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_RAID_INFO Information;
+} CSMI_SAS_RAID_INFO_BUFFER,
+  *PCSMI_SAS_RAID_INFO_BUFFER;
+
+// CC_CSMI_SAS_GET_RAID_CONFIG
+
+typedef struct _CSMI_SAS_RAID_DRIVES {
+   __u8  bModel[40];
+   __u8  bFirmware[8];
+   __u8  bSerialNumber[40];
+   __u8  bSASAddress[8];
+   __u8  bSASLun[8];
+   __u8  bDriveStatus;
+   __u8  bDriveUsage;
+   __u8  bReserved[30];
+} CSMI_SAS_RAID_DRIVES,
+   *PCSMI_SAS_RAID_DRIVES;
+
+typedef struct _CSMI_SAS_RAID_CONFIG {
+   __u32 uRaidSetIndex;
+   __u32 uCapacity;
+   __u32 uStripeSize;
+   __u8  bRaidType;
+   __u8  bStatus;
+   __u8  bInformation;
+   __u8  bDriveCount;
+   __u8  bReserved[20];
+   CSMI_SAS_RAID_DRIVES Drives[1];
+} CSMI_SAS_RAID_CONFIG,
+   *PCSMI_SAS_RAID_CONFIG;
+
+typedef struct _CSMI_SAS_RAID_CONFIG_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_RAID_CONFIG Configuration;
+} CSMI_SAS_RAID_CONFIG_BUFFER,
+  *PCSMI_SAS_RAID_CONFIG_BUFFER;
+
+
+/* * * * * * * * * * SAS HBA Class Structures * * * * * * * * * */
+
+// CC_CSMI_SAS_GET_PHY_INFO
+
+typedef struct _CSMI_SAS_IDENTIFY {
+   __u8  bDeviceType;
+   __u8  bRestricted;
+   __u8  bInitiatorPortProtocol;
+   __u8  bTargetPortProtocol;
+   __u8  bRestricted2[8];
+   __u8  bSASAddress[8];
+   __u8  bPhyIdentifier;
+   __u8  bSignalClass;
+   __u8  bReserved[6];
+} CSMI_SAS_IDENTIFY,
+  *PCSMI_SAS_IDENTIFY;
+
+typedef struct _CSMI_SAS_PHY_ENTITY {
+   CSMI_SAS_IDENTIFY Identify;
+   __u8  bPortIdentifier;
+   __u8  bNegotiatedLinkRate;
+   __u8  bMinimumLinkRate;
+   __u8  bMaximumLinkRate;
+   __u8  bPhyChangeCount;
+   __u8  bAutoDiscover;
+   __u8  bReserved[2];
+   CSMI_SAS_IDENTIFY Attached;
+} CSMI_SAS_PHY_ENTITY,
+  *PCSMI_SAS_PHY_ENTITY;
+
+typedef struct _CSMI_SAS_PHY_INFO {
+   __u8  bNumberOfPhys;
+   __u8  bReserved[3];
+   CSMI_SAS_PHY_ENTITY Phy[32];
+} CSMI_SAS_PHY_INFO,
+  *PCSMI_SAS_PHY_INFO;
+
+typedef struct _CSMI_SAS_PHY_INFO_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_PHY_INFO Information;
+} CSMI_SAS_PHY_INFO_BUFFER,
+  *PCSMI_SAS_PHY_INFO_BUFFER;
+
+// CC_CSMI_SAS_SET_PHY_INFO
+
+typedef struct _CSMI_SAS_SET_PHY_INFO {
+   __u8  bPhyIdentifier;
+   __u8  bNegotiatedLinkRate;
+   __u8  bProgrammedMinimumLinkRate;
+   __u8  bProgrammedMaximumLinkRate;
+   __u8  bSignalClass;
+   __u8  bReserved[3];
+} CSMI_SAS_SET_PHY_INFO,
+  *PCSMI_SAS_SET_PHY_INFO;
+
+typedef struct _CSMI_SAS_SET_PHY_INFO_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_SET_PHY_INFO Information;
+} CSMI_SAS_SET_PHY_INFO_BUFFER,
+  *PCSMI_SAS_SET_PHY_INFO_BUFFER;
+
+// CC_CSMI_SAS_GET_LINK_ERRORS
+
+typedef struct _CSMI_SAS_LINK_ERRORS {
+   __u8  bPhyIdentifier;
+   __u8  bResetCounts;
+   __u8  bReserved[2];
+   __u32 uInvalidDwordCount;
+   __u32 uRunningDisparityErrorCount;
+   __u32 uLossOfDwordSyncCount;
+   __u32 uPhyResetProblemCount;
+} CSMI_SAS_LINK_ERRORS,
+  *PCSMI_SAS_LINK_ERRORS;
+
+typedef struct _CSMI_SAS_LINK_ERRORS_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_LINK_ERRORS Information;
+} CSMI_SAS_LINK_ERRORS_BUFFER,
+  *PCSMI_SAS_LINK_ERRORS_BUFFER;
+
+// CC_CSMI_SAS_SMP_PASSTHRU
+
+typedef struct _CSMI_SAS_SMP_REQUEST {
+   __u8  bFrameType;
+   __u8  bFunction;
+   __u8  bReserved[2];
+   __u8  bAdditionalRequestBytes[1016];
+} CSMI_SAS_SMP_REQUEST,
+  *PCSMI_SAS_SMP_REQUEST;
+
+typedef struct _CSMI_SAS_SMP_RESPONSE {
+   __u8  bFrameType;
+   __u8  bFunction;
+   __u8  bFunctionResult;
+   __u8  bReserved;
+   __u8  bAdditionalResponseBytes[1016];
+} CSMI_SAS_SMP_RESPONSE,
+  *PCSMI_SAS_SMP_RESPONSE;
+
+typedef struct _CSMI_SAS_SMP_PASSTHRU {
+   __u8  bPhyIdentifier;
+   __u8  bPortIdentifier;
+   __u8  bConnectionRate;
+   __u8  bReserved;
+   __u8  bDestinationSASAddress[8];
+   __u32 uRequestLength;
+   CSMI_SAS_SMP_REQUEST Request;
+   __u8  bConnectionStatus;
+   __u8  bReserved2[3];
+   __u32 uResponseBytes;
+   CSMI_SAS_SMP_RESPONSE Response;
+} CSMI_SAS_SMP_PASSTHRU,
+  *PCSMI_SAS_SMP_PASSTHRU;
+
+typedef struct _CSMI_SAS_SMP_PASSTHRU_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_SMP_PASSTHRU Parameters;
+} CSMI_SAS_SMP_PASSTHRU_BUFFER,
+  *PCSMI_SAS_SMP_PASSTHRU_BUFFER;
+
+// CC_CSMI_SAS_SSP_PASSTHRU
+
+typedef struct _CSMI_SAS_SSP_PASSTHRU {
+   __u8  bPhyIdentifier;
+   __u8  bPortIdentifier;
+   __u8  bConnectionRate;
+   __u8  bReserved;
+   __u8  bDestinationSASAddress[8];
+   __u8  bLun[8];
+   __u8  bCDBLength;
+   __u8  bAdditionalCDBLength;
+   __u8  bReserved2[2];
+   __u8  bCDB[16];
+   __u32 uFlags;
+   __u8  bAdditionalCDB[24];
+   __u32 uDataLength;
+} CSMI_SAS_SSP_PASSTHRU,
+  *PCSMI_SAS_SSP_PASSTHRU;
+
+typedef struct _CSMI_SAS_SSP_PASSTHRU_STATUS {
+   __u8  bConnectionStatus;
+   __u8  bSSPStatus;
+   __u8  bReserved[2];
+   __u8  bDataPresent;
+   __u8  bStatus;
+   __u8  bResponseLength[2];
+   __u8  bResponse[256];
+   __u32 uDataBytes;
+} CSMI_SAS_SSP_PASSTHRU_STATUS,
+  *PCSMI_SAS_SSP_PASSTHRU_STATUS;
+
+typedef struct _CSMI_SAS_SSP_PASSTHRU_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_SSP_PASSTHRU Parameters;
+   CSMI_SAS_SSP_PASSTHRU_STATUS Status;
+   __u8  bDataBuffer[1];
+} CSMI_SAS_SSP_PASSTHRU_BUFFER,
+  *PCSMI_SAS_SSP_PASSTHRU_BUFFER;
+
+// CC_CSMI_SAS_STP_PASSTHRU
+
+typedef struct _CSMI_SAS_STP_PASSTHRU {
+   __u8  bPhyIdentifier;
+   __u8  bPortIdentifier;
+   __u8  bConnectionRate;
+   __u8  bReserved;
+   __u8  bDestinationSASAddress[8];
+   __u8  bReserved2[4];
+   __u8  bCommandFIS[20];
+   __u32 uFlags;
+   __u32 uDataLength;
+} CSMI_SAS_STP_PASSTHRU,
+  *PCSMI_SAS_STP_PASSTHRU;
+
+typedef struct _CSMI_SAS_STP_PASSTHRU_STATUS {
+   __u8  bConnectionStatus;
+   __u8  bReserved[3];
+   __u8  bStatusFIS[20];
+   __u32 uSCR[16];
+   __u32 uDataBytes;
+} CSMI_SAS_STP_PASSTHRU_STATUS,
+  *PCSMI_SAS_STP_PASSTHRU_STATUS;
+
+typedef struct _CSMI_SAS_STP_PASSTHRU_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_STP_PASSTHRU Parameters;
+   CSMI_SAS_STP_PASSTHRU_STATUS Status;
+   __u8  bDataBuffer[1];
+} CSMI_SAS_STP_PASSTHRU_BUFFER,
+  *PCSMI_SAS_STP_PASSTHRU_BUFFER;
+
+// CC_CSMI_SAS_GET_SATA_SIGNATURE
+
+typedef struct _CSMI_SAS_SATA_SIGNATURE {
+   __u8  bPhyIdentifier;
+   __u8  bReserved[3];
+   __u8  bSignatureFIS[20];
+} CSMI_SAS_SATA_SIGNATURE,
+  *PCSMI_SAS_SATA_SIGNATURE;
+
+typedef struct _CSMI_SAS_SATA_SIGNATURE_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_SATA_SIGNATURE Signature;
+} CSMI_SAS_SATA_SIGNATURE_BUFFER,
+  *PCSMI_SAS_SATA_SIGNATURE_BUFFER;
+
+// CC_CSMI_SAS_GET_SCSI_ADDRESS
+
+typedef struct _CSMI_SAS_GET_SCSI_ADDRESS_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   __u8  bSASAddress[8];
+   __u8  bSASLun[8];
+   __u8  bHostIndex;
+   __u8  bPathId;
+   __u8  bTargetId;
+   __u8  bLun;
+} CSMI_SAS_GET_SCSI_ADDRESS_BUFFER,
+   *PCSMI_SAS_GET_SCSI_ADDRESS_BUFFER;
+
+// CC_CSMI_SAS_GET_DEVICE_ADDRESS
+
+typedef struct _CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   __u8  bHostIndex;
+   __u8  bPathId;
+   __u8  bTargetId;
+   __u8  bLun;
+   __u8  bSASAddress[8];
+   __u8  bSASLun[8];
+} CSMI_SAS_GET_DEVICE_ADDRESS_BUFFER,
+  *PCSMI_SAS_GET_DEVICE_ADDRESS_BUFFER;
+
+// CC_CSMI_SAS_TASK_MANAGEMENT
+
+typedef struct _CSMI_SAS_SSP_TASK_IU {
+   __u8  bHostIndex;
+   __u8  bPathId;
+   __u8  bTargetId;
+   __u8  bLun;
+   __u32 uFlags;
+   __u32 uQueueTag;
+   __u32 uReserved;
+   __u8  bTaskManagementFunction;
+   __u8  bReserved[7];
+   __u32 uInformation;
+} CSMI_SAS_SSP_TASK_IU,
+  *PCSMI_SAS_SSP_TASK_IU;
+
+typedef struct _CSMI_SAS_SSP_TASK_IU_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_SSP_TASK_IU Parameters;
+   CSMI_SAS_SSP_PASSTHRU_STATUS Status;
+} CSMI_SAS_SSP_TASK_IU_BUFFER,
+  *PCSMI_SAS_SSP_TASK_IU_BUFFER;
+
+// CC_CSMI_SAS_GET_CONNECTOR_INFO
+
+typedef struct _CSMI_SAS_GET_CONNECTOR_INFO {
+   __u32 uPinout;
+   __u8  bConnector[16];
+   __u8  bLocation;
+   __u8  bReserved[15];
+} CSMI_SAS_CONNECTOR_INFO,
+  *PCSMI_SAS_CONNECTOR_INFO;
+
+typedef struct _CSMI_SAS_CONNECTOR_INFO_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   CSMI_SAS_CONNECTOR_INFO Reference[32];
+} CSMI_SAS_CONNECTOR_INFO_BUFFER,
+  *PCSMI_SAS_CONNECTOR_INFO_BUFFER;
+
+// CC_CSMI_SAS_GET_LOCATION
+
+typedef struct _CSMI_SAS_LOCATION_IDENTIFIER {
+   __u32 bLocationFlags;
+   __u8  bSASAddress[8];
+   __u8  bSASLun[8];
+   __u8  bEnclosureIdentifier[8];
+   __u8  bEnclosureName[32];
+   __u8  bBayPrefix[32];
+   __u8  bBayIdentifier;
+   __u8  bLocationState;
+   __u8  bReserved[2];
+} CSMI_SAS_LOCATION_IDENTIFIER,
+  *PCSMI_SAS_LOCATION_IDENTIFIER;
+
+typedef struct _CSMI_SAS_GET_LOCATION_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   __u8  bHostIndex;
+   __u8  bPathId;
+   __u8  bTargetId;
+   __u8  bLun;
+   __u8  bIdentify;
+   __u8  bNumberOfLocationIdentifiers;
+   __u8  bLengthOfLocationIdentifier;
+   CSMI_SAS_LOCATION_IDENTIFIER Location[1];
+} CSMI_SAS_GET_LOCATION_BUFFER,
+  *PCSMI_SAS_GET_LOCATION_BUFFER;
+
+// CC_CSMI_SAS_PHY_CONTROL
+
+typedef struct _CSMI_SAS_CHARACTER {
+   __u8  bTypeFlags;
+   __u8  bValue;
+} CSMI_SAS_CHARACTER,
+  *PCSMI_SAS_CHARACTER;
+
+typedef struct _CSMI_SAS_PHY_CONTROL {
+   __u8  bType;
+   __u8  bRate;
+   __u8  bReserved[6];
+   __u32 uVendorUnique[8];
+   __u32 uTransmitterFlags;
+   __i8  bTransmitAmplitude;
+   __i8  bTransmitterPreemphasis;
+   __i8  bTransmitterSlewRate;
+   __i8  bTransmitterReserved[13];
+   __u8  bTransmitterVendorUnique[64];
+   __u32 uReceiverFlags;
+   __i8  bReceiverThreshold;
+   __i8  bReceiverEqualizationGain;
+   __i8  bReceiverReserved[14];
+   __u8  bReceiverVendorUnique[64];
+   __u32 uPatternFlags;
+   __u8  bFixedPattern;
+   __u8  bUserPatternLength;
+   __u8  bPatternReserved[6];
+   CSMI_SAS_CHARACTER UserPatternBuffer[16];
+} CSMI_SAS_PHY_CONTROL,
+  *PCSMI_SAS_PHY_CONTROL;
+
+typedef struct _CSMI_SAS_PHY_CONTROL_BUFFER {
+   IOCTL_HEADER IoctlHeader;
+   __u32 uFunction;
+   __u8  bPhyIdentifier;
+   __u16 usLengthOfControl;
+   __u8  bNumberOfControls;
+   __u8  bReserved[4];
+   __u32 uLinkFlags;
+   __u8  bSpinupRate;
+   __u8  bLinkReserved[7];
+   __u32 uVendorUnique[8];
+   CSMI_SAS_PHY_CONTROL Control[1];
+} CSMI_SAS_PHY_CONTROL_BUFFER,
+  *PCSMI_SAS_PHY_CONTROL_BUFFER;
+
+// EDM #pragma CSMI_SAS_END_PACK
+#pragma pack()
+
+#endif // _CSMI_SAS_H_
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/include/mv_include.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/mv_include.h
--- linux-3.10.69/drivers/scsi/mv/include/mv_include.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/include/mv_include.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,24 @@
+#if !defined(MV_INCLUDE_H)
+#define MV_INCLUDE_H
+#include "mv_config.h"
+#include "mv_os.h"
+
+#include "com_type.h"
+#include "com_u64.h"
+#include "com_util.h"
+#include "com_roll.h"
+#include "com_list.h"
+#include "com_dbg.h"
+#include "com_scsi.h"
+#include "com_api.h"
+#include "com_extern.h"
+#include "com_struct.h"
+#ifdef SUPPORT_SCSI_PASSTHROUGH
+#include "com_ioctl.h"
+#endif
+
+
+#include "hba_exp.h"
+
+#endif /* MV_INCLUDE_H */
+
Binary files linux-3.10.69/drivers/scsi/mv/lib/libmv_nonraid_32_noregparm.obj and F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/lib/libmv_nonraid_32_noregparm.obj differ
Binary files linux-3.10.69/drivers/scsi/mv/lib/libmv_nonraid_32.obj and F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/lib/libmv_nonraid_32.obj differ
Binary files linux-3.10.69/drivers/scsi/mv/lib/libmv_nonraid_64.obj and F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/lib/libmv_nonraid_64.obj differ
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/linux_iface.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/linux_iface.c
--- linux-3.10.69/drivers/scsi/mv/linux_iface.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/linux_iface.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,2342 @@
+/*
+ *
+ * linux_iface.c - Kernel/CLI interface
+ *
+ */
+
+#include <linux/hdreg.h>
+#include <linux/spinlock.h>
+//#include <linux/ata.h>
+#include "linux_main.h"
+#include "linux_iface.h"
+#include "hba_mod.h"
+#include <scsi/scsi_eh.h>
+#if defined(__VMKLNX__) || defined(MV_VMK_ESX35) 
+struct mv_adp_desc *gl_hba_desc = NULL;
+#endif
+#define SECTOR_SIZE 512
+#define HBA_REQ_TIMER_IOCTL (15)
+
+#define MV_DEVFS_NAME "mv"
+#define IOCTL_BUF_LEN (1024*1024)
+
+#ifdef RAID_DRIVER
+#if defined(__VMKLNX__) || defined(MV_VMK_ESX35) 
+static struct class *apidev_class = NULL;
+#endif
+static long
+mv_unlock_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+static int mv_open(struct inode *inode, struct file *file);
+#if defined (HAVE_UNLOCKED_IOCTL) && !defined (__VMKLNX__)
+static long mv_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
+#else
+static int mv_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+		    unsigned long arg);
+#endif /* HAVE_UNLOCKED_IOCTL */
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,9)) \
+   || defined(__VMKERNEL_MODULE__)
+static loff_t
+mvctl_llseek(struct file *file, loff_t offset, int origin)
+{
+    return -ESPIPE;
+}
+#define no_llseek mvctl_llseek
+#endif
+
+#ifdef MV_VMK_ESX35
+static ssize_t
+mv_write(struct file *file, const char *buf, size_t count, loff_t *ppos)
+{
+    printk(": ioctl WRITE not yet supported\n");
+    return 0;
+}
+                                                                                                                        
+static ssize_t
+mv_read(struct file *file, char *buf, size_t count, loff_t *ptr)
+{
+    printk(": ioctl READ not yet supported\n");
+    return 0;
+}
+
+#endif
+
+#ifdef MV_VMK_ESX35
+struct fasync_struct *async_queue=NULL;
+static int
+mv_release(struct inode *inode, struct file *filep)
+{
+	printk("%s() called\n", __FUNCTION__);
+	return fasync_helper(-1, filep, 0, &async_queue);
+}
+
+static int
+mv_fasync(int fd, struct file *filep, int mode)
+{
+	printk("%s() called\n", __FUNCTION__);
+	return fasync_helper(fd, filep, mode, &async_queue);
+}
+
+static unsigned int mv_poll(struct file *file, struct poll_table_struct *wait) 
+{
+   return 0;
+}
+#endif
+
+static struct file_operations mv_fops = {
+	.owner   =    THIS_MODULE,
+	.llseek	 =    no_llseek,
+#ifndef __VMKLNX__
+	.open    =    mv_open,
+#endif
+/*Build for RHEL48 failed, temp disable this struct definition, if VMWare Driver
+    need use it, need separate with kernel version >= 2.6.11*/
+#if 0//def CONFIG_COMPAT
+	.compat_ioctl = mv_unlock_ioctl,
+#endif
+#if defined (HAVE_UNLOCKED_IOCTL) && !defined (__VMKLNX__)
+	.unlocked_ioctl = mv_unlock_ioctl,
+#else
+	.ioctl   =  mv_ioctl,
+#endif
+#ifdef MV_VMK_ESX35
+	.read =     mv_read,
+	.write =    mv_write,
+#endif
+
+#ifdef MV_VMK_ESX35
+	.poll   =    mv_poll,
+#endif
+#ifdef MV_VMK_ESX35
+	.fasync  =    mv_fasync,
+	.release =    mv_release
+#endif
+};
+#endif /* RAID_DRIVER */
+
+void ioctlcallback(MV_PVOID This, PMV_Request req)
+{
+	struct hba_extension *hba = (struct hba_extension *) This;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&hba->desc->hba_desc->hba_ioctl_sync, 0);
+#else
+	complete(&hba->desc->hba_desc->ioctl_cmpl);
+#endif
+
+#ifdef USE_REQ_POOL
+	hba_req_cache_free(hba,req);
+#else
+    res_free_req_to_pool(hba->req_pool, req);
+#endif
+}
+
+#ifdef RAID_DRIVER
+static MV_U16 API2Driver_ID(MV_U16 API_ID)
+{
+	MV_U16	returnID = API_ID;
+	returnID &= 0xfff;
+	return returnID;
+}
+
+static LD_Info ldinfo[LDINFO_NUM] = {{0}};
+static int mv_proc_ld_info(struct Scsi_Host *host)
+{
+	struct hba_extension *hba;
+	PMV_Request req;
+	MV_U8 Cdb[MAX_CDB_SIZE];
+	MV_U16 LD_ID = 0XFF;
+	MV_U16 i=0;
+	int ret   = 0;
+
+	Cdb[0] = APICDB0_LD;
+	Cdb[1] = APICDB1_LD_GETINFO;
+	Cdb[2] = LD_ID & 0xff;
+	Cdb[3] = API2Driver_ID(LD_ID)>>8;
+
+	hba = __mv_get_ext_from_host(host);
+	if(NULL == hba){
+		MV_DPRINT((  "Marvell : proc info , Invalid operation.\n"));
+		return -EPERM;
+	}
+
+#ifdef USE_REQ_POOL
+	req = hba_req_cache_alloc(hba);
+#else
+	req = res_get_req_from_pool(hba->req_pool);
+#endif
+	if (req == NULL) {
+		return -1;
+	}
+
+	req->Cmd_Initiator = hba;
+	req->Org_Req = req;
+	req->Device_Id = VIRTUAL_DEVICE_ID;
+	req->Cmd_Flag = 0;
+
+	if (SCSI_IS_READ(Cdb[0]))
+		req->Cmd_Flag |= CMD_FLAG_DATA_IN;
+	if (SCSI_IS_READ(Cdb[0]) || SCSI_IS_WRITE(Cdb[0]))
+		req->Cmd_Flag |= CMD_FLAG_DMA;
+
+	req->Data_Transfer_Length = LDINFO_NUM*sizeof(LD_Info);
+	memset(ldinfo, 0, LDINFO_NUM*sizeof(LD_Info));
+	for(i=0;i<LDINFO_NUM;i++)
+		ldinfo[i].Status = LD_STATUS_INVALID;
+
+	req->Data_Buffer = ldinfo;
+	SGTable_Init(&req->SG_Table, 0);
+	memcpy(req->Cdb, Cdb, MAX_CDB_SIZE);
+	memset(req->Context, 0, sizeof(MV_PVOID)*MAX_POSSIBLE_MODULE_NUMBER);
+
+	req->LBA.value = 0;
+	req->Sector_Count = 0;
+	req->Completion = ioctlcallback;
+	req->Req_Type = REQ_TYPE_INTERNAL;
+	req->Scsi_Status = REQ_STATUS_PENDING;
+
+#ifdef SUPPORT_TASKLET
+	tasklet_disable(&hba->desc->hba_desc->mv_tasklet);
+#endif
+
+	spin_lock(&hba->desc->hba_desc->global_lock);
+//	hba->Ioctl_Io_Count++;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&hba->desc->hba_desc->hba_ioctl_sync, 1);
+#endif
+	hba->desc->ops->module_sendrequest(hba->desc->extension, req);
+	spin_unlock(&hba->desc->hba_desc->global_lock);
+
+#ifdef SUPPORT_TASKLET
+	tasklet_enable(&hba->desc->hba_desc->mv_tasklet);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	if ( !__hba_wait_for_atomic_timeout(&hba->desc->hba_desc->hba_ioctl_sync, HBA_REQ_TIMER_IOCTL*HZ) ) {
+#else
+	if (wait_for_completion_timeout(&hba->desc->hba_desc->ioctl_cmpl, HBA_REQ_TIMER_IOCTL*HZ) == 0) {
+#endif
+		MV_DPRINT((  "mv_proc_ld_info req timed out.\n"));
+	        ret = -1;
+#ifdef USE_REQ_POOL
+		hba_req_cache_free(hba,req);
+#else
+		res_free_req_to_pool(hba->req_pool, req);
+#endif
+		goto clean_reqpool;
+	}
+
+clean_reqpool:
+//	res_free_req_to_pool(hba->req_pool, req);
+	return ret;
+}
+
+
+static char* mv_ld_status(int status)
+{
+	switch (status) {
+	case LD_STATUS_FUNCTIONAL:
+		return "online";
+	case LD_STATUS_DEGRADE:
+		return "degraded";
+	case LD_STATUS_DELETED:
+		return "deleted";
+	case LD_STATUS_PARTIALLYOPTIMAL:
+		return "partially optimal";
+	case LD_STATUS_OFFLINE:
+		return "offline";
+	default:
+		return "unknown";
+	}
+}
+
+static char* mv_ld_raid_mode(int status)
+{
+	switch (status) {
+	case LD_MODE_RAID0:
+		return "RAID0";
+	case LD_MODE_RAID1:
+		return "RAID1";
+	case LD_MODE_RAID10:
+		return "RAID10";
+	case LD_MODE_RAID1E:
+		return "RAID1E";
+	case LD_MODE_RAID5:
+		return "RAID5";
+	case LD_MODE_RAID50:
+		return "RAID50";
+	case LD_MODE_RAID6:
+		return "RAID6";
+	case LD_MODE_RAID60:
+		return "RAID60";
+	case LD_MODE_JBOD:
+		return "JBOD";
+	default:
+		return "unknown";
+	}
+}
+
+static char* mv_ld_bga_status(int status)
+{
+	switch (status) {
+	case LD_BGA_STATE_RUNNING:
+		return "running";
+	case LD_BGA_STATE_ABORTED:
+		return "aborted";
+	case LD_BGA_STATE_PAUSED:
+		return "paused";
+	case LD_BGA_STATE_AUTOPAUSED:
+		return "auto paused";
+	case LD_BGA_STATE_DDF_PENDING:
+		return "DDF pending";
+	default:
+		return "N/A";
+	}
+}
+
+static int mv_ld_get_status(struct Scsi_Host *host, MV_U16 ldid, LD_Status *ldstatus)
+{
+	struct hba_extension *hba;
+	PMV_Request req;
+	MV_U8 Cdb[MAX_CDB_SIZE];
+	MV_U16 LD_ID = ldid;/*0XFF;*/
+	//unsigned long flags;
+	int ret   = 0;
+
+	hba = __mv_get_ext_from_host(host);
+	if(NULL == hba){
+		MV_DPRINT((  "Marvell : get ld status , Invalid operation.\n"));
+		return -EPERM;
+	}
+	Cdb[0] = APICDB0_LD;
+	Cdb[1] = APICDB1_LD_GETSTATUS;
+	Cdb[2] = LD_ID & 0xff;
+	Cdb[3] = API2Driver_ID(LD_ID)>>8;
+
+#ifdef USE_REQ_POOL
+	req = hba_req_cache_alloc(hba);
+#else
+	req = res_get_req_from_pool(hba->req_pool);
+#endif
+	if (req == NULL)
+		return -1;
+
+	req->Cmd_Initiator = hba;
+	req->Org_Req = req;
+	req->Device_Id = VIRTUAL_DEVICE_ID;
+	req->Cmd_Flag = 0;
+
+	if (SCSI_IS_READ(Cdb[0]))
+		req->Cmd_Flag |= CMD_FLAG_DATA_IN;
+	if ( SCSI_IS_READ(Cdb[0]) || SCSI_IS_WRITE(Cdb[0]) )
+		req->Cmd_Flag |= CMD_FLAG_DMA;
+
+	/* Data Buffer */
+	req->Data_Transfer_Length = sizeof(LD_Status);
+	memset(ldstatus, 0, sizeof(LD_Status));
+	ldstatus->Status = LD_STATUS_INVALID;
+	req->Data_Buffer = ldstatus;
+
+	SGTable_Init(&req->SG_Table, 0);
+	memcpy(req->Cdb, Cdb, MAX_CDB_SIZE);
+	memset(req->Context, 0, sizeof(MV_PVOID)*MAX_POSSIBLE_MODULE_NUMBER);
+	req->LBA.value = 0;
+	req->Sector_Count = 0;
+	req->Completion = ioctlcallback;
+	req->Req_Type = REQ_TYPE_INTERNAL;
+	req->Scsi_Status = REQ_STATUS_PENDING;
+
+#ifdef SUPPORT_TASKLET
+	tasklet_disable(&hba->desc->hba_desc->mv_tasklet);
+#endif
+
+	//spin_lock_irqsave(&hba->desc->hba_desc->global_lock, flags);
+	spin_lock(&hba->desc->hba_desc->global_lock);
+//	hba->Ioctl_Io_Count++;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&hba->desc->hba_desc->hba_ioctl_sync, 1);
+#endif
+	hba->desc->ops->module_sendrequest(hba->desc->extension, req);
+	//spin_unlock_irqrestore(&hba->desc->hba_desc->global_lock, flags);
+	spin_unlock(&hba->desc->hba_desc->global_lock);
+
+#ifdef SUPPORT_TASKLET
+	tasklet_enable(&hba->desc->hba_desc->mv_tasklet);
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	if (!__hba_wait_for_atomic_timeout(&hba->desc->hba_desc->hba_ioctl_sync, HBA_REQ_TIMER_IOCTL*HZ)) {
+#else
+	if (!wait_for_completion_timeout(&hba->desc->hba_desc->ioctl_cmpl, HBA_REQ_TIMER_IOCTL*HZ)) {
+#endif
+		MV_DPRINT(("mv_ld_get_status timed out.\n"));
+	        ret = -1;
+
+#ifdef USE_REQ_POOL
+                hba_req_cache_free(hba,req);
+#else
+                res_free_req_to_pool(hba->req_pool, req);
+#endif
+		goto clean_reqpool;
+	}
+
+clean_reqpool:
+	return ret;
+}
+
+static int mv_ld_show_status(char *buf, PLD_Status pld_status)
+{
+	char *str, *str1;
+	int ret = 0;
+
+	if ( LD_BGA_STATE_RUNNING == pld_status->BgaState)
+	{
+		if (LD_BGA_REBUILD == pld_status->Bga)
+			str = "rebuilding";
+		else if (LD_BGA_INIT_QUICK == pld_status->Bga ||
+		          LD_BGA_INIT_BACK == pld_status->Bga)
+			str = "initializing";
+		else if (LD_BGA_CONSISTENCY_CHECK == pld_status->Bga ||
+		          LD_BGA_CONSISTENCY_FIX == pld_status->Bga)
+			str = "synchronizing";
+		else if (LD_BGA_MIGRATION == pld_status->Bga)
+			str = "migration";
+		else
+			str = "unknown bga action";
+		ret = sprintf(buf, "  %s is %d%% done", str, pld_status->BgaPercentage);
+	}
+	else if ((LD_BGA_STATE_ABORTED == pld_status->BgaState) ||
+	         (LD_BGA_STATE_PAUSED == pld_status->BgaState) ||
+	         (LD_BGA_STATE_AUTOPAUSED == pld_status->BgaState))
+	{
+		if (LD_BGA_REBUILD == pld_status->Bga)
+			str = "rebuilding";
+		else if (LD_BGA_INIT_QUICK == pld_status->Bga ||
+		         LD_BGA_INIT_BACK == pld_status->Bga)
+			str = "initializing";
+		else if (LD_BGA_CONSISTENCY_CHECK == pld_status->Bga ||
+		          LD_BGA_CONSISTENCY_FIX == pld_status->Bga)
+			str = "synchronizing";
+		else if (LD_BGA_MIGRATION == pld_status->Bga)
+			str = "migration";
+		else
+			str = "unknown bga action";
+
+		if (LD_BGA_STATE_ABORTED == pld_status->BgaState)
+			str1 = "aborted";
+		else if (LD_BGA_STATE_PAUSED == pld_status->BgaState)
+			str1 = "paused";
+		else if (LD_BGA_STATE_AUTOPAUSED == pld_status->BgaState)
+			str1 = "auto paused";
+		else
+			str1 = "aborted";
+		ret = sprintf(buf, "  %s is %s", str, str1);
+	}
+	return ret;
+}
+#endif /*RAID_DRIVER*/
+
+extern MV_BOOLEAN mv_read_hba_info( MV_PVOID This, char *pBuffer, int *offset);
+extern MV_BOOLEAN mv_read_autoload_data( MV_PVOID This, char *pBuffer, int *offset);
+static int mv_proc_hba_info(struct Scsi_Host *host, char *pBuffer)
+{
+    struct hba_extension *hba ;
+	int len = 0;
+	
+    hba = __mv_get_ext_from_host(host);
+	if (hba == NULL)
+		return 0;
+	
+	if (!mv_read_hba_info(hba, pBuffer + len, &len))
+	{
+	    MV_DPRINT(("mv read hba info failed.\n"));
+	}
+	
+	len += sprintf(pBuffer + len,"\n[AUTOLOAD CONFIG]\n");
+    if (!mv_read_autoload_data(hba, pBuffer + len, &len))
+	{
+	    MV_DPRINT(("mv read autoload data failed.\n"));
+	}
+	
+	return len;	
+}
+
+static int mv_char_to_int(char *buf, MV_U32 *value)
+{
+	char *tmp;	
+	int i;
+	//MV_DPRINT(("buf %s****.\n", buf));
+
+	if (((buf[0] == '0') && (buf[1] == 'x')) ||
+		((buf[0] == '0') && (buf[1] == 'X')))
+		tmp = &buf[2];
+	else
+	{
+		MV_DPRINT(("the buf format is wrong.\n"));
+		return -1;
+	}
+
+	for (i = 0; tmp[i] != '\0'; i++)
+	{		
+		if ((tmp[i] >= '0') && (tmp[i] <= '9'))
+			*value = (*value) * 16 + tmp[i] - '0';
+		else if ((tmp[i] >= 'a') && (tmp[i] <= 'f'))
+			*value = (*value) * 16 + tmp[i] - 'a' + 10;
+		else if ((tmp[i] >= 'A') && (tmp[i] <= 'F'))
+			*value = (*value) * 16 + tmp[i] - 'A' + 10;
+		else
+		{
+			MV_DPRINT(("the data format is wrong.%c\n", tmp[i]));
+			return -1;
+		}			
+	}
+
+	return 0;
+}
+
+extern MV_LPVOID mv_get_mmio_base(void *ext);
+extern int mv_read_type_reg(MV_LPVOID *mmio_base, char *buf, MV_U32 offset, char *type, int len);
+extern void mv_write_type_reg(MV_LPVOID *mmio_base, MV_U32 addr_reg,MV_U32 value_reg, char *type);
+extern int mv_dump_intr_reg(MV_LPVOID *mmio_base, char *pBuffer, int len);
+extern int mv_dump_sas_sata_port_cfg_ctrl_reg(MV_LPVOID *mmio_base, char *pBuffer, int len);
+
+static int (*pDumpRegFunc[])(MV_LPVOID *mmio_base,
+							char *pBuffer,
+							int len) =
+{		
+	mv_dump_intr_reg,
+	mv_dump_sas_sata_port_cfg_ctrl_reg,
+	NULL    // Last element must be a NULL value.
+};
+
+static int mv_getDumpFuncCnt(void)
+{
+	int idx = 0;
+	while (pDumpRegFunc[idx] != NULL)
+		idx++;
+	return(idx);
+}
+
+static void mv_handle_proc_write(char *msg, void *data)
+{
+	MV_LPVOID  mmio_base = NULL;
+	struct proc_reg_data *proc_reg_data = (struct proc_reg_data *)data;
+	struct hba_extension *hba =	proc_reg_data->hba;
+	char type[5] = {0};
+	char addr[8] = {0};
+	char value[11] = {0};
+	int i, j;
+	MV_U32 addr_reg = 0;
+	MV_U32 value_reg = 0;	
+
+	mmio_base = mv_get_mmio_base(hba);
+	if (NULL == mmio_base)
+	{
+		return ; 
+	}
+
+	//the msg format is : default
+	if (MV_CompareMemory(msg, "default", 7)== 0)
+	{ 
+		proc_reg_data->flag = 0;
+		return;
+	}
+	//the msg format is : [addr]:[value] or [addr]
+	if ((msg[0] == '0') && ((msg[1] == 'x') || (msg[1] == 'X')))
+	{
+		for (i = 0, j = 0; msg[i] != ':' && msg[i] != '\0'; i++, j++)
+			addr[j] = msg[i];
+		if (msg[i] == ':')
+		{
+			addr[j] = '\0';
+			for (j = 0, i++; msg[i] != '\0'; i++, j++)
+				value[j] = msg[i];
+			value[j - 1] = '\0';
+
+			if (mv_char_to_int(addr, &addr_reg) != 0)
+				return;
+
+			if (mv_char_to_int(value, &value_reg) != 0)
+				return;
+
+			MV_DPRINT(("%s, type %s, addr %s, value %s, addr_reg 0x%x, value_reg 0x%x.\n", \
+						__func__, type, addr, value, addr_reg, value_reg));
+
+			MV_REG_WRITE_DWORD(mmio_base, addr_reg, value_reg);
+		}
+		else
+		{
+			addr[j - 1] = '\0';
+			if (mv_char_to_int(addr, &addr_reg) != 0)
+				return;			
+		}
+		proc_reg_data->flag = 1;
+		proc_reg_data->offset = addr_reg;
+		MV_CopyMemory(proc_reg_data->type, "NULL", 5);
+		return;
+	}
+		
+	//the msg format is : [type][addr]:[value] or [type][addr]
+	for (i = 0; i < 4; i++)
+		type[i] = msg[i];
+	type[i] = '\0';
+
+	for (j = 0, i = 4; msg[i] != ':' && msg[i] != '\0'; i++, j++)
+		addr[j] = msg[i]; 
+	if (msg[i] == ':')
+	{
+		addr[j] = '\0';
+		for (j = 0, i++; msg[i] != '\0'; i++, j++)
+			value[j] = msg[i];
+		value[j - 1] = '\0';
+
+		if (mv_char_to_int(addr, &addr_reg) != 0)
+			return;
+
+		if (mv_char_to_int(value, &value_reg) != 0)
+			return;
+
+		MV_DPRINT(("%s, type %s, addr %s, value %s, addr_reg 0x%x, value_reg 0x%x.\n", \
+			__func__, type, addr, value, addr_reg, value_reg));
+
+		if (MV_CompareMemory(type, "pcie", 5) == 0)
+		{			
+			MV_PCI_WRITE_CONFIG_DWORD(hba, addr_reg, value_reg);
+		}
+		else
+		{
+			mv_write_type_reg(mmio_base, addr_reg, value_reg, type);
+		}		
+	}
+	else
+	{
+		addr[j - 1] = '\0';
+		if (mv_char_to_int(addr, &addr_reg) != 0)
+			return;			
+	}
+
+	proc_reg_data->flag = 1;
+	proc_reg_data->offset = addr_reg;
+	MV_CopyMemory(proc_reg_data->type, type, 5);
+	return;	
+}
+
+int reg_info_read(char *page, char **start, off_t off, int count,
+					int *eof, void *data)
+{
+	MV_LPVOID  mmio_base = NULL;
+	struct proc_reg_data *proc_reg_data = (struct proc_reg_data *)data;
+	struct hba_extension *hba =  proc_reg_data->hba;
+	MV_U32 value = 0;
+	int numFunc = 0;
+	int i = 0;
+	int len = 0;
+	char help[] = {"usage:----------------------------------\n"
+"1. echo default > [file]                 -- cat [file] show default regs value\n"
+"2. echo [offset] > [file]                -- cat [file] show specificed reg value\n"
+"3. echo [offset]:[value] > [file]        -- write value to the offset regs, cat [file]show its value\n"
+"4. echo [type][offset] > [file]          -- the [type] contains: cmds/port/intr/comm/pcie, cat [file]show the offset reg value\n"
+"5. echo [type][offset]:[value] > [file]  -- the [type] same with 4, write the value to the type offset reg\n"};
+
+	mmio_base = mv_get_mmio_base(hba);
+	if (NULL == mmio_base)
+	{
+		return 0; 
+	}
+
+	if (mv_get_register_mode() == 0)
+	{
+		return 0;
+	}
+	
+	if (proc_reg_data->flag == 0)
+	{
+		numFunc = mv_getDumpFuncCnt();
+		for (i = 0; i < numFunc; i++)
+			len = (*pDumpRegFunc[i])(mmio_base, page, len);
+
+		len += sprintf(page + len,"%s\n", help);		 
+		//len += sprintf(page + len,"Now: {jiffies=%ld}\n",jiffies);
+	}
+	else
+	{
+		if (MV_CompareMemory(proc_reg_data->type, "NULL", 4) == 0)
+		{
+			len += sprintf(page + len, "Reg:0X%x Value:%x  \n",
+				 proc_reg_data->offset, MV_REG_READ_DWORD(mmio_base, proc_reg_data->offset));
+		}
+		else
+		{
+			if (MV_CompareMemory(proc_reg_data->type, "pcie", 5) == 0)
+			{
+				MV_PCI_READ_CONFIG_DWORD(hba, proc_reg_data->offset, &value);
+				len += sprintf(page + len, "PCIE Reg:0X%x  Value:%x  \n",
+						 proc_reg_data->offset, value);
+			}
+			else
+			{
+			    len = mv_read_type_reg(mmio_base, page, proc_reg_data->offset, proc_reg_data->type, len);
+			}
+		}		
+	}
+	
+	if (off > len)
+		return 0;
+
+	if (count > len - off)
+		count = len - off;
+
+	return off + count;
+}
+
+
+int reg_info_write(struct file *file, const char __user * buffer,
+		unsigned long count, void *data)
+{
+	//MV_DPRINT(("hba_info_write is called.\n"));	
+	char msg[80];
+	if (copy_from_user(msg, buffer, count))
+	{
+		return -EFAULT;
+	}
+	msg[count] = '\0';
+
+	if (mv_get_register_mode() != 0)
+	{
+		MV_DPRINT(("%s, The data is %s\n", __func__, msg));
+		mv_handle_proc_write(msg, data);
+	}
+	return count;
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+int mv_linux_show_info(struct seq_file *m, struct Scsi_Host *pSHost)
+{
+	int len = 0;
+	int datalen = 0;/*use as a temp flag.*/
+
+#ifdef RAID_DRIVER
+	int i = 0;
+	int j = 0;
+	int ret = -1;
+	LD_Status ld_status;
+	char *tmp = NULL;
+	int tmplen = 0;
+	struct hba_extension *hba;
+#endif
+
+	seq_printf(m, "Marvell %s Driver, Version %s\n",
+		      mv_product_name, mv_version_linux);
+
+#ifdef RAID_DRIVER
+	hba = __mv_get_ext_from_host(pSHost);
+	if (!hba->desc->hba_desc->RunAsNonRAID)
+	{
+		if (mv_proc_ld_info(pSHost) == -1) {
+			len = sprintf(pBuffer,
+				      "Driver is busy, please try later.\n");
+			goto out;
+		} else {
+			for (i = 0; i < MAX_LD_SUPPORTED_PERFORMANCE; i++) {
+				if (ldinfo[i].Status != LD_STATUS_INVALID) {
+					if (ldinfo[i].Status == LD_STATUS_OFFLINE
+					        && ldinfo[i].BGAStatus == LD_BGA_STATE_RUNNING) {
+						ldinfo[i].BGAStatus = LD_BGA_STATE_AUTOPAUSED;
+					}
+					if (ldinfo[i].Status == LD_STATUS_MISSING) {
+						ldinfo[i].Status = LD_STATUS_OFFLINE;
+					}
+				} else {
+					break;
+				}
+			}
+		}
+
+		len += sprintf(pBuffer+len,"Index RAID\tStatus  \t\tBGA Status\n");
+		for (i = 0 ; i < LDINFO_NUM ; i++) {
+			if (ldinfo[i].Size.value == 0) {
+				if (i == 0) {
+					len += sprintf(pBuffer+len,"NO Logical Disk\n");
+				}
+				break;
+			}
+			/* Fixed issue -- An unknown item shown in /proc/scsi/mv64xx/. */
+			if (ldinfo[i].Status == LD_STATUS_INVALID)
+				continue;
+
+			len += sprintf(pBuffer+len,
+				"%-5d %s\t%s",
+				ldinfo[i].ID,
+				mv_ld_raid_mode(ldinfo[i].RaidMode),
+				mv_ld_status(ldinfo[i].Status)
+				);
+
+			tmplen = 24 -strlen(mv_ld_status(ldinfo[i].Status));
+			while (j < tmplen) {
+				len += sprintf(pBuffer+len, "%s", " ");
+				j++;
+			}
+			j = 0;
+
+			len += sprintf(pBuffer+len, "%s", mv_ld_bga_status(ldinfo[i].BGAStatus));
+
+			if (ldinfo[i].BGAStatus != LD_BGA_STATE_NONE) {
+				ret = mv_ld_get_status(pSHost,ldinfo[i].ID,&ld_status);
+				if (ret == 0) {
+					if (ld_status.Status != LD_STATUS_INVALID) {
+						if (ld_status.Status == LD_STATUS_MISSING)
+							ld_status.Status = LD_STATUS_OFFLINE;
+						ld_status.BgaState = ldinfo[i].BGAStatus;
+					}
+					len += mv_ld_show_status(pBuffer+len,&ld_status);
+					ret = -1;
+				}
+			}
+
+			tmp = NULL;
+			tmplen = 0;
+			len += sprintf(pBuffer+len,"\n");
+		}
+	}
+	out:
+#endif
+#if 0
+	if (mv_get_register_mode() != 0)
+		len += mv_proc_hba_info(pSHost, pBuffer + len);
+
+#endif
+	
+	return 0;
+}
+#else
+#ifndef MV_VMK_ESX35
+int mv_linux_proc_info(struct Scsi_Host *pSHost, char *pBuffer,
+		       char **ppStart,off_t offset, int length, int inout)
+#else
+int mv_linux_proc_info(char *pBuffer, char **ppStart,off_t offset,
+                        int length, int host_no, int inout)
+
+#endif
+{
+	int len = 0;
+	int datalen = 0;/*use as a temp flag.*/
+#ifndef MV_VMK_ESX35
+#ifdef RAID_DRIVER
+	int i = 0;
+	int j = 0;
+	int ret = -1;
+	LD_Status ld_status;
+	char *tmp = NULL;
+	int tmplen = 0;
+	struct hba_extension *hba;
+#endif
+#endif
+	if (
+#ifndef MV_VMK_ESX35
+		!pSHost ||
+#endif
+		 !pBuffer)
+		return (-ENOSYS);
+
+	if (inout == 1) {
+		/* User write is not supported. */
+		return (-ENOSYS);
+	}
+
+	len = sprintf(pBuffer,"Marvell %s Driver , Version %s\n",
+		      mv_product_name, mv_version_linux);
+
+#ifndef MV_VMK_ESX35
+#ifdef RAID_DRIVER
+	hba = __mv_get_ext_from_host(pSHost);
+	if (!hba->desc->hba_desc->RunAsNonRAID)
+	{
+		if (mv_proc_ld_info(pSHost) == -1) {
+			len = sprintf(pBuffer,
+				      "Driver is busy, please try later.\n");
+			goto out;
+		} else {
+			for (i = 0; i < MAX_LD_SUPPORTED_PERFORMANCE; i++) {
+				if (ldinfo[i].Status != LD_STATUS_INVALID) {
+					if (ldinfo[i].Status == LD_STATUS_OFFLINE
+					        && ldinfo[i].BGAStatus == LD_BGA_STATE_RUNNING) {
+						ldinfo[i].BGAStatus = LD_BGA_STATE_AUTOPAUSED;
+					}
+					if (ldinfo[i].Status == LD_STATUS_MISSING) {
+						ldinfo[i].Status = LD_STATUS_OFFLINE;
+					}
+				} else {
+					break;
+				}
+			}
+		}
+
+		len += sprintf(pBuffer+len,"Index RAID\tStatus  \t\tBGA Status\n");
+		for (i = 0 ; i < LDINFO_NUM ; i++) {
+			if (ldinfo[i].Size.value == 0) {
+				if (i == 0) {
+					len += sprintf(pBuffer+len,"NO Logical Disk\n");
+				}
+				break;
+			}
+			/* Fixed issue -- An unknown item shown in /proc/scsi/mv64xx/. */
+			if (ldinfo[i].Status == LD_STATUS_INVALID)
+				continue;
+
+			len += sprintf(pBuffer+len,
+				"%-5d %s\t%s",
+				ldinfo[i].ID,
+				mv_ld_raid_mode(ldinfo[i].RaidMode),
+				mv_ld_status(ldinfo[i].Status)
+				);
+
+			tmplen = 24 -strlen(mv_ld_status(ldinfo[i].Status));
+			while (j < tmplen) {
+				len += sprintf(pBuffer+len, "%s", " ");
+				j++;
+			}
+			j = 0;
+
+			len += sprintf(pBuffer+len, "%s", mv_ld_bga_status(ldinfo[i].BGAStatus));
+
+			if (ldinfo[i].BGAStatus != LD_BGA_STATE_NONE) {
+				ret = mv_ld_get_status(pSHost,ldinfo[i].ID,&ld_status);
+				if (ret == 0) {
+					if (ld_status.Status != LD_STATUS_INVALID) {
+						if (ld_status.Status == LD_STATUS_MISSING)
+							ld_status.Status = LD_STATUS_OFFLINE;
+						ld_status.BgaState = ldinfo[i].BGAStatus;
+					}
+					len += mv_ld_show_status(pBuffer+len,&ld_status);
+					ret = -1;
+				}
+			}
+
+			tmp = NULL;
+			tmplen = 0;
+			len += sprintf(pBuffer+len,"\n");
+		}
+	}
+	out:
+#endif
+	if (mv_get_register_mode() != 0)
+		len += mv_proc_hba_info(pSHost, pBuffer + len);
+#endif
+	datalen = len - offset;
+	if (datalen < 0) {
+		datalen = 0;
+		*ppStart = pBuffer + len;
+	} else {
+		*ppStart = pBuffer + offset;
+	}
+	return datalen;
+}
+#endif
+#ifdef MV_BLK_IOCTL
+
+/*DEFINE_MUTEX in gcc 4.3 failed to initialize.*/
+static spinlock_t ioctl_index_spin;
+
+
+void * kbuf_array[512] = {NULL,};
+unsigned char mvcdb[512][16];
+unsigned long kbuf_index[512/8] = {0,};
+
+static inline int mv_is_api_cmd(int cmd)
+{
+	return (cmd >= API_BLOCK_IOCTL_DEFAULT_FUN) && \
+		(cmd < API_BLOCK_IOCTL_DEFAULT_FUN + API_IOCTL_MAX );
+}
+
+/* ATA_16(0x85) SAT command and 0xec for Identify */
+char ata_ident[] = {0x85, 0x08, 0x0e, 0x00, 0x00, 0x00, 0x01, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0x00};
+
+#ifdef AMCC_CLI_WORKROUND
+unsigned char page_buffer[0x4000];
+#endif
+
+/**
+ *	id_to_string - Convert IDENTIFY DEVICE page into string
+ *	@iden: IDENTIFY DEVICE results we will examine
+ *	@s: string into which data is output
+ *	@ofs: offset into identify device page
+ *	@len: length of string to return. must be an even number.
+ *
+ *	The strings in the IDENTIFY DEVICE page are broken up into
+ *	16-bit chunks.  Run through the string, and output each
+ *	8-bit chunk linearly, regardless of platform.
+ *
+ */
+static void id_to_string(const u16 *iden, unsigned char *s,
+		   unsigned int ofs, unsigned int len)
+{
+	unsigned int c;
+	while (len > 0) {
+		c = iden[ofs] >> 8;
+		*s = c;
+		s++;
+
+		c = iden[ofs] & 0xff;
+		*s = c;
+		s++;
+
+		ofs++;
+		len -= 2;
+	}
+}
+static int io_get_identity(void *kbuf)
+{
+	char buf[40];
+	u16 *dst = kbuf;
+	unsigned int i,j;
+	
+	if (!dst)
+		return -1;
+
+#ifdef __MV_BIG_ENDIAN_BITFIELD__
+        for (i = 0; i < 256; i++)
+                dst[i] = MV_LE16_TO_CPU(dst[i]);
+#endif
+
+	/*identify data -> model number: word 27-46*/
+	id_to_string(dst, buf, 27, 40);
+	memcpy(&dst[27], buf, 40);
+
+	/*identify data -> firmware revision: word 23-26*/
+	id_to_string(dst, buf, 23, 8);
+	memcpy(&dst[23], buf, 8);
+	
+	/*identify data -> serial number: word 10-19*/
+	id_to_string(dst, buf, 10, 20);
+	memcpy(&dst[10], buf, 20);
+
+	return 0;
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 12)
+
+/**
+ * scsi_normalize_sense - normalize main elements from either fixed or
+ *			descriptor sense data format into a common format.
+ *
+ * @sense_buffer:	byte array containing sense data returned by device
+ * @sb_len:		number of valid bytes in sense_buffer
+ * @sshdr:		pointer to instance of structure that common
+ *			elements are written to.
+ *
+ * Notes:
+ *	The "main elements" from sense data are: response_code, sense_key,
+ *	asc, ascq and additional_length (only for descriptor format).
+ *
+ *	Typically this function can be called after a device has
+ *	responded to a SCSI command with the CHECK_CONDITION status.
+ *
+ * Return value:
+ *	1 if valid sense data information found, else 0;
+ **/
+int scsi_normalize_sense(const u8 *sense_buffer, int sb_len,
+                         struct scsi_sense_hdr *sshdr)
+{
+	if (!sense_buffer || !sb_len)
+		return 0;
+
+	memset(sshdr, 0, sizeof(struct scsi_sense_hdr));
+
+	sshdr->response_code = (sense_buffer[0] & 0x7f);
+
+	if (!scsi_sense_valid(sshdr))
+		return 0;
+
+	if (sshdr->response_code >= 0x72) {
+		/*
+		 * descriptor format
+		 */
+		if (sb_len > 1)
+			sshdr->sense_key = (sense_buffer[1] & 0xf);
+		if (sb_len > 2)
+			sshdr->asc = sense_buffer[2];
+		if (sb_len > 3)
+			sshdr->ascq = sense_buffer[3];
+		if (sb_len > 7)
+			sshdr->additional_length = sense_buffer[7];
+	} else {
+		/* 
+		 * fixed format
+		 */
+		if (sb_len > 2)
+			sshdr->sense_key = (sense_buffer[2] & 0xf);
+		if (sb_len > 7) {
+			sb_len = (sb_len < (sense_buffer[7] + 8)) ?
+					 sb_len : (sense_buffer[7] + 8);
+			if (sb_len > 12)
+				sshdr->asc = sense_buffer[12];
+			if (sb_len > 13)
+				sshdr->ascq = sense_buffer[13];
+		}
+	}
+
+	return 1;
+}
+#endif	
+/**
+ *	mv_ata_task_ioctl - Handler for HDIO_DRIVE_TASK ioctl
+ *	@scsidev: Device to which we are issuing command
+ *	@arg: User provided data for issuing command
+ *
+ *	LOCKING:
+ *	Defined by the SCSI layer.  We don't really care.
+ *
+ *	RETURNS:
+ *	Zero on success, negative errno on error.
+ */
+int mv_ata_task_ioctl(struct scsi_device *scsidev, void __user *arg)
+{
+	int rc = 0;
+	u8 scsi_cmd[MAX_COMMAND_SIZE];
+	u8 args[7];
+	struct scsi_sense_hdr sshdr;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+	struct scsi_request *sreq;
+#endif
+	if (arg == NULL)
+		return -EINVAL;
+
+	if (copy_from_user(args, arg, sizeof(args)))
+		return -EFAULT;
+
+	memset(scsi_cmd, 0, sizeof(scsi_cmd));
+	scsi_cmd[0]  = ATA_16;
+	scsi_cmd[1]  = (3 << 1); /* Non-data */
+	/* scsi_cmd[2] is already 0 -- no off.line, cc, or data xfer */
+	scsi_cmd[4]  = args[1];
+	scsi_cmd[6]  = args[2];
+	scsi_cmd[8]  = args[3];
+	scsi_cmd[10] = args[4];
+	scsi_cmd[12] = args[5];
+	scsi_cmd[14] = args[0];
+	#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+	sreq = scsi_allocate_request(scsidev, GFP_KERNEL);
+	if (!sreq) {
+		rc= -EINTR;
+		scsi_release_request(sreq);
+		return rc;
+	}
+	sreq->sr_data_direction = DMA_NONE;
+	scsi_wait_req(sreq, scsi_cmd, NULL, 0, (10*HZ), 5);
+
+	/* 
+	 * If there was an error condition, pass the info back to the user. 
+	 */
+	rc = sreq->sr_result;
+#elif LINUX_VERSION_CODE >=KERNEL_VERSION(2, 6, 29)
+	if (scsi_execute_req(scsidev, scsi_cmd, DMA_NONE, NULL, 0, &sshdr,
+				     (10*HZ), 5,0))
+			rc = -EIO;
+
+
+#else
+	if (scsi_execute_req(scsidev, scsi_cmd, DMA_NONE, NULL, 0, &sshdr,
+			     (10*HZ), 5))
+		rc = -EIO;
+#endif
+	/* Need code to retrieve data from check condition? */
+	return rc;
+}
+/****************************************************************
+*  Name:   mv_ial_ht_ata_cmd
+*
+*  Description:    handles mv_sata ata IOCTL special drive command (HDIO_DRIVE_CMD)
+*
+*  Parameters:     scsidev - Device to which we are issuing command
+*                  arg     - User provided data for issuing command
+*
+*  Returns:        0 on success, otherwise of failure.
+*
+****************************************************************/
+static int mv_ial_ht_ata_cmd(struct scsi_device *scsidev, void __user *arg)
+{
+	int rc = 0;
+     	u8 scsi_cmd[MAX_COMMAND_SIZE];
+      	u8 args[4] , *argbuf = NULL, *sensebuf = NULL;
+      	int argsize = 0;
+      	enum dma_data_direction data_dir;
+      	int cmd_result;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+	struct scsi_request *sreq;
+#endif
+      	if (arg == NULL)
+          	return -EINVAL;
+  
+      	if (copy_from_user(args, arg, sizeof(args)))
+          	return -EFAULT;
+      	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+	sensebuf = kmalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);
+	if (sensebuf) {
+		memset(sensebuf, 0, SCSI_SENSE_BUFFERSIZE);
+	}
+#else
+	sensebuf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);
+#endif 
+
+      	if (!sensebuf)
+          	return -ENOMEM;
+  
+      	memset(scsi_cmd, 0, sizeof(scsi_cmd));
+      	if (args[3]) {
+          	argsize = SECTOR_SIZE * args[3];
+          	argbuf = kmalloc(argsize, GFP_KERNEL);
+          	if (argbuf == NULL) {
+              		rc = -ENOMEM;
+              		goto error;
+     	}
+  
+     	scsi_cmd[1]  = (4 << 1); /* PIO Data-in */
+     	scsi_cmd[2]  = 0x0e;     /* no off.line or cc, read from dev,
+                                             block count in sector count field */
+      	data_dir = DMA_FROM_DEVICE;
+      	} else {
+       		scsi_cmd[1]  = (3 << 1); /* Non-data */
+       		scsi_cmd[2]  = 0x20;     /* cc but no off.line or data xfer */
+      		data_dir = DMA_NONE;
+	}
+  
+	scsi_cmd[0] = ATA_16;
+  
+   	scsi_cmd[4] = args[2];
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 27)
+    	if (args[0] == WIN_SMART) { /* hack -- ide driver does this too... */
+#else
+	if (args[0] == ATA_CMD_SMART) { /* hack -- ide driver does this too... */	
+#endif	
+        	scsi_cmd[6]  = args[3];
+       		scsi_cmd[8]  = args[1];
+     		scsi_cmd[10] = 0x4f;
+    		scsi_cmd[12] = 0xc2;
+      	} else {
+          	scsi_cmd[6]  = args[1];
+      	}
+      	scsi_cmd[14] = args[0];
+      	
+      	/* Good values for timeout and retries?  Values below
+         	from scsi_ioctl_send_command() for default case... */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+	sreq = scsi_allocate_request(scsidev, GFP_KERNEL);
+	if (!sreq) {
+		rc= -EINTR;
+		goto free_req;
+	}
+	sreq->sr_data_direction = data_dir;
+	scsi_wait_req(sreq, scsi_cmd, argbuf, argsize, (10*HZ), 5);
+
+	/* 
+	 * If there was an error condition, pass the info back to the user. 
+	 */
+	cmd_result = sreq->sr_result;
+	sensebuf = sreq->sr_sense_buffer;
+   
+#elif LINUX_VERSION_CODE >=KERNEL_VERSION(2, 6, 29)
+      	cmd_result = scsi_execute(scsidev, scsi_cmd, data_dir, argbuf, argsize,
+                                sensebuf, (10*HZ), 5, 0,0);
+#else
+      	cmd_result = scsi_execute(scsidev, scsi_cmd, data_dir, argbuf, argsize,
+                                sensebuf, (10*HZ), 5, 0);
+#endif
+
+  
+      	if (driver_byte(cmd_result) == DRIVER_SENSE) {/* sense data available */
+         	u8 *desc = sensebuf + 8;
+          	cmd_result &= ~(0xFF<<24); /* DRIVER_SENSE is not an error */
+  
+          	/* If we set cc then ATA pass-through will cause a
+          	* check condition even if no error. Filter that. */
+          	if (cmd_result & SAM_STAT_CHECK_CONDITION) {
+              	struct scsi_sense_hdr sshdr;
+              	scsi_normalize_sense(sensebuf, SCSI_SENSE_BUFFERSIZE,
+                                   &sshdr);
+              	if (sshdr.sense_key==0 &&
+                  	sshdr.asc==0 && sshdr.ascq==0)
+                  	cmd_result &= ~SAM_STAT_CHECK_CONDITION;
+          	}
+  
+          	/* Send userspace a few ATA registers (same as drivers/ide) */
+          	if (sensebuf[0] == 0x72 &&     /* format is "descriptor" */
+              		desc[0] == 0x09 ) {        /* code is "ATA Descriptor" */
+              		args[0] = desc[13];    /* status */
+              		args[1] = desc[3];     /* error */
+              		args[2] = desc[5];     /* sector count (0:7) */
+              		if (copy_to_user(arg, args, sizeof(args)))
+                  		rc = -EFAULT;
+          	}
+      	}
+  
+      	if (cmd_result) {
+          	rc = -EIO;
+          	goto free_req;
+      	}
+  
+      	if ((argbuf) && copy_to_user(arg + sizeof(args), argbuf, argsize))
+          	rc = -EFAULT;
+      	
+free_req:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+	scsi_release_request(sreq);
+#endif		
+error:
+      	if (sensebuf) kfree(sensebuf);
+      	if (argbuf) kfree(argbuf);
+      	return rc;
+}
+
+static int check_dma (__u8 ata_op)
+{
+	switch (ata_op) {
+		case ATA_CMD_READ_DMA_EXT:
+		case ATA_CMD_READ_FPDMA_QUEUED:
+		case ATA_CMD_WRITE_DMA_EXT:
+		case ATA_CMD_WRITE_FPDMA_QUEUED:
+		case ATA_CMD_READ_DMA:
+		case ATA_CMD_WRITE_DMA:
+			return SG_DMA;
+		default:
+			return SG_PIO;
+	}
+}
+unsigned char excute_taskfile(struct scsi_device *dev,ide_task_request_t *req_task,u8 
+ rw,char *argbuf,unsigned int buff_size)
+{
+	int rc = 0;
+     	u8 scsi_cmd[MAX_COMMAND_SIZE];
+      	u8 *sensebuf = NULL;
+      	int argsize=0;
+	enum dma_data_direction data_dir;
+      	int cmd_result;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+	struct scsi_request *sreq;
+#endif
+      	argsize=buff_size;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+	sensebuf = kmalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);
+	if (sensebuf) {
+		memset(sensebuf, 0, SCSI_SENSE_BUFFERSIZE);
+	}
+#else
+	sensebuf = kzalloc(SCSI_SENSE_BUFFERSIZE, GFP_NOIO);
+#endif 
+      	if (!sensebuf)
+          	return -ENOMEM;
+  
+      	memset(scsi_cmd, 0, sizeof(scsi_cmd));
+
+  	data_dir = DMA_FROM_DEVICE;   // need to fixed
+	scsi_cmd[0] = ATA_16;
+	scsi_cmd[13] = 0x40;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2, 6, 24)
+      	scsi_cmd[14] = ((task_struct_t *)(&req_task->io_ports))->command;
+#else
+	scsi_cmd[14] = ((char *)(&req_task->io_ports))[7];
+#endif
+	if(check_dma(scsi_cmd[14])){
+		scsi_cmd[1] = argbuf ? SG_ATA_PROTO_DMA : SG_ATA_PROTO_NON_DATA;
+	} else {
+		scsi_cmd[1] = argbuf ? (rw ? SG_ATA_PROTO_PIO_OUT : SG_ATA_PROTO_PIO_IN) : SG_ATA_PROTO_NON_DATA;
+	}
+	scsi_cmd[ 2] = SG_CDB2_CHECK_COND;
+	if (argbuf) {
+		scsi_cmd[2] |= SG_CDB2_TLEN_NSECT | SG_CDB2_TLEN_SECTORS;
+		scsi_cmd[2] |= rw ? SG_CDB2_TDIR_TO_DEV : SG_CDB2_TDIR_FROM_DEV;
+	}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+	sreq = scsi_allocate_request(dev, GFP_KERNEL);
+	if (!sreq) {
+		rc= -EINTR;
+		goto free_req;
+	}
+	sreq->sr_data_direction = data_dir;
+	scsi_wait_req(sreq, scsi_cmd, argbuf, argsize, (10*HZ), 5);
+
+	/* 
+	 * If there was an error condition, pass the info back to the user. 
+	 */
+	cmd_result = sreq->sr_result;
+	sensebuf = sreq->sr_sense_buffer;
+   
+#elif LINUX_VERSION_CODE >=KERNEL_VERSION(2, 6, 29)
+      	cmd_result = scsi_execute(dev, scsi_cmd, data_dir, argbuf, argsize,
+                                sensebuf, (10*HZ), 5, 0,0);
+#else
+      	cmd_result = scsi_execute(dev, scsi_cmd, data_dir, argbuf, argsize,
+                                sensebuf, (10*HZ), 5, 0);
+#endif
+  
+      	if (driver_byte(cmd_result) == DRIVER_SENSE) {/* sense data available */
+         	u8 *desc = sensebuf + 8;
+          	cmd_result &= ~(0xFF<<24); /* DRIVER_SENSE is not an error */
+  		
+          	/* If we set cc then ATA pass-through will cause a
+          	* check condition even if no error. Filter that. */
+          	if (cmd_result & SAM_STAT_CHECK_CONDITION) {
+              	struct scsi_sense_hdr sshdr;
+              	scsi_normalize_sense(sensebuf, SCSI_SENSE_BUFFERSIZE,
+                                   &sshdr);
+              	if (sshdr.sense_key==0 &&
+                  	sshdr.asc==0 && sshdr.ascq==0)
+                  	cmd_result &= ~SAM_STAT_CHECK_CONDITION;
+          	}
+      	}
+  
+      	if (cmd_result) {
+          	rc = EIO;
+		MV_PRINT("EIO=%d\n",-EIO);
+          	goto free_req;
+      	}
+#if 0
+      	if ( copy_to_user(argbuf,sensebuf, argsize))
+       		rc = -EFAULT;
+#endif
+free_req:
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 14)
+	scsi_release_request(sreq);
+#endif		
+      	if (sensebuf) kfree(sensebuf);
+      	return rc;
+}
+u8 mv_do_taskfile_ioctl(struct scsi_device *dev,void __user *arg){
+	ide_task_request_t *req_task=NULL;
+	char __user *buf = (char __user *)arg;
+	u8 *outbuf	= NULL;
+	u8 *inbuf	= NULL;
+	int err		= 0;
+	int tasksize	= sizeof(ide_task_request_t);
+	int taskin	= 0;
+	int taskout	= 0;
+	int rw = SG_READ;
+	
+	req_task = kzalloc(tasksize, GFP_KERNEL);
+	if (req_task == NULL) return -ENOMEM;
+	if (copy_from_user(req_task, buf, tasksize)) {
+		kfree(req_task);
+		return -EFAULT;
+	}
+
+	switch (req_task->req_cmd) {
+		case TASKFILE_CMD_REQ_OUT:
+		case TASKFILE_CMD_REQ_RAW_OUT:
+			rw         = SG_WRITE;
+			break;
+		case TASKFILE_CMD_REQ_IN:
+			break;
+	}
+	taskout = (int) req_task->out_size;
+	taskin  = (int) req_task->in_size;
+
+
+	if (taskout) {
+		int outtotal = tasksize;
+		outbuf = kzalloc(taskout, GFP_KERNEL);
+		if (outbuf == NULL) {
+			err = -ENOMEM;
+			goto abort;
+		}
+		if (copy_from_user(outbuf, buf + outtotal, taskout)) {
+			err = -EFAULT;
+			goto abort;
+		}
+	}
+
+	if (taskin) {
+		int intotal = tasksize + taskout;
+		inbuf = kzalloc(taskin, GFP_KERNEL);
+		if (inbuf == NULL) {
+			err = -ENOMEM;
+			goto abort;
+		}
+		if (copy_from_user(inbuf, buf + intotal, taskin)) {
+			err = -EFAULT;
+			goto abort;
+		}
+	}
+	
+	switch(req_task->data_phase) {
+		case TASKFILE_DPHASE_PIO_OUT:
+			err = excute_taskfile(dev,req_task,rw,outbuf,taskout);
+			break;
+		default:
+			err = -EFAULT;
+			goto abort;
+	}
+	if (copy_to_user(buf, req_task, tasksize)) {
+		err = -EFAULT;
+		goto abort;
+	}
+	if (taskout) {
+		int outtotal = tasksize;
+		if (copy_to_user(buf + outtotal, outbuf, taskout)) {
+			err = -EFAULT;
+			goto abort;
+		}
+	}
+	if (taskin) {
+		int intotal = tasksize + taskout;
+		if (copy_to_user(buf + intotal, inbuf, taskin)) {
+			err = -EFAULT;
+			goto abort;
+		}
+	}
+abort:
+	kfree(req_task);
+	kfree(outbuf);
+	kfree(inbuf);
+
+	return err;
+}
+
+int mv_new_ioctl(struct scsi_device *dev, int cmd, void __user *arg)
+{
+	int error,writing = 0, length;
+	int console,nr_hba;
+	int nbit;
+	static int mutex_flag = 0;
+	void * kbuf = NULL;
+	int val = 0;
+	struct scsi_idlun idlun;
+	struct request *rq;
+	struct request_queue * q = dev->request_queue;
+	PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER psptdwb = NULL;
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,9)
+	struct scsi_request *sreq;
+#endif
+   
+	/*Workaround for GCC 4.3 */
+	if(mutex_flag == 0){		
+		spin_lock_init(&ioctl_index_spin);
+		mutex_flag = 1;
+	}
+	switch (cmd){
+
+	case HDIO_GET_IDENTITY:
+		psptdwb = hba_mem_alloc(sizeof(*psptdwb),MV_FALSE);
+		if (!psptdwb)
+			return -ENOMEM;
+		/* extract with a function */
+		psptdwb->sptd.DataTransferLength = 512;
+		psptdwb->sptd.DataBuffer = arg;
+		psptdwb->sptd.CdbLength = 16;
+		memcpy((void*)psptdwb->sptd.Cdb, ata_ident, 16);
+		goto fetch_data;
+
+	case HDIO_GET_32BIT:
+		if (copy_to_user(arg, &val, 1))
+			return -EFAULT;
+		return 0;
+	case HDIO_SET_32BIT:
+		val = (unsigned long)arg;
+		if (val != 0)
+			return -EINVAL;
+		return 0;
+	case HDIO_DRIVE_CMD:
+             	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
+                 	return -EACCES;
+ 
+             	return mv_ial_ht_ata_cmd(dev, arg);
+
+	case HDIO_DRIVE_TASK:
+		if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
+			return -EACCES;
+		return mv_ata_task_ioctl(dev, arg);
+	case HDIO_DRIVE_TASKFILE:
+		return mv_do_taskfile_ioctl(dev,arg);
+
+	default:
+		break;
+	}
+
+	switch(cmd - API_BLOCK_IOCTL_DEFAULT_FUN){
+	case API_IOCTL_GET_VIRTURL_ID:
+		console = VIRTUAL_DEVICE_ID;
+		if (copy_to_user(((PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER) arg)->sptd.DataBuffer,
+			(void *)&console,sizeof(int)))
+			return -EIO;
+		return 0;
+	case API_IOCTL_GET_HBA_COUNT:
+		nr_hba = __mv_get_adapter_count();
+		if (copy_to_user(((PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER) arg)->sptd.DataBuffer,
+			(void *)&nr_hba,sizeof(unsigned int)))
+			return -EIO;
+		return 0;
+	case API_IOCTL_LOOKUP_DEV:
+		if(copy_from_user(&idlun, ((PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER) arg)->sptd.DataBuffer,
+			sizeof(struct scsi_idlun)))
+			return -EIO;
+		if(dev->host->host_no != ((idlun.dev_id) >> 24))
+			return EFAULT;
+		return 0;
+	case API_IOCTL_CHECK_VIRT_DEV:
+		if( dev->id != VIRTUAL_DEVICE_ID)
+			return -EFAULT;
+		return 0;
+#ifdef API_GET_ENC_ID
+	case API_IOCTL_GET_ENC_ID:
+		return mv_get_enc_scsi_id((MV_PVOID)dev,(MV_PVOID)arg);
+#endif
+	case API_IOCTL_DEFAULT_FUN:
+		break;
+	default:
+		/*  set default with no such terminal, not -ENOPERM to cater to Linux */
+		return -ENOTTY;
+	}
+
+	psptdwb = hba_mem_alloc(sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
+	if (!psptdwb)
+		return -ENOMEM;
+	error = copy_from_user(psptdwb, (void *)arg, sizeof(*psptdwb));
+	if (error) {
+		hba_mem_free(psptdwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
+		return -EIO;
+	}
+fetch_data:
+	length = psptdwb->sptd.DataTransferLength;
+
+	if (length){
+		if(length > IOCTL_BUF_LEN || (kbuf = hba_mem_alloc(length,MV_TRUE)) == NULL ){
+			hba_mem_free(psptdwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
+			return -ENOMEM;
+		}
+		if(copy_from_user(kbuf, psptdwb->sptd.DataBuffer, length)){
+			hba_mem_free(psptdwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
+			hba_mem_free(kbuf,length,MV_TRUE);
+			return -EIO;
+		}
+
+#ifdef AMCC_CLI_WORKROUND
+		if (psptdwb->sptd.Cdb[0] == APICDB0_FLASH && psptdwb->sptd.Cdb[1] == APICDB1_FLASH_BIN && \
+			psptdwb->sptd.Cdb[2] == FLASH_UPLOAD && psptdwb->sptd.Cdb[3] == FLASH_TYPE_CONFIG){
+			memcpy(page_buffer,&((unsigned char *)kbuf)[8], 0x4000);
+		}
+#endif
+		if ((SCSI_IS_WRITE(psptdwb->sptd.Cdb[0])) || (psptdwb->sptd.DataIn == 0))
+			writing = 1;
+	}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
+	rq = blk_get_request(q, writing ? WRITE : READ, GFP_KERNEL);
+	if (!rq) {
+		hba_mem_free(psptdwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
+		return -ENOMEM;
+	}
+#else
+	sreq = scsi_allocate_request(dev, GFP_KERNEL);
+	if (!sreq) {
+		MV_PRINT("SCSI internal ioctl failed, no memory\n");
+		return -ENOMEM;
+	}
+	rq = sreq->sr_request;
+#endif
+
+	rq->cmd_len = psptdwb->sptd.CdbLength;
+	psptdwb->sptd.ScsiStatus = REQ_STATUS_PENDING;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19)
+	rq->cmd_type = REQ_TYPE_BLOCK_PC;
+	rq->tag = psptdwb->sptd.ScsiStatus;
+#else
+  #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
+	rq->flags |= REQ_BLOCK_PC;
+	rq->rq_status = psptdwb->sptd.ScsiStatus;
+  #else
+  	rq->tag = psptdwb->sptd.ScsiStatus;
+  #endif
+#endif
+	rq->timeout = msecs_to_jiffies(psptdwb->sptd.TimeOutValue);
+	if(!rq->timeout)
+		rq->timeout = 60 * HZ;
+	memcpy(rq->cmd, psptdwb->sptd.Cdb, psptdwb->sptd.CdbLength);
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
+	if(length && blk_rq_map_kern(q, rq,kbuf, length, __GFP_WAIT)){
+		error = -EIO;
+		goto out;
+	}
+	rq->retries = 1;
+#else
+	rq->data = kbuf;
+	rq->data_len = length;
+#endif
+
+	rq->sense = psptdwb->Sense_Buffer;
+	rq->sense_len = psptdwb->sptd.SenseInfoLength;
+
+
+
+	spin_lock(&ioctl_index_spin);
+	nbit = find_first_zero_bit((unsigned long*)kbuf_index,512);
+	if(nbit >= 512){		
+		spin_unlock(&ioctl_index_spin);
+		error = -ENOSPC;
+		goto out;
+	}
+	__set_bit(nbit, kbuf_index);
+	spin_unlock(&ioctl_index_spin);
+
+	/*make sure till queuecommand we will not reuse the field.*/
+	rq->errors= nbit + 1;
+	kbuf_array[nbit] = kbuf;
+	memcpy((void*)mvcdb[nbit],rq->cmd,16);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+	error = blk_execute_rq(q, NULL, rq, 0);
+#else
+	error = blk_execute_rq(q, NULL, rq);
+#endif
+
+#else
+	sreq->sr_data_direction = writing ? DMA_TO_DEVICE : DMA_FROM_DEVICE;
+	scsi_wait_req(sreq, rq->cmd, kbuf, length,  rq->timeout, 1);
+	memcpy(rq->sense,sreq->sr_sense_buffer,rq->sense_len);
+	if(sreq->sr_result)
+		error = -EIO;
+	else
+		error = sreq->sr_result;
+#endif	//#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
+
+	spin_lock(&ioctl_index_spin);
+	__clear_bit(nbit,kbuf_index);
+	spin_unlock(&ioctl_index_spin);
+	kbuf_array[nbit] = NULL;
+	memset((void*)mvcdb[nbit],0x00,16);
+
+	/* Fix hdparm -i get inverse param info.*/
+	if (length && (cmd == HDIO_GET_IDENTITY))
+		io_get_identity(kbuf);
+	
+	if (error) {
+		/* REQ_STATUS_HAS_SENSE is Used by SCSI command ;REQ_STATUS_ERROR_WITH_SENSE
+		is used by RAID API and Sense_Info_Buffer[0] is used to pass error code to RAID API . */
+		if ( rq->sense_len && rq->sense && ((MV_PU8)rq->sense)[0]) {
+			MV_DPRINT(("%s has sense,rq->sense[0]=0x%x\n", __func__,((MV_PU8)rq->sense)[0]));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19) || LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,9)
+			if (rq->tag == REQ_STATUS_ERROR_WITH_SENSE)
+				error = rq->tag;
+#else
+			if(rq->rq_status == REQ_STATUS_ERROR_WITH_SENSE)
+				error = rq->rq_status;
+#endif
+		}
+	} else if (length && copy_to_user(psptdwb->sptd.DataBuffer,kbuf,length)) {
+                        error = -EIO;
+                        goto out;
+	}
+	if (mv_is_api_cmd(cmd) && copy_to_user((void*)arg,psptdwb,
+		sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER))){
+		error = -EIO;
+		goto out;
+	}
+
+out:
+	hba_mem_free(psptdwb,sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER),MV_FALSE);
+	hba_mem_free(kbuf, psptdwb->sptd.DataTransferLength,MV_TRUE);
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,9)
+	blk_put_request(rq);
+#else
+	scsi_release_request(sreq);
+#endif
+	return error;
+}
+#endif
+/*
+ *Character Device Interface.
+ */
+#ifdef RAID_DRIVER
+static int mv_open(struct inode *inode, struct file *file)
+{
+	unsigned int minor_number;
+	int retval = -ENODEV;
+	unsigned long flags = 0;
+#ifndef MV_VMK_ESX35
+	spin_lock_irqsave(&inode->i_lock, flags);
+	minor_number = MINOR(inode->i_rdev);
+	if (minor_number >= __mv_get_adapter_count()) {
+		MV_PRINT("MV : No such device.\n");
+		goto out;
+	}
+	retval = 0;
+out:
+	spin_unlock_irqrestore(&inode->i_lock, flags);
+	return retval;
+#else
+	return 0;
+#endif
+}
+
+#ifndef MV_BLK_IOCTL
+#if defined(__VMKLNX__) || defined(MV_VMK_ESX35) 
+static int _mv_major;
+int mv_register_chdev(struct hba_extension *hba)
+{
+#ifndef MV_VMK_ESX35
+	apidev_class = class_create(THIS_MODULE, MV_DEVFS_NAME);
+	if (IS_ERR(apidev_class)) {
+		printk("mv ioctl: %s: Unable to sysfs class\n", __func__);
+		apidev_class = NULL;
+		return 1;
+	}
+	printk("mv ioctl: %s: apidev_class=%p.\n", __func__, apidev_class);
+#endif
+
+	_mv_major = register_chrdev(0,
+        	        MV_DEVFS_NAME,
+                	&mv_fops);
+	if (_mv_major < 0){
+		printk("mv ioctl: %s: Unable to register CHAR device (%d)\n",
+		    __func__, _mv_major);
+#ifndef MV_VMK_ESX35
+		class_destroy(apidev_class);
+		apidev_class = NULL;
+#endif
+		return _mv_major;
+	}
+
+else
+	printk("mv ioctl: %s: Successfully to register CHAR device (%d)\n",
+		__func__, _mv_major);
+
+#ifndef MV_VMK_ESX35
+        class_device_create(apidev_class, NULL, MKDEV(_mv_major, 0), NULL,
+            		MV_DEVFS_NAME);
+#endif
+}
+
+void mv_unregister_chdev(struct hba_extension *hba)
+{
+#ifndef MV_VMK_ESX35
+	if (!apidev_class)
+		return;
+	class_device_destroy(apidev_class, MKDEV(_mv_major, 0));
+#endif
+	unregister_chrdev(_mv_major, MV_DEVFS_NAME);
+
+#ifndef MV_VMK_ESX35
+	class_destroy(apidev_class);
+	apidev_class = NULL;
+#endif
+}
+
+#else
+static dev_t _mv_major = 0;
+
+int mv_register_chdev(struct hba_extension *hba)
+{
+	int ret = 0;
+	dev_t num;
+
+	/*
+	 * look for already-allocated major number first, if not found or
+	 * fail to register, try allocate one .
+	 *
+	 */
+	if (_mv_major) {
+		ret = register_chrdev_region(MKDEV(_mv_major,
+						   hba->desc->hba_desc->id),
+					     1,
+					     MV_DEVFS_NAME);
+		num = MKDEV(_mv_major, hba->desc->hba_desc->id);
+	}
+	if (ret) {
+		MV_DPRINT(("registered chrdev (%d, %d) failed.\n",
+	       	_mv_major, hba->desc->hba_desc->id));
+		return	ret;
+	}
+	if (ret || !_mv_major) {
+		ret = alloc_chrdev_region(&num,
+					  hba->desc->hba_desc->id,
+					  1,
+					  MV_DEVFS_NAME);
+		if (ret) {
+			MV_DPRINT(( "allocate chrdev (%d, %d) failed.\n",
+		       	MAJOR(num), hba->desc->hba_desc->id));
+			return ret;
+		} else
+			_mv_major = MAJOR(num);
+	}
+
+	memset(&hba->desc->hba_desc->cdev, 0, sizeof(struct cdev));
+	cdev_init(&hba->desc->hba_desc->cdev, &mv_fops);
+	hba->desc->hba_desc->cdev.owner = THIS_MODULE;
+	hba->desc->hba_desc->dev_no = num;
+	MV_DPRINT((  "registered chrdev (%d, %d).\n",
+	       MAJOR(num), MINOR(num)));
+	ret = cdev_add(&hba->desc->hba_desc->cdev, num, 1);
+
+	return ret;
+}
+
+void mv_unregister_chdev(struct hba_extension *hba)
+{
+	cdev_del(&hba->desc->hba_desc->cdev);
+	unregister_chrdev_region(hba->desc->hba_desc->dev_no, 1);
+}
+
+#endif
+#endif
+
+MV_U8 mv_check_ioctl_req(PMV_Request    req)
+{
+	switch(req->Cdb[0]){
+	case APICDB0_ADAPTER:
+	case APICDB0_LD:
+	case APICDB0_PD:
+	case APICDB0_BLOCK:
+	case APICDB0_EVENT:
+	case APICDB0_DBG:
+	case API_SCSI_CMD_RCV_DIAG_RSLT:
+	case API_SCSI_CMD_SND_DIAG:
+#ifdef SUPPORT_PASS_THROUGH_DIRECT
+	case APICDB0_PASS_THRU_CMD_SCSI:
+	case APICDB0_PASS_THRU_CMD_ATA:
+#endif
+		return	MV_TRUE;
+
+	default:
+		return	MV_FALSE;
+	}
+	return	MV_FALSE;
+}
+
+#ifdef API_GET_ENC_ID
+ int mv_get_enc_scsi_id(MV_PVOID hba_dev,MV_PVOID arg)
+{
+	struct Scsi_Host  *host;
+	struct scsi_device *sdev = NULL;
+	penc_hctl_info enc_hctl = NULL;
+	MV_U16 target_id = 0,i=0;
+	MV_U8 num = 0,max_enc_num = 0;
+	unsigned long data_transfer_length = 0;
+#ifdef MV_BLK_IOCTL
+	struct scsi_device *dev = (struct scsi_device * )hba_dev;
+	host = dev->host;
+#else
+	struct hba_extension *hba =(struct hba_extension *)hba_dev;
+	host = hba->desc->hba_desc->hba_host;
+#endif
+	data_transfer_length = ((PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER) arg)->sptd.DataTransferLength;
+	max_enc_num = data_transfer_length/sizeof(enc_hctl_info);
+	enc_hctl = (penc_hctl_info)hba_mem_alloc(data_transfer_length,MV_FALSE);
+	if(!enc_hctl){
+		hba_mem_free(enc_hctl, data_transfer_length,MV_FALSE);
+		return -ENOMEM;
+	}
+	memset(enc_hctl,0,data_transfer_length);
+
+	for(target_id=0;target_id<0xFF;target_id++) {
+		sdev = scsi_device_lookup(host,0 ,target_id,0);
+		if(sdev) {
+			if((sdev->type == enclosure)&&(num < max_enc_num)){
+				enc_hctl[num].host_no=sdev->host->host_no;
+				enc_hctl[num].channel = sdev->channel;
+				enc_hctl[num].target_id = sdev->id;
+				enc_hctl[num].lun = sdev->lun;
+				//enc_hctl[num].dev_id = MIN_ENC_ID+num;
+				enc_hctl[num].enc_num = num+1;
+				num++;
+			}
+			scsi_device_put(sdev);
+		}
+	}
+#ifdef MV_DEBUG
+	for(i=0;i<num;i++)
+		MV_DPRINT(("max_enc_num: %d enc_num:%d dev_id:%02d Host:%d Channel:%02d Id:%02d Lun:%02d\n", \
+			max_enc_num,enc_hctl[i].enc_num ,enc_hctl[i].dev_id,enc_hctl[i].host_no,\
+			enc_hctl[i].channel ,enc_hctl[i].target_id,enc_hctl[i].lun ));
+#endif
+	if(num){
+		if (copy_to_user(((PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER) arg)->sptd.DataBuffer,
+			enc_hctl,data_transfer_length)){
+			hba_mem_free(enc_hctl, data_transfer_length,MV_FALSE);
+              	return -EIO;
+      	 	}
+	}
+	hba_mem_free(enc_hctl, data_transfer_length,MV_FALSE);
+	return 0;
+}
+#endif
+
+
+#if defined (HAVE_UNLOCKED_IOCTL) && !defined (__VMKLNX__)
+static long mv_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+#else
+static int mv_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+#endif
+{
+	struct _SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER karg;
+	struct _SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER  __user *uarg = (void __user *) arg;
+	struct hba_extension	*hba;
+	struct mv_adp_desc *hba_desc;
+	PMV_Request    req = NULL;
+	int error = 0;
+	int ret   = 0;
+	int sptdwb_size = sizeof(SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER);
+	int console_id  = VIRTUAL_DEVICE_ID;
+	unsigned long flags;
+	PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER psptdwb = NULL;
+	int mv_device_count;
+	struct scsi_idlun idlun;
+#ifdef SUPPORT_SES
+	BUS_ADDRESS busaddr = 0;
+	dma_addr_t      dma_addr;
+	MV_PVOID        vir_addr = NULL;
+#endif
+	void *ioctl_buf = NULL;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36))
+	DECLARE_MUTEX(sem_lock);
+#else
+    DEFINE_SEMAPHORE(sem_lock);
+#endif
+
+
+#if defined(__VMKLNX__) || defined(MV_VMK_ESX35) 
+	hba_desc = gl_hba_desc;
+#else
+#ifdef HAVE_UNLOCKED_IOCTL
+	hba_desc = container_of(file->f_dentry->d_inode->i_cdev,struct mv_adp_desc, cdev);
+#else
+	hba_desc = container_of(inode->i_cdev, struct mv_adp_desc, cdev);
+#endif
+#endif
+
+	if (!hba_desc) {
+		MV_DPRINT(( "Marvell : Driver is not installed ,Invalid operation.\n"));
+		return -EPERM;
+
+	}
+	hba = (struct hba_extension	*)mv_get_hba_extension(hba_desc);
+
+	/*if the driver is shutdown ,any process shouldn't call mv_ioctl*/
+	if(hba != NULL) {
+		if( DRIVER_STATUS_SHUTDOWN == hba->State ) {
+			MV_DPRINT((  "Marvell : Driver had been rmmoded ,Invalid operation.\n"));
+			return -EPERM;
+		}
+	} else {
+		MV_DPRINT(( "Marvell : Driver is not installed ,Invalid operation.\n"));
+		return -EPERM;
+	}
+
+	mv_device_count =  __mv_get_adapter_count();
+
+	if (cmd >= API_IOCTL_MAX) {
+			MV_DPRINT(( "Marvell : Invalid ioctl command.\n"));
+			return -EBADF;
+	}
+
+	if (copy_from_user(&karg, uarg, sizeof(struct _SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER))) {
+		MV_PRINT(( "Marvell : Clone User Data Error.\n"));
+		return -EFAULT;
+	}	
+
+	if (cmd == API_IOCTL_GET_VIRTURL_ID) {
+		if (copy_to_user((void __user *)karg.sptd.DataBuffer,
+			(void *)&console_id,sizeof(int)) != 0 ) {
+			MV_DPRINT(( "Marvell : Get VIRTUAL_DEVICE_ID Error.\n"));
+			return -EIO;
+		}
+		return 0;
+	}
+
+	if (cmd == API_IOCTL_GET_HBA_COUNT) {
+		if (copy_to_user((void __user *)karg.sptd.DataBuffer,
+			(void *)&mv_device_count,sizeof(unsigned int)) != 0) {
+			MV_DPRINT(( "Marvell : Get Device Number Error.\n"));
+			return -EIO;
+		}
+		return 0;
+	}
+
+	if (cmd == API_IOCTL_LOOKUP_DEV) {
+		if( copy_from_user(&idlun, (void __user *)karg.sptd.DataBuffer,
+			sizeof(struct scsi_idlun)) !=0) {
+			MV_DPRINT(( "Marvell : Get Device idlun Error.\n"));
+			return -EIO;
+		}
+
+		/*To check host no, if fail, return EFAULT (Bad address) */
+		if (hba_desc->hba_host->host_no != ((idlun.dev_id) >> 24)) {
+			MV_DPRINT(( "Marvell : lookup device host number error .\n"));
+			return EFAULT;
+		}
+		/*
+		if (hba->host->host_no == ((idlun.dev_id) >> 24)) {
+			sdev = scsi_device_lookup(hba->host, (idlun.dev_id >> 16)&0xff,(idlun.dev_id)&0xff,(idlun.dev_id >> 8)&0xff);
+			if (!sdev) {
+				MV_DBG(DMSG_IOCTL, "Marvell : lookup device .\n");
+				return -EIO;
+			}
+			scsi_device_put(sdev);
+		}
+		*/
+		return 0;
+	}
+
+#ifdef API_GET_ENC_ID
+		if (cmd==API_IOCTL_GET_ENC_ID){
+			return mv_get_enc_scsi_id((MV_PVOID)hba,(MV_PVOID)&karg;
+		}
+#endif
+	if (down_trylock(&sem_lock)) {
+		up(&sem_lock);
+		return -EINTR;
+	}
+	psptdwb = hba_mem_alloc(sptdwb_size,MV_FALSE);
+	if ( NULL == psptdwb ) {
+		MV_DPRINT(( "__MV__ alloc psptwb buffer fail .\n"));
+		ret = -ENOMEM;
+		goto free_lock;
+	}
+
+	error = copy_from_user(psptdwb, uarg, sptdwb_size);
+	if (error) {
+		ret = -EIO;
+		goto clean_pspbuf;
+	}
+
+	if (psptdwb->sptd.DataTransferLength) {
+#ifdef SUPPORT_SES
+		/*receive dialog info,cdb[1]=0x01;send dialog info ,cdb[1]=0x10; */
+		if( __is_scsi_cmd_rcv_snd_diag(psptdwb->sptd.Cdb[0])) {
+			if((psptdwb->sptd.Cdb[1] ==0x01) ||(psptdwb->sptd.Cdb[1]==0x10)) {
+				psptdwb->sptd.DataTransferLength = ROUNDING(psptdwb->sptd.DataTransferLength, 8);
+				psptdwb->sptd.DataBuffer = (MV_PVOID) pci_alloc_consistent(hba_desc->dev,
+					psptdwb->sptd.DataTransferLength,&dma_addr);
+				if (NULL == psptdwb->sptd.DataBuffer ) {
+					MV_DPRINT(( "Ioctl unable to alloc 0x%lx consistent mem.\n",
+						psptdwb->sptd.DataTransferLength));
+					pci_free_consistent(hba_desc->dev,  psptdwb->sptd.DataTransferLength,
+						psptdwb->sptd.DataBuffer,dma_addr);
+					ret = -ENOMEM;
+					goto clean_pspbuf;
+				}
+				memset(psptdwb->sptd.DataBuffer, 0, psptdwb->sptd.DataTransferLength);
+				vir_addr = psptdwb->sptd.DataBuffer;
+			} else {
+				ioctl_buf = hba_mem_alloc(psptdwb->sptd.DataTransferLength,MV_FALSE);
+				if ( NULL == ioctl_buf ) {
+					MV_DPRINT((  "__MV__ alloc ioctl_buf fail .\n"));
+					ret = -ENOMEM;
+					goto clean_pspbuf;
+				}
+				psptdwb->sptd.DataBuffer = ioctl_buf;
+				memset(ioctl_buf, 0, psptdwb->sptd.DataTransferLength);
+			}
+
+		}else
+#endif
+		{
+			ioctl_buf = hba_mem_alloc(psptdwb->sptd.DataTransferLength,MV_FALSE);
+			if ( NULL == ioctl_buf ) {
+				MV_DPRINT(( "__MV__ alloc ioctl_buf fail .\n"));
+				ret = -ENOMEM;
+				goto clean_pspbuf;
+			}
+			psptdwb->sptd.DataBuffer = ioctl_buf;
+			memset(ioctl_buf, 0, psptdwb->sptd.DataTransferLength);
+		}
+		error = copy_from_user( psptdwb->sptd.DataBuffer,
+					(void __user *)karg.sptd.DataBuffer,psptdwb->sptd.DataTransferLength);
+		if (error) {
+			ret = -EIO;
+			goto clean_dmabuf;
+		}
+	} else {
+		psptdwb->sptd.DataBuffer = NULL;
+	}
+	memset(psptdwb->Sense_Buffer, 0, SENSE_INFO_BUFFER_SIZE);
+
+	#ifdef USE_REQ_POOL
+		req = hba_req_cache_alloc(hba);
+	#else
+		req = res_get_req_from_pool(hba->req_pool);
+	#endif
+
+	if (NULL == req) {
+		ret = -ENOMEM;
+		goto clean_dmabuf;
+	}
+
+	req->Cmd_Initiator = hba;
+	req->Org_Req = req;
+	req->Device_Id = psptdwb->sptd.TargetId;
+	req->Cmd_Flag = 0;
+	req->Req_Type = REQ_TYPE_INTERNAL;
+	psptdwb->sptd.ScsiStatus = REQ_STATUS_PENDING;
+	req->Scsi_Status = psptdwb->sptd.ScsiStatus;
+
+	if (psptdwb->sptd.DataTransferLength == 0) {
+		//req->Cmd_Flag |= CMD_FLAG_NON_DATA;
+	} else {
+		if (SCSI_IS_READ(psptdwb->sptd.Cdb[0]))
+			req->Cmd_Flag |= CMD_FLAG_DATA_IN;
+		if (SCSI_IS_READ(psptdwb->sptd.Cdb[0]) || SCSI_IS_WRITE(psptdwb->sptd.Cdb[0]))
+			req->Cmd_Flag |= CMD_FLAG_DMA;
+	}
+
+	req->Data_Transfer_Length = psptdwb->sptd.DataTransferLength;
+	req->Data_Buffer = psptdwb->sptd.DataBuffer;
+	req->Sense_Info_Buffer = psptdwb->Sense_Buffer;
+	memcpy(req->Cdb, psptdwb->sptd.Cdb, MAX_CDB_SIZE);
+	memset(req->Context, 0, sizeof(MV_PVOID)*MAX_POSSIBLE_MODULE_NUMBER);
+	req->LBA.value = 0;
+	req->Sector_Count = 0;
+	req->Completion = ioctlcallback;
+	SGTable_Init(&req->SG_Table, 0);
+
+#ifdef SUPPORT_SES
+	/*receive dialog info,cdb[1]=0x01; send dialog info , cdb[1]=0x10; */
+	if( __is_scsi_cmd_rcv_snd_diag(req->Cdb[0])) {
+		if((req->Cdb[1] ==0x01) ||(req->Cdb[1]==0x10)) {
+			if(req->Cdb[0] ==API_SCSI_CMD_RCV_DIAG_RSLT)
+				req->Cmd_Flag = CMD_FLAG_DATA_IN;
+			if(req->Cdb[0] ==API_SCSI_CMD_SND_DIAG	)
+				req->Cmd_Flag &= ~CMD_FLAG_DATA_IN;
+			busaddr = (BUS_ADDRESS)dma_addr;
+			SGTable_Append(
+				&req->SG_Table,
+				LO_BUSADDR(busaddr),
+				HI_BUSADDR(busaddr),
+				req->Data_Transfer_Length);
+		}
+	}
+#endif
+	if( hba->Ioctl_Io_Count > MV_MAX_IOCTL_REQUEST){
+			MV_DPRINT(( "__MV__  ioctl Io Count = 0x%x req->Cdb[0-2](%x-%x-%x).\n",
+				hba->Ioctl_Io_Count,req->Cdb[0],req->Cdb[1],req->Cdb[2]));
+			ret = -EBUSY;
+#ifdef USE_REQ_POOL
+                hba_req_cache_free(hba,req);
+#else
+                res_free_req_to_pool(hba->req_pool, req);
+#endif
+			goto clean_reqpool;
+	}
+
+#ifdef SUPPORT_TASKLET
+	tasklet_disable(&hba->desc->hba_desc->mv_tasklet);
+#endif	
+	spin_lock_irqsave(&hba->desc->hba_desc->global_lock, flags);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&hba->desc->hba_desc->hba_ioctl_sync, 1);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+	 hba->Ioctl_Io_Count++;
+	hba->desc->ops->module_sendrequest(hba->desc->extension, req);
+
+#ifdef CORE_NO_RECURSIVE_CALL
+	{
+		MV_PVOID core = (MV_PVOID)HBA_GetModuleExtension(hba, MODULE_CORE);
+		core_push_queues(core);
+	}
+#endif
+
+	spin_unlock_irqrestore(&hba->desc->hba_desc->global_lock, flags);
+
+#ifdef SUPPORT_TASKLET
+	tasklet_enable(&hba->desc->hba_desc->mv_tasklet);
+#endif
+
+#ifdef CORE_NO_RECURSIVE_CALL
+	{
+		MV_PVOID core = (MV_PVOID)HBA_GetModuleExtension(hba, MODULE_CORE);
+		core_push_queues(core);
+	}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	if (!__hba_wait_for_atomic_timeout(&hba->desc->hba_desc->hba_ioctl_sync,HBA_REQ_TIMER_IOCTL*HZ))
+#else
+	if (!wait_for_completion_timeout(&hba->desc->hba_desc->ioctl_cmpl,HBA_REQ_TIMER_IOCTL*HZ))
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+	{
+		MV_DPRINT((  "__MV__  ioctl Io timerout req->Cdb[0-2](%x-%x-%x).\n",
+		req->Cdb[0],req->Cdb[1],req->Cdb[2]));
+		if(hba->Ioctl_Io_Count)
+		hba->Ioctl_Io_Count--;
+#ifdef USE_REQ_POOL
+		hba_req_cache_free(hba,req);
+#else
+		res_free_req_to_pool(hba->req_pool, req);
+#endif
+	        ret = -EIO;
+	        goto clean_reqpool;
+	}
+
+	if (psptdwb->sptd.DataTransferLength) {
+		error = copy_to_user((void __user *)karg.sptd.DataBuffer,
+				     psptdwb->sptd.DataBuffer, psptdwb->sptd.DataTransferLength);
+		if (error) {
+			ret = -EIO;
+			goto clean_reqpool;
+		}
+	}
+	psptdwb->sptd.ScsiStatus = req->Scsi_Status ;
+	error = copy_to_user(uarg, (void *)psptdwb, sptdwb_size);
+	if (error) {
+		ret = -EIO;
+		goto clean_reqpool;
+	}
+
+	if (req->Scsi_Status)
+		ret = req->Scsi_Status;
+
+	if (req->Scsi_Status == REQ_STATUS_INVALID_PARAMETER)
+		ret = -EPERM;
+
+clean_reqpool:
+
+clean_dmabuf:
+	#ifdef SUPPORT_SES
+	if( __is_scsi_cmd_rcv_snd_diag(psptdwb->sptd.Cdb[0])) {
+		if(( psptdwb->sptd.Cdb[1] == 0x01) || (psptdwb->sptd.Cdb[1] == 0x10)) {
+			if (NULL != vir_addr)
+				pci_free_consistent(hba_desc->dev,  psptdwb->sptd.DataTransferLength,vir_addr,dma_addr);
+		} else {
+			if(ioctl_buf)
+				hba_mem_free(ioctl_buf, psptdwb->sptd.DataTransferLength,MV_FALSE);
+		}
+	} else {
+		if(ioctl_buf)
+			hba_mem_free(ioctl_buf, psptdwb->sptd.DataTransferLength,MV_FALSE);
+	}
+	#endif
+clean_pspbuf:
+	hba_mem_free(psptdwb,sptdwb_size,MV_FALSE);
+
+free_lock:
+	up(&sem_lock);
+	if(hba->Ioctl_Io_Count)
+		hba->Ioctl_Io_Count --;
+
+	return ret;
+}
+
+static long
+mv_unlock_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+        long ret;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36))
+     DECLARE_MUTEX(sem_ioctl_lock);
+#else
+     DEFINE_SEMAPHORE(sem_ioctl_lock);
+#endif
+        up(&sem_ioctl_lock);
+#if defined (HAVE_UNLOCKED_IOCTL) && !defined (__VMKLNX__)
+        ret = mv_ioctl(file, cmd, arg);
+#else
+		ret = mv_ioctl(NULL, file, cmd, arg);
+#endif
+        down(&sem_ioctl_lock);
+
+        return ret;
+}
+
+#else  /* RAID_DRIVER */
+inline int mv_register_chdev(struct hba_extension *hba) {return 0;}
+inline void mv_unregister_chdev(struct hba_extension *hba) {}
+#endif /* RAID_DRIVER */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/linux_iface.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/linux_iface.h
--- linux-3.10.69/drivers/scsi/mv/linux_iface.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/linux_iface.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,152 @@
+/*
+ *
+ *  Kernel/CLI interface
+ *
+ */
+
+#ifndef __MV_HBA_LINUX_INTERFACE__
+#define __MV_HBA_LINUX_INTERFACE__
+
+#include "hba_header.h"
+#include "com_ioctl.h"
+#include "com_adapter_struct.h"
+
+/*Request Structure.*/
+#define SENSE_INFO_BUFFER_SIZE		32
+#define MAX_COMMAND_SIZE		16
+
+/* For Character Device Interface */
+#define MV_DEVICE_MAX_SLOT 4
+
+#define LDINFO_NUM (MAX_LD_SUPPORTED_PERFORMANCE * MAX_NUM_ADAPTERS)
+#define HDINFO_NUM (MAX_DEVICE_SUPPORTED_PERFORMANCE * MAX_NUM_ADAPTERS)
+
+/* DMA read write command */
+#define ATA_CMD_READ_DMA			0xC8	/* 24 bit DMA read */
+#define ATA_CMD_READ_DMA_QUEUED			0xC7	/* 24 bit TCQ DMA read */
+#define ATA_CMD_READ_DMA_EXT			0x25	/* 48 bit DMA read */
+#define ATA_CMD_READ_DMA_QUEUED_EXT		0x26	/* 48 bit TCQ DMA read */
+#define ATA_CMD_READ_FPDMA_QUEUED		0x60	/* NCQ DMA read: SATA only.* Always 48 bit */
+
+#define ATA_CMD_WRITE_DMA			0xCA	
+#define ATA_CMD_WRITE_DMA_QUEUED		0xCC
+#define ATA_CMD_WRITE_DMA_EXT  			0x35
+#define ATA_CMD_WRITE_DMA_QUEUED_EXT		0x36
+#define ATA_CMD_WRITE_FPDMA_QUEUED		0x61
+
+#define ATA_CMD_READ_PIO			0x20
+#define ATA_CMD_READ_PIO_MULTIPLE               0xC4
+#define ATA_CMD_READ_PIO_EXT			0x24
+#define ATA_CMD_READ_PIO_MULTIPLE_EXT 		0x29
+#define ATA_CMD_WRITE_PIO			0x30
+#define ATA_CMD_WRITE_PIO_MULTIPLE              0xC5
+#define ATA_CMD_WRITE_PIO_EXT			0x34
+#define ATA_CMD_WRITE_PIO_MULTIPLE_EXT		0x39
+#define ATA_CMD_WRITE_PIO_MULTIPLE_FUA_EXT      0xCE
+
+#ifndef ATA_CMD_SMART
+#define ATA_CMD_SMART					0xB0
+#endif
+
+enum {
+	SG_CDB2_TLEN_NODATA	= 0 << 0,
+	SG_CDB2_TLEN_FEAT	= 1 << 0,
+	SG_CDB2_TLEN_NSECT	= 2 << 0,
+
+	SG_CDB2_TLEN_BYTES	= 0 << 2,
+	SG_CDB2_TLEN_SECTORS	= 1 << 2,
+
+	SG_CDB2_TDIR_TO_DEV	= 0 << 3,
+	SG_CDB2_TDIR_FROM_DEV	= 1 << 3,
+
+	SG_CDB2_CHECK_COND	= 1 << 5,
+};
+
+#define SG_READ			0
+#define SG_WRITE		1
+#define SG_PIO			0
+#define SG_DMA			1
+
+enum {
+	/*
+	 * These (redundantly) specify the category of the request
+	 */
+	TASKFILE_CMD_REQ_NODATA	= 0,	/* ide: IDE_DRIVE_TASK_NO_DATA */
+	TASKFILE_CMD_REQ_IN	= 2,	/* ide: IDE_DRIVE_TASK_IN */
+	TASKFILE_CMD_REQ_OUT	= 3,	/* ide: IDE_DRIVE_TASK_OUT */
+	TASKFILE_CMD_REQ_RAW_OUT= 4,	/* ide: IDE_DRIVE_TASK_RAW_WRITE */
+	/*
+	 * These specify the method of transfer (pio, dma, multi, ..)
+	 */
+	TASKFILE_DPHASE_NONE	= 0,	/* ide: TASKFILE_IN */
+	TASKFILE_DPHASE_PIO_IN	= 1,	/* ide: TASKFILE_IN */
+	TASKFILE_DPHASE_PIO_OUT	= 4,	/* ide: TASKFILE_OUT */
+};
+#define SG_ATA_LBA48		1
+#define SG_ATA_PROTO_NON_DATA	( 3 << 1)
+#define SG_ATA_PROTO_PIO_IN	( 4 << 1)
+#define SG_ATA_PROTO_PIO_OUT	( 5 << 1)
+#define SG_ATA_PROTO_DMA	( 6 << 1)
+#define SG_ATA_PROTO_UDMA_IN	(11 << 1) /* not yet supported in libata */
+#define SG_ATA_PROTO_UDMA_OUT	(12 << 1) /* not yet supported in libata */
+
+typedef struct _SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER{
+	SCSI_PASS_THROUGH_DIRECT        sptd;
+	unsigned long                   Filler;
+	unsigned char                   Sense_Buffer[SENSE_INFO_BUFFER_SIZE];
+}SCSI_PASS_THROUGH_DIRECT_WITH_BUFFER, *PSCSI_PASS_THROUGH_DIRECT_WITH_BUFFER;
+
+#ifdef API_GET_ENC_ID
+typedef struct _enc_hctl_info{
+	unsigned int dev_id;
+	unsigned int enc_num;
+	unsigned int host_no;
+	unsigned int channel;
+	unsigned int target_id;
+	unsigned int lun;
+}enc_hctl_info ,*penc_hctl_info;
+
+/*scsi.c :scsi_device_types*/
+enum mv_scsi_device_types {
+	direct_access   = 0x00,
+	enclosure  = 0x0d,
+};
+
+int mv_get_enc_scsi_id(MV_PVOID hba_dev,MV_PVOID arg);
+
+#endif
+
+int reg_info_read(char *page, char **start, off_t off, int count,
+	      int *eof, void *data);
+
+int reg_info_write(struct file *file, const char __user * buffer,
+		unsigned long count, void *data);
+struct proc_reg_data
+{
+    struct hba_extension *hba;
+	MV_BOOLEAN flag;
+	char type[5];
+	MV_U32 offset;	
+};
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+int mv_linux_show_info(struct seq_file *m, struct Scsi_Host *pSHost);
+#else
+
+#ifndef MV_VMK_ESX35
+int mv_linux_proc_info(struct Scsi_Host *pSHost, char *pBuffer,
+		       char **ppStart,  off_t offset, int length, int inout);
+#else
+int mv_linux_proc_info(char *pBuffer, char **ppStart,off_t offset,
+                        int length, int host_no, int inout);
+#endif
+
+#endif
+
+void IOHBARequestCallback(MV_PVOID This, PMV_Request pReq);
+struct hba_extension;
+int mv_register_chdev(struct hba_extension *hba);
+void mv_unregister_chdev(struct hba_extension *hba);
+
+#endif /* ifndef __MV_HBA_LINUX_INTERFACE__ */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/linux_main.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/linux_main.c
--- linux-3.10.69/drivers/scsi/mv/linux_main.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/linux_main.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,2918 @@
+/*
+ *
+ *  Copyright (C) 2006 Marvell Technology Group Ltd. All Rights Reserved.
+ *  linux_main.c
+ *
+ *
+ */
+#include "linux_main.h"
+#include "hba_mod.h"
+#include "linux_iface.h"
+#include "hba_timer.h"
+#include "csmisas.h"
+#if defined(__VMKLNX__)
+#if (VMWARE_ESX_DDK_VERSION == 41000)
+#include <vmklinux26/vmklinux26_scsi.h>
+#else
+#include <vmklinux_9/vmklinux_scsi.h>
+#endif
+#endif
+
+#if defined(SUPPORT_MODULE_CONSOLIDATE)
+#include "cc.h"
+#endif		/* SUPPORT_MODULE_CONSOLIDATE */
+
+#ifdef RAID_DRIVER
+#include "raid_structure.h"
+#endif
+
+#if defined(__VMKLNX__) || defined(MV_VMK_ESX35)
+#define PCI_DEVICE(vend,dev) \
+       .vendor = (vend), .device = (dev), \
+        .subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
+spinlock_t io_request_lock;
+#endif
+
+static const struct pci_device_id mv_pci_ids[] = {
+#ifdef THOR_PRODUCT
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_THORLITE_0S1P)},
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_THORLITE_1S1P)},
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_THORLITE_2S1P)},
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_THORLITE_2S1P_WITH_FLASH)},
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_THOR_4S1P)},
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_THOR_4S1P_NEW)},
+#endif
+#ifdef MAGNI_PRODUCT
+	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_9123)},
+#endif
+#ifdef ODIN_PRODUCT
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_6320)},
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_6340)},
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_6440)},
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_6480)},
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_6485)},
+#endif
+#ifdef VANIR_PRODUCT
+	{PCI_DEVICE(VENDOR_ID, DEVICE_ID_9480)},
+	{PCI_DEVICE(VENDOR_ID_EXT,DEVICE_ID_9480)},
+	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_9485)},
+	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_9440)},
+	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_9445)},
+	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_9340)},
+	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_9345)},
+	{PCI_DEVICE(VENDOR_ID_EXT,DEVICE_ID_948F)},
+#endif
+#ifdef ATHENA_PRODUCT
+	{PCI_DEVICE(VENDOR_ID_EXT,DEVICE_ID_ATHENA_1480)},
+	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_ATHENA_1580)},
+	{PCI_DEVICE(VENDOR_ID_EXT, DEVICE_ID_ATHENA_FPGA)},
+#endif
+	{0}
+};
+
+
+/*
+ *  cmd line parameters
+ */
+static int mv_msi_enable;
+module_param(mv_msi_enable, int, 0);
+MODULE_PARM_DESC(mv_msi_enable, " Enable MSI Support for Marvell \
+	controllers (default=0)");
+
+static int mv_test_enable;
+module_param(mv_test_enable, int, S_IRUGO);
+MODULE_PARM_DESC(mv_test_enable, " Support do test for Marvell \
+	controllers (default=0)");
+
+static int mv_reg_enable;
+module_param(mv_reg_enable, int, S_IRUGO);
+MODULE_PARM_DESC(mv_reg_enable, " Support register r/w for Marvell \
+	controllers (default=0)");
+
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12))
+
+/* notifier block to get notified on system shutdown/halt/reboot/down */
+static int mv_linux_halt(struct notifier_block *nb, unsigned long event,
+			 void *buf)
+{
+	switch (event) {
+	case SYS_RESTART:
+	case SYS_HALT:
+	case SYS_POWER_OFF:
+		MV_DPRINT(("%s assert!\n",__func__));
+              	mv_hba_stop(NULL);
+		break;
+	default:
+		break;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block mv_linux_notifier = {
+	mv_linux_halt, NULL, 0
+};
+#endif /*#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12))*/
+
+
+static int mv_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	unsigned int ret = PCIBIOS_SUCCESSFUL;
+	int err = 0;
+
+#if defined(PRODUCTNAME_ATHENA) /*for Athena Z0/Z1, only function 0 works ok*/
+	if (dev->devfn != 0)
+		return -ENODEV;
+#endif
+
+	ret = pci_enable_device(dev);
+	if (ret) {
+		MV_PRINT("%s : enable device failed.\n", mv_product_name);
+		return ret;
+	}
+
+	ret = pci_request_regions(dev, mv_driver_name);
+	if (ret)
+		goto err_req_region;
+
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(3,0,13)
+	if ( !pci_set_dma_mask(dev, DMA_64BIT_MASK) ) {
+#ifndef MV_VMK_ESX35
+		ret = pci_set_consistent_dma_mask(dev, DMA_64BIT_MASK);
+		if (ret) {
+			ret = pci_set_consistent_dma_mask(dev,
+							  DMA_32BIT_MASK);
+			if (ret)
+				goto err_dma_mask;
+		}
+#endif
+	} else {
+		ret = pci_set_dma_mask(dev, DMA_32BIT_MASK);
+		if (ret)
+			goto err_dma_mask;
+#ifndef MV_VMK_ESX35
+		ret = pci_set_consistent_dma_mask(dev, DMA_32BIT_MASK);
+		if (ret)
+			goto err_dma_mask;
+#endif
+	}
+#else
+    if ( !pci_set_dma_mask(dev, DMA_BIT_MASK(64)) ) {
+#ifndef MV_VMK_ESX35
+        ret = pci_set_consistent_dma_mask(dev, DMA_BIT_MASK(64));
+        if (ret) {
+            ret = pci_set_consistent_dma_mask(dev,
+                              DMA_BIT_MASK(32));
+            if (ret)
+                goto err_dma_mask;
+        }
+#endif
+    } else {
+        ret = pci_set_dma_mask(dev, DMA_BIT_MASK(32));
+        if (ret)
+            goto err_dma_mask;
+#ifndef MV_VMK_ESX35
+        ret = pci_set_consistent_dma_mask(dev, DMA_BIT_MASK(32));
+        if (ret)
+            goto err_dma_mask;
+#endif
+    }
+#endif
+
+	pci_set_master(dev);
+
+	MV_PRINT("Marvell Storage Controller is found, using IRQ %d, driver version %s.\n",
+	       dev->irq, mv_version_linux);
+
+	MV_PRINT("Marvell Linux driver %s, driver version %s.\n",
+	      mv_driver_name, mv_version_linux);
+
+	MV_DPRINT(("Start mv_hba_init.\n"));
+
+	ret = mv_hba_init(dev, MV_MAX_IO);
+	if (ret) {
+		MV_DPRINT(( "Error no %d.\n", ret));
+		ret = -ENOMEM;
+		goto err_dma_mask;
+	}
+
+	MV_DPRINT(("Start mv_hba_start.\n"));
+
+	if (mv_hba_start(dev)) {
+		ret = -ENODEV;
+		goto err_mod_start;
+	}
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)) && !defined (MV_VMK_ESX35)
+		if (__mv_get_adapter_count() == 1) {
+			register_reboot_notifier(&mv_linux_notifier);
+		}
+#endif
+
+	MV_DPRINT(("Finished mv_probe.\n"));
+
+	return 0;
+err_mod_start:
+	err++;
+	mv_hba_stop(dev);
+	mv_hba_release(dev);
+err_dma_mask:
+	err++;
+	pci_release_regions(dev);
+err_req_region:
+	err++;
+	pci_disable_device(dev);
+
+	MV_PRINT("%s : error counter %d.\n", mv_product_name, err);
+	return ret;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0))
+static void mv_remove(struct pci_dev *dev)
+#else
+static void __devexit mv_remove(struct pci_dev *dev)
+#endif
+{
+	mv_hba_stop(dev);
+	mv_hba_release(dev);
+	pci_release_regions(dev);
+	pci_disable_device(dev);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12))
+	if (__mv_get_adapter_count() == 0) {
+		unregister_reboot_notifier(&mv_linux_notifier);
+	}
+#endif
+
+	MV_PRINT("%s : Marvell %s linux driver removed !\n", mv_product_name, mv_product_name);
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
+static void mv_shutdown(struct pci_dev * pdev)
+{
+	mv_hba_stop(NULL);
+}
+#endif
+
+void core_disable_ints(void * ext);
+void core_enable_ints(void * ext);
+MV_BOOLEAN core_check_int(void *ext);
+
+#ifdef MV_VMK_ESX35
+static int mv_hba_int_handler(void *dev_id)
+#else
+static irqreturn_t mv_hba_int_handler(void *dev_id)
+#endif
+{
+#ifndef MV_VMK_ESX35
+	irqreturn_t retval = MV_FALSE;
+#else
+	int retval = MV_FALSE;
+#endif
+	struct hba_extension *hba = (struct hba_extension *) dev_id;
+
+#ifndef SUPPORT_TASKLET
+	unsigned long flags;
+
+	spin_lock_irqsave(&hba->desc->hba_desc->global_lock, flags);
+	retval = hba->desc->child->ops->module_service_isr(hba->desc->child->extension);
+	spin_unlock_irqrestore(&hba->desc->hba_desc->global_lock, flags);
+	
+#else
+	struct mv_mod_desc *core_desc;
+	core_desc=__get_lowest_module(hba->desc->hba_desc);
+			   
+	core_disable_ints(core_desc->extension);
+
+	if (!hba->msi_enabled) {
+		/*filter the interrupts from other device sharing IRQ.*/
+		retval = core_check_int(core_desc->extension);
+		if (!retval) {
+			core_enable_ints(core_desc->extension);
+			return IRQ_RETVAL(retval);
+		}
+	} else {
+		/*no IRQ sharing with MSI-enabled, schedule tasklet unconditionally.*/
+		retval = MV_TRUE;
+	}
+	
+	tasklet_schedule(&hba->desc->hba_desc->mv_tasklet);
+#endif	/*SUPPORT_TASKLET*/
+
+	return IRQ_RETVAL(retval);
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19)
+#ifdef __VMKERNLE_MODULE__
+ int mv_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+#else
+ irqreturn_t mv_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+#endif
+{
+	return mv_hba_int_handler(dev_id);
+}
+#else
+ irqreturn_t mv_intr_handler(int irq, void *dev_id)
+{
+	return mv_hba_int_handler(dev_id);
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 19) */
+
+#ifdef CONFIG_PM
+int core_suspend (void *ext);
+int core_resume (void *ext);
+
+static void hba_suspend_resume_cb(MV_PVOID This, PMV_Request req)
+{
+	struct hba_extension *hba = (struct hba_extension *) This;
+
+#ifdef USE_REQ_POOL
+	hba_req_cache_free(hba,req);
+#else
+	res_free_req_to_pool(hba->req_pool, req);
+#endif
+    
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&hba->desc->hba_desc->hba_ioctl_sync, 0);
+#else
+	complete(&hba->desc->hba_desc->ioctl_cmpl);
+#endif
+}
+
+static int mv_hba_suspend(struct mv_mod_desc *hba_mod)
+{
+	unsigned long flags;
+	PMV_Request pReq;
+	struct hba_extension *phba;
+	struct mv_mod_desc *core_mod;
+	struct mv_adp_desc *ioc = hba_mod->hba_desc;
+
+	BUG_ON(!ioc);
+	MV_PRINT("start  mv_hba_suspend.\n");
+
+	phba = (struct hba_extension *)hba_mod->extension;
+	core_mod = __get_lowest_module(ioc);
+
+#ifndef MV_VMK_ESX35
+#ifdef RAID_DRIVER
+	if (!phba->desc->hba_desc->RunAsNonRAID) {		
+#ifdef USE_REQ_POOL
+		pReq = hba_req_cache_alloc(phba);
+#else
+		pReq = res_get_req_from_pool(phba->req_pool);
+#endif
+		if (NULL == pReq) {
+			MV_PRINT("%s : cannot allocate memory for req.\n",
+			       mv_product_name);
+			return -1;
+		}
+
+		WARN_ON(phba->Io_Count != 0);
+		WARN_ON(phba->Ioctl_Io_Count != 0);
+
+		pReq->Cmd_Initiator = phba;
+		pReq->Org_Req = pReq;
+		pReq->Scsi_Status = REQ_STATUS_SUCCESS;	
+		pReq->Completion = hba_suspend_resume_cb;
+
+		pReq->Cdb[0] = APICDB0_ADAPTER;
+		pReq->Cdb[1] = APICDB1_ADAPTER_POWER_STATE_CHANGE;
+		pReq->Cdb[2] = APICDB2_ADAPTER_POWER_CHANGE_LEAVING_S0;
+		pReq->Cmd_Flag = 0;
+		pReq->Req_Type = REQ_TYPE_INTERNAL;
+
+#ifndef SUPPORT_TASKLET
+		spin_lock_irqsave(&phba->desc->hba_desc->global_lock, flags);
+#else
+		spin_lock_bh(&phba->desc->hba_desc->global_lock);
+#endif
+		phba->Io_Count++;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+		atomic_set(&phba->desc->hba_desc->hba_sync, 1);
+#endif
+		phba->desc->ops->module_sendrequest(phba->desc->extension, pReq);
+
+#ifndef SUPPORT_TASKLET
+		spin_unlock_irqrestore(&phba->desc->hba_desc->global_lock, flags);
+#else
+		spin_unlock_bh(&phba->desc->hba_desc->global_lock);
+#endif		
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+		if (!__hba_wait_for_atomic_timeout(&phba->desc->hba_desc->hba_sync,60*HZ))
+#else
+		if (!wait_for_completion_timeout(&phba->desc->hba_desc->ioctl_cmpl,60*HZ))
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+		{
+		    MV_DPRINT(("mv_hba_suspend cmd failed.\n"));
+#ifdef USE_REQ_POOL
+			hba_req_cache_free(phba,pReq);
+#else
+			res_free_req_to_pool(phba->req_pool, pReq);
+#endif
+			phba->Io_Count--;
+			return -1;
+		}
+
+		phba->Io_Count--;
+	}
+#endif
+#endif
+
+	if (core_suspend(core_mod->extension)){
+		MV_DPRINT(("core_suspend failed.\n"));
+		return -1;
+	}
+
+	return 0;	
+}
+
+static int mv_hba_resume(struct mv_mod_desc *hba_mod)
+{
+	unsigned long flags;
+	PMV_Request pReq;
+	struct hba_extension *phba;
+	struct mv_mod_desc *core_mod;
+	struct mv_adp_desc *ioc = hba_mod->hba_desc;
+
+	BUG_ON(!ioc);
+	MV_PRINT("start  mv_hba_resume.\n");
+
+	phba = (struct hba_extension *)hba_mod->extension;
+	core_mod = __get_lowest_module(ioc);
+
+	if (core_resume(core_mod->extension)) {
+		MV_PRINT("mv_resume_core failed.\n");
+		return -1;
+	}	
+
+#ifndef MV_VMK_ESX35
+#ifdef RAID_DRIVER
+	if (!phba->desc->hba_desc->RunAsNonRAID) {		
+#ifdef USE_REQ_POOL
+		pReq = hba_req_cache_alloc(phba);
+#else
+		pReq = res_get_req_from_pool(phba->req_pool);
+#endif
+		if (NULL == pReq) {
+			MV_PRINT("%s : cannot allocate memory for req.\n",
+				   mv_product_name);
+			return -1;
+		}
+
+		WARN_ON(phba->Io_Count != 0);
+		WARN_ON(phba->Ioctl_Io_Count != 0);
+
+		pReq->Cmd_Initiator = phba;
+		pReq->Org_Req = pReq;
+		pReq->Scsi_Status = REQ_STATUS_SUCCESS; 
+		pReq->Completion = hba_suspend_resume_cb;
+
+		pReq->Cdb[0] = APICDB0_ADAPTER;
+		pReq->Cdb[1] = APICDB1_ADAPTER_POWER_STATE_CHANGE;
+		pReq->Cdb[2] = APICDB2_ADAPTER_POWER_CHANGE_ENTER_S0;
+		pReq->Cmd_Flag = 0;
+		pReq->Req_Type = REQ_TYPE_INTERNAL;
+
+#ifndef SUPPORT_TASKLET
+		spin_lock_irqsave(&phba->desc->hba_desc->global_lock, flags);
+#else
+		spin_lock_bh(&phba->desc->hba_desc->global_lock);
+#endif
+		phba->Io_Count++;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+		atomic_set(&phba->desc->hba_desc->hba_sync, 1);
+#endif
+		phba->desc->ops->module_sendrequest(phba->desc->extension, pReq);
+
+#ifndef SUPPORT_TASKLET
+		spin_unlock_irqrestore(&phba->desc->hba_desc->global_lock, flags);
+#else
+		spin_unlock_bh(&phba->desc->hba_desc->global_lock);
+#endif		
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+		if (!__hba_wait_for_atomic_timeout(&phba->desc->hba_desc->hba_sync,60*HZ))
+#else
+		if (!wait_for_completion_timeout(&phba->desc->hba_desc->ioctl_cmpl,60*HZ))
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+		{
+			MV_DPRINT(("mv_hba_resume cmd failed.\n"));
+#ifdef USE_REQ_POOL
+			hba_req_cache_free(phba,pReq);
+#else
+			res_free_req_to_pool(phba->req_pool, pReq);
+#endif
+			phba->Io_Count--;
+			return -1;
+		}
+
+		phba->Io_Count--;
+	}
+#endif
+#endif
+	
+	return 0;	
+}
+
+#ifndef MV_VMK_ESX35
+static int mv_suspend(struct pci_dev *pdev, pm_message_t state)
+#else
+static int mv_suspend(struct pci_dev *pdev, int state)
+#endif
+{
+	struct hba_extension *ext;
+	struct mv_mod_desc *hba_mod = pci_get_drvdata(pdev);
+	struct mv_adp_desc *ioc = hba_mod->hba_desc;
+
+	BUG_ON(!ioc);
+	MV_PRINT("start  mv_suspend.\n");
+
+	ext = (struct hba_extension *)hba_mod->extension;
+	
+    if (mv_hba_suspend(hba_mod)){
+        MV_DPRINT(("mv_hba_suspend failed.\n"));
+		return -1;
+    }
+	
+	free_irq(ioc->dev->irq,ext);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
+	pci_save_state(pdev);
+#else
+	pci_save_state(pdev,ioc->pci_config_space);
+#endif
+	pci_disable_device(pdev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
+	pci_set_power_state(pdev,pci_choose_state(pdev,state));
+#else
+	pci_set_power_state(pdev,state);
+#endif
+
+	return 0;
+}
+#ifdef MV_VMK_ESX35
+#define  PCI_D0 	0
+#endif
+
+static int mv_resume (struct pci_dev *pdev)
+{
+	int ret;
+	struct hba_extension *ext;
+	struct mv_mod_desc *hba_mod = pci_get_drvdata(pdev);
+	struct mv_adp_desc *ioc = hba_mod->hba_desc;
+
+	ext = (struct hba_extension *)hba_mod->extension;	
+	MV_PRINT("start  mv_resume.\n");
+
+	pci_set_power_state(pdev, PCI_D0);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11))
+	pci_enable_wake(pdev, PCI_D0, 0);
+	pci_restore_state(pdev);
+#else
+	pci_restore_state(pdev,ioc->pci_config_space);
+#endif
+	pci_set_master(pdev);
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 19)
+	ret = request_irq(ioc->dev->irq, mv_intr_handler, IRQF_SHARED,
+	                  mv_driver_name, ext);
+#else
+	ret = request_irq(ioc->dev->irq, mv_intr_handler, SA_SHIRQ,
+		mv_driver_name, ext);
+#endif
+	if (ret < 0) {
+	        MV_PRINT("request IRQ failed.\n");
+	        return -1;
+	}
+
+    if (mv_hba_resume(hba_mod)){
+        MV_DPRINT(("mv_hba_resume failed.\n"));
+		return -1;
+    }
+	
+	return 0;
+}
+#endif
+
+
+static struct pci_driver mv_pci_driver = {
+	.name     = mv_driver_name,
+	.id_table = mv_pci_ids,
+	.probe    = mv_probe,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,8,0))
+	.remove   = mv_remove,
+#else
+	.remove   = __devexit_p(mv_remove),
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
+	.shutdown = mv_shutdown,
+#endif
+#ifdef CONFIG_PM
+	.resume = mv_resume,
+	.suspend = mv_suspend,
+#endif
+};
+
+#ifdef USE_REQ_POOL
+
+int hba_req_cache_create(MV_PVOID hba_ext)
+{
+	PHBA_Extension phba = (PHBA_Extension)hba_ext;
+	struct mv_adp_desc   *hba_desc=phba->desc->hba_desc;
+	sprintf(phba->cache_name,"%s%d%d","mv_request_",hba_desc->Device_Id, hba_desc->id);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+	phba->mv_request_cache = kmem_cache_create(phba->cache_name,sizeof(struct _MV_Request),
+			0, SLAB_HWCACHE_ALIGN, NULL);
+#else
+	phba->mv_request_cache = kmem_cache_create(phba->cache_name,sizeof(struct _MV_Request),
+			0, SLAB_HWCACHE_ALIGN, NULL,NULL);
+#endif
+	if(phba->mv_request_cache == NULL)
+		return -ENOMEM;
+	sprintf(phba->sg_name,"%s%d%d","mv_sgtable_",hba_desc->Device_Id, hba_desc->id);
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+	phba->mv_request_sg_cache = kmem_cache_create(phba->sg_name,
+		phba->max_sg_count  * sizeof(MV_SG_Entry),
+			0,SLAB_HWCACHE_ALIGN, NULL);
+#else
+	phba->mv_request_sg_cache = kmem_cache_create(phba->sg_name,
+		phba->max_sg_count  * sizeof(MV_SG_Entry),
+			0,SLAB_HWCACHE_ALIGN, NULL,NULL);
+#endif
+	if(phba->mv_request_sg_cache == NULL) {
+		kmem_cache_destroy(phba->mv_request_cache);
+		return -ENOMEM;
+	}
+
+	phba->mv_mempool= mempool_create(2, mempool_alloc_slab,mempool_free_slab,
+		phba->mv_request_sg_cache);
+	if(!phba->mv_mempool){
+		kmem_cache_destroy(phba->mv_request_cache);
+		kmem_cache_destroy(phba->mv_request_sg_cache);
+		return -ENOMEM;
+	}
+
+#if defined(HAVE_HW_COMPLIANT_SG)
+    sprintf(phba->sgpool_name, "%s%d%d", "mv_sgpool_", 
+        hba_desc->Device_Id, hba_desc->id);
+    phba->mv_sgtable_pool = pci_pool_create(phba->sgpool_name, hba_desc->dev, 
+            phba->max_sg_count * sizeof(MV_SG_Entry), 16, 0);
+    if(!phba->mv_sgtable_pool)
+    {
+        mempool_destroy(phba->mv_mempool);
+        kmem_cache_destroy(phba->mv_request_cache);
+        kmem_cache_destroy(phba->mv_request_sg_cache);
+        return -ENOMEM;
+    }
+#endif
+	return 0;
+}
+
+PMV_Request hba_req_cache_alloc(MV_PVOID hba_ext)
+{
+	int max_sg = 0;
+	MV_SG_Entry * sgtable= NULL;
+	struct _MV_Request * req = NULL;
+	PHBA_Extension phba = (PHBA_Extension)hba_ext;
+	
+#if defined(HAVE_HW_COMPLIANT_SG)
+	struct mv_mod_desc *mod_desc = __ext_to_gen(hba_ext)->desc;
+	dma_addr_t	  dma_addr;
+	BUS_ADDRESS   bus_addr;
+	MV_PHYSICAL_ADDR phy_addr;
+#endif
+
+	max_sg = phba->max_sg_count;
+	req = kmem_cache_alloc(phba->mv_request_cache, GFP_ATOMIC);
+	if (!req) {
+		MV_DPRINT(("cache alloc req failed.\n"));
+		return NULL;
+	}
+	memset(req,0x00,sizeof(struct _MV_Request));
+#if !defined(HAVE_HW_COMPLIANT_SG)
+	sgtable =  mempool_alloc(phba->mv_mempool, GFP_ATOMIC);
+#else
+    sgtable = pci_pool_alloc(phba->mv_sgtable_pool, GFP_ATOMIC, &dma_addr);
+	if (NULL == sgtable) {
+	    kmem_cache_free(phba->mv_request_cache, req);
+		MV_DPRINT(("unable to alloc 0x%lx consistent mem.\n",
+		       phba->max_sg_count  * sizeof(MV_SG_Entry)));
+		return NULL;
+	}
+
+	bus_addr            = (BUS_ADDRESS) dma_addr;
+	phy_addr.parts.low  = LO_BUSADDR(bus_addr);
+	phy_addr.parts.high = HI_BUSADDR(bus_addr);
+	req->bus_addr = phy_addr;	
+#endif
+
+	if (sgtable) {
+		memset(sgtable, 0x00,sizeof(max_sg  * sizeof(MV_SG_Entry)));
+		req->SG_Table.Entry_Ptr= sgtable;
+		req->SG_Table.Max_Entry_Count = max_sg;
+	} else {
+		kmem_cache_free(phba->mv_request_cache,req);
+		//MV_DPRINT(("cache alloc sg failed, running io %d.\n",phba->Io_Count));
+		return NULL;
+	}
+	MV_ZeroMvRequest(req);
+	return req;
+}
+
+void hba_req_cache_free(MV_PVOID hba_ext,PMV_Request req)
+{
+	PHBA_Extension phba = (PHBA_Extension)hba_ext;
+#if defined(HAVE_HW_COMPLIANT_SG)
+	dma_addr_t       dma_addr;
+	MV_PHYSICAL_ADDR phy_addr;
+
+	struct mv_mod_desc *mod_desc = __ext_to_gen(hba_ext)->desc;
+
+	if(!mod_desc){
+		MV_DPRINT(("mod decript is destried.\n"));
+	}
+
+	phy_addr = req->bus_addr;
+	dma_addr = (dma_addr_t) (phy_addr.parts.low |
+				 ((u64) phy_addr.parts.high << 32));
+    pci_pool_free(phba->mv_sgtable_pool, (void *)req->SG_Table.Entry_Ptr, 
+                  dma_addr);
+#else
+	mempool_free((void *)req->SG_Table.Entry_Ptr,phba->mv_mempool);
+#endif
+	kmem_cache_free(phba->mv_request_cache,req);
+}
+
+void  hba_req_cache_destroy(MV_PVOID hba_ext)
+{
+	PHBA_Extension phba = (PHBA_Extension)hba_ext;
+#if defined(HAVE_HW_COMPLIANT_SG)
+    pci_pool_destroy(phba->mv_sgtable_pool);
+#endif
+	mempool_destroy(phba->mv_mempool);
+	kmem_cache_destroy(phba->mv_request_cache);
+	kmem_cache_destroy(phba->mv_request_sg_cache);
+}
+#else
+struct mv_request_pool *res_reserve_req_pool(MV_U32 mod_id,
+					     MV_U32 size,
+					     MV_U32 sg_count)
+{
+	int i;
+	unsigned int mem_size;
+	struct mv_request_pool *pool;
+	struct _MV_Request *req;
+	MV_SG_Entry *sg;
+
+	MV_DPRINT(( "module %u reserves reqcount=%d, sgcount=%d,request pool of size %lu.\n",
+	       mod_id,size,sg_count,
+	       (unsigned long) (sizeof(struct _MV_Request) * size +
+				sizeof(MV_SG_Entry)* sg_count * size)));
+
+	mem_size = sizeof(struct mv_request_pool);
+	pool = hba_mem_alloc(mem_size,MV_FALSE);
+	if (NULL == pool)
+		goto res_err_pool;
+	memset(pool, 0, mem_size);
+
+	/* assuming its size is already 64bit-aligned */
+	mem_size = sizeof(struct _MV_Request) * size;
+	req = hba_mem_alloc(mem_size,MV_FALSE);
+	if (NULL == req)
+		goto res_err_req;
+	memset(req, 0, mem_size);
+
+	mem_size = sizeof(MV_SG_Entry) * sg_count * size;
+	sg  = hba_mem_alloc(mem_size,MV_FALSE);
+	if (NULL == sg)
+		goto res_err_sg;
+	memset(sg, 0, mem_size);
+
+	MV_LIST_HEAD_INIT(&pool->free_list);
+	MV_LIST_HEAD_INIT(&pool->use_list);
+	spin_lock_init(&pool->lock);
+
+	pool->mod_id  = mod_id;
+	pool->size    = size;
+	pool->sg_count    = sg_count;
+	pool->req_mem = (void *) req;
+	pool->sg_mem = (void *)sg;
+
+	for (i = 0; i < size; i++) {
+		req->SG_Table.Entry_Ptr  = sg;
+		req->SG_Table.Max_Entry_Count = sg_count;
+		List_AddTail(&req->pool_entry, &pool->free_list);
+		req++;
+		sg += sg_count;
+	}
+
+	return pool;
+
+res_err_sg:
+	hba_mem_free(req,sizeof(struct _MV_Request) * size,MV_FALSE);
+	MV_ASSERT(MV_FALSE);
+res_err_req:
+	hba_mem_free(pool,sizeof(struct mv_request_pool),MV_FALSE);
+	MV_ASSERT(MV_FALSE);
+res_err_pool:
+	MV_ASSERT(MV_FALSE);
+	return NULL;
+}
+
+struct _MV_Request *res_get_req_from_pool(struct mv_request_pool *pool)
+{
+	struct _MV_Request *req;
+	unsigned long flags;
+
+	BUG_ON(pool == NULL);
+	spin_lock_irqsave(&pool->lock, flags);
+	if (List_Empty(&pool->free_list)) {
+		res_dump_pool_info(pool);
+		spin_unlock_irqrestore(&pool->lock, flags);
+		return NULL;
+	}
+
+	req = LIST_ENTRY(pool->free_list.next, struct _MV_Request, pool_entry);
+	MV_ZeroMvRequest(req); /* FIX: we can do better than this */
+	List_MoveTail(pool->free_list.next, &pool->use_list);
+	spin_unlock_irqrestore(&pool->lock, flags);
+
+	return req;
+}
+
+void res_free_req_to_pool(struct mv_request_pool *pool,
+			  struct _MV_Request *req)
+{
+	unsigned long flags;
+	BUG_ON((NULL == pool) || (NULL == req));
+	spin_lock_irqsave(&pool->lock, flags);
+	List_Move(&req->pool_entry, &pool->free_list);
+	spin_unlock_irqrestore(&pool->lock, flags);
+}
+
+void res_dump_pool_info(struct mv_request_pool *pool)
+{
+
+}
+
+void res_release_req_pool(struct mv_request_pool *pool)
+{
+	BUG_ON(NULL == pool);
+
+	MV_DPRINT(("module %d release pool at %p.\n",
+	       pool->mod_id, pool));
+	hba_mem_free(pool->req_mem,sizeof(struct _MV_Request) *(pool->size),MV_FALSE);
+	hba_mem_free(pool->sg_mem,sizeof(MV_SG_Entry) * (pool->sg_count) *(pool->size),MV_FALSE);
+	hba_mem_free(pool,sizeof(struct mv_request_pool),MV_FALSE);
+}
+#endif
+
+#if defined(SUPPORT_DIX) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+int mv_prot_dma_map(struct scsi_cmnd *cmd)
+{
+	int nseg = 0;
+
+	if (mv_prot_use_sg(cmd)) {
+		struct device *dev = cmd->device->host->dma_dev;
+
+		nseg = dma_map_sg(dev, mv_prot_bf(cmd), mv_prot_use_sg(cmd),
+				  cmd->sc_data_direction);
+		if (unlikely(!nseg))
+			return -ENOMEM;
+	}
+	return nseg;
+}
+
+void mv_prot_dma_unmap(struct scsi_cmnd *cmd)
+{
+	if (mv_prot_use_sg(cmd)) {
+		struct device *dev = cmd->device->host->dma_dev;
+
+		dma_unmap_sg(dev, mv_prot_bf(cmd), mv_prot_use_sg(cmd),
+			     cmd->sc_data_direction);
+	}
+}
+
+#define left_len(x, y)  (y - (x % y))
+
+static void append_intersect_sg_table(struct scatterlist *data_sg,
+		struct scatterlist *prot_sg, PMV_SG_Table sg_table, unsigned int data_len)
+{
+	dma_addr_t data_ent_addr = 0;
+	dma_addr_t prot_ent_addr = 0;
+	unsigned int pro_len = 0, pro_prot_len = 0;
+	unsigned int data_sg_len, prot_sg_len;
+	unsigned int data_sg_num = 0, prot_sg_num = 0;
+	unsigned int i;
+
+	data_ent_addr = sg_dma_address(&data_sg[0]);
+	prot_ent_addr = sg_dma_address(&prot_sg[0]);
+	data_sg_len = sg_dma_len(&data_sg[0]);
+	prot_sg_len = sg_dma_len(&prot_sg[0]);
+
+	while (pro_len < data_len) {
+		do {
+			if (data_sg_len > left_len(pro_len, 512)) {
+#ifdef HAVE_HW_COMPLIANT_SG
+				sgdt_append(sg_table, LO_BUSADDR(data_ent_addr),
+					HI_BUSADDR(data_ent_addr), left_len(pro_len, 512));
+#else
+				sgdt_append_pctx(sg_table, LO_BUSADDR(data_ent_addr),
+					HI_BUSADDR(data_ent_addr), left_len(pro_len, 512), data_sg + data_sg_num);
+#endif
+				data_sg_len -= left_len(pro_len, 512);
+				data_ent_addr += left_len(pro_len, 512);
+				pro_len += left_len(pro_len, 512);
+			} else {
+#ifdef HAVE_HW_COMPLIANT_SG
+				sgdt_append(sg_table, LO_BUSADDR(data_ent_addr),
+					HI_BUSADDR(data_ent_addr), data_sg_len);
+#else
+				sgdt_append_pctx(sg_table, LO_BUSADDR(data_ent_addr),
+					HI_BUSADDR(data_ent_addr), data_sg_len, data_sg + data_sg_num);
+#endif
+				pro_len += data_sg_len;
+				data_sg_num++;
+				data_ent_addr = sg_dma_address(&data_sg[data_sg_num]);
+				data_sg_len = sg_dma_len(&data_sg[data_sg_num]);
+			}
+		} while (pro_len % 512 != 0);
+
+		do {
+			if (prot_sg_len > left_len(pro_prot_len, 8)) {
+#ifdef HAVE_HW_COMPLIANT_SG
+				sgdt_append(sg_table, LO_BUSADDR(prot_ent_addr),
+					HI_BUSADDR(prot_ent_addr), left_len(pro_prot_len, 8));
+#else
+				sgdt_append_pctx(sg_table, LO_BUSADDR(prot_ent_addr),
+					HI_BUSADDR(prot_ent_addr), left_len(pro_prot_len, 8), prot_sg + prot_sg_num);
+#endif
+				prot_sg_len -= left_len(pro_prot_len, 8);
+				prot_ent_addr += left_len(pro_prot_len, 8);
+				pro_prot_len += left_len(pro_prot_len, 8);
+			} else {
+#ifdef HAVE_HW_COMPLIANT_SG
+				sgdt_append(sg_table, LO_BUSADDR(prot_ent_addr),
+					HI_BUSADDR(prot_ent_addr), prot_sg_len);
+#else
+				sgdt_append_pctx(sg_table, LO_BUSADDR(prot_ent_addr),
+					HI_BUSADDR(prot_ent_addr), prot_sg_len, prot_sg + prot_sg_num);
+#endif
+				pro_prot_len += prot_sg_len;
+				prot_sg_num++;
+				prot_ent_addr = sg_dma_address(&prot_sg[prot_sg_num]);
+				prot_sg_len = sg_dma_len(&prot_sg[prot_sg_num]);
+			}
+		} while (pro_prot_len % 8 != 0);
+	}
+	if (pro_len != data_len || pro_prot_len != (data_len / 512)*8) {
+		MV_PRINT("ERR: process not complete: pro len is %d , %d; actual len is %d\n",
+			pro_len, pro_prot_len, data_len);
+	}
+}
+#endif
+
+static void generate_sg_table(struct hba_extension *phba,
+			      struct scsi_cmnd *scmd,
+			      PMV_SG_Table sg_table)
+{
+	struct scatterlist *sg;
+	unsigned int sg_count = 0;
+	unsigned int length;
+	dma_addr_t busaddr = 0;
+	int i;
+#if defined(SUPPORT_DIX) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+	struct scatterlist *prot_sg;
+	unsigned int prot_sg_count = 0;
+	unsigned int prot_buf_len = 0;
+#endif
+#ifdef MV_VMK_ESXI5
+	struct scatterlist *sgl;
+#endif
+
+	if (mv_rq_bf_l(scmd) > (mv_scmd_host(scmd)->max_sectors << 9)) {
+		MV_DPRINT(( "ERROR: request length exceeds "
+		"the maximum alowed value.\n"));
+	}
+
+	if (0 == mv_rq_bf_l(scmd))
+		return ;
+
+	if (mv_use_sg(scmd)) {
+		sg = (struct scatterlist *) mv_rq_bf(scmd);
+	if (MV_SCp(scmd)->mapped == 0){
+#ifndef MV_VMK_ESX35
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
+		sg_count = scsi_dma_map(scmd);
+#else
+		sg_count = pci_map_sg(phba->desc->hba_desc->dev,sg,mv_use_sg(scmd),
+		scsi_to_pci_dma_dir(scmd->sc_data_direction));
+#endif
+#else
+		sg_count = scmd->use_sg;
+#endif
+
+		if (sg_count != mv_use_sg(scmd)) {
+			MV_PRINT("WARNING sg_count(%d) != scmd->use_sg(%d)\n",
+			(unsigned int) sg_count, mv_use_sg(scmd));
+		}
+		MV_SCp(scmd)->mapped = 1;
+	}
+#if defined(SUPPORT_DIX) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+		prot_sg = (struct scatterlist *) mv_prot_bf(scmd);
+		if (prot_sg != NULL) {
+			prot_sg_count = mv_prot_dma_map(scmd);
+
+			for (i = 0; i < prot_sg_count; i++) {
+				prot_buf_len += sg_dma_len(&prot_sg[i]);
+			}
+			if ((prot_buf_len / 8) * 512 != mv_rq_bf_l(scmd)) {
+				MV_PRINT("DIF (%d) is not in accord with Data (%d)\n",
+				prot_buf_len, mv_rq_bf_l(scmd));
+			} else {
+				append_intersect_sg_table(sg, prot_sg, sg_table, mv_rq_bf_l(scmd));
+				return;
+			}
+		}
+#endif
+
+#ifdef MV_VMK_ESXI5
+		scsi_for_each_sg(scmd, sgl, sg_count, i) {
+			busaddr = sg_dma_address(sgl);
+			length = sg_dma_len(sgl);
+#else
+		for (i = 0; i < sg_count; i++) {
+			busaddr = sg_dma_address(&sg[i]);
+			length = sg_dma_len(&sg[i]);
+#endif
+
+#if defined(MV_DEBUG) && defined(RAID_DRIVER) && !defined(__VMKLNX__)
+			if(length > PAGE_SIZE)
+			MV_DPRINT(("Warning: sg[%i] length %d > PAGE_SIZE\n", i, length));
+#endif
+#ifndef HAVE_HW_COMPLIANT_SG           
+			sgdt_append_pctx(sg_table,LO_BUSADDR(busaddr), HI_BUSADDR(busaddr),
+			length,  sg + i);
+#else
+			sgdt_append(sg_table,LO_BUSADDR(busaddr), HI_BUSADDR(busaddr),length);
+#endif
+
+		}
+	} else {
+		if (MV_SCp(scmd)->mapped == 0) {
+#ifndef MV_VMK_ESX35
+			busaddr = dma_map_single(&phba->desc->hba_desc->dev->dev,mv_rq_bf(scmd),mv_rq_bf_l(scmd),
+			scsi_to_pci_dma_dir(scmd->sc_data_direction));
+#else
+			busaddr = scmd->request_bufferMA;
+#endif
+			MV_SCp(scmd)->bus_address = busaddr;
+			MV_SCp(scmd)->mapped = 1;
+		}
+#if defined(MV_DEBUG) && defined(RAID_DRIVER) && !defined(__VMKLNX__)
+		if(mv_rq_bf_l(scmd) > PAGE_SIZE)
+			MV_DPRINT(("Warning: single sg request_bufflen %d > PAGE_SIZE\n", mv_rq_bf_l(scmd)));
+#endif
+#ifndef HAVE_HW_COMPLIANT_SG		
+		sgdt_append_vp(sg_table,mv_rq_bf(scmd), mv_rq_bf_l(scmd),
+		LO_BUSADDR(busaddr),   HI_BUSADDR(busaddr));
+#else
+        sgdt_append(sg_table,LO_BUSADDR(busaddr),HI_BUSADDR(busaddr),
+           mv_rq_bf_l(scmd));
+#endif
+	}
+}
+#if (defined(SUPPORT_DIF) || defined(SUPPORT_DIX)) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+/* SCSI IO EEDPFlags bits */
+
+#define MV_EEDPFLAGS_INC_PRI_REFTAG        (0x8000)
+#define MV_EEDPFLAGS_INC_SEC_REFTAG        (0x4000)
+#define MV_EEDPFLAGS_INC_PRI_APPTAG        (0x2000)
+#define MV_EEDPFLAGS_INC_SEC_APPTAG        (0x1000)
+
+#define MV_EEDPFLAGS_CHECK_REFTAG          (0x0400)
+#define MV_EEDPFLAGS_CHECK_APPTAG          (0x0200)
+#define MV_EEDPFLAGS_CHECK_GUARD           (0x0100)
+
+/*zheng: change the operation value of eedpflags into bitwise control on
+ * the corresponding four DIF control bit supplied by HW*/
+
+#define MV_EEDPFLAGS_MASK_OP               (0x0007)
+#define MV_EEDPFLAGS_NOOP_OP               (0x0000)
+#define MV_EEDPFLAGS_CHECK_OP              (0x0001)
+#define MV_EEDPFLAGS_STRIP_OP              (0x0002)
+#define MV_EEDPFLAGS_CHECK_REMOVE_OP       (0x0003)
+#define MV_EEDPFLAGS_INSERT_OP             (0x0004)
+#define MV_EEDPFLAGS_REPLACE_OP            (0x0008)
+#define MV_EEDPFLAGS_CHECK_REGEN_OP        (0x0005)
+/**
+ * mv_setup_eedp - setup MV request for EEDP transfer
+ * @scmd: pointer to scsi command object
+ * @pReq: pointer to the SCSI_IO reqest message frame
+ *
+ * Supporting protection type 1 and 3.
+ *
+ * Returns nothing
+ */
+static void
+mv_setup_eedp(struct scsi_cmnd *scmd, PMV_Request pReq)
+{
+	MV_U16 eedp_flags;
+	unsigned char prot_op = scsi_get_prot_op(scmd);
+	unsigned char prot_type = scsi_get_prot_type(scmd);
+
+	if (prot_type == SCSI_PROT_DIF_TYPE0 ||
+	   prot_op == SCSI_PROT_NORMAL)
+		return;
+
+	switch (prot_op) {
+		case SCSI_PROT_READ_STRIP:
+			eedp_flags = MV_EEDPFLAGS_CHECK_REMOVE_OP;
+			break;
+		case SCSI_PROT_WRITE_INSERT:
+			eedp_flags = MV_EEDPFLAGS_INSERT_OP;
+			break;
+		case SCSI_PROT_READ_INSERT:
+			eedp_flags = MV_EEDPFLAGS_INSERT_OP;
+			break;
+		case SCSI_PROT_WRITE_STRIP:
+			eedp_flags = MV_EEDPFLAGS_CHECK_REMOVE_OP;
+			break;
+		case SCSI_PROT_READ_PASS:
+			eedp_flags = MV_EEDPFLAGS_CHECK_OP;
+			break;
+		case SCSI_PROT_WRITE_PASS:
+			eedp_flags = MV_EEDPFLAGS_CHECK_OP;
+			break;
+		default:
+			return;
+	}
+
+	switch (prot_type) {
+	case SCSI_PROT_DIF_TYPE1:
+	case SCSI_PROT_DIF_TYPE2:
+		/*
+		* enable ref/guard checking
+		* auto increment ref tag
+		*/
+		pReq->EEDPFlags = eedp_flags |
+		    MV_EEDPFLAGS_INC_PRI_REFTAG |
+		    MV_EEDPFLAGS_CHECK_REFTAG |
+		    MV_EEDPFLAGS_CHECK_GUARD;
+		break;
+
+	case SCSI_PROT_DIF_TYPE3:
+
+		/*
+		* enable guard checking
+		*/
+		pReq->EEDPFlags = eedp_flags |
+		    MV_EEDPFLAGS_CHECK_GUARD;
+
+		break;
+	}
+}
+/**
+ * mv_eedp_error_handling - return sense code for EEDP errors
+ * @scmd: pointer to scsi command object
+ * @ioc_status: ioc status
+ *
+ * Returns nothing
+ */
+static void
+mv_eedp_error_handling(struct scsi_cmnd *scmd, MV_U8 req_status)
+{
+	MV_U8	sk;
+	MV_U8	asc;
+	MV_U8	ascq;
+
+	sk = SCSI_SK_ABORTED_COMMAND;
+	asc = SCSI_ASC_ECC_ERROR;
+	switch (req_status) {
+	/* 
+	when asc is SCSI_ASC_ECC_ERROR
+	the ascq refers to:
+	0x01  Logical Block Gurad check failed
+	0x02  Logical Block Application tag check failed
+	0x03  Logical Block Reference tag check failed
+	*/
+	case REQ_STATUS_DIF_GUARD_ERROR:
+		ascq = 0x01;
+		break;
+	case REQ_STATUS_DIF_APP_TAG_ERROR:
+		ascq = 0x02;
+		break;
+	case REQ_STATUS_DIF_REF_TAG_ERROR:
+		ascq = 0x03;
+		break;
+	default:
+		ascq = 0x01;
+		break;
+	}
+	MV_SetSenseData(scmd->sense_buffer, sk, asc, ascq);
+	scmd->result = (DRIVER_SENSE << 24) | (DID_OK << 16);
+	return;
+}
+#endif
+
+void mv_complete_request(struct hba_extension *phba,
+				struct scsi_cmnd *scmd,
+				PMV_Request pReq)
+{
+	PMV_Sense_Data  senseBuffer = (PMV_Sense_Data)pReq->Sense_Info_Buffer;
+
+	if (mv_rq_bf_l(scmd)) {
+		if (MV_SCp(scmd)->mapped) {
+#ifndef MV_VMK_ESX35
+			if (mv_use_sg(scmd)) {
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
+				scsi_dma_unmap(scmd);
+#else
+				pci_unmap_sg(phba->desc->hba_desc->dev,
+					     mv_rq_bf(scmd),
+					     mv_use_sg(scmd),
+					 	scsi_to_pci_dma_dir(scmd->sc_data_direction));
+#endif
+			} else {
+				dma_unmap_single(&phba->desc->hba_desc->dev->dev,
+						 MV_SCp(scmd)->bus_address,
+						 mv_rq_bf_l(scmd),
+				     	scsi_to_pci_dma_dir(scmd->sc_data_direction));
+			}
+#endif
+		}
+	}
+#if 0//def SUPPORT_IO_DELAY
+		if ((pReq->Scsi_Status != REQ_STATUS_SUCCESS) && (pReq->Cdb[0] != SCSI_CMD_INQUIRY)) {
+			MV_DPRINT(("Device %d [0x%x] return status 0x%x\n",pReq->Device_Id, pReq->Cdb[0], pReq->Scsi_Status));
+		}
+#endif
+
+	switch (pReq->Scsi_Status) {
+	case REQ_STATUS_SUCCESS:
+		scmd->result = 0x00;
+#ifdef SUPPORT_BALDUR
+        /* when IO complete, Data_Transfer_Length is the acutal transfer length
+         * if it's less than request length, notify OS */
+        if (pReq->Data_Transfer_Length < mv_rq_bf_l(scmd)) {
+            mv_set_resid(scmd, mv_rq_bf_l(scmd) - pReq->Data_Transfer_Length);
+            if (pReq->Data_Transfer_Length < scmd->underflow) {
+                scmd->result = (DID_ERROR << 16);
+            }
+        }
+#endif
+		break;
+	case REQ_STATUS_MEDIA_ERROR:
+		scmd->result = (DID_BAD_TARGET << 16);
+		break;
+	case REQ_STATUS_BUSY:
+		scmd->result = (DID_BUS_BUSY << 16);
+		break;
+	case REQ_STATUS_NO_DEVICE:
+		scmd->result = (DID_NO_CONNECT << 16);
+		break;
+	case REQ_STATUS_HAS_SENSE:
+		scmd->result  = (DRIVER_SENSE << 24) | (DID_OK << 16) |
+			SAM_STAT_CHECK_CONDITION;
+
+		if (scmd->cmnd[0]== 0x85 || scmd->cmnd[0]== 0xa1)
+			break;
+
+		if (((MV_PU8) senseBuffer)[0] >= 0x72) {
+			MV_DPRINT(("dev %d MV Sense: response %x SK %s  "
+		       		  "ASC %x ASCQ %x.\n\n", mv_scmd_target(scmd), ((MV_PU8) senseBuffer)[0],
+		       		MV_DumpSenseKey(((MV_PU8) senseBuffer)[1]),
+		       		((MV_PU8) senseBuffer)[2],((MV_PU8) senseBuffer)[3]));
+		} else {
+			MV_DPRINT(("dev:%d MV Sense: response %x SK %s "
+		       		  "ASC %x ASCQ %x.\n\n", mv_scmd_target(scmd), ((MV_PU8) senseBuffer)[0],
+		       		MV_DumpSenseKey(((MV_PU8) senseBuffer)[2]),
+		       		((MV_PU8) senseBuffer)[12],((MV_PU8) senseBuffer)[13]));
+		}
+		break;
+#if (defined(SUPPORT_DIF) || defined(SUPPORT_DIX)) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+case REQ_STATUS_DIF_GUARD_ERROR:
+	case REQ_STATUS_DIF_REF_TAG_ERROR:
+	case REQ_STATUS_DIF_APP_TAG_ERROR:
+		mv_eedp_error_handling(scmd, pReq->Scsi_Status);
+		break;
+#endif
+	default:
+		scmd->result = DRIVER_INVALID << 24 | DID_ABORT << 16;
+		break;
+	}
+	if(scmd && scmd->scsi_done) {
+#if defined(MV_VMK_ESX35) || defined(MV_VMK_ESXI5)
+		spin_unlock(&phba->desc->hba_desc->global_lock);
+#endif
+
+		scmd->scsi_done(scmd);
+
+#if defined(MV_VMK_ESX35) || defined(MV_VMK_ESXI5)
+		spin_lock(&phba->desc->hba_desc->global_lock);
+#endif
+	} else
+		MV_DPRINT(("scmd %p no scsi_done.\n",scmd));
+}
+
+/* This should be the _only_ os request exit point. */
+static void hba_req_callback(MV_PVOID This, PMV_Request pReq)
+{
+	struct hba_extension *phba = (struct hba_extension *)This;
+	struct scsi_cmnd *scmd = (struct scsi_cmnd *)pReq->Org_Req_Scmd;
+
+	/* Return this request to OS. */
+	mv_complete_request(phba, scmd, pReq);
+	phba->Io_Count--;
+#ifdef SUPPORT_MODULE_CONSOLIDATE
+	ModConsolid_PushFireRequest (phba->PCC_Extension, pReq);
+#endif
+
+#ifdef USE_REQ_POOL
+	hba_req_cache_free(phba,pReq);
+#else
+	res_free_req_to_pool(phba->req_pool, pReq);
+#endif
+}
+
+static int scsi_cmd_to_req_conv(struct hba_extension *phba,
+				struct scsi_cmnd *scmd,
+				PMV_Request pReq)
+{
+#if (defined(SUPPORT_DIF) || defined(SUPPORT_DIX)) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+	mv_setup_eedp(scmd, pReq);
+#endif
+	/*
+	 * Set three flags: CMD_FLAG_NON_DATA
+	 *                  CMD_FLAG_DATA_IN
+	 *                  CMD_FLAG_DMA
+	 * currently data in/out all go thru DMA
+	 */
+	pReq->Cmd_Flag = 0;
+	switch (scmd->sc_data_direction) {
+	case DMA_NONE:
+		//pReq->Cmd_Flag |= CMD_FLAG_NON_DATA;
+		break;
+	case DMA_FROM_DEVICE:
+		pReq->Cmd_Flag |= CMD_FLAG_DATA_IN;
+	case DMA_TO_DEVICE:
+		pReq->Cmd_Flag |= CMD_FLAG_DMA;
+		break;
+	case DMA_BIDIRECTIONAL :
+		MV_DPRINT(( " unexpected DMA_BIDIRECTIONAL.\n"));
+		break;
+	default:
+		break;
+	}
+
+	/* max CDB length set for 32 */
+	memset(pReq->Cdb, 0, MAX_CDB_SIZE);
+	
+#ifdef USE_OS_TIMEOUT_VALUE
+#if LINUX_VERSION_CODE >KERNEL_VERSION(2, 6, 27)
+	pReq->Time_Out = jiffies_to_msecs(scmd->request->timeout)/1000;
+#else
+	#if (LINUX_VERSION_CODE ==KERNEL_VERSION(2, 6, 27) && (IS_OPENSUSE_SLED_SLES))
+		pReq->Time_Out = jiffies_to_msecs(scmd->request->timeout)/1000;
+	#else
+		pReq->Time_Out = jiffies_to_msecs(scmd->timeout_per_command)/1000;
+	#endif
+#endif
+#endif
+	switch (scmd->cmnd[0]) {
+/* per smartctl, it sets SCSI_TIMEOUT_DEFAULT to 6 , but for captive mode, we extends to 60 HZs */
+	case SCSI_CMD_ATA_PASSTHRU_16:
+		if (scmd->cmnd[14] != ATA_CMD_PM_CHECK)
+			pReq->Time_Out = 60;
+		pReq->Cmd_Flag = hba_parse_ata_protocol(scmd);
+		break;
+	case SCSI_CMD_ATA_PASSTHRU_12:
+		if (scmd->cmnd[9] != ATA_CMD_PM_CHECK)
+			pReq->Time_Out = 60;
+		pReq->Cmd_Flag = hba_parse_ata_protocol(scmd);
+		break;
+	default:
+		break;
+	}
+	memcpy(pReq->Cdb, scmd->cmnd, scmd->cmd_len);
+
+	pReq->Data_Buffer = mv_rq_bf(scmd);
+#if defined(SUPPORT_DIX) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+	if (mv_prot_use_sg(scmd))
+		pReq->Data_Transfer_Length = mv_rq_bf_l(scmd) + mv_prot_bf_l(scmd);
+	else {
+		pReq->Data_Transfer_Length = mv_rq_bf_l(scmd);
+		if (scmd->cmnd[0] == SCSI_CMD_READ_10) {
+			pReq->Cdb[1] = 0x00; //temp solution
+		}
+	}
+#else
+	pReq->Data_Transfer_Length = mv_rq_bf_l(scmd);
+#endif
+	pReq->Sense_Info_Buffer = scmd->sense_buffer;
+	pReq->Sense_Info_Buffer_Length = SCSI_SENSE_BUFFERSIZE;
+
+	SGTable_Init(&pReq->SG_Table, 0);
+	generate_sg_table(phba, scmd, &pReq->SG_Table);
+#if defined(HAVE_HW_COMPLIANT_SG)
+	//pReq->SG_Table.Flag |= SGT_FLAG_PRDT_IN_HOST;
+	pReq->SG_Table.prdt_bus_addr.parts.low = pReq->bus_addr.parts.low;//(MV_U32)pReq->SG_Table.Entry_Ptr; //FIXME
+	pReq->SG_Table.prdt_bus_addr.parts.high = pReq->bus_addr.parts.high;//0;
+#endif
+
+	MV_SetLBAandSectorCount(pReq);
+
+	pReq->Req_Type      = REQ_TYPE_OS;
+	pReq->Org_Req_Scmd       = scmd;
+	pReq->Tag           = scmd->tag;
+	pReq->Scsi_Status   = REQ_STATUS_PENDING;
+	pReq->Completion    = hba_req_callback;
+	pReq->Cmd_Initiator = phba;
+	//pReq->Scsi_Status   = REQ_STATUS_INVALID_REQUEST;
+#ifdef SUPPORT_MUL_LUN
+	pReq->Device_Id     = (MV_U16)scmd->device->hostdata;
+#else
+	pReq->Device_Id     = __MAKE_DEV_ID(mv_scmd_target(scmd),
+					    mv_scmd_lun(scmd));
+#endif
+	return 0;
+}
+
+#if defined(MV_BLK_IOCTL)
+extern void * kbuf_array[512];
+static void hba_ioctl_req_callback(MV_PVOID This, PMV_Request pReq)
+{
+	struct hba_extension *phba = (struct hba_extension *)This;
+	struct scsi_cmnd *scmd = (struct scsi_cmnd *)pReq->Org_Req_Scmd;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+/*openSUSE 11.1 SLES 11 SLED 11*/
+#if ((LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 27))&&(!IS_OPENSUSE_SLED_SLES))
+        /* Return this request to OS. */
+	scmd->eh_timeout.expires = jiffies + 1;
+	add_timer(&scmd->eh_timeout);
+#endif
+#endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,19) || LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,9)
+	scmd->request->tag = pReq->Scsi_Status;
+#else
+	scmd->request->rq_status = pReq->Scsi_Status;
+#endif
+	scmd->request->sense = pReq->Sense_Info_Buffer;
+	scmd->request->sense_len = pReq->Sense_Info_Buffer_Length;
+	mv_complete_request(phba, scmd, pReq);
+	phba->Io_Count--;
+#ifdef USE_REQ_POOL
+	hba_req_cache_free(phba,pReq);
+#else
+	res_free_req_to_pool(phba->req_pool, pReq);
+#endif
+}
+
+//extern unsigned char mvcdb[512][16];
+
+static int scsi_ioctl_cmd_adjust(struct hba_extension *phba,
+                                struct scsi_cmnd *scmd,
+                                PMV_Request pReq)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
+/*openSUSE 11.1 SLES 11 SLED 11*/
+#if ((LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 27))&&(!IS_OPENSUSE_SLED_SLES))
+	del_timer(&scmd->eh_timeout);
+#endif
+#endif
+	memcpy(pReq->Cdb,mvcdb[scmd->request->errors - 1],16);
+#ifdef SUPPORT_SES
+	if( __is_scsi_cmd_rcv_snd_diag(pReq->Cdb[0])) {
+		/* SES-2, PCV set to one (0x01) and PF set to one (0x10) with
+		* data transfer and GOOD status, so can't bypass */
+		if (pReq->Cdb[1] == 0x0) {
+			if(pReq->Cdb[0] ==API_SCSI_CMD_RCV_DIAG_RSLT)
+				pReq->Cmd_Flag = CMD_FLAG_DATA_IN;
+			if(pReq->Cdb[0] ==API_SCSI_CMD_SND_DIAG  )
+				pReq->Cmd_Flag &= ~CMD_FLAG_DATA_IN;
+			goto bypass;
+		}
+	}
+#endif
+	pReq->Data_Buffer = kbuf_array[scmd->request->errors - 1];
+#ifdef SUPPORT_SES
+bypass:
+#endif
+	scmd->request->errors = 0;
+	pReq->Sense_Info_Buffer = scmd->request->sense;
+	pReq->Sense_Info_Buffer_Length = scmd->request->sense_len;
+	pReq->Req_Type = REQ_TYPE_INTERNAL;
+	pReq->Org_Req = pReq;
+	pReq->Completion =  hba_ioctl_req_callback;
+	return 0;
+}
+#endif
+
+static void hba_shutdown_req_cb(MV_PVOID this, PMV_Request req)
+{
+	struct hba_extension *phba = (struct hba_extension *) this;
+	#ifdef SUPPORT_REQUEST_TIMER
+	if(req!=NULL)
+	{
+		MV_DPRINT(( "Shutdown HBA timer!\n"));
+		hba_remove_timer_sync(req);
+	}
+	#endif
+
+#ifdef USE_REQ_POOL
+	hba_req_cache_free(phba,req);
+#else
+	res_free_req_to_pool(phba->req_pool, req);
+#endif
+	phba->Io_Count--;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&phba->desc->hba_desc->hba_sync, 0);
+#else
+	complete(&phba->desc->hba_desc->cmpl);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+}
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+/* will wait for atomic value atomic to become zero until timed out */
+/* return how much 'timeout' is left or 0 if already timed out */
+int __hba_wait_for_atomic_timeout(atomic_t *atomic, unsigned long timeout)
+{
+	unsigned intv = HZ/20;
+
+	while (timeout) {
+		if (0 == atomic_read(atomic))
+			break;
+
+		if (timeout < intv)
+			intv = timeout;
+		set_current_state(TASK_INTERRUPTIBLE);
+		timeout -= (intv - schedule_timeout(intv));
+	}
+	return timeout;
+}
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+
+#ifdef CACHE_MODULE_SUPPORT
+static void _hba_send_shutdown_req(PHBA_Extension phba)
+{
+	unsigned long flags;
+	PMV_Request pReq;
+
+	/*Send MV_REQUEST to do something.*/
+#ifdef USE_REQ_POOL
+	pReq = hba_req_cache_alloc(phba);
+#else
+	pReq = res_get_req_from_pool(phba->req_pool);
+#endif
+	if (NULL == pReq) {
+		MV_PRINT("%s : cannot allocate memory for req.\n",
+		       mv_product_name);
+		return;
+	}
+	if ((phba->Io_Count) || (phba->Ioctl_Io_Count))
+	{
+		MV_DPRINT(("Shutdown CACHE have running request, wait...\n"));
+		msleep(100);
+	}
+	WARN_ON(phba->Io_Count != 0);
+	WARN_ON(phba->Ioctl_Io_Count != 0);
+	pReq->Cmd_Initiator = phba;
+	pReq->Org_Req = NULL;
+	pReq->Completion = hba_shutdown_req_cb;
+	pReq->Req_Type = REQ_TYPE_OS;
+	pReq->Cmd_Flag = 0;
+	//pReq->Cmd_Flag |= CMD_FLAG_NON_DATA;
+	pReq->Sense_Info_Buffer_Length = 0;
+	pReq->Data_Transfer_Length = 0;
+	pReq->Data_Buffer = NULL;
+	pReq->Sense_Info_Buffer = NULL;
+
+	pReq->LBA.value = 0;
+	pReq->Sector_Count = 0;
+
+	pReq->Scsi_Status = REQ_STATUS_SUCCESS;
+
+	SGTable_Init(&pReq->SG_Table, 0);
+	memset(pReq->Context, 0, sizeof(MV_PVOID) * MAX_POSSIBLE_MODULE_NUMBER);
+
+	MV_DPRINT(("send SHUTDOWN request to CACHE.\n"));
+	pReq->Cdb[0] = APICDB0_ADAPTER;
+	pReq->Cdb[1] = APICDB1_ADAPTER_POWER_STATE_CHANGE;
+	pReq->Cdb[2] = 0;
+
+
+	/* Must lock IRQ during flush cache to hard disk, for we use one BIG same global_lock */
+	spin_lock_irqsave(&phba->desc->hba_desc->global_lock, flags);
+	phba->Io_Count++;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&phba->desc->hba_desc->hba_sync, 1);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+	phba->desc->ops->module_sendrequest(phba->desc->extension, pReq);
+	spin_unlock_irqrestore(&phba->desc->hba_desc->global_lock, flags);
+
+	MV_DPRINT(("wait finished send_shutdown_cache_req.\n"));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	if (0 == __hba_wait_for_atomic_timeout(&phba->desc->hba_desc->hba_sync, 10 * HZ))
+		goto err_shutdown_cache_req;
+#else
+	if(0 == wait_for_completion_timeout(&phba->desc->hba_desc->cmpl, 10*HZ))
+		goto err_shutdown_cache_req;
+#endif
+	MV_DPRINT(("finished send_shutdown_cache_req.\n"));
+	return;
+err_shutdown_cache_req:
+	MV_PRINT("send_shutdown_cache_req failed.\n");
+}
+#endif /* CACHE_MODULE_SUPPORT */
+
+void hba_send_shutdown_req(MV_PVOID extension)
+{
+	unsigned long flags;
+	PMV_Request pReq;
+	MV_U32 timeout=100;
+	struct hba_extension *phba = (struct hba_extension *)extension;
+#ifdef CACHE_MODULE_SUPPORT
+	if(!phba->desc->hba_desc->RunAsNonRAID)
+		_hba_send_shutdown_req(phba);
+#endif
+
+#ifdef USE_REQ_POOL
+	pReq = hba_req_cache_alloc(phba);
+#else
+	pReq = res_get_req_from_pool(phba->req_pool);
+#endif
+	if (NULL == pReq) {
+		MV_PRINT("%s : cannot allocate memory for req.\n",
+		       mv_product_name);
+		return;
+	}
+
+	while (((phba->Io_Count) || (phba->Ioctl_Io_Count)) && timeout) {
+//		MV_DPRINT(("have running request, Io_Count = %d,, ioctl_count=%d, wait...\n",
+//			phba->Io_Count,phba->Ioctl_Io_Count));
+		msleep(100);
+		timeout--;
+	}
+//	WARN_ON(phba->Io_Count != 0);
+//	WARN_ON(phba->Ioctl_Io_Count != 0);
+	pReq->Device_Id = VIRTUAL_DEVICE_ID;
+	pReq->Cmd_Initiator = phba;
+	pReq->Org_Req = pReq;
+	pReq->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
+	pReq->Completion = hba_shutdown_req_cb;
+
+#ifdef RAID_DRIVER
+	if (!phba->desc->hba_desc->RunAsNonRAID) {
+		MV_DPRINT(("Send SHUTDOWN request to RAID.\n"));
+		pReq->Cdb[0] = APICDB0_LD;
+		pReq->Cdb[1] = APICDB1_LD_SHUTDOWN;
+		pReq->Req_Type = REQ_TYPE_INTERNAL;
+	} else
+#endif
+	{
+		MV_DPRINT(("Send SHUTDOWN request to CORE.\n"));
+		pReq->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
+		pReq->Cdb[1] = CDB_CORE_MODULE;
+		pReq->Cdb[2] = CDB_CORE_SHUTDOWN;
+		pReq->Req_Type = REQ_TYPE_OS;
+	}
+
+	spin_lock_irqsave(&phba->desc->hba_desc->global_lock, flags);
+	phba->Io_Count++;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&phba->desc->hba_desc->hba_sync, 1);
+#endif
+	phba->desc->ops->module_sendrequest(phba->desc->extension, pReq);
+	spin_unlock_irqrestore(&phba->desc->hba_desc->global_lock, flags);
+
+	MV_DPRINT(("wait finished send_shutdown_req.\n"));
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	if (0 == __hba_wait_for_atomic_timeout(&phba->desc->hba_desc->hba_sync, 10 * HZ))
+		goto err_shutdown_req;
+#else
+	if(0 == wait_for_completion_timeout(&phba->desc->hba_desc->cmpl, 10 * HZ))
+		goto err_shutdown_req;
+#endif
+	MV_DPRINT(("finished send_shutdown_req.\n"));
+
+
+	return;
+err_shutdown_req:
+	MV_PRINT("hba_send_shutdown_req failed.\n");
+}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 7)
+/*openSUSE 11.1 SLES 11 SLED 11*/
+#if ((LINUX_VERSION_CODE == KERNEL_VERSION(2, 6, 27))&& (IS_OPENSUSE_SLED_SLES))
+static enum blk_eh_timer_return mv_linux_timed_out(struct scsi_cmnd *cmd)
+{
+	MV_BOOLEAN ret = MV_TRUE;
+	return (ret)?BLK_EH_RESET_TIMER:BLK_EH_NOT_HANDLED;
+
+}
+#elif LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
+static enum scsi_eh_timer_return mv_linux_timed_out(struct scsi_cmnd *cmd)
+{
+	MV_BOOLEAN ret = MV_TRUE;
+#if 0
+	MV_DPRINT(("command time out, device %d,  cdb[%2x,%2x,%2x,%2x, %2x,%2x,%2x,%2x, %2x,%2x,%2x,%2x].\n",
+		__MAKE_DEV_ID(mv_scmd_target(cmd),
+					    mv_scmd_lun(cmd)),
+		cmd->cmnd[0],
+		cmd->cmnd[1],
+		cmd->cmnd[2],
+		cmd->cmnd[3],
+		cmd->cmnd[4],
+		cmd->cmnd[5],
+		cmd->cmnd[6],
+		cmd->cmnd[7],
+		cmd->cmnd[8],
+		cmd->cmnd[9],
+		cmd->cmnd[10],
+		cmd->cmnd[11]
+		));
+#endif
+	return (ret)?EH_RESET_TIMER:EH_NOT_HANDLED;
+
+}
+#else
+static enum blk_eh_timer_return mv_linux_timed_out(struct scsi_cmnd *cmd)
+{
+	MV_BOOLEAN ret = MV_TRUE;
+	return (ret)?BLK_EH_RESET_TIMER:BLK_EH_NOT_HANDLED;
+
+}
+#endif
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 7) */
+
+void dump_scsi_cmd(const char * prefix, struct scsi_cmnd * scmd)
+{
+	int i = 0;
+	MV_PRINT("%s dump cdb[",prefix);
+	for(i = 0; i < 16; i++)
+		MV_PRINT("0x%02x ", scmd->cmnd[i]);
+	MV_PRINT("]\n");
+}
+
+#ifdef RAID_DRIVER
+extern void RAID_HandleWaitingReq(PRAID_Core pRaidCore);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+static int mv_linux_queue_command_lck(struct scsi_cmnd *scmd,
+				  void (*done) (struct scsi_cmnd *))
+#else
+static int mv_linux_queue_command(struct scsi_cmnd *scmd,
+				  void (*done) (struct scsi_cmnd *))
+#endif	
+{
+	struct Scsi_Host *host = mv_scmd_host(scmd);
+	struct hba_extension *hba = *((struct hba_extension * *) host->hostdata);
+	PMV_Request req;
+	unsigned long flags;
+
+
+	if (done == NULL) {
+		MV_PRINT( ": in queuecommand, done function can't be NULL\n");
+		return 0;
+    	}
+
+	scmd->result = 0;
+ 	scmd->scsi_done = done;
+	MV_SCp(scmd)->bus_address = 0;
+	MV_SCp(scmd)->mapped = 0;
+	MV_SCp(scmd)->map_atomic = 0;
+
+	if (mv_scmd_channel(scmd)) {
+		scmd->result = DID_BAD_TARGET << 16;
+		goto done;
+	}
+#if 0
+	dump_scsi_cmd(__func__, scmd);
+#endif
+	/*
+	 * Get mv_request resource and translate the scsi_cmnd request
+	 * to mv_request.
+	 */
+#ifdef USE_REQ_POOL
+	req = hba_req_cache_alloc(hba);
+#else
+	req = res_get_req_from_pool(hba->req_pool);
+#endif
+
+	if (req == NULL) {
+		//MV_PRINT("No sufficient request.\n");
+		return SCSI_MLQUEUE_HOST_BUSY;
+	}
+
+	if (scsi_cmd_to_req_conv(hba, scmd, req)) {
+		/*
+		 * Even TranslateOSRequest failed,
+		 * it still should set some of the variables to the MV_Request
+		 * especially MV_Request.Org_Req and MV_Request.Scsi_Status;
+		 */
+		MV_DPRINT(( "ERROR - Translation from OS Request failed.\n"));
+		hba_req_callback(hba, req);
+		return 0;
+	}
+
+	/* transfer length set to 0 shall not considered as an error */
+	if ((req->Sector_Count == 0) && (SCSI_IS_READ(req->Cdb[0])
+		|| SCSI_IS_WRITE(req->Cdb[0]) || SCSI_IS_VERIFY(req->Cdb[0]))) {
+		req->Data_Transfer_Length = 0;
+		req->Scsi_Status = REQ_STATUS_SUCCESS;
+		hba->Io_Count++;
+		hba_req_callback(hba, req);
+		return 0;
+	}
+
+#if defined(MV_BLK_IOCTL)
+	if(scmd->request->errors)
+		scsi_ioctl_cmd_adjust(hba,scmd,req);
+#endif
+
+	spin_unlock_irq(host->host_lock);
+#ifndef SUPPORT_TASKLET
+		spin_lock_irqsave(&hba->desc->hba_desc->global_lock, flags);
+#else
+		spin_lock_bh(&hba->desc->hba_desc->global_lock);
+#endif
+	hba->Io_Count++;
+
+	MV_ASSERT(hba->State == DRIVER_STATUS_STARTED);
+	
+	hba->desc->ops->module_sendrequest(hba->desc->extension, req);
+
+#ifdef CORE_NO_RECURSIVE_CALL
+	{
+		MV_PVOID core = (MV_PVOID)HBA_GetModuleExtension(hba, MODULE_CORE);
+		core_push_queues(core);
+	}
+#endif
+
+#ifdef RAID_DRIVER
+	//extern void RAID_HandleWaitingReq(PRAID_Core pRaidCore);
+	/* Run stress on VD, hotplug HDD under expander, saw system hang.
+	 * Found requests are hold in RAID while Core Driver is free. So add push. */
+	if (!hba->RunAsNonRAID)// added by liang, if set NonRAID feature, below case should not happened
+	{
+		PRAID_Core pRaidCore;
+		pRaidCore = (PRAID_Core)HBA_GetModuleExtension(hba, MODULE_RAID);;
+		if(pRaidCore!= NULL)
+			RAID_HandleWaitingReq(pRaidCore);
+	}
+#endif		/* RAID_DRIVER */
+
+#ifndef SUPPORT_TASKLET
+		spin_unlock_irqrestore(&hba->desc->hba_desc->global_lock, flags);
+#else
+		spin_unlock_bh(&hba->desc->hba_desc->global_lock);
+#endif
+	spin_lock_irq(host->host_lock);
+	
+	return 0;
+done:
+        scmd->scsi_done(scmd);
+        return 0;
+}
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
+static DEF_SCSI_QCMD(mv_linux_queue_command)
+#endif
+
+#if defined(MV_VMK_ESX35) || defined(MV_VMK_ESXI5)
+#ifdef __VMKLNX__
+static int mv_linux_detect(struct scsi_host_template *sht)
+#else
+static int mv_linux_detect (Scsi_Host_Template * sht)
+#endif
+{
+	return __mv_get_adapter_count();
+}
+
+#ifdef MV_VMK_ESXI5
+int mv_linux_abort(struct scsi_cmnd *scmd)
+#else
+int mv_linux_abort(Scsi_Cmnd * scmd)
+#endif
+{
+	printk("[%s]\n",__func__);
+	return FAILED;
+}
+#endif
+
+static int mv_linux_reset (struct scsi_cmnd *scmd)
+{
+	MV_PRINT("__MV__ reset handler %p.\n", scmd);
+	return FAILED;
+}
+
+#if defined(SUPPORT_SG_RESET) || defined(__VMKLNX__)
+#define MV_HBA_RESET				0
+#define MV_BUS_RESET				1
+#define MV_TARGET_RESET				2
+#define MV_TASK_MANAGEMENT			3
+
+void tm_cmd_callback(MV_PVOID This, PMV_Request req)
+{
+		struct hba_extension *hba = (struct hba_extension *) This;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+		atomic_set(&hba->desc->hba_desc->hba_ioctl_sync, 0);
+#else
+		complete(&hba->desc->hba_desc->ioctl_cmpl);
+#endif
+
+#ifdef USE_REQ_POOL
+		hba_req_cache_free(hba,req);
+#else
+		res_free_req_to_pool(hba->req_pool, req);
+#endif
+}
+
+static int tm_cmd_to_req_conv(struct hba_extension *phba,
+							struct scsi_cmnd *scmd, PMV_Request pReq,
+							MV_U8 ctl_func, MV_U8 tm_func)
+{
+	pReq->Cmd_Flag = 0;
+	/* max CDB length set for 32 */
+	memset(pReq->Cdb, 0, MAX_CDB_SIZE);
+
+    pReq->Time_Out = 30;
+	pReq->Req_Type		= REQ_TYPE_OS;
+	pReq->Org_Req_Scmd	= scmd;
+	pReq->Tag			= scmd->tag;
+	pReq->Scsi_Status	= REQ_STATUS_PENDING;
+	pReq->Completion	= tm_cmd_callback;
+	pReq->Cmd_Initiator = phba;
+
+#ifdef SUPPORT_MUL_LUN
+	pReq->Device_Id 	= get_id_by_targetid_lun(phba,mv_scmd_target(scmd),mv_scmd_lun(scmd));
+#else
+	pReq->Device_Id 	= __MAKE_DEV_ID(mv_scmd_target(scmd),
+						mv_scmd_lun(scmd));
+#endif
+	switch (ctl_func) {
+	case MV_HBA_RESET:
+		/*not support yet*/
+		return -1;
+	case MV_BUS_RESET:
+#ifdef SUPPORT_SG_RESET
+		pReq->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
+		pReq->Cdb[1] = CDB_HBA_RESET;
+		pReq->Cdb[2] = CDB_HBA_BUS_RESET;
+		pReq->Cmd_Flag = 0;		
+		break;
+#endif
+	case MV_TARGET_RESET:
+		tm_func= CSMI_SAS_SSP_LOGICAL_UNIT_RESET;
+	case MV_TASK_MANAGEMENT:
+#ifdef __VMKLNX__
+		pReq->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
+		pReq->Cdb[1] = CDB_CORE_MODULE;
+		pReq->Cdb[2] = CDB_CORE_TASK_MGMT;
+		
+#else
+        pReq->Cdb[0] = SCSI_CMD_MARVELL_SPECIFIC;
+        pReq->Cdb[1] = CDB_HBA_RESET;
+		pReq->Cdb[2] = CDB_HBA_DEVICE_RESET;
+
+#endif
+	    pReq->Cdb[3] = (MV_U8)(scmd->tag&0xff);
+		pReq->Cdb[4] = (MV_U8)(scmd->tag>>8);
+		pReq->Cdb[5] = tm_func;
+		pReq->Cmd_Flag = 0;
+
+	}
+
+	return 0;
+}
+
+static int mv_linux_ctl (struct scsi_cmnd *scmd, MV_U8 ctl_func, MV_U8 tm_func)
+{
+	struct Scsi_Host *host = mv_scmd_host(scmd);
+	struct hba_extension *hba = *((struct hba_extension * *) host->hostdata);
+	PMV_Request req;
+	unsigned long flags;
+#ifdef __VMKLNX__
+	scsi_print_command(scmd);
+	return SUCCESS;
+#endif
+
+	if (mv_scmd_channel(scmd)) 
+		return FAILED;
+
+#ifdef USE_REQ_POOL
+	req = hba_req_cache_alloc(hba);
+#else
+	req = res_get_req_from_pool(hba->req_pool);
+#endif
+	if (req == NULL)
+		return FAILED;
+	if (tm_cmd_to_req_conv(hba, scmd, req, ctl_func, tm_func)) {
+		/*
+		 * Even TranslateOSRequest failed,
+		 * it still should set some of the variables to the MV_Request
+		 * especially MV_Request.Org_Req and MV_Request.Scsi_Status;
+		 */
+		MV_PRINT(( "ERROR - Translation from OS Request failed.\n"));
+		tm_cmd_callback(hba, req);
+		return FAILED;
+	}
+
+	spin_lock_irqsave(&hba->desc->hba_desc->global_lock, flags);
+	hba->Ioctl_Io_Count++;
+
+	if (hba->State != DRIVER_STATUS_STARTED) {
+		MV_ASSERT(0);
+	} else {
+		hba->desc->ops->module_sendrequest(hba->desc->extension, req);
+	}
+#ifdef CORE_NO_RECURSIVE_CALL
+	{
+		MV_PVOID core = (MV_PVOID)HBA_GetModuleExtension(hba, MODULE_CORE);
+		core_push_queues(core);
+	}
+#endif
+	spin_unlock_irqrestore(&hba->desc->hba_desc->global_lock, flags);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	if (!__hba_wait_for_atomic_timeout(&hba->desc->hba_desc->hba_sync,60*HZ))
+#else
+	if (!wait_for_completion_timeout(&hba->desc->hba_desc->ioctl_cmpl,60*HZ))
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+	{
+#ifdef USE_REQ_POOL
+		hba_req_cache_free(hba,req);
+#else
+		res_free_req_to_pool(hba->req_pool, req);
+#endif
+	}
+
+	if (hba->Ioctl_Io_Count++)
+		hba->Ioctl_Io_Count--;
+
+	if (req->Scsi_Status == REQ_STATUS_SUCCESS){
+		return SUCCESS;
+	} else {
+		return FAILED;
+	}
+}
+
+static int mv_device_reset (struct scsi_cmnd *scmd)
+{
+	MV_PRINT("__MV__ device reset handler %p.\n", scmd);
+#ifdef __VMKLNX__
+	if (scmd->vmkflags & VMK_FLAGS_USE_LUNRESET)
+		return mv_linux_ctl(scmd, MV_TASK_MANAGEMENT, CSMI_SAS_SSP_LOGICAL_UNIT_RESET);
+	else
+#endif
+		return mv_linux_ctl(scmd, MV_TASK_MANAGEMENT, CSMI_SAS_SSP_LOGICAL_UNIT_RESET);
+}
+
+static int mv_bus_reset (struct scsi_cmnd *scmd)
+{
+	MV_PRINT("__MV__ bus reset handler %p.\n", scmd);
+	return mv_linux_ctl(scmd, MV_BUS_RESET, 0);
+}
+#endif
+
+#ifdef __VMKLNX__
+static int mv_host_reset (struct scsi_cmnd *scmd)
+{
+        MV_PRINT("__MV__ host reset handler %p.\n", scmd);
+        return SUCCESS;
+}
+
+#endif
+
+
+struct mv_lu *mv_get_avaiable_device(struct hba_extension *hba, MV_U16  target_id, MV_U16 lun)
+{
+#ifdef SUPPORT_MUL_LUN
+	MV_U16 id=0;
+	struct mv_lu * lu=NULL;
+	for (id =0; id < MV_MAX_TARGET_NUMBER; id++) {
+		lu = &hba->mv_unit[id];
+		if (lu && (lu->sdev == NULL) && (lu->lun == 0xFFFF)&& (lu->target_id == 0xFFFF)) {
+			return lu;
+		}
+	}
+	MV_PRINT("invalid target id %d, lun %d.\n",target_id, lun);
+	return NULL;
+#else
+	if (target_id >= MV_MAX_TARGET_NUMBER)
+		return NULL;
+	else
+		return &hba->mv_unit[target_id];
+#endif
+}
+
+static int mv_scsi_slave_alloc(struct scsi_device *sdev)
+{
+	struct hba_extension *hba = *((struct hba_extension * *) sdev->host->hostdata);
+	struct mv_lu * lu = mv_get_avaiable_device (hba, sdev->id, sdev->lun);
+	MV_U16 base_id;
+	if(lu == NULL)
+		return -1;
+
+	lu->sdev = sdev;
+	lu->lun = sdev->lun;
+	lu->target_id = sdev->id;
+#ifdef SUPPORT_MUL_LUN
+	base_id = get_id_by_targetid_lun(hba, sdev->id, sdev->lun);
+	if (base_id == 0xFFFF) {
+		MV_DPRINT(("device %d-%d is not exist.\n", sdev->id, sdev->lun));
+		return -1;
+	}
+	sdev->hostdata = (void *)base_id;
+	
+	sdev->scsi_level=SCSI_SPC_2;
+#endif
+
+	return 0;
+}
+
+struct mv_lu *mv_get_device_by_target_lun(struct hba_extension *hba, MV_U16  target_id, MV_U16 lun)
+{
+#ifdef SUPPORT_MUL_LUN
+	MV_U16 id=0;
+	struct mv_lu * lu=NULL;
+	for (id =0; id < MV_MAX_TARGET_NUMBER; id++) {
+		lu = &hba->mv_unit[id];
+		if (lu && lu->sdev && (lu->lun == lun) && (lu->target_id == target_id)) {
+			return lu;
+		}
+	}
+	return NULL;
+#else
+	if (target_id >= MV_MAX_TARGET_NUMBER)
+		return NULL;
+	else
+		return &hba->mv_unit[target_id];
+#endif
+}
+
+
+static void mv_scsi_slave_destroy(struct scsi_device *sdev)
+{
+	struct hba_extension *hba = *((struct hba_extension * *) sdev->host->hostdata);
+	struct mv_lu *lu = mv_get_device_by_target_lun (hba, sdev->id, sdev->lun);
+	if(lu == NULL)
+		return;
+	lu->sdev = NULL;
+	lu->lun = 0xFFFF;
+	lu->target_id = 0xFFFF;
+
+	return;
+}
+
+static void hba_send_ioctl_cb(MV_PVOID this, PMV_Request req)
+{
+	struct hba_extension *phba = (struct hba_extension *) this;
+#ifdef SUPPORT_REQUEST_TIMER
+	if(req!=NULL)
+	{
+		MV_DPRINT(( "Io control HBA timer!\n"));
+		hba_remove_timer_sync(req);
+	}
+#endif
+
+#ifdef USE_REQ_POOL
+	hba_req_cache_free(phba,req);
+#else
+	res_free_req_to_pool(phba->req_pool, req);
+#endif
+	phba->Io_Count--;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&phba->desc->hba_desc->hba_sync, 0);
+#else
+	complete(&phba->desc->hba_desc->cmpl);
+#endif /* LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11) */
+}
+
+void hba_send_internal_ioctl(struct scsi_device *sdev, MV_PVOID extension, MV_PVOID buffer, MV_U8 cdb1)
+{
+	unsigned long flags;
+	PMV_Request pReq;
+	struct hba_extension *phba = (struct hba_extension *)extension;
+
+#ifdef USE_REQ_POOL
+	pReq = hba_req_cache_alloc(phba);
+#else
+	pReq = res_get_req_from_pool(phba->req_pool);
+#endif
+	if (NULL == pReq) {
+		MV_PRINT("%s : cannot allocate memory for req.\n",
+		       mv_product_name);
+		return;
+	}
+
+	if ((phba->Io_Count) || (phba->Ioctl_Io_Count)) {
+		//MV_DPRINT(("have running request, Io_Count = %d,, ioctl_count=%d, wait...\n",
+		//	phba->Io_Count,phba->Ioctl_Io_Count));
+		msleep(100);
+	}
+	WARN_ON(phba->Ioctl_Io_Count != 0);
+	pReq->Device_Id = VIRTUAL_DEVICE_ID;
+	pReq->Cmd_Initiator = phba;
+	pReq->Org_Req = pReq;
+	pReq->Data_Buffer = buffer;
+	pReq->Data_Transfer_Length = sizeof(OS_disk_info);
+	pReq->Scsi_Status = REQ_STATUS_INVALID_REQUEST;
+	pReq->Completion = hba_send_ioctl_cb;
+	pReq->Cdb[0] = APICDB0_IOCONTROL;
+	pReq->Cdb[1] = cdb1;
+	pReq->Cdb[2] = sdev->id;
+	pReq->Cdb[3] = sdev->lun;
+	pReq->Req_Type = REQ_TYPE_INTERNAL;
+
+	init_completion(&phba->desc->hba_desc->cmpl);
+	spin_lock_irqsave(&phba->desc->hba_desc->global_lock, flags);
+	phba->Io_Count++;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	atomic_set(&phba->desc->hba_desc->hba_sync, 1);
+#endif
+	phba->desc->ops->module_sendrequest(phba->desc->extension, pReq);
+	spin_unlock_irqrestore(&phba->desc->hba_desc->global_lock, flags);
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+	if (0 == __hba_wait_for_atomic_timeout(&phba->desc->hba_desc->hba_sync, 10 * HZ))
+		goto err_get_hdinfo_req;
+#else
+	if(0 == wait_for_completion_timeout(&phba->desc->hba_desc->cmpl, 10 * HZ))
+		goto err_get_hdinfo_req;
+#endif
+	MV_DPRINT(("finished io control.\n"));
+	return;
+
+err_get_hdinfo_req:
+	MV_PRINT("io control req failed.\n");
+}
+
+#ifndef MV_VMK_ESX35
+static int mv_scsi_slave_configure(struct scsi_device *sdev)
+{
+	struct hba_extension *hba = *((struct hba_extension * *) sdev->host->hostdata);
+	OS_disk_info disk_info;
+	int dev_qth = 1;
+
+	MV_ZeroMemory(&disk_info, sizeof(OS_disk_info));
+	if (hba->RunAsNonRAID) {
+		hba_send_internal_ioctl(sdev, hba, &disk_info, APICDB1_GET_OS_DISK_INFO);
+		if (disk_info.queue_depth)
+			dev_qth = disk_info.queue_depth;
+
+		/* Not set auto wake up for SATA disk */
+		if (disk_info.disk_type != DISK_TYPE_SATA)
+			sdev->allow_restart = 1;
+	} else
+		dev_qth = MV_MAX_REQUEST_PER_LUN;
+
+	if (sdev->tagged_supported)
+		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev),
+					dev_qth);
+	else {
+		scsi_adjust_queue_depth(sdev, 0, 1);
+		dev_qth = 1;
+	}
+	
+	return 0;
+}
+#endif
+	
+#if  LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 33) 
+static int mv_change_queue_depth(struct scsi_device *sdev, int new_depth)
+#else
+static int mv_change_queue_depth(struct scsi_device *sdev, int new_depth, int reason)
+#endif
+{
+	struct hba_extension *hba = *((struct hba_extension * *) sdev->host->hostdata);
+	OS_disk_info disk_info;
+	int res = 0, dev_qth = 1;
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 33) 
+	if (reason != SCSI_QDEPTH_DEFAULT)
+		return -EOPNOTSUPP;
+#endif
+	
+	MV_ZeroMemory(&disk_info, sizeof(OS_disk_info));
+	if (hba->RunAsNonRAID) {
+		hba_send_internal_ioctl(sdev, hba, &disk_info, APICDB1_GET_OS_DISK_INFO);
+		if (disk_info.queue_depth)
+			dev_qth = disk_info.queue_depth;
+	} else
+		dev_qth = MV_MAX_REQUEST_PER_LUN;
+#ifdef SUPPORT_MUL_LUN	
+	if(new_depth > MAX_REQUEST_PER_LUN_PERFORMANCE)
+		return dev_qth;
+	res=new_depth;
+#else
+	res = min(new_depth, dev_qth);
+#endif
+	if (sdev->tagged_supported) {
+		scsi_adjust_queue_depth(sdev, scsi_get_tag_type(sdev), res);
+		//hba_send_internal_ioctl(sdev, hba, &hd_info, APICDB1_GET_OS_DISK_INFO);
+	} else {
+		scsi_adjust_queue_depth(sdev, 0, 1);
+		res = 1;
+	}
+
+	return res;
+}
+
+static int mv_change_queue_type(struct scsi_device *scsi_dev, int qt)
+{
+	struct hba_extension *hba = *((struct hba_extension * *) scsi_dev->host->hostdata);
+	OS_disk_info disk_info;
+
+	switch (qt) {
+	case MSG_ORDERED_TAG:
+		disk_info.queue_type = TCQ_QUEUE_TYPE_ORDERED;
+		break;
+	case 0:
+		/*fall through*/
+	case MSG_SIMPLE_TAG:
+		disk_info.queue_type = TCQ_QUEUE_TYPE_SIMPLE;
+		break;
+	default:
+		break;
+	}
+
+	if (hba->RunAsNonRAID) {
+		hba_send_internal_ioctl(scsi_dev, hba, &disk_info, APICDB1_SET_OS_DISK_QUEUE_TYPE);
+	}
+	if (!scsi_dev->tagged_supported)
+		return 0;
+
+	scsi_deactivate_tcq(scsi_dev, 1);
+
+	scsi_set_tag_type(scsi_dev, qt);
+	scsi_activate_tcq(scsi_dev, scsi_dev->queue_depth);
+
+	return qt;
+}
+#endif
+
+#ifndef MV_VMK_ESX35
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+struct class_device_attribute *mvs_host_attrs[];
+#else
+struct device_attribute *mvs_host_attrs[];
+#endif
+#endif
+
+#ifndef MV_VMK_ESX35
+static struct scsi_host_template mv_driver_template = {
+#else
+Scsi_Host_Template mv_driver_template = {
+#endif
+	.module                      =  THIS_MODULE,
+	.name                        =  "Marvell Storage Controller",
+	.proc_name                   =  mv_driver_name,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0)
+	.show_info			= mv_linux_show_info,
+#else
+	.proc_info                   =  mv_linux_proc_info,
+#endif
+	.queuecommand                =  mv_linux_queue_command,
+	.eh_host_reset_handler       =  mv_linux_reset,
+
+#if defined(SUPPORT_SG_RESET) || defined(__VMKLNX__)
+	.eh_device_reset_handler     =  mv_device_reset,
+	.eh_bus_reset_handler        =  mv_bus_reset,
+#endif
+#ifdef __VMKLNX__
+	.eh_host_reset_handler       =  mv_host_reset,
+#endif
+#ifndef MV_VMK_ESX35
+	.slave_alloc                = mv_scsi_slave_alloc,
+	.slave_configure         = mv_scsi_slave_configure,
+	.slave_destroy            = mv_scsi_slave_destroy,
+#endif
+#if  LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 10)
+	.change_queue_depth	= mv_change_queue_depth,
+	.change_queue_type 	= mv_change_queue_type,
+#endif
+#if  LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 7) && \
+	LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 16)
+	.eh_timed_out                =  mv_linux_timed_out,
+#endif
+	.can_queue                   =  MV_MAX_REQUEST_DEPTH,
+	.this_id                     =  MV_SHT_THIS_ID,
+	.max_sectors                 =  (MV_MAX_TRANSFER_SIZE >> 9),
+	.sg_tablesize                =  MV_MAX_SG_ENTRY,
+	.cmd_per_lun                 =  MV_MAX_REQUEST_PER_LUN,
+	.use_clustering              =  MV_SHT_USE_CLUSTERING,
+	.emulated                    =  MV_SHT_EMULATED,
+#if defined(MV_BLK_IOCTL) && !defined(MV_VMK_ESX35)
+	.ioctl                       =  mv_new_ioctl,
+#endif
+#ifdef MV_VMK_ESX35
+	.detect                      = mv_linux_detect,
+	.abort                       = mv_linux_abort,
+#elif defined(MV_VMK_ESXI5)
+	.detect				= mv_linux_detect,
+	.eh_abort_handler		= mv_linux_abort,
+#endif
+#ifndef MV_VMK_ESX35
+	.shost_attrs		= mvs_host_attrs,
+#endif
+};
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 15)
+static struct scsi_transport_template mv_transport_template = {
+	.eh_timed_out   =  mv_linux_timed_out,
+};
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 16) */
+
+void HBA_ModuleStart(MV_PVOID extension)
+{
+	struct Scsi_Host *host = NULL;
+	struct hba_extension *hba;
+	struct mv_adp_desc *hba_desc;
+	struct proc_reg_data* data;
+	int ret;	
+
+	hba = (struct hba_extension *) extension;
+	hba_desc = hba->desc->hba_desc;
+#ifdef MV_VMK_ESX35
+	host = vmk_scsi_register(&mv_driver_template,sizeof(void *),
+	                         hba_desc->dev->bus->number, hba_desc->dev->devfn);
+#else
+	host = scsi_host_alloc(&mv_driver_template, sizeof(void *));
+    hba->reg_enabled = mv_reg_enable;
+	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,10,0)
+    if (hba->reg_enabled)
+    {
+		sprintf(hba->proc_name,"%d_register", host->host_no);
+		hba->proc_dir = mv_driver_template.proc_dir;
+		hba->reg_info = create_proc_entry(hba->proc_name, S_IFREG | S_IRWXU, hba->proc_dir);
+		if (NULL == hba->reg_info)
+		{	   
+		   MV_DPRINT(("%s create proc entry failed.\n", __func__));
+		}
+
+		data = kmalloc(sizeof(struct proc_reg_data), GFP_ATOMIC);
+		data->hba = hba;
+		data->flag = 0;
+		hba->reg_info->data = (void *)data;
+		hba->reg_info->write_proc = reg_info_write;
+		hba->reg_info->read_proc = reg_info_read; 
+    }
+#endif
+
+#endif
+	if (NULL == host) {
+		MV_PRINT("%s : Unable to allocate a scsi host.\n",
+		       mv_product_name);
+		goto err_out;
+	}
+
+	*((MV_PVOID *) host->hostdata) = extension;
+	hba_desc->hba_host = host;
+#ifdef MV_VMK_ESX35
+	host->pci_dev = hba_desc->dev;
+#endif
+	host->irq          = hba_desc->dev->irq;
+#ifdef SUPPORT_OEM_PROJECT
+	host->max_id	   = MV_MAX_TARGET_NUMBER-1;	//do not report virtual device
+#else
+	host->max_id       = MV_MAX_TARGET_NUMBER;
+#endif
+	host->max_lun      = MV_MAX_LUN_NUMBER;
+	host->max_channel  = 0;
+#ifdef SUPPORT_VAR_LEN_CDB
+	host->max_cmd_len  = 32;
+#else
+	host->max_cmd_len = 16;
+#endif
+{
+	if ((hba->Max_Io) && (hba->Max_Io < MV_MAX_REQUEST_DEPTH)){
+		/* set can queue as resource limitation */
+		host->can_queue = 1;
+	}
+
+	MV_DPRINT(("HBA queue command = %d.\n", host->can_queue));
+}
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 15)
+	host->transportt   = &mv_transport_template;
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 16) */
+
+    hba->test_enabled = mv_test_enable;
+	printk("mv_do_test value is %d\n", mv_test_enable);
+
+    hba->msi_enabled = mv_msi_enable;
+
+	if (hba->msi_enabled)
+		pci_enable_msi(hba->desc->hba_desc->dev);
+
+	MV_DPRINT(( "start install request_irq.\n"));
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 19)
+	ret = request_irq(hba_desc->dev->irq, mv_intr_handler, IRQF_SHARED,
+			  mv_driver_name, hba);
+#else
+	ret = request_irq(hba_desc->dev->irq, mv_intr_handler, SA_SHIRQ,
+			  mv_driver_name, hba);
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 19) */
+	if (ret < 0) {
+		MV_PRINT("%s : Error upon requesting IRQ %d.\n",
+		       mv_product_name, hba_desc->dev->irq);
+		goto  err_request_irq;
+	}
+	MV_DPRINT(("request_irq has been installed.\n"));
+
+	return ;
+
+err_request_irq:
+#ifndef MV_VMK_ESX35
+	scsi_host_put(host);
+#endif
+	hba_desc->hba_host = NULL;
+err_out:
+	return;
+}
+
+#ifndef MV_VMK_ESX35
+
+MV_U16 mv_register_mode = 0;
+
+MV_U16 mv_get_register_mode(void)
+{
+    return mv_register_mode;
+}
+
+#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static ssize_t mvs_show_register_mode(struct class_device *cdev, char *buffer)
+{
+#else
+static ssize_t mvs_show_register_mode(struct device *cdev, struct device_attribute *attr, char *buffer)
+{
+#endif
+	return snprintf(buffer, PAGE_SIZE, "%d\n", mv_register_mode);
+}
+
+#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static ssize_t
+mvs_store_register_mode(struct class_device *cdev,  const char *buffer, size_t size)
+{
+#else
+static ssize_t
+mvs_store_register_mode(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t size)
+{
+#endif
+	int val = 0;
+
+	if (buffer == NULL)
+		return size;
+
+	if (sscanf(buffer, "%d", &val) != 1) {
+		printk( "Input invalid register mode, please input number:0 or 1.\n");
+		return -EINVAL;
+	}
+
+	mv_register_mode = val;
+	if(mv_register_mode != 0)
+	{
+		mv_register_mode = 1;
+	}
+
+	printk( "set register mode to 0x%x\n",  mv_register_mode);
+	return strlen(buffer);
+}
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static CLASS_DEVICE_ATTR(register_mode,
+			 S_IRUGO|S_IWUSR,
+			 mvs_show_register_mode,
+			 mvs_store_register_mode);
+#else
+static DEVICE_ATTR(register_mode, S_IRUGO|S_IWUSR,
+			 mvs_show_register_mode,
+			 mvs_store_register_mode);
+#endif
+
+#ifdef SUPPORT_IO_DELAY
+MV_U16 io_delay=10;
+#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static ssize_t
+mvs_store_io_delay(struct class_device *cdev,  const char *buffer, size_t size)
+{
+#else
+static ssize_t
+mvs_store_io_delay(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t size)
+{
+#endif
+
+	int val = 0;
+
+	if (buffer == NULL)
+		return size;
+
+	if (sscanf(buffer, "%d", &val) != 1)
+		return -EINVAL;
+
+	io_delay = val;
+	if(io_delay > 10){
+		printk( "io delay time %d seconds is too long, max is 10s\n",  io_delay);
+		io_delay = 10;
+		return strlen(buffer);
+	}
+	printk( "set io delay time to %d seconds\n",  io_delay);
+	return strlen(buffer);
+}
+
+#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static ssize_t mvs_show_io_delay(struct class_device *cdev, char *buffer)
+{
+#else
+static ssize_t mvs_show_io_delay(struct device *cdev, struct device_attribute *attr, char *buffer)
+{
+#endif
+	return snprintf(buffer, PAGE_SIZE, "%d\n", io_delay);
+}
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static CLASS_DEVICE_ATTR(io_delay,
+			 S_IRUGO|S_IWUSR,
+			 mvs_show_io_delay,
+			 mvs_store_io_delay);
+#else
+static DEVICE_ATTR(io_delay,
+			 S_IRUGO|S_IWUSR,
+			 mvs_show_io_delay,
+			 mvs_store_io_delay);
+#endif
+
+
+MV_U16 hba_get_io_delay_value(void)
+{
+	MV_U16 value=0;
+	value = io_delay;
+	return value;
+}
+
+#endif	/* #ifdef SUPPORT_IO_DELAY */
+
+#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static ssize_t
+mvs_show_driver_version(struct class_device *cdev,  char *buffer)
+{
+#else
+static ssize_t
+mvs_show_driver_version(struct device *cdev, struct device_attribute *attr,  char *buffer)
+{
+#endif
+	return snprintf(buffer, PAGE_SIZE, "%s\n", mv_version_linux);
+}
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static CLASS_DEVICE_ATTR(driver_version,
+			 S_IRUGO,
+			 mvs_show_driver_version,
+			 NULL);
+#else
+static DEVICE_ATTR(driver_version,
+			 S_IRUGO,
+			 mvs_show_driver_version,
+			 NULL);
+#endif
+
+#ifdef SUPPORT_CHANGE_CAN_QUEUE
+
+#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static ssize_t mvs_show_host_can_queue(struct class_device *cdev, char *buffer)
+{
+#else
+static ssize_t mvs_show_host_can_queue(struct device *cdev, struct device_attribute *attr, char *buffer)
+{
+#endif
+	struct Scsi_Host *shost = class_to_shost(cdev);
+	struct hba_extension *hba = *((struct hba_extension * *) shost->hostdata);
+	struct mv_adp_desc *hba_desc;
+	hba_desc = hba->desc->hba_desc;
+	return snprintf(buffer, PAGE_SIZE, "%d\n", hba_desc->hba_host->can_queue);
+}
+
+#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static ssize_t
+mvs_store_host_can_queue(struct class_device *cdev,  const char *buffer, size_t size)
+{
+#else
+static ssize_t
+mvs_store_host_can_queue(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t size)
+{
+#endif
+	struct Scsi_Host *shost = class_to_shost(cdev);
+	struct hba_extension *hba = *((struct hba_extension * *) shost->hostdata);
+	struct mv_adp_desc *hba_desc;
+	int val = 0;
+
+	hba_desc = hba->desc->hba_desc;
+	if (buffer == NULL)
+		return size;
+
+	if (sscanf(buffer, "%d", &val) != 1)
+		return -EINVAL;
+
+	if(val > MAX_REQUEST_NUMBER_PERFORMANCE - 2){
+		printk( "can_queue %d exceeds max vaule:%d\n",  val, MV_MAX_REQUEST_DEPTH);
+		hba_desc->hba_host->can_queue = MV_MAX_REQUEST_DEPTH;
+		return strlen(buffer);
+	} else if (val < 1){
+		printk( "can_queue legal value is >= 1\n");
+		hba_desc->hba_host->can_queue = 1;
+		return strlen(buffer);
+	} else
+		hba_desc->hba_host->can_queue = val;
+	printk( "set host can queue to %d \n",  hba_desc->hba_host->can_queue);
+	return strlen(buffer);
+}
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static CLASS_DEVICE_ATTR(host_can_queue,
+			 S_IRUGO|S_IWUSR,
+			 mvs_show_host_can_queue,
+			 mvs_store_host_can_queue);
+#else
+static DEVICE_ATTR(host_can_queue, S_IRUGO|S_IWUSR,
+			 mvs_show_host_can_queue,
+			 mvs_store_host_can_queue);
+#endif
+
+#endif	/* #ifdef SUPPORT_CHANGE_CAN_QUEUE */
+
+#ifdef SUPPORT_CHANGE_DEBUG_MODE
+MV_U16 mv_debug_mode = CORE_FULL_DEBUG_INFO;
+#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static ssize_t mvs_show_debug_mode(struct class_device *cdev, char *buffer)
+{
+#else
+static ssize_t mvs_show_debug_mode(struct device *cdev, struct device_attribute *attr, char *buffer)
+{
+#endif
+	return snprintf(buffer, PAGE_SIZE, "0x%x\n", mv_debug_mode);
+}
+
+#if   LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static ssize_t
+mvs_store_debug_mode(struct class_device *cdev,  const char *buffer, size_t size)
+{
+#else
+static ssize_t
+mvs_store_debug_mode(struct device *cdev, struct device_attribute *attr, const char *buffer, size_t size)
+{
+#endif
+
+	int val = 0;
+
+	if (buffer == NULL)
+		return size;
+
+	if (sscanf(buffer, "0x%x", &val) != 1) {
+		printk( "Input invalid debug mode, please input hexadecimal number:0x0~0xf.\n");
+		return -EINVAL;
+	}
+
+	mv_debug_mode = val;
+	if(mv_debug_mode > 0xF){
+		printk( "Invalid debug mode, close all debug info!\n");
+		mv_debug_mode = 0x0;
+		return strlen(buffer);
+	} else
+		printk( "set debug mode to 0x%x\n",  mv_debug_mode);
+	return strlen(buffer);
+}
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+static CLASS_DEVICE_ATTR(debug_mode,
+			 S_IRUGO|S_IWUSR,
+			 mvs_show_debug_mode,
+			 mvs_store_debug_mode);
+#else
+static DEVICE_ATTR(debug_mode, S_IRUGO|S_IWUSR,
+			 mvs_show_debug_mode,
+			 mvs_store_debug_mode);
+#endif
+
+#endif /* #ifdef SUPPORT_CHANGE_DEBUG_MODE */
+
+#if  LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 26)
+struct class_device_attribute *mvs_host_attrs[] = {
+	&class_device_attr_driver_version,
+#ifdef SUPPORT_IO_DELAY
+	&class_device_attr_io_delay,
+#endif
+
+#ifdef SUPPORT_TARGET
+	&class_device_attr_target_mode,
+#endif
+#ifdef SUPPORT_CHANGE_CAN_QUEUE
+	&class_device_attr_host_can_queue,
+#endif
+#ifdef SUPPORT_CHANGE_DEBUG_MODE
+	&class_device_attr_debug_mode,
+#endif
+    &class_device_attr_register_mode,
+
+	NULL,
+};
+#else
+struct device_attribute *mvs_host_attrs[] = {
+	&dev_attr_driver_version,
+#ifdef SUPPORT_IO_DELAY
+	&dev_attr_io_delay,
+#endif
+
+#ifdef SUPPORT_TARGET
+	&dev_attr_target_mode,
+#endif
+#ifdef SUPPORT_CHANGE_CAN_QUEUE
+	&dev_attr_host_can_queue,
+#endif
+#ifdef SUPPORT_CHANGE_DEBUG_MODE
+	&dev_attr_debug_mode,
+#endif
+    &dev_attr_register_mode,
+    
+	NULL,
+};
+#endif
+
+#if defined(SUPPORT_DIF) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+/*
+# mv_prot_mask: i
+#	- Bit mask of host protection capabilities used to register with the
+#	  SCSI mid-layer
+#
+*/
+unsigned int mv_prot_mask =  SHOST_DIF_TYPE1_PROTECTION |SHOST_DIF_TYPE3_PROTECTION
+						| SHOST_DIF_TYPE2_PROTECTION;
+
+module_param(mv_prot_mask, uint, 0);
+MODULE_PARM_DESC(mv_prot_mask, "host protection mask");
+#if defined(SUPPORT_DIX) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+/*
+# mv_prot_guard: i
+#	- Bit mask of protection guard types to register with the SCSI mid-layer
+# 	- Guard types are currently either 1) IP checksum 2) T10-DIF CRC
+#
+*/
+unsigned char mv_prot_guard = SHOST_DIX_GUARD_CRC;
+module_param(mv_prot_guard, byte, 0);
+MODULE_PARM_DESC(mv_prot_guard, "host protection guard type");
+#endif
+#endif
+
+#endif
+static int __init sas_hba_init(void)
+{
+#ifdef MV_VMK_ESX35
+	int rc=0;
+	if(!vmk_set_module_version(mv_version_linux))
+		return 0;
+	spin_lock_init(&io_request_lock);
+	mv_driver_template.driverLock = &io_request_lock;
+#endif
+	hba_house_keeper_init();
+#ifdef MV_VMK_ESX35
+	rc = pci_register_driver(&mv_pci_driver);
+	if(rc < 0) {
+		spin_lock_destroy(&io_request_lock);
+		return -ENODEV;
+	}
+	rc = scsi_register_module(MODULE_SCSI_HA,&mv_driver_template);
+	if(rc){
+		spin_lock_destroy(&io_request_lock);
+		pci_unregister_driver(&mv_pci_driver);
+	}
+	return 0;
+#else
+	return pci_register_driver(&mv_pci_driver);
+#endif
+}
+
+static void __exit sas_hba_exit(void)
+{
+	pci_unregister_driver(&mv_pci_driver);
+	MV_DPRINT(("sas_hba_exit: before hba_house_keeper_exit\n"));
+	hba_house_keeper_exit();
+#ifdef MV_VMK_ESX35
+	spin_lock_destroy(&io_request_lock);
+#endif
+}
+
+MODULE_AUTHOR ("Marvell Technolog Group Ltd.");
+MODULE_DESCRIPTION ("Marvell SAS hba driver");
+
+
+MODULE_LICENSE("proprietary");
+
+MODULE_VERSION(mv_version_linux);
+MODULE_DEVICE_TABLE(pci, mv_pci_ids);
+module_init(sas_hba_init);
+module_exit(sas_hba_exit);
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/linux_main.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/linux_main.h
--- linux-3.10.69/drivers/scsi/mv/linux_main.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/linux_main.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,105 @@
+#ifndef _LINUX_MAIN_H
+#define _LINUX_MAIN_H
+
+#include "hba_header.h"
+
+#define __mv_get_ext_from_host(phost) \
+          (((HBA_Extension **) (phost)->hostdata)[0])
+
+/* for communication with OS/SCSI mid layer only */
+enum {
+	MV_MAX_REQUEST_DEPTH		 = MAX_REQUEST_NUMBER_PERFORMANCE - 2,
+	MV_MAX_IO                = MAX_REQUEST_NUMBER_PERFORMANCE,
+#ifdef RAID_DRIVER
+	MV_MAX_REQUEST_PER_LUN   = MAX_REQUEST_NUMBER_PERFORMANCE/MAX_LD_SUPPORTED_PERFORMANCE,
+	MV_MAX_SG_ENTRY          = MV_MAX_TRANSFER_SIZE/PAGE_SIZE, /*MV_MAX_TRANSFER_SIZE should be <=512Kbytes*/
+	MV_SHT_USE_CLUSTERING    = DISABLE_CLUSTERING,  /*raid driver only support 4k sg entry length*/
+#else /* RAID_DRIVER */
+	MV_MAX_REQUEST_PER_LUN   = MAX_REQUEST_PER_LUN_PERFORMANCE,
+	MV_MAX_SG_ENTRY          = SG_ALL,
+	MV_SHT_USE_CLUSTERING    = ENABLE_CLUSTERING, 
+#endif /* RAID_DRIVER */
+	MV_MAX_IOCTL_REQUEST = 30,
+	MV_SHT_EMULATED          = 0,
+	MV_SHT_THIS_ID           = -1,
+};
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#define mv_scmd_host(cmd)    cmd->device->host
+#define mv_scmd_channel(cmd) cmd->device->channel
+#define mv_scmd_target(cmd)  cmd->device->id
+#define mv_scmd_lun(cmd)     cmd->device->lun
+#else
+#define mv_scmd_host(cmd)    cmd->host
+#define mv_scmd_channel(cmd) cmd->channel
+#define mv_scmd_target(cmd)  cmd->target
+#define mv_scmd_lun(cmd)     cmd->lun
+#endif
+
+#define LO_BUSADDR(x) ((MV_U32)(x))
+#define HI_BUSADDR(x) (MV_U32)(sizeof(BUS_ADDRESS)>4? (u64)(x) >> 32 : 0)
+
+struct _MV_SCP {
+	MV_U16           mapped;
+	MV_U16           map_atomic;
+	BUS_ADDRESS bus_address;
+};
+
+#define MV_SCp(cmd) ((struct _MV_SCP *)(&((struct scsi_cmnd *)cmd)->SCp))
+
+#ifndef scsi_to_pci_dma_dir
+#define scsi_to_pci_dma_dir(scsi_dir) ((int)(scsi_dir))
+#endif
+
+#ifdef USE_REQ_POOL
+void  hba_req_cache_destroy(MV_PVOID hba_ext);
+int hba_req_cache_create(MV_PVOID hba_ext);
+PMV_Request hba_req_cache_alloc(MV_PVOID hba_ext);
+void hba_req_cache_free(MV_PVOID hba_ext,PMV_Request req) ;
+#else /* USE_REQ_POOL */
+struct mv_request_pool {
+	List_Head free_list;
+	List_Head use_list;
+	void        *req_mem;  /* starting address of the request mem pool */
+	void 		*sg_mem;
+	spinlock_t  lock;
+	MV_U32      mod_id;
+	MV_U32      size;
+	MV_U32      sg_count;
+};
+
+/* request structure related
+ * mod_id   : id of the module that is making the request
+ * size     : size of the pool, measured in the number of requests
+ * sg_count : scatter gather list entries supported by each request
+ */
+struct mv_request_pool *res_reserve_req_pool(MV_U32 mod_id,
+					     MV_U32 size,
+					     MV_U32 sg_count);
+
+struct _MV_Request *res_get_req_from_pool(struct mv_request_pool *pool);
+
+void res_free_req_to_pool(struct mv_request_pool *pool,
+			  struct _MV_Request *req);
+void res_release_req_pool(struct mv_request_pool *pool);
+void res_dump_pool_info(struct mv_request_pool *pool);
+#endif /* !defined(USE_REQ_POOL)*/
+
+void mv_complete_request(struct hba_extension *phba,
+				struct scsi_cmnd *scmd,
+				PMV_Request pReq);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 11)
+/* will wait for atomic value atomic to become zero until timed out */
+/* return how much 'timeout' is left or 0 if already timed out */
+int __hba_wait_for_atomic_timeout(atomic_t *atomic, unsigned long timeout);
+#endif
+
+#ifdef MV_BLK_IOCTL
+extern void * kbuf_array[512];
+extern unsigned char mvcdb[512][16];
+extern int mv_new_ioctl(struct scsi_device *dev, int cmd, void __user *arg);
+#endif
+void hba_send_shutdown_req(MV_PVOID);
+
+#endif /*_LINUX_MAIN_H*/
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/Makefile F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/Makefile
--- linux-3.10.69/drivers/scsi/mv/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/Makefile	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,175 @@
+#
+#
+# Note: This Makefile is for 2.6 kernel only, at present.
+#
+# V0.0.0.6 Ver.Make
+
+# default to build for the running kernel
+ifeq ("x", "x$(KERNEL_SRC)")
+	KERNEL_SRC=/lib/modules/$(shell uname -r)/build
+
+  ifeq ("powerpc", "$(ARCH)")
+   	KERNEL_SRC=/root/katmai_29/lib/modules/2.6.29/build
+  endif
+ 
+  ifeq ("arm", "$(ARCH)")
+	KERNEL_SRC=/root/armadaxp/linux-2.6.35.9	
+  endif
+
+endif
+
+# use KERNEL_SRC if not called by our driver disk maker
+ifeq ("x", "x$(KERNEL_SOURCE_DIR)")
+        KERNEL_SRC_DIR=$(KERNEL_SRC)
+else
+	KERNEL_SRC_DIR=$(KERNEL_SOURCE_DIR)
+endif
+
+ifeq ("x", "x$(KERNEL_BUILD_DIR)")
+	KERNEL_BLD_DIR=$(KERNEL_SRC_DIR)
+else
+        KERNEL_BLD_DIR=$(KERNEL_BUILD_DIR)
+endif
+
+include $(src)/mv_conf.mk
+
+ifeq ("xy", "x$(RAID_MODULE)")
+	USE_RAID=y
+	LIB_TYPE=_raid_
+else
+	USE_RAID=n
+	LIB_TYPE=_nonraid_
+endif
+
+
+# KERNEL_VER := $(shell cat $(KERNEL_BLD_SRC)/include/linux/version.h | grep UTS_RELEASE | cut -c22-24 | head -n 1)
+
+ifneq ("arm", "$(ARCH)")
+# we may build for 32bit kernel on a 64bit system
+#CONFIG_64BIT=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_64BIT | awk -F= '{print $$2}')
+CONFIG_64BIT=y
+#CONFIG_REGPARM=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_REGPARM | awk -F= '{print $$2}')
+#CONFIG_SUSE_KERNEL=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_SUSE_KERNEL | awk -F= '{print $$2}')
+endif
+
+
+ifeq ($(strip $(CONFIG_64BIT)),y)
+	ARCH_TYPE=x86_64
+		MV_LIB_NAME=libmv$(LIB_TYPE)64
+else	
+	ARCH_TYPE=i386 
+	ifeq ($(strip $(CONFIG_REGPARM)),y)
+		MV_LIB_NAME=libmv$(LIB_TYPE)32
+	else
+		MV_LIB_NAME=libmv$(LIB_TYPE)32_noregparm
+	endif
+endif
+
+
+ifeq ($(ARCH), )
+ifeq ($(strip $(CONFIG_64BIT)),y)
+	ARCH_TYPE=x86_64
+	RAID_LIB_NAME=libmv$(LIB_TYPE)64
+else	
+	ARCH_TYPE=i386 
+	ifeq ($(strip $(CONFIG_REGPARM)),y)
+		RAID_LIB_NAME=libmv$(LIB_TYPE)32
+	else
+		RAID_LIB_NAME=libmv$(LIB_TYPE)32_noregparm
+	endif
+endif
+else
+	ARCH_TYPE=$(ARCH)
+endif
+
+ifeq ("powerpc", "$(ARCH)")
+	MV_CC     =  $(CROSS_COMPILE)gcc
+	MV_LD     =  $(CROSS_COMPILE)ld
+else
+
+ifeq ("arm", "$(ARCH)")
+	MV_CC	  =  $(CROSS_COMPILE)gcc
+	MV_LD	  =  $(CROSS_COMPILE)ld
+else
+	MV_CC     =  $(CROSS_COMPILE)$(CC)
+	MV_LD     =  $(CROSS_COMPILE)$(LD)
+endif
+endif
+
+export LD_LIBRARY_PATH
+
+OSDEP_OBJS      := linux_main.o    hba_exp.o          \
+		   hba_mod.o       hba_timer.o        \
+		   mv_os.o   linux_iface.o				
+
+LIBMV_OBJS      := lib/$(MV_LIB_NAME).obj
+
+HBA_OBJS        := $(OSDEP_OBJS) $(LIBMV_OBJS)
+
+
+ifneq ("arm", "$(ARCH)")
+INCLUDE_DIR     = -I$(KERNEL_BLD_DIR)/include                          \
+		  -I$(KERNEL_BLD_DIR)/include/scsi                     \
+		  -I$(KERNEL_BLD_DIR)/drivers/scsi                     \
+	 	  -I$(KERNEL_SRC_DIR)/include                          \
+	 	  -I$(KERNEL_SRC_DIR)/include/scsi                     \
+	 	  -I$(KERNEL_SRC_DIR)/drivers/scsi
+endif
+
+
+
+ifeq ($(SUPPORT_VANIR), y)
+obj-$(CONFIG_SCSI_MV_94xx)      :=   mv94xx.o
+mv94xx-objs   :=   $(HBA_OBJS) 
+endif
+ifeq ($(SUPPORT_ODIN), y)
+obj-$(CONFIG_SCSI_MV_64xx)      :=   mv64xx.o
+mv64xx-objs   :=   $(HBA_OBJS) 
+endif
+clean-files   +=   Modules.symvers
+clean-files   +=   Module.symvers
+
+EXTRA_CFLAGS  :=   -I$(src)/include -I$(src)/.
+
+EXTRA_CFLAGS  +=  -D__MV_LINUX__ $(INCLUDE_DIR) -std=gnu99 #-D__MV_DEBUG__
+
+ifeq ($(CONFIG_64BIT), y)
+EXTRA_CFLAGS  +=   -D_64_SYS_
+else
+EXTRA_CFLAGS  +=   -D_32_LEGACY_
+endif
+
+EXTRA_CFLAGS  +=   -D_64_BIT_COMPILER
+
+EXTRA_CFLAGS  +=   -include $(src)/mv_config.h
+
+ifeq ($(RAID_MODULE), y)
+EXTRA_CFLAGS  +=   -DRAID_DRIVER=1
+endif
+
+ifeq ($(RAID6_MODULE), y)
+EXTRA_CFLAGS  +=   -DSUPPORT_RAID6=1
+endif
+
+ifeq ($(CACHE_MODULE), y)
+EXTRA_CFLAGS  +=   -DCACHE_MODULE_SUPPORT=1
+endif
+
+ifeq ($(SUPPORT_VANIR), y)
+EXTRA_CFLAGS  +=   -DPRODUCTNAME_VANIR
+endif
+
+ifeq ($(SUPPORT_ODIN), y)
+EXTRA_CFLAGS  +=   -DPRODUCTNAME_ODIN
+endif
+
+
+ifeq ($(CONFIG_SUSE_KERNEL), y)
+EXTRA_CFLAGS  += -DIS_OPENSUSE_SLED_SLES=1
+else
+EXTRA_CFLAGS	+= -DIS_OPENSUSE_SLED_SLES=0
+endif
+
+EXTRA_CFLAGS  +=  -Wno-unused-variable 
+EXTRA_CFLAGS  += -D__LEGACY_OSSW__=1 -D_OS_LINUX	  
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/Makefile.kbuild F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/Makefile.kbuild
--- linux-3.10.69/drivers/scsi/mv/Makefile.kbuild	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/Makefile.kbuild	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,182 @@
+#
+#
+# Note: This Makefile is for 2.6.X and 3.X kernel, at present.
+#
+# V0.0.0.6 Ver.Make
+
+# default to build for the running kernel
+ifeq ("x", "x$(KERNEL_SRC)")
+	KERNEL_SRC=/lib/modules/$(shell uname -r)/build
+
+  ifeq ("powerpc", "$(ARCH)")
+   	KERNEL_SRC=/root/katmai_29/lib/modules/2.6.29/build
+  endif
+ 
+  ifeq ("arm", "$(ARCH)")
+	KERNEL_SRC=/root/armadaxp/linux-2.6.35.9	
+  endif
+
+endif
+
+# use KERNEL_SRC if not called by our driver disk maker
+ifeq ("x", "x$(KERNEL_SOURCE_DIR)")
+        KERNEL_SRC_DIR=$(KERNEL_SRC)
+else
+	KERNEL_SRC_DIR=$(KERNEL_SOURCE_DIR)
+endif
+
+ifeq ("x", "x$(KERNEL_BUILD_DIR)")
+	KERNEL_BLD_DIR=$(KERNEL_SRC_DIR)
+else
+        KERNEL_BLD_DIR=$(KERNEL_BUILD_DIR)
+endif
+
+include $(src)/mv_conf.mk
+
+ifeq ("xy", "x$(RAID_MODULE)")
+	USE_RAID=y
+	LIB_TYPE=_raid_
+else
+	USE_RAID=n
+	LIB_TYPE=_nonraid_
+endif
+
+
+# KERNEL_VER := $(shell cat $(KERNEL_BLD_SRC)/include/linux/version.h | grep UTS_RELEASE | cut -c22-24 | head -n 1)
+
+ifneq ("arm", "$(ARCH)")
+# we may build for 32bit kernel on a 64bit system
+CONFIG_64BIT=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_64BIT | awk -F= '{print $$2}')
+CONFIG_REGPARM=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_REGPARM | awk -F= '{print $$2}')
+CONFIG_SUSE_KERNEL=$(shell [ -f $(KERNEL_BLD_DIR)/.config ] && cat $(KERNEL_BLD_DIR)/.config | grep -m 1 CONFIG_SUSE_KERNEL | awk -F= '{print $$2}')
+endif
+
+
+ifeq ($(strip $(CONFIG_64BIT)),y)
+	ARCH_TYPE=x86_64
+		MV_LIB_NAME=libmv$(LIB_TYPE)64
+else	
+	ARCH_TYPE=i386 
+	ifeq ($(strip $(CONFIG_REGPARM)),y)
+		MV_LIB_NAME=libmv$(LIB_TYPE)32
+	else
+		MV_LIB_NAME=libmv$(LIB_TYPE)32_noregparm
+	endif
+endif
+
+
+ifeq ($(ARCH), )
+ifeq ($(strip $(CONFIG_64BIT)),y)
+	ARCH_TYPE=x86_64
+	RAID_LIB_NAME=libmv$(LIB_TYPE)64
+else	
+	ARCH_TYPE=i386 
+	ifeq ($(strip $(CONFIG_REGPARM)),y)
+		RAID_LIB_NAME=libmv$(LIB_TYPE)32
+	else
+		RAID_LIB_NAME=libmv$(LIB_TYPE)32_noregparm
+	endif
+endif
+else
+	ARCH_TYPE=$(ARCH)
+endif
+
+ifeq ("powerpc", "$(ARCH)")
+	MV_CC     =  $(CROSS_COMPILE)gcc
+	MV_LD     =  $(CROSS_COMPILE)ld
+else
+
+ifeq ("arm", "$(ARCH)")
+	MV_CC	  =  $(CROSS_COMPILE)gcc
+	MV_LD	  =  $(CROSS_COMPILE)ld
+else
+	MV_CC     =  $(CROSS_COMPILE)$(CC)
+	MV_LD     =  $(CROSS_COMPILE)$(LD)
+endif
+endif
+
+export LD_LIBRARY_PATH
+
+OSDEP_OBJS      := linux_main.o    hba_exp.o          \
+		   hba_mod.o       hba_timer.o        \
+		   mv_os.o   linux_iface.o				
+
+LIBMV_OBJS      := lib/$(MV_LIB_NAME).obj
+
+HBA_OBJS        := $(OSDEP_OBJS) $(LIBMV_OBJS)
+
+
+ifneq ("arm", "$(ARCH)")
+INCLUDE_DIR     = -I$(KERNEL_BLD_DIR)/include                          \
+		  -I$(KERNEL_BLD_DIR)/include/scsi                     \
+		  -I$(KERNEL_BLD_DIR)/drivers/scsi                     \
+	 	  -I$(KERNEL_SRC_DIR)/include                          \
+	 	  -I$(KERNEL_SRC_DIR)/include/scsi                     \
+	 	  -I$(KERNEL_SRC_DIR)/drivers/scsi
+endif
+
+
+
+ifeq ($(SUPPORT_VANIR), y)
+obj-$(CONFIG_SCSI_MV_94xx)      :=   mv94xx.o
+mv94xx-objs   :=   $(HBA_OBJS) 
+endif
+ifeq ($(SUPPORT_VANIRLITES), y)
+obj-$(CONFIG_SCSI_MV_934x)      :=   mv934x.o
+mv934x-objs   :=   $(HBA_OBJS) 
+endif
+ifeq ($(SUPPORT_ODIN), y)
+obj-$(CONFIG_SCSI_MV_64xx)      :=   mv64xx.o
+mv64xx-objs   :=   $(HBA_OBJS) 
+endif
+clean-files   +=   Modules.symvers
+clean-files   +=   Module.symvers
+
+EXTRA_CFLAGS  :=   -I$(src)/include -I$(src)/.
+
+EXTRA_CFLAGS  +=  -D__MV_LINUX__ $(INCLUDE_DIR) -std=gnu99 #-D__MV_DEBUG__
+
+ifeq ($(CONFIG_64BIT), y)
+EXTRA_CFLAGS  +=   -D_64_SYS_
+else
+EXTRA_CFLAGS  +=   -D_32_LEGACY_
+endif
+
+EXTRA_CFLAGS  +=   -D_64_BIT_COMPILER
+
+EXTRA_CFLAGS  +=   -include $(src)/mv_config.h
+
+ifeq ($(RAID_MODULE), y)
+EXTRA_CFLAGS  +=   -DRAID_DRIVER=1
+endif
+
+ifeq ($(RAID6_MODULE), y)
+EXTRA_CFLAGS  +=   -DSUPPORT_RAID6=1
+endif
+
+ifeq ($(CACHE_MODULE), y)
+EXTRA_CFLAGS  +=   -DCACHE_MODULE_SUPPORT=1
+endif
+
+ifeq ($(SUPPORT_VANIR), y)
+EXTRA_CFLAGS  +=   -DPRODUCTNAME_VANIR
+endif
+
+ifeq ($(SUPPORT_VANIRLITES), y)
+EXTRA_CFLAGS  +=   -DPRODUCTNAME_VANIRLITES
+endif
+
+ifeq ($(SUPPORT_ODIN), y)
+EXTRA_CFLAGS  +=   -DPRODUCTNAME_ODIN
+endif
+
+
+ifeq ($(CONFIG_SUSE_KERNEL), y)
+EXTRA_CFLAGS  += -DIS_OPENSUSE_SLED_SLES=1
+else
+EXTRA_CFLAGS	+= -DIS_OPENSUSE_SLED_SLES=0
+endif
+
+EXTRA_CFLAGS  +=  -Wno-unused-variable 
+EXTRA_CFLAGS  += -D__LEGACY_OSSW__=1 -D_OS_LINUX	  
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/mv_cache.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_cache.h
--- linux-3.10.69/drivers/scsi/mv/mv_cache.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_cache.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,143 @@
+#ifndef _CACHE_PARAMETER_FILE_
+#define _CACHE_PARAMETER_FILE_
+/*
+*
+ *  these is used for count related and the number is sector
+ */
+
+#define SECTOR_SHIFT     9
+
+////////////////////////////////////////////////
+#define MAX_PAGES_PER_CU ( 32*4 )
+#define COUNT_PAGE    (512 * 4  )
+#define SHIFT_CNSECTOR_PER_PAGE (3)  //This valu is equal to log2 (COUNT_SECTOR_PER_PAGE)
+
+
+
+#define MIN_CACHE_UNIT	 ( ( 1 << ( K_SHIFT - SECTOR_SHIFT ) )   * 128)   //sector  128k
+#define SHIFT_FACTOR_WIDTH 31
+
+//////////////////////////////////////////////////////////////////////////////
+
+#define COUNT_CU      ((COUNT_PAGE) >> 4 )
+#define COUNT_CACHE_REQUEST  (COUNT_CU << 2)
+#define COUNT_VALIDRANGE (COUNT_CU * 3)
+
+
+#define MAX_CDEVICE_SUPPORT MAX_LD_SUPPORTED_PERFORMANCE
+#define MAX_CTARGET_NUM MV_MAX_TARGET_NUMBER 
+
+
+#define COUNT_SECTOR_LARGE_REQUEST  (512*2)  //in sectors, so the value no is 512k
+
+
+/* dertermine the low and high mark
+*/
+#define CACHE_LOW_MARK_PAGE  ( COUNT_PAGE >> 2)  
+#define CACHE_HIGH_MARK_PAGE (  (COUNT_PAGE >> 2) * 3 )
+
+#define CACHE_LOW_MARK_CU  ( COUNT_CU >> 3 )
+#define CACHE_HIGH_MARK_CU  (COUNT_CU >> 1)
+
+#define CACHE_LOW_MARK_VR  ((COUNT_VALIDRANGE) >> 3)
+#define CACHE_HIGH_MARK_VR   (  COUNT_VALIDRANGE >> 1)
+
+/*this define are used for seq recognize*/
+#define WATERMARK_SERIAL_SEQ 1 
+#define WATERMARK_SERIAL_LOC 8
+
+#define MARK_SMALL_BLOCK 16 //8K
+
+
+/*MAX AND MIN PREREAD LENGTH  */
+#define MAX_PREREAD_LENGTH	1024
+#define MIN_PREREAD_LENGTH	128
+
+
+/*these define are used for release resource config*/
+
+#define RELEASE_LOOP 0xff
+#define RELEASE_COUNT_PER_DEVICE 0xfff
+
+
+#define COUNT_MAXLOGSEQ_PER_DEVICE		20
+#define COUNT_MAXLOGLOC_PER_DEVICE		10
+#define MAX_MISS_COUNT		20
+#define MAX_HIT_COUNT_ADJUST  30
+
+/*
+ * these macros are for time interval adjust
+ */
+#define TIME_INTERVAL_IDLE 2
+#define TIME_INTERVAL_BUSY 2
+
+
+
+
+
+#if 0
+#define CACHE_DBG_INFO(_x_)	do {if (g_cache_print & PRINT_D0) {MV_PRINT("Cache Engine: ");	MV_PRINT _x_; } } while (0)
+#else
+#define CACHE_DBG_INFO(_x_)	
+#if defined(SUPPORT_CHANGE_DEBUG_MODE)
+extern MV_U16 mv_debug_mode;
+#define CACHE_DBGn_INFO(_x_,n)	do {if ((CACHE_DEBUG_INFO & mv_debug_mode) && (g_cache_print & MV_BIT(n))) {MV_PRINT("Cache Engine d"#n":" );	MV_PRINT _x_; } } while (0)
+
+#else
+
+//#define CACHE_DBG_PRINT
+#ifdef CACHE_DBG_PRINT
+#define CACHE_DBGn_INFO(_x_,n)	do {if (g_cache_print & MV_BIT(n)) {MV_PRINT("Cache Engine d"#n":" );	MV_PRINT _x_; } } while (0)
+#else
+#define CACHE_DBGn_INFO(_x_,n)
+#endif
+
+#endif /*SUPPORT_CHANGE_DEBUG_MODE*/
+
+#endif
+#if 0 
+#define C_PRINT MV_PRINT("\n%s %s %d",__FILE__,__FUNCTION__,__LINE__);MV_PRINT
+#else
+#define C_PRINT MV_PRINT
+#endif
+
+/*dertermine system busy?*/
+#define WATER_MARK_BUSY 10
+
+
+/*
+  debug options
+*/
+#ifndef DBG
+#define CACHE_DEBUG_RES 	0
+#define CACHE_DEBUG_PAGE 	0
+#define CACHE_CRC_CHECK		0 /* this should always be 0*/
+#define CACHE_DEBUG_BBU         0
+#undef	CACHE_DEBUG_SEQ
+#else 
+#define CACHE_DEBUG_RES 	1
+#define CACHE_DEBUG_PAGE 	1
+#define CACHE_CRC_CHECK		0  /* this should always be 0*/
+#define CACHE_DEBUG_BBU         1
+#undef	CACHE_DEBUG_SEQ
+#endif
+
+/*template configures
+*/
+//#define  CACHE_BBU_ECC
+
+//feature control
+#define CACHE_DEVICE_LOCK 	0
+#define CACHE_SUPPORT_LOC	0
+#define CACHE_EXTENT_WIDTH_R10  0
+#define CACHE_SUPPORT_SYNC_CMD  1
+#define CACHE_WT_FEATURE	0
+#define CACHE_OP_LOG		0
+
+#if defined(_OS_LINUX)
+#define _XOR_DMA
+#endif
+#endif
+
+
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/mv_config.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_config.h
--- linux-3.10.69/drivers/scsi/mv/mv_config.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_config.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,14 @@
+#if !defined(MV_CONFIGURATION_H)
+#define MV_CONFIGURATION_H
+#ifdef PRODUCTNAME_ODIN
+#include "mv_config_odin.h"
+#elif defined(PRODUCTNAME_VANIR) || defined(PRODUCTNAME_VANIRLITES)
+#include "mv_config_vanir.h"
+#elif defined(SIMULATOR)
+#include "mv_simu.h"
+#elif defined(PRODUCTNAME_THOR)
+#include "mv_config_thor.h"
+#elif defined(PRODUCTNAME_MAGNI)
+#include "mv_config_magni.h"
+#endif /*PRODUCTNAME_ODIN , PRODUCTNAME_THOR*/
+#endif /* MV_CONFIGURATION_H */
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/mv_config_vanir.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_config_vanir.h
--- linux-3.10.69/drivers/scsi/mv/mv_config_vanir.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_config_vanir.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,94 @@
+#ifndef __MV_CONFIG_VANIR_H__
+#define __MV_CONFIG_VANIR_H__
+
+#define VANIR_PRODUCT
+
+/* driver configuration */
+#define mv_driver_name   "mv94xx"
+#define mv_product_name  "VANIR"
+
+/*Driver Version for Command Line Interface Query.*/
+#define VER_MAJOR           4
+#define VER_MINOR        0
+#define VER_OEM        	0
+#ifdef RAID_DRIVER
+#define VER_BUILD        1411
+#define VER_TEST         ""
+#else
+#define VER_BUILD        1543
+#define VER_TEST         "N"
+#endif
+
+#define 	MV_DEBUG	1
+#ifdef MV_DEBUG
+//#define	STRONG_DEBUG	1
+#endif
+
+#ifndef RAID_DRIVER
+#define LINUX_NONRAID
+#define SUPPORT_STAGGERED_SPIN_UP			1
+//#define	SUPPORT_OEM_PROJECT		1	//Enable it only OEM project, generic driver should disable it.
+#ifndef SUPPORT_OEM_PROJECT
+/*Temp disable DIF support. If a DIF type 2 disk is attached the  VARLEN CDB must also be supported*/
+#define		SUPPORT_VARLEN_CDB	1
+#define		SUPPORT_DIF	1
+//#define		USE_OS_TIMEOUT_VALUE 1
+#endif
+#endif
+
+//#define 	SUPPORT_IO_DELAY	1
+//#define	DEBUG_EXPANDER			1
+#ifdef SUPPORT_OEM_PROJECT
+#define	SKIP_INTERNAL_INITIALIZE	1
+#define 	ENABLE_HARD_RESET_EH		1
+#endif
+
+#define SUPPORT_ENHANCED_EH	1
+#ifdef SUPPORT_ENHANCED_EH
+/* This workaround can recovered all disks drop issue with AIC expanders.
+   Temp disable it, if one real bad disk exists, which can't be recoverd,
+   we shouldn't reset all expander port. This will block IO on all devices.*/
+//#define SUPPORT_PORT_RESET_FOR_STP	1
+#endif
+
+#ifndef MV_VMK_ESX35
+#if (!defined(RAID_DRIVER) && !defined(__VMKLNX__))
+#define SUPPORT_MUL_LUN					1
+#endif
+#endif
+
+#define SUPPORT_SG_RESET 1
+
+#define SUPPORT_LUIGI	1
+#ifdef SUPPORT_LUIGI
+#ifndef RAID_DRIVER
+#define USE_OS_TIMEOUT_VALUE	1
+#endif
+#endif
+
+#if defined(PRODUCTNAME_VANIR)
+#include "mv_product_vanir.h"
+#elif defined(PRODUCTNAME_VANIRLITES)
+#include "mv_product_vanirlites.h"
+#endif
+
+#include "mv_hba.h"
+#ifdef RAID_DRIVER
+#include "mv_raid.h"
+#endif
+
+#define SUPPORT_VU_CMD				1
+#ifdef SUPPORT_EXPANDER
+#define ASIC_WORKAROUND_WD_TO_RESET
+#endif
+//#define SWAP_VANIR_PORT_FOR_LENOVO
+#ifndef RAID_DRIVER
+#define FIX_SCSI_ID_WITH_PHY_ID
+#endif
+
+#ifdef FIX_SCSI_ID_WITH_PHY_ID
+	#define PORT_NUMBER 8
+#endif
+#include "mv_linux.h"
+
+#endif/*__MV_CONFIG_VANIR_H__*/
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/mv_conf.mk F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_conf.mk
--- linux-3.10.69/drivers/scsi/mv/mv_conf.mk	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_conf.mk	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,13 @@
+#
+# config file for Makefile and script
+#
+SUPPORT_VANIR=y
+SUPPORT_ODIN=n
+SUPPORT_THOR=n
+SUPPORT_MAGNI=n
+SUPPORT_VANIRLITES=n
+
+RAID_MODULE=n
+RAID6_MODULE=n
+CACHE_MODULE=n
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/mv_hba.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_hba.h
--- linux-3.10.69/drivers/scsi/mv/mv_hba.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_hba.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,54 @@
+/*Macros within this file are OS independently */
+#ifndef __MV_HBA_H__
+#define __MV_HBA_H__
+
+#define NEW_CORE_DRIVER		1
+#define CORE_NO_RECURSIVE_CALL
+#ifndef _OS_LINUX
+#define SUPPORT_MODULE_CONSOLIDATE		1
+#endif
+/* allocate uncached memory multiple times for RAID/Cache module*/
+#ifdef _OS_LINUX
+#define MULTI_UNCACHE_ALLOC
+#endif
+/*open this macro to zero sg entry, command header/table memory
+ * of each sending request, R/W test on SATA disk easily timeout.*/
+#define CORE_ZERO_MEMORY_TEST
+
+#define SUPPORT_TIMER                1
+#define SUPPORT_SMALL_TIMER			1
+#define SUPPORT_EVENT                1
+#define REDUCED_SENSE              1
+#define SUPPORT_SCSI_PASSTHROUGH     1
+#define SUPPORT_PASS_THROUGH_DIRECT	1
+#define REQUEST_TIME_OUT				20		// in multiples of TIMER_INTERVAL, see hba_timer.h
+
+#define MV_MAX_LUN_NUMBER               128
+#ifdef SUPPORT_SCSI_PASSTHROUGH
+#   define SAT_RETURN_FIS_IN_CDB	1
+#   define SUPPORT_VIRTUAL_DEVICE       1
+#if !defined (__VMKLNX__)  && !defined(MV_VMK_ESX35)
+#   define VIRTUAL_DEVICE_ID            (MV_MAX_TARGET_NUMBER - 1)
+#else /*for not use virtual device with vmware*/
+#   define VIRTUAL_DEVICE_ID            MV_MAX_TARGET_NUMBER
+#endif
+#endif /* SUPPORT_SCSI_PASSTHROUGH */
+#define MV_MAX_HD_DEVICE_ID                   		MAX_DEVICE_SUPPORTED_PERFORMANCE
+
+/*
+ * define USE_NEW_SGTABLE to use the new SG format as defined in
+ * "General SG Format" document.
+ */
+#define USE_NEW_SGTABLE
+#ifndef WIN_STORPORT
+#if defined(USE_NEW_SGTABLE) && (defined(SOFTWARE_XOR) || defined(CACHE_MODULE_SUPPORT))
+#define USE_VIRTUAL_PRD_TABLE           1
+#endif
+#endif		/* WIN_STORPORT*/
+
+/* support to use NVSRAM memory to save transaction log */
+#ifdef SUPPORT_TRANSACTION_LOG
+#define SUPPORT_NVSRAM	1
+#endif
+
+#endif /*__MV_HBA_H__*/
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/mv_linux.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_linux.h
--- linux-3.10.69/drivers/scsi/mv/mv_linux.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_linux.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,41 @@
+/*This file defined macro only used by Linux driver.*/
+#ifndef __MV_LINUX_H__
+#define __MV_LINUX_H__
+
+#ifdef MV_DEBUG
+#define SUPPORT_CHANGE_DEBUG_MODE	1
+#endif
+#define SUPPORT_CHANGE_CAN_QUEUE		1
+
+#ifndef MV_VMK_ESX35
+#define SUPPORT_WORKQUEUE       	1
+#ifndef __VMKLNX__
+#define MV_BLK_IOCTL           	 		1
+#define SUPPORT_TASKLET		1
+#endif
+#define USE_REQ_POOL  			1
+#endif
+
+#define CACHE_NAME_LEN 			32
+
+//#define API_GET_ENC_ID
+
+/*dynamic memory alloc for command table and sg entry*/
+#ifndef MV_VMK_ESX35
+#define PCI_POOL_SUPPORT
+#endif
+/*
+ * define USE_NEW_SGTABLE to use the new SG format as defined in
+ * "General SG Format" document.
+ */
+#ifdef USE_NEW_SGTABLE
+#define USE_NEW_SGVP
+#endif /* USE_NEW_SGTABLE */
+
+/*Max ID report to OS: HD+Enclosure+PM+virtual device*/
+#define MV_MAX_ID                                      \
+        (MV_MAX_TARGET_NUMBER + MAX_EXPANDER_SUPPORTED + \
+         MAX_PM_SUPPORTED + 1)/*reserved 1 ID for virtual device ID*/			
+
+#endif /* __MV_LINUX_H__ */
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/mv_os.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_os.c
--- linux-3.10.69/drivers/scsi/mv/mv_os.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_os.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,482 @@
+#include "mv_os.h"
+#include "hba_mod.h"
+
+#if defined(MV_VMK_ESX35) || defined(MV_VMK_ESXI5)
+#define do_div(n,base) ({ \
+	unsigned long __upper, __low, __high, __mod; \
+	asm("":"=a" (__low), "=d" (__high):"A" (n)); \
+	__upper = __high; \
+	if (__high) { \
+	__upper = __high % (base); \
+	__high = __high / (base); \
+	} \
+	asm("divl %2":"=a" (__low), "=d" (__mod):"rm" (base), "0" (__low), "1" (__upper)); \
+	asm("":"=A" (n):"a" (__low),"d" (__high)); \
+	__mod; \
+})
+#endif
+
+
+/* os timer function */
+void ossw_init_timer(struct timer_list *timer)
+{
+	timer->function = NULL;
+	init_timer(timer);
+}
+
+u8 ossw_add_timer(struct timer_list *timer,
+		    u32 msec,
+		    void (*function)(unsigned long),
+		    unsigned long data)
+{
+	u64 jif;
+
+	if(timer_pending(timer))
+		del_timer(timer);
+
+	timer->function = function;
+	timer->data     = data;
+
+	jif = (u64) (msec * HZ);
+#ifdef __VMKLNX__
+	do_div(jif, 100);         /* wait in unit of second */
+#else
+	do_div(jif, 1000);		   /* wait in unit of second */
+#endif
+	timer->expires = jiffies + 1 + jif;
+
+	add_timer(timer);
+	return	0;
+}
+
+
+void ossw_del_timer(struct timer_list *timer)
+{
+	if (timer->function)
+		del_timer(timer);
+	timer->function = NULL;
+}
+
+int ossw_time_expired(unsigned long time_value)
+{
+	return (time_before(time_value, jiffies));
+}
+
+unsigned long ossw_set_expired_time(u32 msec)
+{
+	return (jiffies + msecs_to_jiffies(msec));
+}
+
+/* os spin lock function */
+void  ossw_local_irq_save(unsigned long *flags){ unsigned long save_flag;local_irq_save(save_flag); *flags = save_flag; }
+void ossw_local_irq_restore(unsigned long *flags){unsigned long save_flag = *flags;local_irq_restore(save_flag);}
+void  ossw_local_irq_disable(void){ local_irq_disable();}
+void ossw_local_irq_enable(void){local_irq_enable();}
+/* expect pointers */
+void ossw_init_spin_lock(void *ext)
+{
+	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
+	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
+	spinlock_t *plock = &hba_desc->global_lock;
+	spin_lock_init(plock);
+}
+
+
+void ossw_spin_lock(void *ext)
+{
+	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
+	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
+	spinlock_t *plock = &hba_desc->global_lock;
+	spin_lock(plock);
+}
+
+void ossw_spin_unlock(void *ext)
+{
+	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
+	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
+	spinlock_t *plock = &hba_desc->global_lock;
+	spin_unlock(plock);
+}
+
+void ossw_spin_lock_irq(void *ext)
+{
+	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
+	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
+	spinlock_t *plock = &hba_desc->global_lock;
+	spin_lock_irq(plock);
+}
+
+void ossw_spin_unlock_irq(void *ext)
+{
+	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
+	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
+	spinlock_t *plock = &hba_desc->global_lock;
+	spin_unlock_irq(plock);
+}
+
+void ossw_spin_lock_irq_save(void *ext, unsigned long *flags)
+{
+	unsigned long save_flag;
+	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
+	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
+	spinlock_t *plock = &hba_desc->global_lock;
+	spin_lock_irqsave(plock, save_flag);
+	*flags = save_flag;
+}
+
+void ossw_spin_unlock_irq_restore(void *ext, unsigned long *flags)
+{
+	unsigned long save_flag = *flags;
+	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
+	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
+	spinlock_t *plock = &hba_desc->global_lock;
+	spin_unlock_irqrestore(plock, save_flag);
+}
+
+#ifdef SUPPORT_STAGGERED_SPIN_UP
+void ossw_spin_lock_irq_save_spin_up(void *ext, unsigned long *flags)
+{
+	unsigned long save_flag;
+	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
+	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
+	spinlock_t *plock = &hba_desc->device_spin_up;
+	spin_lock_irqsave(plock, save_flag);
+	*flags = save_flag;
+}
+
+void ossw_spin_unlock_irq_restore_spin_up(void *ext, unsigned long *flags)
+{
+	unsigned long save_flag = *flags;
+	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
+	struct mv_adp_desc *hba_desc = mod_desc->hba_desc;
+	spinlock_t *plock = &hba_desc->device_spin_up;
+	spin_unlock_irqrestore(plock, save_flag);
+}
+#endif
+
+/* os get time function */
+u32 ossw_get_time_in_sec(void)
+{
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+	return (u32) tv.tv_sec;
+}
+
+u32 ossw_get_msec_of_time(void)
+{
+	struct timeval tv;
+
+	do_gettimeofday(&tv);
+	return (u32) tv.tv_usec*1000*1000;
+}
+
+#if !defined(__VMKLNX__) && !defined(MV_VMK_ESX35)
+/*kernel time.h:extern struct timezone sys_tz;*/
+extern struct timezone sys_tz;
+u32 ossw_get_local_time(void)
+{
+	static MV_U32 utc_time=0,local_time=0;
+	utc_time=ossw_get_time_in_sec();
+	local_time = (u32)(utc_time - (sys_tz.tz_minuteswest * 60));
+	return local_time;
+}
+#endif
+
+/* os bit endian function */
+u16 ossw_cpu_to_le16(u16 x)  	{ return cpu_to_le16(x);}
+u32 ossw_cpu_to_le32(u32 x)	{ return cpu_to_le32(x);}
+u64 ossw_cpu_to_le64(u64 x)   	{ return cpu_to_le64(x);}
+u16 ossw_cpu_to_be16(u16 x)      	{ return cpu_to_be16(x);}
+u32 ossw_cpu_to_be32(u32 x)	{ return cpu_to_be32(x);}
+u64 ossw_cpu_to_be64(u64 x)   	{ return cpu_to_be64(x);}
+
+u16 ossw_le16_to_cpu(u16 x)      	{ return le16_to_cpu(x);}
+u32 ossw_le32_to_cpu(u32 x)      	{ return le32_to_cpu(x);}
+u64 ossw_le64_to_cpu(u64 x)      	{ return le64_to_cpu(x);}
+u16 ossw_be16_to_cpu(u16 x)      	{ return be16_to_cpu(x);}
+u32 ossw_be32_to_cpu(u32 x)      	{ return be32_to_cpu(x);}
+u64 ossw_be64_to_cpu(u64 x)      	{ return be64_to_cpu(x);}
+
+/* os map sg address function */
+void *ossw_kmap(void  *sg)
+{
+#if !defined(CONFIG_ARM) && !defined(MV_VMK_ESXI5)
+	struct scatterlist *ksg = (struct scatterlist *)sg;
+	void *kvaddr = NULL;
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+	kvaddr = page_address(ksg->page);
+	if (!kvaddr)
+#endif
+		kvaddr = map_sg_page(ksg);
+	kvaddr += ksg->offset;
+	return kvaddr;
+#else
+	BUG_ON(1);
+#endif	
+}
+
+void ossw_kunmap(void  *sg, void *mapped_addr)
+{
+#if !defined(CONFIG_ARM) && !defined(MV_VMK_ESXI5)
+	struct scatterlist *ksg = (struct scatterlist *)sg;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+	void *kvaddr = NULL;
+	kvaddr = page_address(ksg->page);
+	if (!kvaddr)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	kunmap_atomic(mapped_addr - ksg->offset);
+#else
+	kunmap_atomic(mapped_addr - ksg->offset, KM_IRQ0);
+#endif
+
+#else
+	BUG_ON(1);
+#endif
+}
+
+void *ossw_kmap_sec(void  *sg)
+{
+#if !defined(CONFIG_ARM) && !defined(MV_VMK_ESXI5)
+	struct scatterlist *ksg = (struct scatterlist *)sg;
+	void *kvaddr = NULL;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+	kvaddr = page_address(ksg->page);
+	if (!kvaddr)
+#endif
+		kvaddr = map_sg_page_sec(ksg);
+	kvaddr += ksg->offset;
+	return kvaddr;
+#else
+	BUG_ON(1);
+#endif
+}
+
+void ossw_kunmap_sec(void  *sg, void *mapped_addr)
+{
+#if !defined(CONFIG_ARM) && !defined(MV_VMK_ESXI5)
+	struct scatterlist *ksg = (struct scatterlist *)sg;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+	void *kvaddr = NULL;
+	kvaddr = page_address(ksg->page);
+	if (!kvaddr)
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+	kunmap_atomic(mapped_addr - ksg->offset);
+#else
+	kunmap_atomic(mapped_addr - ksg->offset, KM_IRQ1);
+#endif
+
+#else
+	BUG_ON(1);
+#endif
+}
+
+
+#ifndef MV_VMK_ESX35
+struct pci_pool *ossw_pci_pool_create( char *name, void *ext ,
+	size_t size, size_t align, size_t alloc)
+{
+
+	struct pci_dev *dev;
+	struct mv_mod_desc *mod_desc = __ext_to_gen(ext)->desc;
+	MV_DASSERT(mod_desc);
+	dev = mod_desc->hba_desc->dev;
+	sprintf(name,"%s%d",name,mod_desc->hba_desc->id);
+	return pci_pool_create(name, dev, size, align, alloc);
+}
+
+void ossw_pci_pool_destroy(struct pci_pool * pool)
+{
+	pci_pool_destroy(pool);
+}
+
+void *ossw_pci_pool_alloc(struct pci_pool *pool, u64 *dma_handle)
+{
+	return pci_pool_alloc(pool, GFP_ATOMIC, (dma_addr_t *)dma_handle);
+}
+
+void ossw_pci_pool_free(struct pci_pool *pool, void *vaddr, u64 addr)
+{
+	pci_pool_free(pool, vaddr, addr);
+}
+
+void * ossw_kmem_cache_create(const char *name, size_t size,
+		size_t align, unsigned long flags)
+{
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22))
+	return (void *)kmem_cache_create(name, size, align, flags, NULL);
+#else
+	return (void *)kmem_cache_create(name, size, align, flags, NULL, NULL);
+#endif
+}
+
+void * ossw_kmem_cache_alloc( void * cachep, u32 flags)
+{
+	kmem_cache_t  *cache = (kmem_cache_t *)cachep;
+#ifndef  __VMKLNX__
+	return kmem_cache_alloc(cache, (gfp_t)flags);
+#else
+	return kmem_cache_alloc(cache, flags);
+#endif
+}
+
+void ossw_kmem_cache_free(void *cachep, void *objp)
+{
+	kmem_cache_t  *cache = (kmem_cache_t *)cachep;
+	kmem_cache_free(cache, objp);
+}
+
+void ossw_kmem_cache_distroy(void *cachep)
+{
+	kmem_cache_t  *cache = (kmem_cache_t *)cachep;
+	kmem_cache_destroy(cache);
+}
+
+unsigned long ossw_virt_to_phys(void *address)
+{
+ 	return virt_to_phys(address);
+}
+
+void * ossw_phys_to_virt(unsigned long address)
+{
+	return phys_to_virt(address);
+}
+
+#endif
+
+/* os u64 div function */
+u64 ossw_u64_div(u64 n, u64 base)
+{
+	do_div(n, (unsigned int)base);
+	return n;
+}
+
+u64 ossw_u64_mod(u64 n, u64 base)
+{
+	return do_div(n, (unsigned int)base);
+}
+
+
+/* bit operation */
+u32 ossw_rotr32(u32 v, int count)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
+	return ror32(v, count);
+#else
+	return (v << count) | (v >> (32 - count));
+#endif
+}
+
+ /*ffs - normally return from 1 to MSB, if not find set bit, return 0*/
+int ossw_ffz(unsigned long v)	{return (ffs(~v)-1);}
+int ossw_ffs(unsigned long v)	{return (ffs(v)-1);}
+
+void *ossw_memcpy(void *dest, const void *source, size_t len) { return memcpy(dest, source, len);}
+void *ossw_memset(void *buf, int pattern, size_t len) {return memset(buf, pattern, len);}
+int ossw_memcmp(const void *buf0, const void *buf1, size_t len) {return memcmp(buf0, buf1, len); }
+
+
+/* os read pci config function */
+int MV_PCI_READ_CONFIG_DWORD(void * ext, u32 offset, u32 *ptr)	{return pci_read_config_dword(__ext_to_gen(ext)->desc->hba_desc->dev, offset, ptr);}
+int MV_PCI_READ_CONFIG_WORD(void * ext, u32 offset, u16 *ptr)	{return pci_read_config_word(__ext_to_gen(ext)->desc->hba_desc->dev, offset, ptr);}
+int MV_PCI_READ_CONFIG_BYTE(void * ext, u32 offset, u8 *ptr) 		{return  pci_read_config_byte(__ext_to_gen(ext)->desc->hba_desc->dev, offset, ptr);}
+int MV_PCI_WRITE_CONFIG_DWORD(void *ext, u32 offset, u32 val)	{return  pci_write_config_dword(__ext_to_gen(ext)->desc->hba_desc->dev, offset, val);}
+int MV_PCI_WRITE_CONFIG_WORD(void *ext, u32 offset, u16 val) 	{return pci_write_config_word(__ext_to_gen(ext)->desc->hba_desc->dev, offset, val);}
+int MV_PCI_WRITE_CONFIG_BYTE(void *ext, u32 offset, u8 val)		{return pci_write_config_byte(__ext_to_gen(ext)->desc->hba_desc->dev, offset, val);}
+
+/* System dependent macro for flushing CPU write cache */
+void MV_CPU_WRITE_BUFFER_FLUSH(void) 	{smp_wmb();}
+void MV_CPU_READ_BUFFER_FLUSH(void)  	{smp_rmb();}
+void MV_CPU_BUFFER_FLUSH(void)       			{smp_mb();}
+
+/* register read write: memory io */
+void MV_REG_WRITE_BYTE(void *base, u32 offset, u8 val)		{writeb(val, base + offset);}
+void MV_REG_WRITE_WORD(void *base, u32 offset, u16 val)	{writew(val, base + offset);}
+void MV_REG_WRITE_DWORD(void *base, u32 offset, u32 val)   {writel(val, base + offset);}
+
+u8 		MV_REG_READ_BYTE(void *base, u32 offset)			{return readb(base + offset);}
+u16 		MV_REG_READ_WORD(void *base, u32 offset)			{return readw(base + offset);}
+u32 		MV_REG_READ_DWORD(void *base, u32 offset)		{return readl(base + offset);}
+
+/* register read write: port io */
+void	MV_IO_WRITE_BYTE(void *base, u32 offset, u8 val)	{outb(val, (unsigned)(MV_PTR_INTEGER)(base + offset));}
+void MV_IO_WRITE_WORD(void *base, u32 offset, u16 val)    {outw(val, (unsigned)(MV_PTR_INTEGER)(base + offset));}
+void MV_IO_WRITE_DWORD(void *base, u32 offset, u32 val)    {outl(val, (unsigned)(MV_PTR_INTEGER)(base + offset));}
+
+u8	MV_IO_READ_BYTE(void *base, u32 offset)	{return inb((unsigned)(MV_PTR_INTEGER)(base + offset));}
+u16	MV_IO_READ_WORD(void *base, u32 offset)	{return inw((unsigned)(MV_PTR_INTEGER)(base + offset));}
+u32 	MV_IO_READ_DWORD(void *base, u32 offset)	{return inl((unsigned)(MV_PTR_INTEGER)(base + offset));}
+
+
+/* os print function */
+int  ossw_printk(char *fmt, ...)
+{
+#ifdef __VMK_LNX__
+        printk(fmt, ...);
+#else
+	va_list args;
+	static char buf[1024];
+
+	va_start(args, fmt);
+	vsnprintf(buf, sizeof(buf), fmt, args);
+	va_end(args);
+	return printk("%s",  buf);
+#endif
+}
+
+#ifdef MV_DEBUG
+#ifdef _SUPPORT_64_BIT
+void MV_DUMP_SP(void)
+{
+#ifndef __VMKLNX__
+	printk("THREAD_SIZE= %d,PID =%d.\n", (unsigned int)THREAD_SIZE,(unsigned int)current->tgid);
+	dump_stack();
+#endif
+}
+
+#else
+void MV_DUMP_SP(void )
+{
+#ifndef __VMKLNX__
+	unsigned long sp;
+#ifdef CONFIG_X86
+	__asm__ __volatile__("andl %%esp,%0" :"=r" (sp) : "0" (THREAD_SIZE - 1));
+	printk("SP = %ld ,THREAD_SIZE= %d,PID =%d.\n",sp, (unsigned int)THREAD_SIZE,(unsigned int)current->tgid);
+#elif defined(CONFIG_PPC)
+	__asm__ __volatile__("mr %0, 1":"=r"(sp));
+	printk("SP = %ld ,THREAD_SIZE= %d,PID =%d.\n",sp, (unsigned int)THREAD_SIZE,(unsigned int)current->tgid);
+#elif defined(CONFIG_ARM)
+
+#else
+#error "Please add the corresponding stack retrieval info."
+#endif
+	dump_stack();
+#endif
+}
+#endif
+
+
+/* Sleeping is disallowed if any of these macroes evalute as true*/
+void MV_DUMP_CTX(void)
+{
+#if !defined(__VMKLNX__) && !defined(MV_VMK_ESX35)
+	if( in_irq())
+		printk("Present process is in hard IRQ context.\n");
+	if(in_softirq())
+		printk("Present process is in soft IRQ(BH) context.\n");
+	if( in_interrupt())
+		 printk("Present process is in hard/soft IRQ context.\n");
+	if(in_atomic())
+		 printk("Present process is  in preemption-disabled context .\n");
+#endif
+}
+
+#endif	//#ifdef MV_DEBUG
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/mv_os.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_os.h
--- linux-3.10.69/drivers/scsi/mv/mv_os.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_os.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,338 @@
+#ifndef __LINUX_OS_H__
+#define __LINUX_OS_H__
+
+#ifndef LINUX_VERSION_CODE
+#   include <linux/version.h>
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)) && (!defined AUTOCONF_INCLUDED)
+#   include <linux/config.h>
+#endif
+
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/time.h>
+#include <linux/reboot.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/cdev.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+#include <linux/completion.h>
+#include <linux/blkdev.h>
+#include <linux/vmalloc.h>
+#include <linux/kthread.h>
+
+#ifdef MV_VMK_ESX35
+#include <linux/libata-compat.h>
+#endif
+
+#ifndef __VMKLNX__
+#include <linux/device.h>
+#include <linux/nmi.h>
+#endif
+
+#include <linux/slab.h>
+#include <linux/mempool.h>
+#include <linux/ctype.h>
+#include "linux/hdreg.h"
+
+#if !defined(__VMKLNX__) || defined(MV_VMK_ESXI5)
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/div64.h>
+#else
+#include <asm-x86_64/uaccess.h>
+#include <asm-x86_64/io.h>
+#include <asm-x86_64/div64.h>
+#endif
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsi_transport.h>
+#include <scsi/scsi_ioctl.h>
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,9)
+#include <scsi/scsi_request.h>
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,19)
+#include <linux/freezer.h>
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+	#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,6))
+	#include <linux/moduleparam.h>
+	#endif
+#endif /* LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 7) */
+
+/* OS specific flags */
+
+
+#ifndef NULL
+#   define NULL 0
+#endif
+#ifndef  MV_VMK_ESX35
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+#define PCI_D0 0
+#include <linux/suspend.h>
+typedef u32 pm_message_t;
+
+static inline int try_to_freeze(unsigned long refrigerator_flags)
+{
+        if (unlikely(current->flags & PF_FREEZE)) {
+               refrigerator(refrigerator_flags);
+                return 1;
+        } else
+             return 0;
+}
+#endif
+#endif
+
+#define MV_INLINE inline
+#define CDB_INQUIRY_EVPD    1 //TBD
+
+
+
+/* If VER_BUILD ,the 4th bit is 0 */
+#if (VER_BUILD < 1000)
+#define NUM_TO_STRING(num1, num2, num3, num4) # num1"."# num2"."# num3".""0"# num4
+#else
+#define NUM_TO_STRING(num1, num2, num3, num4) # num1"."# num2"."# num3"."# num4
+#endif
+#define VER_VAR_TO_STRING(major, minor, oem, build) NUM_TO_STRING(major, \
+								  minor, \
+								  oem,   \
+								  build)
+
+#define mv_version_linux   VER_VAR_TO_STRING(VER_MAJOR, VER_MINOR,       \
+					     VER_OEM, VER_BUILD) VER_TEST
+
+#ifndef TRUE
+#define TRUE 	1
+#define FALSE	0
+#endif
+
+#ifdef CONFIG_64BIT
+#   define __KCONF_64BIT__
+#endif /* CONFIG_64BIT */
+
+#if defined(__LITTLE_ENDIAN)
+#   define __MV_LITTLE_ENDIAN__  1
+#elif defined(__BIG_ENDIAN)
+#   define __MV_BIG_ENDIAN__     1
+#else
+#   error "error in endianness"
+#endif
+
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+#   define __MV_LITTLE_ENDIAN_BITFIELD__   1
+#elif defined(__BIG_ENDIAN_BITFIELD)
+#   define __MV_BIG_ENDIAN_BITFIELD__      1
+#else
+#   error "error in endianness"
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 25)
+#define mv_use_sg(cmd)	cmd->use_sg
+#define mv_rq_bf(cmd)	cmd->request_buffer
+#define mv_rq_bf_l(cmd)	cmd->request_bufflen
+#else
+#define mv_use_sg(cmd)	scsi_sg_count(cmd)
+#define mv_rq_bf(cmd)	scsi_sglist(cmd)
+#define mv_rq_bf_l(cmd)	scsi_bufflen(cmd)
+#endif
+#if defined(SUPPORT_DIX) && (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27))
+#define mv_prot_use_sg(cmd)	scsi_prot_sg_count(cmd)
+#define mv_prot_bf(cmd)		scsi_prot_sglist(cmd)
+#define mv_prot_bf_l(cmd)	((scsi_bufflen(cmd)/512)*8)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 24)
+#define map_sg_page(sg)		kmap_atomic(sg->page, KM_IRQ0)
+#define map_sg_page_sec(sg)		kmap_atomic(sg->page, KM_IRQ1)
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3, 4, 0)
+#define map_sg_page(sg)		kmap_atomic(sg_page(sg))
+#define map_sg_page_sec(sg)		kmap_atomic(sg_page(sg))
+#else
+#define map_sg_page(sg)		kmap_atomic(sg_page(sg), KM_IRQ0)
+#define map_sg_page_sec(sg)		kmap_atomic(sg_page(sg), KM_IRQ1)
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 23)
+#define mv_set_resid(cmd, len)    do{ cmd->resid = len; } while(0)
+#else
+#define mv_set_resid(cmd, len)    scsi_set_resid(cmd, len)
+#endif
+
+struct gen_module_desc {
+/* Must the first */
+	struct mv_mod_desc *desc;
+};
+#define __ext_to_gen(_ext)       ((struct gen_module_desc *) (_ext))
+
+
+/* os timer function */
+void ossw_init_timer(struct timer_list *timer);
+u8 ossw_add_timer(struct timer_list *timer,
+		    u32 msec,
+		    void (*function)(unsigned long),
+		    unsigned long data);
+void ossw_del_timer(struct timer_list *timer);
+
+int ossw_time_expired(unsigned long time_value);
+unsigned long ossw_set_expired_time(u32 msec);
+
+/* os spin lock function */
+void  ossw_local_irq_save(unsigned long *flags);
+void ossw_local_irq_restore(unsigned long *flags);
+void  ossw_local_irq_disable(void);
+void ossw_local_irq_enable(void);
+
+/* expect pointers */
+void ossw_init_spin_lock(void *ext);
+void ossw_spin_lock(void *ext);
+void ossw_spin_unlock(void *ext);
+void ossw_spin_lock_irq(void *ext);
+void ossw_spin_unlock_irq(void *ext);
+void ossw_spin_lock_irq_save(void *ext, unsigned long *flags);
+void ossw_spin_unlock_irq_restore(void *ext, unsigned long *flags);
+#ifdef SUPPORT_STAGGERED_SPIN_UP
+void ossw_spin_lock_irq_save_spin_up(void *ext, unsigned long *flags);
+void ossw_spin_unlock_irq_restore_spin_up(void *ext, unsigned long *flags);
+#endif
+
+
+/* os get time function */
+u32 ossw_get_time_in_sec(void);
+u32 ossw_get_msec_of_time(void);
+u32 ossw_get_local_time(void);
+
+/* os kmem_cache */
+#define MV_ATOMIC GFP_ATOMIC
+
+struct pci_pool *ossw_pci_pool_create(char *name, void *ext,
+	size_t size, size_t align, size_t alloc);
+void ossw_pci_pool_destroy(struct pci_pool * pool);
+void *ossw_pci_pool_alloc(struct pci_pool *pool, u64 *dma_handle);
+void ossw_pci_pool_free(struct pci_pool *pool, void *vaddr, u64 addr);
+
+
+void * ossw_kmem_cache_create(const char *, size_t, size_t, unsigned long);
+void * ossw_kmem_cache_alloc( void *, unsigned);
+void ossw_kmem_cache_free(void *, void *);
+void ossw_kmem_cache_distroy(void *);
+
+unsigned long ossw_virt_to_phys(void *);
+void * ossw_phys_to_virt(unsigned long address);
+
+
+/* os bit endian function */
+u16 ossw_cpu_to_le16(u16 x);
+u32 ossw_cpu_to_le32(u32 x);
+u64 ossw_cpu_to_le64(u64 x);
+u16 ossw_cpu_to_be16(u16 x);
+u32 ossw_cpu_to_be32(u32 x);
+u64 ossw_cpu_to_be64(u64 x);
+
+u16 ossw_le16_to_cpu(u16 x);
+u32 ossw_le32_to_cpu(u32 x);
+u64 ossw_le64_to_cpu(u64 x) ;
+u16 ossw_be16_to_cpu(u16 x);
+u32 ossw_be32_to_cpu(u32 x);
+u64 ossw_be64_to_cpu(u64 x) ;
+
+/* os map sg address function */
+void *ossw_kmap(void  *sg);
+void ossw_kunmap(void  *sg, void *mapped_addr);
+void *ossw_kmap_sec(void  *sg);
+void ossw_kunmap_sec(void  *sg, void *mapped_addr);
+
+/* MISC Services */
+#define ossw_udelay(x) udelay(x)
+
+/* os u64 div function */
+u64 ossw_u64_div(u64 n, u64 base);
+u64 ossw_u64_mod(u64 n, u64 base);
+
+
+/* bit operation */
+u32 ossw_rotr32(u32 v, int count);
+
+int ossw_ffz(unsigned long v);
+int ossw_ffs(unsigned long v);
+
+void *ossw_memcpy(void *dest, const void *source, size_t len) ;
+void *ossw_memset(void *buf, int patten, size_t len) ;
+int ossw_memcmp(const void *buf0, const void *buf1, size_t len) ;
+
+/* os read pci config function */
+int MV_PCI_READ_CONFIG_DWORD(void * ext, u32 offset, u32 *ptr);
+int MV_PCI_READ_CONFIG_WORD(void * ext, u32 offset, u16 *ptr);
+int MV_PCI_READ_CONFIG_BYTE(void * ext, u32 offset, u8 *ptr);
+int MV_PCI_WRITE_CONFIG_DWORD(void *ext, u32 offset, u32 val);
+int MV_PCI_WRITE_CONFIG_WORD(void *ext, u32 offset, u16 val);
+int MV_PCI_WRITE_CONFIG_BYTE(void *ext, u32 offset, u8 val);
+
+/* System dependent macro for flushing CPU write cache */
+void MV_CPU_WRITE_BUFFER_FLUSH(void);
+void MV_CPU_READ_BUFFER_FLUSH(void);
+void MV_CPU_BUFFER_FLUSH(void);
+
+/* register read write: memory io */
+void MV_REG_WRITE_BYTE(void *base, u32 offset, u8 val);
+void MV_REG_WRITE_WORD(void *base, u32 offset, u16 val);
+void MV_REG_WRITE_DWORD(void *base, u32 offset, u32 val);
+
+u8 		MV_REG_READ_BYTE(void *base, u32 offset);
+u16 		MV_REG_READ_WORD(void *base, u32 offset)	;
+u32 		MV_REG_READ_DWORD(void *base, u32 offset);
+
+/* register read write: port io */
+void	MV_IO_WRITE_BYTE(void *base, u32 offset, u8 val);
+void MV_IO_WRITE_WORD(void *base, u32 offset, u16 val) ;
+void MV_IO_WRITE_DWORD(void *base, u32 offset, u32 val) ;
+
+u8	MV_IO_READ_BYTE(void *base, u32 offset);
+u16	MV_IO_READ_WORD(void *base, u32 offset);
+u32 	MV_IO_READ_DWORD(void *base, u32 offset);
+
+
+/* os print function */
+int  ossw_printk(char *fmt, ...);
+
+#ifdef MV_DEBUG
+void MV_DUMP_SP(void);
+/* Sleeping is disallowed if any of these macroes evalute as true*/
+void MV_DUMP_CTX(void);
+#else
+#define MV_DUMP_SP()	do{}while(0)
+#define MV_DUMP_CTX()	do{}while(0)
+#endif	//#ifdef MV_DEBUG
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 18)
+#ifdef _SUPPORT_64_BIT
+	typedef u64 resource_size_t;
+ #else
+	typedef u32 resource_size_t;
+#endif
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 23)
+typedef struct kmem_cache kmem_cache_t;
+#endif
+
+#endif /* LINUX_OS_H */
+
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/mv_product_vanir.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_product_vanir.h
--- linux-3.10.69/drivers/scsi/mv/mv_product_vanir.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_product_vanir.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,150 @@
+#ifndef __MV_PRODUCT_VANIR_H__
+#define __MV_PRODUCT_VANIR_H__
+
+/*hardware related*/
+#define ODIN_DRIVER                      1
+#define SUPPORT_BALDUR			1
+#define RUN_AS_PCIE_DRIVER
+#define SUPPORT_6G_PHYRATE	1
+
+/*Work around for hardware*/
+#ifdef SUPPORT_BALDUR
+	#define HOTPLUG_BYTE_COUNT_ERROR_WORKAROUND
+	#define TRASH_BUCKET_SIZE 0x400 //1k
+	#define NOT_SPINUP_WORKAROUND
+//        #define XOR_PI_TABLE                    1
+//        #define PRD_DATA_SKIP                   1
+//        #define DDR_MEM_SUPPORT                 1
+        #define XOR_COALESCE_INT                1
+        #define CORE_WIDEPORT_LOAD_BALACE_WORKAROUND
+	//#define	DEBUG_PCI_E_ERROR
+
+	/*prepare and reserve slot0 buffer before phy enabled for 
+	 *first unassociated data fis transfer. Enable only for Brainaire.(#4885)*/
+//	#define COLD_BOOT_DMA_HANG_WORKAROUND
+#endif
+
+/*Software workaround and new features*/
+#define I2C_NAK20_WORKAROUND			1
+#ifndef SUPPORT_MUL_LUN
+#define CORE_SCSI_ID_MAP_FOR_NONE_RAID  	1
+#endif
+//#define SUPPORT_MULTIPATH				1
+#ifndef SKIP_INTERNAL_INITIALIZE
+#define CORE_SUPPORT_LARGE_REQUEST
+#endif
+#define CORE_SUPPORT_HBA_PAGE
+#define SUPPORT_READ_LOG_EXT
+#ifndef RAID_DRIVER
+#define HAVE_HW_COMPLIANT_SG
+#endif
+
+/*product based raid/xor feature*/
+#ifdef RAID_DRIVER
+#define SUPPORT_RAID1E                  1
+#define HARDWARE_XOR
+#ifndef SOFTWARE_XOR
+//        #define XOR_LOAD_BALANCE                1
+#define XOR_USE_SG_PTR                  1
+#endif
+/*XOR*/
+//#define XOR_LOKI_MISSED_ISR_WORKAROUND          1
+//#define LOKI_MISSED_ISR_WORKAROUND              1
+//#define CORE_FORCED_ISR_WORKAROUND              1
+#endif
+
+/* driver capabilities */
+#define MAX_BASE_ADDRESS                6
+#ifdef CORE_SUPPORT_LARGE_REQUEST
+#ifdef RAID_DRIVER
+#define MV_MAX_TRANSFER_SIZE            256*1024 /*can't be larger than 512k*/
+#else
+#define MV_MAX_TRANSFER_SIZE            4*1024*1024
+#endif
+#define MAX_SG_ENTRY                    130
+#else
+#define MV_MAX_TRANSFER_SIZE            (128*1024)
+#define MAX_SG_ENTRY                    34
+#endif
+#define MAX_SG_ENTRY_REDUCED            16
+#define MV_MAX_PHYSICAL_BREAK           (MAX_SG_ENTRY - 1)
+
+#if (defined(WIN_NONRAID) || defined(LINUX_NONRAID))
+#define MAX_REQUEST_NUMBER_PERFORMANCE	    4096
+#ifndef SUPPORT_OEM_PROJECT
+#define MAX_REQUEST_PER_LUN_PERFORMANCE		128 // set 128, sometimes SAS disk will task full, if performance ok, can try 64. TBD.
+#else
+#define MAX_REQUEST_PER_LUN_PERFORMANCE		8 // when supporting max 1024 drives. 
+#endif
+
+#else
+#define MAX_REQUEST_NUMBER_PERFORMANCE	     1024
+#endif
+#ifdef SUPPORT_OEM_PROJECT
+#define MV_MAX_TARGET_NUMBER            1024
+#define MAX_EXPANDER_SUPPORTED		      20
+#else
+#define MV_MAX_TARGET_NUMBER            128
+#define MAX_EXPANDER_SUPPORTED		      10
+#endif
+
+/* hardware capabilities */
+#define MAX_PM_SUPPORTED                      8
+#define MAX_BLOCK_PER_HD_SUPPORTED            8
+#define MAX_DEVICE_SUPPORTED_WHQL             8
+#define MAX_DEVICE_SUPPORTED_PERFORMANCE      MV_MAX_TARGET_NUMBER
+#define MAX_DEVICE_SUPPORTED_RAID             64
+
+/*
+define for Flash operation
+*/
+#define SUPPORT_FLASH_ROM	1
+/*support flash update command in core_api*/
+#define SUPPORT_FLASH        1
+#ifdef SUPPORT_FLASH_ROM
+        #define SUPPORT_RMW_FLASH       1
+	#define SUPPORT_BOARD_ALARM		1
+#endif
+
+
+/* for PD Page support */
+#ifdef RAID_DRIVER
+#ifndef SCSI_ID_MAP
+#define SUPPORT_PD_PAGE					1
+#endif
+#ifdef SUPPORT_PD_PAGE
+	#define SUPPORT_KEEP_SCSI_ID		1
+#endif
+#endif	
+
+/* for PD Write Cache Setting saved in Flash (PD Page) */
+#define SUPPORT_SAVE_CACHE_IN_FLASH	1
+//#define SUPPORT_ERASE_PD_PAGE			1
+//#define    SUPPORT_CONFIG_FILE                 1
+//#define EXP_ABORT_REQ_DURING_BROADCAST	1
+
+#ifndef _OS_LINUX
+#ifdef RAID_DRIVER
+/*support NVSRAM memory to save transaction log*/
+#define SUPPORT_TRANSACTION_LOG			1
+#endif
+
+#else
+#define	DISABLE_VSR_IRQ_PHY_TIMEOUT				1
+#endif
+
+//#define SUPPORT_I2C                     1
+#define SUPPORT_SES                     1
+#ifndef SKIP_INTERNAL_INITIALIZE
+#define SUPPORT_SGPIO					1
+#endif
+#ifdef SUPPORT_SGPIO
+#define SUPPORT_SGPIO_DATA_IN			1
+#define SUPPORT_SGPIO_ACTIVE_LED		1
+#endif
+//#define SUPPORT_CSMI                    1
+#if defined(SUPPORT_I2C)&&defined(SUPPORT_SES)
+#define SUPPORT_I2C_SES					1
+#endif
+
+#endif/*__MV_PRODUCT_VANIR_H__*/
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/mv_raid.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_raid.h
--- linux-3.10.69/drivers/scsi/mv/mv_raid.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/mv_raid.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,119 @@
+#ifndef __MV_RAID_H__
+#define __MV_RAID_H__
+
+#   define BGA_SUPPORT                     1
+//#   define SUPPORT_MP					   1
+#   define SUPPORT_FREE_POLICY             1
+//#   define SUPPORT_SRL                     1
+//#   define SUPPORT_MIGRATION               1
+//#   define SUPPORT_RAID_LEVEL_RAID6        1
+#   define SUPPORT_DUAL_DDF                0
+//#   define SUPPORT_RAID6                   1	/* defined in makefile*/
+#      ifdef SUPPORT_RAID6
+#         define USE_MATH_LIBARY           1
+#         define SUPPORT_READ_MODIFY_WRITE 1
+#         define RAID_USE_64K_SU           1
+#         define RAID5_FAST_REBUILD
+#ifndef SOFTWARE_XOR
+#         define RAID6_MULTIPLE_PARITY		/* new feature */
+#         define RAID6_HARDWARE_XOR
+#endif
+#      endif /* SUPPORT_RAID6 */
+#   define MV_MIGRATION_RESERVED_SPACE_V1  2048
+#   define MV_MIGRATION_RESERVED_SPACE_V2  32768 //16MB	// SECTORS
+#   define MV_MIGRATION_SHIFT_SPACE        2048  //1MB	// SECTORS
+#   define PERFORMANCE_WHQL_SWITCH
+
+
+/* New features in RAID  */
+#ifndef SOFTWARE_XOR
+#   define USE_NEW_GF_TABLE				1
+#   define USE_NEW_RAID_MATRIX			1       //Note: NEW_RAID_MATRIX must be used with NEW_GF_TABLE
+#endif
+
+//#   define _FOREGROUND_INIT				1
+//#   define NEW_MEM_ALLOC			1
+//#   define SUPPORT_DISK_GRP			1
+#ifdef SUPPORT_DISK_GRP
+//#   define SUPPORT_PD_PATH			1
+//#   define _BGA_COPY_BACK			1
+/* support backward compatibility (odin to loki)*/
+//#define SUPPORT_BACKWARD_COMPATIBLE	1
+#ifdef SUPPORT_BACKWARD_COMPATIBLE
+#define SUPPORT_IMPORT					1
+#endif /* SUPPORT_BACKWARD_COMPATIBLE */
+#endif	/* SUPPORT_DISK_GRP */
+
+#if defined(SUPPORT_RAID6)
+#ifndef SUPPORT_DEDICATED_SPARE
+#define SUPPORT_DEDICATED_SPARE
+#endif
+//#   define SUPPORT_REBUILD_WITH_MULTI_SPARE		1
+
+#   define SUPPORT_RAID_MP			1
+#endif /*SUPPORT_RAID6*/
+
+/* for Spin Down Disks */
+//#   define START_SAS_IF_STOPPED				1
+#define	RAID_SPIN_DOWN_ALL_PD			1
+
+#ifdef _BGA_COPY_BACK
+	#if !defined(SUPPORT_PD_PATH) || (SUPPORT_PD_PATH==0)
+		#error "Must define SUPPORT_PD_PATH for CopyBack."
+	#endif
+#endif
+
+#	define ALLOCATE_SENSE_BUFFER		1
+#	define RAID_ERROR_HANDLING		1	/* New RAID module error handling implementation */
+
+#ifdef RAID_ERROR_HANDLING
+	#if !defined(ALLOCATE_SENSE_BUFFER) || (ALLOCATE_SENSE_BUFFER==0)
+		#error "Must allocate sense buffer!"
+	#endif
+	#define ERROR_HANDLING_SUPPORT	1	/* DDF related code is still using old implemention */
+	#ifdef NEW_MEM_ALLOC
+		#error "RAID_ERROR_HANDLING doesn't support NEW_MEM_ALLOC yet."
+	#endif
+	#define SUPPORT_DO_TEST			1	/* dbg APIs */
+	#define MEDIA_DEFECT_FIXING		1	/* Fix the media defect found */
+#else
+	#define ERROR_HANDLING_SUPPORT	0	/* DDF related code is still using old implemention */
+
+#endif
+
+/* Cache */
+#ifndef _OS_LINUX /*linux define it within config file*/
+#ifndef HAVE_PRD_SKIP
+#   define CACHE_MODULE_SUPPORT
+#endif
+#ifdef CACHE_MODULE_SUPPORT
+#   define NEW_CACHE_SUPPORT
+#endif
+#endif
+//#	define CACHE_FREE_DISK_ENABLE          1
+#	ifndef USE_NEW_SGTABLE
+#		define SUPPORT_VIRTUAL_AND_PHYSICAL_SG
+#	endif
+
+#if defined(SUPPORT_RAID6)
+#define MULTIPLE_BGA_RATE					1
+#endif /*SUPPORT_RAID6*/
+
+#ifdef SUPPORT_DISK_GRP
+	#define MAX_LD_SUPPORTED_PERFORMANCE          64
+    #ifdef BLK_NUMBER_CHANGE
+	#define MAX_BLOCK_SUPPORTED_PERFORMANCE       1024
+    #else
+	#define MAX_BLOCK_SUPPORTED_PERFORMANCE       240
+    #endif
+#else
+	#define MAX_LD_SUPPORTED_PERFORMANCE          8
+	#define MAX_BLOCK_SUPPORTED_PERFORMANCE       128
+#endif
+
+#ifdef CACHE_MODULE_SUPPORT
+	#include "mv_cache.h"
+#endif
+
+#endif /* __MV_RAID_H__ */
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/patch.kbuild F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/patch.kbuild
--- linux-3.10.69/drivers/scsi/mv/patch.kbuild	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/patch.kbuild	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,10 @@
+--- scsi/Makefile	2009-10-15 23:03:27.153059900 -0400
++++ scsi_new/Makefile	2009-10-15 23:11:29.673495100 -0400
+@@ -48,6 +48,7 @@
+ obj-$(CONFIG_A2091_SCSI)	+= a2091.o	wd33c93.o
+ obj-$(CONFIG_GVP11_SCSI)	+= gvp11.o	wd33c93.o
+ obj-$(CONFIG_MVME147_SCSI)	+= mvme147.o	wd33c93.o
++obj-$(CONFIG_SCSI_MV_94xx)	+= mv/
+ obj-$(CONFIG_SGIWD93_SCSI)	+= sgiwd93.o	wd33c93.o
+ obj-$(CONFIG_ATARI_SCSI)	+= atari_scsi.o
+ obj-$(CONFIG_MAC_SCSI)		+= mac_scsi.o
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/patch.sh F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/patch.sh
--- linux-3.10.69/drivers/scsi/mv/patch.sh	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/patch.sh	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,104 @@
+#!/bin/sh
+. ./mv_conf.mk
+subtxt(){
+
+    if [ ! -f "$1" ] || [ ! -w "$1" ]; then
+	echo "File does not exist or is not writable."
+	exit 1
+    fi
+
+    if [ "$2" = "a" ];then
+        if [ "$SUPPORT_THOR" = "y"  ];then
+        
+            grep SCSI_MV_61xx "$1" >/dev/null 2>&1
+	    if [ "$?" = "0" ];then
+	        cat "$1"
+                return
+	    fi
+
+            sed -e '/if SCSI_LOWLEVEL && SCSI/{
+                    a\
+config SCSI_MV_61xx\
+	tristate "Marvell Storage Controller 6121/6122/6141/6145"\
+	depends on SCSI && BLK_DEV_SD\
+	help\
+		Provides support for Marvell 61xx Storage Controller series.\n
+}' "$1"
+
+        elif [ "$SUPPORT_VANIR" = "y" ]; then
+        
+            grep SCSI_MV_94xx "$1" >/dev/null 2>&1
+            if [ "$?" = "0" ];then
+            cat "$1"
+               return
+            fi
+
+            sed -e '/if SCSI_LOWLEVEL && SCSI/{
+                    a\
+config SCSI_MV_94xx\
+	tristate "Marvell Storage Controller 9180/9480"\
+	depends on SCSI && BLK_DEV_SD\
+	help\
+		Provides support for Marvell 94xx Storage Controller series.\n
+}' "$1"
+
+        elif [ "$SUPPORT_VANIRLITES" = "y" ]; then
+        
+            grep SCSI_MV_934x "$1" >/dev/null 2>&1
+            if [ "$?" = "0" ];then
+            cat "$1"
+               return
+            fi
+
+            sed -e '/if SCSI_LOWLEVEL && SCSI/{
+                    a\
+config SCSI_MV_934x\
+	tristate "Marvell Storage Controller 9340/9345"\
+	depends on SCSI && BLK_DEV_SD\
+	help\
+		Provides support for Marvell 934x Storage Controller series.\n
+}' "$1"
+        elif [ "$SUPPORT_ODIN" = "y" ]; then
+            grep SCSI_MV_64xx "$1" >/dev/null 2>&1
+            if [ "$?" = "0" ];then
+            cat "$1"
+               return
+            fi
+
+            sed -e '/if SCSI_LOWLEVEL && SCSI/{
+                    a\
+config SCSI_MV_64xx\
+	tristate "Marvell Storage Controller 6430/6320/6440/6445/6480/6485"\
+	depends on SCSI && BLK_DEV_SD\
+	help\
+		Provides support for Marvell 64xx Storage Controller series.\n
+}' "$1"
+        else
+      	   echo "Cannot find the specified product, define mv_conf.mk."
+      	   exit 1
+        fi
+    else
+        if [ "$SUPPORT_THOR" = "y"  ];then
+            sed -e '/SCSI_MV_61xx/,+5 d' "$1"
+        elif [ "$SUPPORT_VANIR" = "y"  ];then 
+            sed -e '/SCSI_MV_94xx/,+5 d' "$1"
+        elif [ "$SUPPORT_ODIN" = "y"  ];then 
+            sed -e '/SCSI_MV_64xx/,+5 d' "$1"
+        else
+      	   echo "Cannot find the specified product, define mv_conf.mk."
+      	   exit 1
+        fi
+    fi
+}
+
+# $1 is supposed to be the $KERNEL_SRC/drivers/scsi
+if [ ! -d "$1" ];then
+    echo "Cannot find the specified directory."
+    exit 1
+fi
+
+cd "$1"
+subtxt Kconfig $2 > Kconfig.new
+mv Kconfig Kconfig.orig
+mv Kconfig.new Kconfig
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mv/readme F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/readme
--- linux-3.10.69/drivers/scsi/mv/readme	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mv/readme	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,132 @@
+   Marvell 61xx/64xx Controller Linux Open Source Driver
+ ---------------------------------------------------------
+    
+1. Introduction
+2. Build driver 
+3. Build the driver into kernel
+4. Note
+---------------------------------------
+
+1. Introduction
+---------------
+
+    This is the partial linux kernel driver source code for Marvell SATA 
+controllers. Current version of the source supports 2.6.X and 3.X kernel.
+
+
+2. Build driver 
+---------------
+
+    2.1 Make sure kernel source/headers is ready.
+
+        Depending on your need, you may want to build a driver for the running
+    kernel of your host machine, or you might want to build drivers for other
+    versions of kernel. In both cases, you should have the source code of the 
+    kernel installed. For example, you should launch yast and install the
+    'kernel-source' package if you're using SuSE Linux (including SLED/SLES ).
+
+        To build the module, you also should know where the kernel source is. 
+    For SuSE Linux and Red Hat, the source to the running kernel can be found
+    at /lib/modules/`uname -r`/build. If you want to build driver for a 
+    customized kernel, make sure your user account have the access to the 
+    source. 
+
+    2.2 Build the driver
+
+      	If you're building driver for a kernel other than the running one, you
+    should let driver source know the path to the kernel source before issuing
+    make. You have two ways of issuing make command:
+
+        1) Set the shell environment variable 'KERNEL_SRC' to the path to
+           kernel source for which you want to build the driver. Suppose the
+           source is located at /usr/src/linux, then execute the following
+           command:
+		
+            # export KERNEL_SRC=/usr/src/linux
+            # make
+        
+        2) Specify the KERNEL_SRC in the invocation of make command:
+
+            # make KERNEL_SRC=/usr/src/linux
+
+           Watching the sources being compiled, and when it stops, you're done.
+
+        Note : 
+           Make sure the kernel source is properly prepared for external module 
+           building. Execute 'make modules_prepare' in the kernel source
+	   directory if you haven't done so.
+	
+    2.3 Install the driver.
+
+        If the module is named as mv61xx.ko,to install the driver, you type:
+	
+            # insmod mv61xx.ko
+	        
+        If the module is named as mv64xx.ko,to install the driver, you type:
+	
+	    			# insmod mv64xx.ko
+
+3. Build the driver into kernel
+-------------------------------
+
+    3.1 Make sure you have the complete kernel source installed.
+
+        To patch a kernel tree, you'll need the complete source to the linux
+    kernel. Also you'll need to verify that you have the write permission on
+    the source directory.
+
+
+    3.2 Patch the source.
+
+        Change working directory to the driver source code, type:*
+	     # export KERNEL_SRC=/usr/src/linux
+            # make $KERNEL_SRC kbuild
+
+        You should substitute '/usr/src/linux' with the absolute path to the
+        kernel source directory.
+
+        You can always rewind the patch by using the following command:
+
+	    			# make $KERNEL_SRC ukbuild
+
+    3.3 Build the kernel
+
+        Now you can start kernel configuration process, follow the normal kernel
+    building process, which varies on different linux distributions and is not 
+    covered here. then you can configure the driver into kernel during the
+    kernel configuration process (e.g. "make menuconfig"). 
+     
+        Below is an example to make and install a kernel with the driver built-in:
+     		# export KERNEL_SRC=/usr/src/linux
+        # cd /usr/src/linux
+        # make mrproper
+        # make menuconfig
+        
+        Select "Device Drivers --->" and press enter.
+        Select "SCSI device support", then press 'Y' to make it built-in.
+        Select "SCSI disk support" then press 'Y' to make it build-in.
+        Select "SCSI low-level drivers --->" and press enter.
+        
+        Select "Marvell Storage Controller 9180/9480" and press 'Y'.
+        or
+        Select "Marvell Storage Controller 6320/6340/6440/6450/6480" and press 'Y'.
+        
+        Exit and save the kernel configuration.
+        # make dep
+	 			# make clean
+ 	 			# make bzImage
+	 			# make modules
+        # make modules_install
+        # make install
+        
+        Now mv94xx/mv64xx driver will be built into kernel image. Note that
+    mv94xx/mv64xx driver depends on SCSI and SCSI disk support, so you should
+    also build them as part of the kernel ( not as modules ). Then you can
+    reboot from the new kernel.
+ 
+4. Note
+-------
+
+* We've tested the patch successfully against kernel 2.6.16 and upward.
+
+
diff -rubB --new-file linux-3.10.69/drivers/scsi/mvsas/mv_init.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mvsas/mv_init.c
--- linux-3.10.69/drivers/scsi/mvsas/mv_init.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/mvsas/mv_init.c	2017-05-02 03:31:56.000000000 +0200
@@ -729,6 +729,15 @@
 		.class_mask	= 0,
 		.driver_data	= chip_9485,
 	},
+	{
+                .vendor         = PCI_VENDOR_ID_MARVELL_EXT,
+                .device         = 0x9485,
+                .subvendor      = PCI_ANY_ID,
+                .subdevice      = 0x9485,
+                .class          = 0,
+                .class_mask     = 0,
+                .driver_data    = chip_9485,
+        },
 	{ PCI_VDEVICE(OCZ, 0x1021), chip_9485}, /* OCZ RevoDrive3 */
 	{ PCI_VDEVICE(OCZ, 0x1022), chip_9485}, /* OCZ RevoDrive3/zDriveR4 (exact model unknown) */
 	{ PCI_VDEVICE(OCZ, 0x1040), chip_9485}, /* OCZ RevoDrive3/zDriveR4 (exact model unknown) */
diff -rubB --new-file linux-3.10.69/drivers/scsi/scsi.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/scsi.c
--- linux-3.10.69/drivers/scsi/scsi.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/scsi.c	2017-05-02 03:31:56.000000000 +0200
@@ -108,8 +108,14 @@
 	"WORM             ",
 	"CD-ROM           ",
 	"Scanner          ",
+#ifdef CONFIG_BUFFALO_PLATFORM
+	/* __LS_COMMENT__ BUFFALO change 2004.8.30 */
+	"Optical-Device   ",
+	"Medium-Changer   ",
+#else	/* CONFIG_BUFFALO_PLATFORM */
 	"Optical Device   ",
 	"Medium Changer   ",
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	"Communications   ",
 	"ASC IT8          ",
 	"ASC IT8          ",
@@ -700,8 +706,15 @@
 	 */
 	if (cmd->device->scsi_level <= SCSI_2 &&
 	    cmd->device->scsi_level != SCSI_UNKNOWN) {
+#ifdef CONFIG_BUFFALO_IGNORE_LUN
+		/* support for AVU2 */
+		if (!cmd->device->ignore_lun || !(cmd->cmnd[0] & 0xc0))
 		cmd->cmnd[1] = (cmd->cmnd[1] & 0x1f) |
 			       (cmd->device->lun << 5 & 0xe0);
+#else	/* CONFIG_BUFFALO_IGNORE_LUN */
+		cmd->cmnd[1] = (cmd->cmnd[1] & 0x1f) |
+			       (cmd->device->lun << 5 & 0xe0);
+#endif	/* CONFIG_BUFFALO_IGNORE_LUN */
 	}
 
 	/*
diff -rubB --new-file linux-3.10.69/drivers/scsi/scsi_scan.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/scsi_scan.c
--- linux-3.10.69/drivers/scsi/scsi_scan.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/scsi_scan.c	2017-05-02 03:31:56.000000000 +0200
@@ -1343,6 +1343,10 @@
 	struct Scsi_Host *shost = dev_to_shost(&starget->dev);
 	int ret = 0;
 
+#ifdef CONFIG_BUFFALO_IGNORE_LUN
+	return 1;
+#endif	/* CONFIG_BUFFALO_IGNORE_LUN */
+
 	/*
 	 * Only support SCSI-3 and up devices if BLIST_NOREPORTLUN is not set.
 	 * Also allow SCSI-2 if BLIST_REPORTLUN2 is set and host adapter does
diff -rubB --new-file linux-3.10.69/drivers/scsi/scsi_sysfs.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/scsi_sysfs.c
--- linux-3.10.69/drivers/scsi/scsi_sysfs.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/scsi_sysfs.c	2017-05-02 03:31:56.000000000 +0200
@@ -529,6 +529,9 @@
 sdev_rd_attr (vendor, "%.8s\n");
 sdev_rd_attr (model, "%.16s\n");
 sdev_rd_attr (rev, "%.4s\n");
+#ifdef CONFIG_BUFFALO_IGNORE_LUN
+sdev_rw_attr (ignore_lun, "%d\n");
+#endif	/* CONFIG_BUFFALO_IGNORE_LUN */
 
 /*
  * TODO: can we make these symlinks to the block layer ones?
@@ -714,6 +717,9 @@
 	&dev_attr_vendor.attr,
 	&dev_attr_model.attr,
 	&dev_attr_rev.attr,
+#ifdef CONFIG_BUFFALO_IGNORE_LUN
+	&dev_attr_ignore_lun,
+#endif	/* CONFIG_BUFFALO_IGNORE_LUN */
 	&dev_attr_rescan.attr,
 	&dev_attr_delete.attr,
 	&dev_attr_state.attr,
diff -rubB --new-file linux-3.10.69/drivers/scsi/sd.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/sd.c
--- linux-3.10.69/drivers/scsi/sd.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/sd.c	2017-05-02 03:31:56.000000000 +0200
@@ -2827,6 +2827,10 @@
 	gd->fops = &sd_fops;
 	gd->private_data = &sdkp->driver;
 	gd->queue = sdkp->device->request_queue;
+#ifdef CONFIG_BUFFALO_IOERRS
+	gd->io_errors = 0;
+	gd->limit_io_errors = 1000;	/* default limit *//* XXX: should use MAXERR_CNT_DEFAULT in dirivers/md/md.h ? but it is not reasonable to include drivers/md/md.h ... */
+#endif	/* CONFIG_BUFFALO_IOERRS */
 
 	/* defaults, until the device tells us otherwise */
 	sdp->sector_size = 512;
diff -rubB --new-file linux-3.10.69/drivers/scsi/sd.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/sd.h
--- linux-3.10.69/drivers/scsi/sd.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/scsi/sd.h	2017-05-02 03:31:56.000000000 +0200
@@ -11,7 +11,11 @@
 /*
  * Time out in seconds for disks and Magneto-opticals (which are slower).
  */
+#ifdef CONFIG_BUFFALO_PLATFORM
+#define SD_TIMEOUT		(120 * HZ)
+#else	/* CONFIG_BUFFALO_PLATFORM */
 #define SD_TIMEOUT		(30 * HZ)
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 #define SD_MOD_TIMEOUT		(75 * HZ)
 #define SD_FLUSH_TIMEOUT	(60 * HZ)
 #define SD_WRITE_SAME_TIMEOUT	(120 * HZ)
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_auth.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_auth.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_auth.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_auth.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file houses the main functions for the iSCSI CHAP support
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -113,7 +111,7 @@
 	/*
 	 * Set Identifier.
 	 */
-	chap->id = ISCSI_TPG_C(conn)->tpg_chap_id++;
+	chap->id = conn->tpg->tpg_chap_id++;
 	*aic_len += sprintf(aic_str + *aic_len, "CHAP_I=%d", chap->id);
 	*aic_len += 1;
 	pr_debug("[server] Sending CHAP_I=%d\n", chap->id);
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains main functions related to the iSCSI Target Core Driver.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -63,7 +61,6 @@
 
 struct iscsit_global *iscsit_global;
 
-struct kmem_cache *lio_cmd_cache;
 struct kmem_cache *lio_qr_cache;
 struct kmem_cache *lio_dr_cache;
 struct kmem_cache *lio_ooo_cache;
@@ -220,11 +217,6 @@
 		spin_unlock_bh(&np->np_thread_lock);
 		return -1;
 	}
-	if (np->np_login_tpg) {
-		pr_err("np->np_login_tpg() is not NULL!\n");
-		spin_unlock_bh(&np->np_thread_lock);
-		return -1;
-	}
 	spin_unlock_bh(&np->np_thread_lock);
 	/*
 	 * Determine if the portal group is accepting storage traffic.
@@ -239,26 +231,38 @@
 	/*
 	 * Here we serialize access across the TIQN+TPG Tuple.
 	 */
-	ret = mutex_lock_interruptible(&tpg->np_login_lock);
+	ret = down_interruptible(&tpg->np_login_sem);
 	if ((ret != 0) || signal_pending(current))
 		return -1;
 
-	spin_lock_bh(&np->np_thread_lock);
-	np->np_login_tpg = tpg;
-	spin_unlock_bh(&np->np_thread_lock);
+	spin_lock_bh(&tpg->tpg_state_lock);
+	if (tpg->tpg_state != TPG_STATE_ACTIVE) {
+		spin_unlock_bh(&tpg->tpg_state_lock);
+		up(&tpg->np_login_sem);
+		return -1;
+	}
+	spin_unlock_bh(&tpg->tpg_state_lock);
 
 	return 0;
 }
 
-int iscsit_deaccess_np(struct iscsi_np *np, struct iscsi_portal_group *tpg)
+void iscsit_login_kref_put(struct kref *kref)
+{
+	struct iscsi_tpg_np *tpg_np = container_of(kref,
+				struct iscsi_tpg_np, tpg_np_kref);
+
+	complete(&tpg_np->tpg_np_comp);
+}
+
+int iscsit_deaccess_np(struct iscsi_np *np, struct iscsi_portal_group *tpg,
+		       struct iscsi_tpg_np *tpg_np)
 {
 	struct iscsi_tiqn *tiqn = tpg->tpg_tiqn;
 
-	spin_lock_bh(&np->np_thread_lock);
-	np->np_login_tpg = NULL;
-	spin_unlock_bh(&np->np_thread_lock);
+	up(&tpg->np_login_sem);
 
-	mutex_unlock(&tpg->np_login_lock);
+	if (tpg_np)
+		kref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);
 
 	if (tiqn)
 		iscsit_put_tiqn_for_login(tiqn);
@@ -418,20 +422,10 @@
 int iscsit_reset_np_thread(
 	struct iscsi_np *np,
 	struct iscsi_tpg_np *tpg_np,
-	struct iscsi_portal_group *tpg)
+	struct iscsi_portal_group *tpg,
+	bool shutdown)
 {
 	spin_lock_bh(&np->np_thread_lock);
-	if (tpg && tpg_np) {
-		/*
-		 * The reset operation need only be performed when the
-		 * passed struct iscsi_portal_group has a login in progress
-		 * to one of the network portals.
-		 */
-		if (tpg_np->tpg_np->np_login_tpg != tpg) {
-			spin_unlock_bh(&np->np_thread_lock);
-			return 0;
-		}
-	}
 	if (np->np_thread_state == ISCSI_NP_THREAD_INACTIVE) {
 		spin_unlock_bh(&np->np_thread_lock);
 		return 0;
@@ -446,6 +440,12 @@
 	}
 	spin_unlock_bh(&np->np_thread_lock);
 
+	if (tpg_np && shutdown) {
+		kref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);
+
+		wait_for_completion(&tpg_np->tpg_np_comp);
+	}
+
 	return 0;
 }
 
@@ -474,6 +474,7 @@
 		 */
 		send_sig(SIGINT, np->np_thread, 1);
 		kthread_stop(np->np_thread);
+		np->np_thread = NULL;
 	}
 
 	np->np_transport->iscsit_free_np(np);
@@ -506,7 +507,6 @@
 	.iscsit_setup_np	= iscsit_setup_np,
 	.iscsit_accept_np	= iscsit_accept_np,
 	.iscsit_free_np		= iscsit_free_np,
-	.iscsit_alloc_cmd	= iscsit_alloc_cmd,
 	.iscsit_get_login_rx	= iscsit_get_login_rx,
 	.iscsit_put_login_tx	= iscsit_put_login_tx,
 	.iscsit_get_dataout	= iscsit_build_r2ts_for_cmd,
@@ -516,9 +516,164 @@
 	.iscsit_queue_status	= iscsit_queue_rsp,
 };
 
+static struct proc_dir_entry *proc_iscsi_target_dir_entry = NULL,
+                             *proc_status_dir_entry = NULL,
+                             *proc_session_dir_entry = NULL,
+                             *proc_conn_dir_entry = NULL;
+
+static int session_show(struct seq_file *seq, void *v)
+{
+        struct iscsi_tiqn *tiqn = NULL;
+        struct iscsi_portal_group *tpg = NULL;
+        struct se_session *se_sess = NULL;
+        struct iscsi_session *sess = NULL;
+        struct timespec ts;
+	int inst = 1;
+
+        seq_printf(seq, "inst node sid intr_name tgt_name creation_time\n");
+
+        spin_lock(iscsit_global->tiqn_lock);
+        list_for_each_entry(tiqn, iscsit_global->tiqn_list, tiqn_list) {
+                spin_lock(&tiqn->tiqn_tpg_lock);
+                list_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {
+                        spin_lock(&tpg->tpg_se_tpg.session_lock);
+                        list_for_each_entry(se_sess,
+                                            &tpg->tpg_se_tpg.tpg_sess_list,
+                                            sess_list) {
+                                sess = (struct iscsi_session *)
+                                       se_sess->fabric_sess_ptr;
+				getnstimeofday(&ts);
+                                seq_printf(seq,
+                                               "%d %d %d %s %s %llu\n",
+                                               inst++, tiqn->tiqn_index,
+                                               sess->sid,
+                                               sess->sess_ops->InitiatorName,
+                                               sess->sess_ops->TargetName,
+                                               (ts.tv_sec + ts.tv_nsec / 1000000000) -
+                                               ((get_jiffies_64() - INITIAL_JIFFIES) / HZ) +
+                                               ((sess->creation_time - INITIAL_JIFFIES) / HZ));
+                        }
+                        spin_unlock(&tpg->tpg_se_tpg.session_lock);
+                }
+                spin_unlock(&tiqn->tiqn_tpg_lock);
+        }
+        spin_unlock(iscsit_global->tiqn_lock);	
+
+	return 0;
+}
+
+static int session_seq_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, session_show, NULL);
+}
+
+static struct file_operations session_proc_fops = {
+        .owner = THIS_MODULE,
+        .open = session_seq_open,
+        .read = seq_read,
+        .llseek = seq_lseek,
+        .release = single_release,
+};
+
+static int connection_show(struct seq_file *seq, void *v)
+{
+	struct iscsi_tiqn *tiqn = NULL;
+        struct iscsi_portal_group *tpg = NULL;
+        struct se_session *se_sess = NULL;
+        struct iscsi_session *sess = NULL;
+        struct iscsi_conn *conn = NULL;
+        int inst = 1;
+
+        seq_printf(seq, "inst node sid cid addr_type local_ip local_port rem_ip rem_port\n");
+
+        spin_lock(iscsit_global->tiqn_lock);
+        list_for_each_entry(tiqn, iscsit_global->tiqn_list, tiqn_list) {
+                spin_lock(&tiqn->tiqn_tpg_lock);
+                list_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {
+                        spin_lock(&tpg->tpg_se_tpg.session_lock);
+                        list_for_each_entry(se_sess,
+                                            &tpg->tpg_se_tpg.tpg_sess_list,
+                                            sess_list) {
+                                sess = (struct iscsi_session *)
+                                       se_sess->fabric_sess_ptr;
+                                list_for_each_entry(conn,
+                                                    &sess->sess_conn_list,
+                                                    conn_list) {
+                                        seq_printf(seq,
+                                               "%d %d %d %d %s %s %d %s %d\n",
+                                               inst++, tiqn->tiqn_index,
+                                               sess->sid, conn->cid,
+                                               conn->login_family == AF_INET6 ? "ipv6" : "ipv4",
+                                               conn->local_ip,
+                                               conn->local_port,
+                                               conn->login_ip,
+                                               conn->login_port);
+                                }
+                        }
+                        spin_unlock(&tpg->tpg_se_tpg.session_lock);
+                }
+                spin_unlock(&tiqn->tiqn_tpg_lock);
+        }
+        spin_unlock(iscsit_global->tiqn_lock);
+
+	return 0;
+}
+
+static int connection_seq_open(struct inode *inode, struct file *file)
+{
+        return single_open(file, connection_show, NULL);
+}
+
+static struct file_operations connection_proc_fops = {
+	.owner = THIS_MODULE,
+	.open = connection_seq_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+};
+
+static void create_proc_entries(void)
+{
+	proc_iscsi_target_dir_entry = proc_mkdir("iscsi_target", NULL);
+	if (proc_iscsi_target_dir_entry == NULL) {
+		pr_err("Failed to create proc 'iscsi_target' dir\n");
+	}
+	else {
+		proc_status_dir_entry =
+			proc_mkdir("status", proc_iscsi_target_dir_entry);
+		if (proc_status_dir_entry == NULL) {
+			pr_err("Failed to create proc 'iscsi_target/status' dir\n");
+		}
+		else {
+			proc_session_dir_entry =
+				proc_create("session", 0444,
+                                            proc_status_dir_entry, &session_proc_fops);
+			proc_conn_dir_entry =
+				proc_create("connection", 0444,
+                                            proc_status_dir_entry, &connection_proc_fops);
+		}
+	}
+}
+
+static void remove_proc_entries(void)
+{
+	if (proc_session_dir_entry != NULL) {
+		proc_remove(proc_session_dir_entry);
+	}
+	if (proc_conn_dir_entry != NULL) {
+		proc_remove(proc_conn_dir_entry);
+	}
+	if (proc_status_dir_entry != NULL) {
+		proc_remove(proc_status_dir_entry);
+	}
+	if (proc_iscsi_target_dir_entry != NULL) {
+		proc_remove(proc_iscsi_target_dir_entry);
+	}
+}
+
 static int __init iscsi_target_init_module(void)
 {
-	int ret = 0;
+	int ret = 0, size;
 
 	pr_debug("iSCSI-Target "ISCSIT_VERSION"\n");
 
@@ -527,6 +682,13 @@
 		pr_err("Unable to allocate memory for iscsit_global\n");
 		return -1;
 	}
+
+	iscsit_global->tiqn_list = &g_tiqn_list;
+	iscsit_global->np_list = &g_np_list;
+	iscsit_global->tiqn_lock = &tiqn_lock;
+	iscsit_global->np_lock = &np_lock;
+
+	spin_lock_init(&iscsit_global->ts_bitmap_lock);
 	mutex_init(&auth_id_lock);
 	spin_lock_init(&sess_idr_lock);
 	idr_init(&tiqn_idr);
@@ -536,24 +698,11 @@
 	if (ret < 0)
 		goto out;
 
-	ret = iscsi_thread_set_init();
-	if (ret < 0)
+	size = BITS_TO_LONGS(ISCSIT_BITMAP_BITS) * sizeof(long);
+	iscsit_global->ts_bitmap = vzalloc(size);
+	if (!iscsit_global->ts_bitmap) {
+		pr_err("Unable to allocate iscsit_global->ts_bitmap\n");
 		goto configfs_out;
-
-	if (iscsi_allocate_thread_sets(TARGET_THREAD_SET_COUNT) !=
-			TARGET_THREAD_SET_COUNT) {
-		pr_err("iscsi_allocate_thread_sets() returned"
-			" unexpected value!\n");
-		goto ts_out1;
-	}
-
-	lio_cmd_cache = kmem_cache_create("lio_cmd_cache",
-			sizeof(struct iscsi_cmd), __alignof__(struct iscsi_cmd),
-			0, NULL);
-	if (!lio_cmd_cache) {
-		pr_err("Unable to kmem_cache_create() for"
-				" lio_cmd_cache\n");
-		goto ts_out2;
 	}
 
 	lio_qr_cache = kmem_cache_create("lio_qr_cache",
@@ -562,7 +711,7 @@
 	if (!lio_qr_cache) {
 		pr_err("nable to kmem_cache_create() for"
 				" lio_qr_cache\n");
-		goto cmd_out;
+		goto bitmap_out;
 	}
 
 	lio_dr_cache = kmem_cache_create("lio_dr_cache",
@@ -597,6 +746,8 @@
 	if (iscsit_load_discovery_tpg() < 0)
 		goto r2t_out;
 
+	create_proc_entries();
+
 	return ret;
 r2t_out:
 	kmem_cache_destroy(lio_r2t_cache);
@@ -606,12 +757,8 @@
 	kmem_cache_destroy(lio_dr_cache);
 qr_out:
 	kmem_cache_destroy(lio_qr_cache);
-cmd_out:
-	kmem_cache_destroy(lio_cmd_cache);
-ts_out2:
-	iscsi_deallocate_thread_sets();
-ts_out1:
-	iscsi_thread_set_free();
+bitmap_out:
+	vfree(iscsit_global->ts_bitmap);
 configfs_out:
 	iscsi_target_deregister_configfs();
 out:
@@ -621,11 +768,10 @@
 
 static void __exit iscsi_target_cleanup_module(void)
 {
-	iscsi_deallocate_thread_sets();
-	iscsi_thread_set_free();
+	remove_proc_entries();
+
 	iscsit_release_discovery_tpg();
 	iscsit_unregister_transport(&iscsi_target_transport);
-	kmem_cache_destroy(lio_cmd_cache);
 	kmem_cache_destroy(lio_qr_cache);
 	kmem_cache_destroy(lio_dr_cache);
 	kmem_cache_destroy(lio_ooo_cache);
@@ -633,6 +779,7 @@
 
 	iscsi_target_deregister_configfs();
 
+	vfree(iscsit_global->ts_bitmap);
 	kfree(iscsit_global);
 }
 
@@ -643,7 +790,7 @@
 {
 	struct iscsi_cmd *cmd;
 
-	cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+	cmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);
 	if (!cmd)
 		return -1;
 
@@ -775,7 +922,8 @@
 
 static void iscsit_ack_from_expstatsn(struct iscsi_conn *conn, u32 exp_statsn)
 {
-	struct iscsi_cmd *cmd;
+	LIST_HEAD(ack_list);
+	struct iscsi_cmd *cmd, *cmd_p;
 
 	conn->exp_statsn = exp_statsn;
 
@@ -783,19 +931,23 @@
 		return;
 
 	spin_lock_bh(&conn->cmd_lock);
-	list_for_each_entry(cmd, &conn->conn_cmd_list, i_conn_node) {
+	list_for_each_entry_safe(cmd, cmd_p, &conn->conn_cmd_list, i_conn_node) {
 		spin_lock(&cmd->istate_lock);
 		if ((cmd->i_state == ISTATE_SENT_STATUS) &&
 		    iscsi_sna_lt(cmd->stat_sn, exp_statsn)) {
 			cmd->i_state = ISTATE_REMOVE;
 			spin_unlock(&cmd->istate_lock);
-			iscsit_add_cmd_to_immediate_queue(cmd, conn,
-						cmd->i_state);
+			list_move_tail(&cmd->i_conn_node, &ack_list);
 			continue;
 		}
 		spin_unlock(&cmd->istate_lock);
 	}
 	spin_unlock_bh(&conn->cmd_lock);
+
+	list_for_each_entry_safe(cmd, cmd_p, &ack_list, i_conn_node) {
+		list_del_init(&cmd->i_conn_node);
+		iscsit_free_cmd(cmd, false);
+	}
 }
 
 static int iscsit_allocate_iovecs(struct iscsi_cmd *cmd)
@@ -822,14 +974,7 @@
 	int iscsi_task_attr;
 	int sam_task_attr;
 
-	spin_lock_bh(&conn->sess->session_stats_lock);
-	conn->sess->cmd_pdus++;
-	if (conn->sess->se_sess->se_node_acl) {
-		spin_lock(&conn->sess->se_sess->se_node_acl->stats_lock);
-		conn->sess->se_sess->se_node_acl->num_cmds++;
-		spin_unlock(&conn->sess->se_sess->se_node_acl->stats_lock);
-	}
-	spin_unlock_bh(&conn->sess->session_stats_lock);
+	atomic_long_inc(&conn->sess->cmd_pdus);
 
 	hdr			= (struct iscsi_scsi_req *) buf;
 	payload_length		= ntoh24(hdr->dlength);
@@ -1179,7 +1324,7 @@
 	 * traditional iSCSI block I/O.
 	 */
 	if (iscsit_allocate_iovecs(cmd) < 0) {
-		return iscsit_add_reject_cmd(cmd,
+		return iscsit_reject_cmd(cmd,
 				ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);
 	}
 	immed_data = cmd->immediate_data;
@@ -1265,25 +1410,16 @@
 	struct iscsi_data *hdr = (struct iscsi_data *)buf;
 	struct iscsi_cmd *cmd = NULL;
 	struct se_cmd *se_cmd;
-	unsigned long flags;
 	u32 payload_length = ntoh24(hdr->dlength);
 	int rc;
 
 	if (!payload_length) {
-		pr_err("DataOUT payload is ZERO, protocol error.\n");
-		return iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,
-					 buf);
+		pr_warn("DataOUT payload is ZERO, ignoring.\n");
+		return 0;
 	}
 
 	/* iSCSI write */
-	spin_lock_bh(&conn->sess->session_stats_lock);
-	conn->sess->rx_data_octets += payload_length;
-	if (conn->sess->se_sess->se_node_acl) {
-		spin_lock(&conn->sess->se_sess->se_node_acl->stats_lock);
-		conn->sess->se_sess->se_node_acl->write_bytes += payload_length;
-		spin_unlock(&conn->sess->se_sess->se_node_acl->stats_lock);
-	}
-	spin_unlock_bh(&conn->sess->session_stats_lock);
+	atomic_long_add(payload_length, &conn->sess->rx_data_octets);
 
 	if (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {
 		pr_err("DataSegmentLength: %u is greater than"
@@ -1342,14 +1478,9 @@
 		 */
 
 		/* Something's amiss if we're not in WRITE_PENDING state... */
-		spin_lock_irqsave(&se_cmd->t_state_lock, flags);
 		WARN_ON(se_cmd->t_state != TRANSPORT_WRITE_PENDING);
-		spin_unlock_irqrestore(&se_cmd->t_state_lock, flags);
-
-		spin_lock_irqsave(&se_cmd->t_state_lock, flags);
 		if (!(se_cmd->se_cmd_flags & SCF_SUPPORTED_SAM_OPCODE))
 			dump_unsolicited_data = 1;
-		spin_unlock_irqrestore(&se_cmd->t_state_lock, flags);
 
 		if (dump_unsolicited_data) {
 			/*
@@ -1507,7 +1638,7 @@
 
 static int iscsit_handle_data_out(struct iscsi_conn *conn, unsigned char *buf)
 {
-	struct iscsi_cmd *cmd;
+	struct iscsi_cmd *cmd = NULL;
 	struct iscsi_data *hdr = (struct iscsi_data *)buf;
 	int rc;
 	bool data_crc_failed = false;
@@ -1527,18 +1658,10 @@
 	return iscsit_check_dataout_payload(cmd, hdr, data_crc_failed);
 }
 
-int iscsit_handle_nop_out(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
-			unsigned char *buf)
+int iscsit_setup_nop_out(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
+			 struct iscsi_nopout *hdr)
 {
-	unsigned char *ping_data = NULL;
-	int cmdsn_ret, niov = 0, ret = 0, rx_got, rx_size;
-	u32 checksum, data_crc, padding = 0, payload_length;
-	struct iscsi_cmd *cmd_p = NULL;
-	struct kvec *iov = NULL;
-	struct iscsi_nopout *hdr;
-
-	hdr			= (struct iscsi_nopout *) buf;
-	payload_length		= ntoh24(hdr->dlength);
+	u32 payload_length = ntoh24(hdr->dlength);
 
 	if (hdr->itt == RESERVED_ITT && !(hdr->opcode & ISCSI_OP_IMMEDIATE)) {
 		pr_err("NOPOUT ITT is reserved, but Immediate Bit is"
@@ -1577,11 +1700,6 @@
 	 * can contain ping data.
 	 */
 	if (hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {
-		if (!cmd)
-			return iscsit_reject_cmd(cmd,
-					ISCSI_REASON_BOOKMARK_NO_RESOURCES,
-					(unsigned char *)hdr);
-
 		cmd->iscsi_opcode	= ISCSI_OP_NOOP_OUT;
 		cmd->i_state		= ISTATE_SEND_NOPIN;
 		cmd->immediate_cmd	= ((hdr->opcode & ISCSI_OP_IMMEDIATE) ?
@@ -1593,8 +1711,87 @@
 		cmd->data_direction	= DMA_NONE;
 	}
 
+	return 0;
+}
+EXPORT_SYMBOL(iscsit_setup_nop_out);
+
+int iscsit_process_nop_out(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
+			   struct iscsi_nopout *hdr)
+{
+	struct iscsi_cmd *cmd_p = NULL;
+	int cmdsn_ret = 0;
+	/*
+	 * Initiator is expecting a NopIN ping reply..
+	 */
+	if (hdr->itt != RESERVED_ITT) {
+		if (!cmd)
+			return iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR,
+						(unsigned char *)hdr);
+
+		spin_lock_bh(&conn->cmd_lock);
+		list_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);
+		spin_unlock_bh(&conn->cmd_lock);
+
+		iscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));
+
+		if (hdr->opcode & ISCSI_OP_IMMEDIATE) {
+			iscsit_add_cmd_to_response_queue(cmd, conn,
+							 cmd->i_state);
+			return 0;
+		}
+
+		cmdsn_ret = iscsit_sequence_cmd(conn, cmd,
+				(unsigned char *)hdr, hdr->cmdsn);
+                if (cmdsn_ret == CMDSN_LOWER_THAN_EXP)
+			return 0;
+		if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)
+			return -1;
+
+		return 0;
+	}
+	/*
+	 * This was a response to a unsolicited NOPIN ping.
+	 */
+	if (hdr->ttt != cpu_to_be32(0xFFFFFFFF)) {
+		cmd_p = iscsit_find_cmd_from_ttt(conn, be32_to_cpu(hdr->ttt));
+		if (!cmd_p)
+			return -EINVAL;
+
+		iscsit_stop_nopin_response_timer(conn);
+
+		cmd_p->i_state = ISTATE_REMOVE;
+		iscsit_add_cmd_to_immediate_queue(cmd_p, conn, cmd_p->i_state);
+
+		iscsit_start_nopin_timer(conn);
+		return 0;
+	}
+	/*
+	 * Otherwise, initiator is not expecting a NOPIN is response.
+	 * Just ignore for now.
+	 */
+        return 0;
+}
+EXPORT_SYMBOL(iscsit_process_nop_out);
+
+static int iscsit_handle_nop_out(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
+				 unsigned char *buf)
+{
+	unsigned char *ping_data = NULL;
+	struct iscsi_nopout *hdr = (struct iscsi_nopout *)buf;
+	struct kvec *iov = NULL;
+	u32 payload_length = ntoh24(hdr->dlength);
+	int ret;
+
+	ret = iscsit_setup_nop_out(conn, cmd, hdr);
+	if (ret < 0)
+		return 0;
+	/*
+	 * Handle NOP-OUT payload for traditional iSCSI sockets
+	 */
 	if (payload_length && hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {
-		rx_size = payload_length;
+		u32 checksum, data_crc, padding = 0;
+		int niov = 0, rx_got, rx_size = payload_length;
+
 		ping_data = kzalloc(payload_length + 1, GFP_KERNEL);
 		if (!ping_data) {
 			pr_err("Unable to allocate memory for"
@@ -1673,75 +1870,14 @@
 		pr_debug("Ping Data: \"%s\"\n", ping_data);
 	}
 
-	if (hdr->itt != RESERVED_ITT) {
-		if (!cmd) {
-			pr_err("Checking CmdSN for NOPOUT,"
-				" but cmd is NULL!\n");
-			return -1;
-		}
-		/*
-		 * Initiator is expecting a NopIN ping reply,
-		 */
-		spin_lock_bh(&conn->cmd_lock);
-		list_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);
-		spin_unlock_bh(&conn->cmd_lock);
-
-		iscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));
-
-		if (hdr->opcode & ISCSI_OP_IMMEDIATE) {
-			iscsit_add_cmd_to_response_queue(cmd, conn,
-					cmd->i_state);
-			return 0;
-		}
-
-		cmdsn_ret = iscsit_sequence_cmd(conn, cmd,
-				(unsigned char *)hdr, hdr->cmdsn);
-		if (cmdsn_ret == CMDSN_LOWER_THAN_EXP) {
-			ret = 0;
-			goto ping_out;
-		}
-		if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)
-			return -1;
-
-		return 0;
-	}
-
-	if (hdr->ttt != cpu_to_be32(0xFFFFFFFF)) {
-		/*
-		 * This was a response to a unsolicited NOPIN ping.
-		 */
-		cmd_p = iscsit_find_cmd_from_ttt(conn, be32_to_cpu(hdr->ttt));
-		if (!cmd_p)
-			return -1;
-
-		iscsit_stop_nopin_response_timer(conn);
-
-		cmd_p->i_state = ISTATE_REMOVE;
-		iscsit_add_cmd_to_immediate_queue(cmd_p, conn, cmd_p->i_state);
-		iscsit_start_nopin_timer(conn);
-	} else {
-		/*
-		 * Initiator is not expecting a NOPIN is response.
-		 * Just ignore for now.
-		 *
-		 * iSCSI v19-91 10.18
-		 * "A NOP-OUT may also be used to confirm a changed
-		 *  ExpStatSN if another PDU will not be available
-		 *  for a long time."
-		 */
-		ret = 0;
-		goto out;
-	}
-
-	return 0;
+	return iscsit_process_nop_out(conn, cmd, hdr);
 out:
 	if (cmd)
 		iscsit_free_cmd(cmd, false);
-ping_out:
+
 	kfree(ping_data);
 	return ret;
 }
-EXPORT_SYMBOL(iscsit_handle_nop_out);
 
 int
 iscsit_handle_task_mgt_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
@@ -1958,44 +2094,131 @@
 EXPORT_SYMBOL(iscsit_handle_task_mgt_cmd);
 
 /* #warning FIXME: Support Text Command parameters besides SendTargets */
-static int iscsit_handle_text_cmd(
-	struct iscsi_conn *conn,
-	unsigned char *buf)
+int
+iscsit_setup_text_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
+		      struct iscsi_text *hdr)
 {
-	char *text_ptr, *text_in;
-	int cmdsn_ret, niov = 0, rx_got, rx_size;
-	u32 checksum = 0, data_crc = 0, payload_length;
-	u32 padding = 0, pad_bytes = 0, text_length = 0;
-	struct iscsi_cmd *cmd;
-	struct kvec iov[3];
-	struct iscsi_text *hdr;
-
-	hdr			= (struct iscsi_text *) buf;
-	payload_length		= ntoh24(hdr->dlength);
+	u32 payload_length = ntoh24(hdr->dlength);
 
 	if (payload_length > conn->conn_ops->MaxXmitDataSegmentLength) {
 		pr_err("Unable to accept text parameter length: %u"
 			"greater than MaxXmitDataSegmentLength %u.\n",
 		       payload_length, conn->conn_ops->MaxXmitDataSegmentLength);
-		return iscsit_add_reject(conn, ISCSI_REASON_PROTOCOL_ERROR, buf);
+		return iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,
+					 (unsigned char *)hdr);
+	}
+
+	if (!(hdr->flags & ISCSI_FLAG_CMD_FINAL) ||
+	     (hdr->flags & ISCSI_FLAG_TEXT_CONTINUE)) {
+		pr_err("Multi sequence text commands currently not supported\n");
+		return iscsit_reject_cmd(cmd, ISCSI_REASON_CMD_NOT_SUPPORTED,
+					(unsigned char *)hdr);
 	}
 
 	pr_debug("Got Text Request: ITT: 0x%08x, CmdSN: 0x%08x,"
 		" ExpStatSN: 0x%08x, Length: %u\n", hdr->itt, hdr->cmdsn,
 		hdr->exp_statsn, payload_length);
 
-	rx_size = text_length = payload_length;
-	if (text_length) {
-		text_in = kzalloc(text_length, GFP_KERNEL);
+	cmd->iscsi_opcode	= ISCSI_OP_TEXT;
+	cmd->i_state		= ISTATE_SEND_TEXTRSP;
+	cmd->immediate_cmd	= ((hdr->opcode & ISCSI_OP_IMMEDIATE) ? 1 : 0);
+	conn->sess->init_task_tag = cmd->init_task_tag  = hdr->itt;
+	cmd->targ_xfer_tag	= 0xFFFFFFFF;
+	cmd->cmd_sn		= be32_to_cpu(hdr->cmdsn);
+	cmd->exp_stat_sn	= be32_to_cpu(hdr->exp_statsn);
+	cmd->data_direction	= DMA_NONE;
+
+	return 0;
+}
+EXPORT_SYMBOL(iscsit_setup_text_cmd);
+
+int
+iscsit_process_text_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
+			struct iscsi_text *hdr)
+{
+	unsigned char *text_in = cmd->text_in_ptr, *text_ptr;
+	int cmdsn_ret;
+
+	if (!text_in) {
+		pr_err("Unable to locate text_in buffer for sendtargets"
+		       " discovery\n");
+		goto reject;
+	}
+	if (strncmp("SendTargets", text_in, 11) != 0) {
+		pr_err("Received Text Data that is not"
+			" SendTargets, cannot continue.\n");
+		goto reject;
+	}
+	text_ptr = strchr(text_in, '=');
+	if (!text_ptr) {
+		pr_err("No \"=\" separator found in Text Data,"
+			"  cannot continue.\n");
+		goto reject;
+	}
+	if (!strncmp("=All", text_ptr, 4)) {
+		cmd->cmd_flags |= IFC_SENDTARGETS_ALL;
+	} else if (!strncmp("=iqn.", text_ptr, 5) ||
+		   !strncmp("=eui.", text_ptr, 5)) {
+		cmd->cmd_flags |= IFC_SENDTARGETS_SINGLE;
+	} else {
+		pr_err("Unable to locate valid SendTargets=%s value\n", text_ptr);
+		goto reject;
+	}
+
+	spin_lock_bh(&conn->cmd_lock);
+	list_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);
+	spin_unlock_bh(&conn->cmd_lock);
+
+	iscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));
+
+	if (!(hdr->opcode & ISCSI_OP_IMMEDIATE)) {
+		cmdsn_ret = iscsit_sequence_cmd(conn, cmd,
+				(unsigned char *)hdr, hdr->cmdsn);
+		if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)
+			return -1;
+
+		return 0;
+	}
+
+	return iscsit_execute_cmd(cmd, 0);
+
+reject:
+	return iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR,
+				 (unsigned char *)hdr);
+}
+EXPORT_SYMBOL(iscsit_process_text_cmd);
+
+static int
+iscsit_handle_text_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,
+		       unsigned char *buf)
+{
+	struct iscsi_text *hdr = (struct iscsi_text *)buf;
+	char *text_in = NULL;
+	u32 payload_length = ntoh24(hdr->dlength);
+	int rx_size, rc;
+
+	rc = iscsit_setup_text_cmd(conn, cmd, hdr);
+	if (rc < 0)
+		return 0;
+
+	rx_size = payload_length;
+	if (payload_length) {
+		u32 checksum = 0, data_crc = 0;
+		u32 padding = 0, pad_bytes = 0;
+		int niov = 0, rx_got;
+		struct kvec iov[3];
+
+		text_in = kzalloc(payload_length, GFP_KERNEL);
 		if (!text_in) {
 			pr_err("Unable to allocate memory for"
 				" incoming text parameters\n");
-			return -1;
+			goto reject;
 		}
+		cmd->text_in_ptr = text_in;
 
 		memset(iov, 0, 3 * sizeof(struct kvec));
 		iov[niov].iov_base	= text_in;
-		iov[niov++].iov_len	= text_length;
+		iov[niov++].iov_len	= payload_length;
 
 		padding = ((-payload_length) & 3);
 		if (padding != 0) {
@@ -2012,14 +2235,12 @@
 		}
 
 		rx_got = rx_data(conn, &iov[0], niov, rx_size);
-		if (rx_got != rx_size) {
-			kfree(text_in);
-			return -1;
-		}
+		if (rx_got != rx_size)
+			goto reject;
 
 		if (conn->conn_ops->DataDigest) {
 			iscsit_do_crypto_hash_buf(&conn->conn_rx_hash,
-					text_in, text_length,
+					text_in, payload_length,
 					padding, (u8 *)&pad_bytes,
 					(u8 *)&data_crc);
 
@@ -2031,8 +2252,7 @@
 					pr_err("Unable to recover from"
 					" Text Data digest failure while in"
 						" ERL=0.\n");
-					kfree(text_in);
-					return -1;
+					goto reject;
 				} else {
 					/*
 					 * Silently drop this PDU and let the
@@ -2047,67 +2267,22 @@
 			} else {
 				pr_debug("Got CRC32C DataDigest"
 					" 0x%08x for %u bytes of text data.\n",
-						checksum, text_length);
+						checksum, payload_length);
 			}
 		}
-		text_in[text_length - 1] = '\0';
+		text_in[payload_length - 1] = '\0';
 		pr_debug("Successfully read %d bytes of text"
-				" data.\n", text_length);
-
-		if (strncmp("SendTargets", text_in, 11) != 0) {
-			pr_err("Received Text Data that is not"
-				" SendTargets, cannot continue.\n");
-			kfree(text_in);
-			return -1;
-		}
-		text_ptr = strchr(text_in, '=');
-		if (!text_ptr) {
-			pr_err("No \"=\" separator found in Text Data,"
-				"  cannot continue.\n");
-			kfree(text_in);
-			return -1;
-		}
-		if (strncmp("=All", text_ptr, 4) != 0) {
-			pr_err("Unable to locate All value for"
-				" SendTargets key,  cannot continue.\n");
-			kfree(text_in);
-			return -1;
-		}
-/*#warning Support SendTargets=(iSCSI Target Name/Nothing) values. */
-		kfree(text_in);
+				" data.\n", payload_length);
 	}
 
-	cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
-	if (!cmd)
-		return iscsit_add_reject(conn,
-					 ISCSI_REASON_BOOKMARK_NO_RESOURCES, buf);
-
-	cmd->iscsi_opcode	= ISCSI_OP_TEXT;
-	cmd->i_state		= ISTATE_SEND_TEXTRSP;
-	cmd->immediate_cmd	= ((hdr->opcode & ISCSI_OP_IMMEDIATE) ? 1 : 0);
-	conn->sess->init_task_tag = cmd->init_task_tag	= hdr->itt;
-	cmd->targ_xfer_tag	= 0xFFFFFFFF;
-	cmd->cmd_sn		= be32_to_cpu(hdr->cmdsn);
-	cmd->exp_stat_sn	= be32_to_cpu(hdr->exp_statsn);
-	cmd->data_direction	= DMA_NONE;
-
-	spin_lock_bh(&conn->cmd_lock);
-	list_add_tail(&cmd->i_conn_node, &conn->conn_cmd_list);
-	spin_unlock_bh(&conn->cmd_lock);
-
-	iscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr->exp_statsn));
-
-	if (!(hdr->opcode & ISCSI_OP_IMMEDIATE)) {
-		cmdsn_ret = iscsit_sequence_cmd(conn, cmd,
-				(unsigned char *)hdr, hdr->cmdsn);
-		if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)
-			return -1;
-
-		return 0;
-	}
+	return iscsit_process_text_cmd(conn, cmd, hdr);
 
-	return iscsit_execute_cmd(cmd, 0);
+reject:
+	kfree(cmd->text_in_ptr);
+	cmd->text_in_ptr = NULL;
+	return iscsit_reject_cmd(cmd, ISCSI_REASON_PROTOCOL_ERROR, buf);
 }
+EXPORT_SYMBOL(iscsit_handle_text_cmd);
 
 int iscsit_logout_closesession(struct iscsi_cmd *cmd, struct iscsi_conn *conn)
 {
@@ -2472,7 +2647,7 @@
 	if (!found)
 		return;
 
-	cmd = iscsit_allocate_cmd(conn_p, GFP_ATOMIC);
+	cmd = iscsit_allocate_cmd(conn_p, TASK_RUNNING);
 	if (!cmd) {
 		iscsit_dec_conn_usage_count(conn_p);
 		return;
@@ -2618,14 +2793,7 @@
 		return -1;
 	}
 
-	spin_lock_bh(&conn->sess->session_stats_lock);
-	conn->sess->tx_data_octets += datain.length;
-	if (conn->sess->se_sess->se_node_acl) {
-		spin_lock(&conn->sess->se_sess->se_node_acl->stats_lock);
-		conn->sess->se_sess->se_node_acl->read_bytes += datain.length;
-		spin_unlock(&conn->sess->se_sess->se_node_acl->stats_lock);
-	}
-	spin_unlock_bh(&conn->sess->session_stats_lock);
+	atomic_long_add(datain.length, &conn->sess->tx_data_octets);
 	/*
 	 * Special case for successfully execution w/ both DATAIN
 	 * and Sense Data.
@@ -3150,9 +3318,7 @@
 	if (inc_stat_sn)
 		cmd->stat_sn = conn->stat_sn++;
 
-	spin_lock_bh(&conn->sess->session_stats_lock);
-	conn->sess->rsp_pdus++;
-	spin_unlock_bh(&conn->sess->session_stats_lock);
+	atomic_long_inc(&conn->sess->rsp_pdus);
 
 	memset(hdr, 0, ISCSI_HDR_LEN);
 	hdr->opcode		= ISCSI_OP_SCSI_CMD_RSP;
@@ -3269,8 +3435,6 @@
 		return ISCSI_TMF_RSP_NO_LUN;
 	case TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED:
 		return ISCSI_TMF_RSP_NOT_SUPPORTED;
-	case TMR_FUNCTION_AUTHORIZATION_FAILED:
-		return ISCSI_TMF_RSP_AUTH_FAILED;
 	case TMR_FUNCTION_REJECTED:
 	default:
 		return ISCSI_TMF_RSP_REJECTED;
@@ -3356,7 +3520,9 @@
 
 #define SENDTARGETS_BUF_LIMIT 32768U
 
-static int iscsit_build_sendtargets_response(struct iscsi_cmd *cmd)
+static int
+iscsit_build_sendtargets_response(struct iscsi_cmd *cmd,
+				  enum iscsit_transport_type network_transport)
 {
 	char *payload = NULL;
 	struct iscsi_conn *conn = cmd->conn;
@@ -3364,7 +3530,9 @@
 	struct iscsi_tiqn *tiqn;
 	struct iscsi_tpg_np *tpg_np;
 	int buffer_len, end_of_buf = 0, len = 0, payload_len = 0;
+	int target_name_printed;
 	unsigned char buf[ISCSI_IQN_LEN+12]; /* iqn + "TargetName=" + \0 */
+	unsigned char *text_in = cmd->text_in_ptr, *text_ptr = NULL;
 
 	buffer_len = max(conn->conn_ops->MaxRecvDataSegmentLength,
 			 SENDTARGETS_BUF_LIMIT);
@@ -3375,22 +3543,48 @@
 				" response.\n");
 		return -ENOMEM;
 	}
+	/*
+	 * Locate pointer to iqn./eui. string for IFC_SENDTARGETS_SINGLE
+	 * explicit case..
+	 */
+	if (cmd->cmd_flags & IFC_SENDTARGETS_SINGLE) {
+		text_ptr = strchr(text_in, '=');
+		if (!text_ptr) {
+			pr_err("Unable to locate '=' string in text_in:"
+			       " %s\n", text_in);
+			kfree(payload);
+			return -EINVAL;
+		}
+		/*
+		 * Skip over '=' character..
+		 */
+		text_ptr += 1;
+	}
 
 	spin_lock(&tiqn_lock);
 	list_for_each_entry(tiqn, &g_tiqn_list, tiqn_list) {
-		len = sprintf(buf, "TargetName=%s", tiqn->tiqn);
-		len += 1;
-
-		if ((len + payload_len) > buffer_len) {
-			end_of_buf = 1;
-			goto eob;
+		if ((cmd->cmd_flags & IFC_SENDTARGETS_SINGLE) &&
+		     strcmp(tiqn->tiqn, text_ptr)) {
+			continue;
 		}
-		memcpy(payload + payload_len, buf, len);
-		payload_len += len;
+
+		target_name_printed = 0;
 
 		spin_lock(&tiqn->tiqn_tpg_lock);
 		list_for_each_entry(tpg, &tiqn->tiqn_tpg_list, tpg_list) {
 
+			/* If demo_mode_discovery=0 and generate_node_acls=0
+			 * (demo mode dislabed) do not return
+			 * TargetName+TargetAddress unless a NodeACL exists.
+			 */
+
+			if ((tpg->tpg_attrib.generate_node_acls == 0) &&
+			    (tpg->tpg_attrib.demo_mode_discovery == 0) &&
+			    (!core_tpg_get_initiator_node_acl(&tpg->tpg_se_tpg,
+				cmd->conn->sess->sess_ops->InitiatorName))) {
+				continue;
+			}
+
 			spin_lock(&tpg->tpg_state_lock);
 			if ((tpg->tpg_state == TPG_STATE_FREE) ||
 			    (tpg->tpg_state == TPG_STATE_INACTIVE)) {
@@ -3405,13 +3599,30 @@
 				struct iscsi_np *np = tpg_np->tpg_np;
 				bool inaddr_any = iscsit_check_inaddr_any(np);
 
+				if (np->np_network_transport != network_transport)
+					continue;
+
+				if (!target_name_printed) {
+					len = sprintf(buf, "TargetName=%s",
+						      tiqn->tiqn);
+					len += 1;
+
+					if ((len + payload_len) > buffer_len) {
+						spin_unlock(&tpg->tpg_np_lock);
+						spin_unlock(&tiqn->tiqn_tpg_lock);
+						end_of_buf = 1;
+						goto eob;
+					}
+					memcpy(payload + payload_len, buf, len);
+					payload_len += len;
+					target_name_printed = 1;
+				}
+
 				len = sprintf(buf, "TargetAddress="
-					"%s%s%s:%hu,%hu",
-					(np->np_sockaddr.ss_family == AF_INET6) ?
-					"[" : "", (inaddr_any == false) ?
+					"%s:%hu,%hu",
+					(inaddr_any == false) ?
 						np->np_ip : conn->local_ip,
-					(np->np_sockaddr.ss_family == AF_INET6) ?
-					"]" : "", (inaddr_any == false) ?
+					(inaddr_any == false) ?
 						np->np_port : conn->local_port,
 					tpg->tpgt);
 				len += 1;
@@ -3431,6 +3642,9 @@
 eob:
 		if (end_of_buf)
 			break;
+
+		if (cmd->cmd_flags & IFC_SENDTARGETS_SINGLE)
+			break;
 	}
 	spin_unlock(&tiqn_lock);
 
@@ -3439,34 +3653,20 @@
 	return payload_len;
 }
 
-/*
- *	FIXME: Add support for F_BIT and C_BIT when the length is longer than
- *	MaxRecvDataSegmentLength.
- */
-static int iscsit_send_text_rsp(
-	struct iscsi_cmd *cmd,
-	struct iscsi_conn *conn)
+int
+iscsit_build_text_rsp(struct iscsi_cmd *cmd, struct iscsi_conn *conn,
+		      struct iscsi_text_rsp *hdr,
+		      enum iscsit_transport_type network_transport)
 {
-	struct iscsi_text_rsp *hdr;
-	struct kvec *iov;
-	u32 padding = 0, tx_size = 0;
-	int text_length, iov_count = 0;
+	int text_length, padding;
 
-	text_length = iscsit_build_sendtargets_response(cmd);
+	text_length = iscsit_build_sendtargets_response(cmd, network_transport);
 	if (text_length < 0)
 		return text_length;
 
-	padding = ((-text_length) & 3);
-	if (padding != 0) {
-		memset(cmd->buf_ptr + text_length, 0, padding);
-		pr_debug("Attaching %u additional bytes for"
-			" padding.\n", padding);
-	}
-
-	hdr			= (struct iscsi_text_rsp *) cmd->pdu;
-	memset(hdr, 0, ISCSI_HDR_LEN);
 	hdr->opcode		= ISCSI_OP_TEXT_RSP;
 	hdr->flags		|= ISCSI_FLAG_CMD_FINAL;
+	padding = ((-text_length) & 3);
 	hton24(hdr->dlength, text_length);
 	hdr->itt		= cmd->init_task_tag;
 	hdr->ttt		= cpu_to_be32(cmd->targ_xfer_tag);
@@ -3477,14 +3677,39 @@
 	hdr->exp_cmdsn		= cpu_to_be32(conn->sess->exp_cmd_sn);
 	hdr->max_cmdsn		= cpu_to_be32(conn->sess->max_cmd_sn);
 
-	iov = &cmd->iov_misc[0];
+	pr_debug("Built Text Response: ITT: 0x%08x, StatSN: 0x%08x,"
+		" Length: %u, CID: %hu\n", cmd->init_task_tag, cmd->stat_sn,
+		text_length, conn->cid);
 
+	return text_length + padding;
+}
+EXPORT_SYMBOL(iscsit_build_text_rsp);
+
+/*
+ *	FIXME: Add support for F_BIT and C_BIT when the length is longer than
+ *	MaxRecvDataSegmentLength.
+ */
+static int iscsit_send_text_rsp(
+	struct iscsi_cmd *cmd,
+	struct iscsi_conn *conn)
+{
+	struct iscsi_text_rsp *hdr = (struct iscsi_text_rsp *)cmd->pdu;
+	struct kvec *iov;
+	u32 tx_size = 0;
+	int text_length, iov_count = 0, rc;
+
+	rc = iscsit_build_text_rsp(cmd, conn, hdr, ISCSI_TCP);
+	if (rc < 0)
+		return rc;
+
+	text_length = rc;
+	iov = &cmd->iov_misc[0];
 	iov[iov_count].iov_base = cmd->pdu;
 	iov[iov_count++].iov_len = ISCSI_HDR_LEN;
 	iov[iov_count].iov_base	= cmd->buf_ptr;
-	iov[iov_count++].iov_len = text_length + padding;
+	iov[iov_count++].iov_len = text_length;
 
-	tx_size += (ISCSI_HDR_LEN + text_length + padding);
+	tx_size += (ISCSI_HDR_LEN + text_length);
 
 	if (conn->conn_ops->HeaderDigest) {
 		u32 *header_digest = (u32 *)&cmd->pdu[ISCSI_HDR_LEN];
@@ -3500,7 +3725,7 @@
 
 	if (conn->conn_ops->DataDigest) {
 		iscsit_do_crypto_hash_buf(&conn->conn_tx_hash,
-				cmd->buf_ptr, (text_length + padding),
+				cmd->buf_ptr, text_length,
 				0, NULL, (u8 *)&cmd->data_crc);
 
 		iov[iov_count].iov_base	= &cmd->data_crc;
@@ -3508,16 +3733,13 @@
 		tx_size	+= ISCSI_CRC_LEN;
 
 		pr_debug("Attaching DataDigest for %u bytes of text"
-			" data, CRC 0x%08x\n", (text_length + padding),
+			" data, CRC 0x%08x\n", text_length,
 			cmd->data_crc);
 	}
 
 	cmd->iov_misc_count = iov_count;
 	cmd->tx_size = tx_size;
 
-	pr_debug("Built Text Response: ITT: 0x%08x, StatSN: 0x%08x,"
-		" Length: %u, CID: %hu\n", cmd->init_task_tag, cmd->stat_sn,
-			text_length, conn->cid);
 	return 0;
 }
 
@@ -3590,17 +3812,16 @@
 
 void iscsit_thread_get_cpumask(struct iscsi_conn *conn)
 {
-	struct iscsi_thread_set *ts = conn->thread_set;
 	int ord, cpu;
 	/*
-	 * thread_id is assigned from iscsit_global->ts_bitmap from
-	 * within iscsi_thread_set.c:iscsi_allocate_thread_sets()
+	 * bitmap_id is assigned from iscsit_global->ts_bitmap from
+	 * within iscsit_start_kthreads()
 	 *
-	 * Here we use thread_id to determine which CPU that this
-	 * iSCSI connection's iscsi_thread_set will be scheduled to
+	 * Here we use bitmap_id to determine which CPU that this
+	 * iSCSI connection's RX/TX threads will be scheduled to
 	 * execute upon.
 	 */
-	ord = ts->thread_id % cpumask_weight(cpu_online_mask);
+	ord = conn->bitmap_id % cpumask_weight(cpu_online_mask);
 	for_each_online_cpu(cpu) {
 		if (ord-- == 0) {
 			cpumask_set_cpu(cpu, conn->conn_cpumask);
@@ -3792,7 +4013,7 @@
 	switch (state) {
 	case ISTATE_SEND_LOGOUTRSP:
 		if (!iscsit_logout_post_handler(cmd, conn))
-			goto restart;
+			return -ECONNRESET;
 		/* fall through */
 	case ISTATE_SEND_STATUS:
 	case ISTATE_SEND_ASYNCMSG:
@@ -3820,8 +4041,6 @@
 
 err:
 	return -1;
-restart:
-	return -EAGAIN;
 }
 
 static int iscsit_handle_response_queue(struct iscsi_conn *conn)
@@ -3848,21 +4067,13 @@
 int iscsi_target_tx_thread(void *arg)
 {
 	int ret = 0;
-	struct iscsi_conn *conn;
-	struct iscsi_thread_set *ts = arg;
+	struct iscsi_conn *conn = arg;
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
 
-restart:
-	conn = iscsi_tx_thread_pre_handler(ts);
-	if (!conn)
-		goto out;
-
-	ret = 0;
-
 	while (!kthread_should_stop()) {
 		/*
 		 * Ensure that both TX and RX per connection kthreads
@@ -3871,11 +4082,9 @@
 		iscsit_thread_check_cpumask(conn, current, 1);
 
 		wait_event_interruptible(conn->queues_wq,
-					 !iscsit_conn_all_queues_empty(conn) ||
-					 ts->status == ISCSI_THREAD_SET_RESET);
+					 !iscsit_conn_all_queues_empty(conn));
 
-		if ((ts->status == ISCSI_THREAD_SET_RESET) ||
-		     signal_pending(current))
+		if (signal_pending(current))
 			goto transport_err;
 
 get_immediate:
@@ -3886,15 +4095,20 @@
 		ret = iscsit_handle_response_queue(conn);
 		if (ret == 1)
 			goto get_immediate;
-		else if (ret == -EAGAIN)
-			goto restart;
+		else if (ret == -ECONNRESET)
+			goto out;
 		else if (ret < 0)
 			goto transport_err;
 	}
 
 transport_err:
+	/*
+	 * Avoid the normal connection failure code-path if this connection
+	 * is still within LOGIN mode, and iscsi_np process context is
+	 * responsible for cleaning up the early connection failure.
+	 */
+	if (conn->conn_state != TARG_CONN_STATE_IN_LOGIN)
 	iscsit_take_action_for_connection_exit(conn);
-	goto restart;
 out:
 	return 0;
 }
@@ -3907,7 +4121,7 @@
 
 	switch (hdr->opcode & ISCSI_OPCODE_MASK) {
 	case ISCSI_OP_SCSI_CMD:
-		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+		cmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);
 		if (!cmd)
 			goto reject;
 
@@ -3919,24 +4133,28 @@
 	case ISCSI_OP_NOOP_OUT:
 		cmd = NULL;
 		if (hdr->ttt == cpu_to_be32(0xFFFFFFFF)) {
-			cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+			cmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);
 			if (!cmd)
 				goto reject;
 		}
 		ret = iscsit_handle_nop_out(conn, cmd, buf);
 		break;
 	case ISCSI_OP_SCSI_TMFUNC:
-		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+		cmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);
 		if (!cmd)
 			goto reject;
 
 		ret = iscsit_handle_task_mgt_cmd(conn, cmd, buf);
 		break;
 	case ISCSI_OP_TEXT:
-		ret = iscsit_handle_text_cmd(conn, buf);
+		cmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);
+		if (!cmd)
+			goto reject;
+
+		ret = iscsit_handle_text_cmd(conn, cmd, buf);
 		break;
 	case ISCSI_OP_LOGOUT:
-		cmd = iscsit_allocate_cmd(conn, GFP_KERNEL);
+		cmd = iscsit_allocate_cmd(conn, TASK_INTERRUPTIBLE);
 		if (!cmd)
 			goto reject;
 
@@ -3976,33 +4194,33 @@
 
 int iscsi_target_rx_thread(void *arg)
 {
-	int ret;
+	int ret, rc;
 	u8 buffer[ISCSI_HDR_LEN], opcode;
 	u32 checksum = 0, digest = 0;
-	struct iscsi_conn *conn = NULL;
-	struct iscsi_thread_set *ts = arg;
+	struct iscsi_conn *conn = arg;
 	struct kvec iov;
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
 	 */
 	allow_signal(SIGINT);
-
-restart:
-	conn = iscsi_rx_thread_pre_handler(ts);
-	if (!conn)
-		goto out;
+	/*
+	 * Wait for iscsi_post_login_handler() to complete before allowing
+	 * incoming iscsi/tcp socket I/O, and/or failing the connection.
+	 */
+	rc = wait_for_completion_interruptible(&conn->rx_login_comp);
+	if (rc < 0)
+		return 0;
 
 	if (conn->conn_transport->transport_type == ISCSI_INFINIBAND) {
 		struct completion comp;
-		int rc;
 
 		init_completion(&comp);
 		rc = wait_for_completion_interruptible(&comp);
 		if (rc < 0)
 			goto transport_err;
 
-		goto out;
+		goto transport_err;
 	}
 
 	while (!kthread_should_stop()) {
@@ -4024,11 +4242,6 @@
 			goto transport_err;
 		}
 
-		/*
-		 * Set conn->bad_hdr for use with REJECT PDUs.
-		 */
-		memcpy(&conn->bad_hdr, &buffer, ISCSI_HDR_LEN);
-
 		if (conn->conn_ops->HeaderDigest) {
 			iov.iov_base	= &digest;
 			iov.iov_len	= ISCSI_CRC_LEN;
@@ -4052,9 +4265,7 @@
 				 * hit default in the switch below.
 				 */
 				memset(buffer, 0xff, ISCSI_HDR_LEN);
-				spin_lock_bh(&conn->sess->session_stats_lock);
-				conn->sess->conn_digest_errors++;
-				spin_unlock_bh(&conn->sess->session_stats_lock);
+				atomic_long_inc(&conn->sess->conn_digest_errors);
 			} else {
 				pr_debug("Got HeaderDigest CRC32C"
 						" 0x%08x\n", checksum);
@@ -4085,8 +4296,6 @@
 	if (!signal_pending(current))
 		atomic_set(&conn->transport_failed, 1);
 	iscsit_take_action_for_connection_exit(conn);
-	goto restart;
-out:
 	return 0;
 }
 
@@ -4136,13 +4345,36 @@
 	pr_debug("Closing iSCSI connection CID %hu on SID:"
 		" %u\n", conn->cid, sess->sid);
 	/*
-	 * Always up conn_logout_comp just in case the RX Thread is sleeping
-	 * and the logout response never got sent because the connection
-	 * failed.
+	 * Always up conn_logout_comp for the traditional TCP case just in case
+	 * the RX Thread in iscsi_target_rx_opcode() is sleeping and the logout
+	 * response never got sent because the connection failed.
+	 *
+	 * However for iser-target, isert_wait4logout() is using conn_logout_comp
+	 * to signal logout response TX interrupt completion.  Go ahead and skip
+	 * this for iser since isert_rx_opcode() does not wait on logout failure,
+	 * and to avoid iscsi_conn pointer dereference in iser-target code.
 	 */
+	if (conn->conn_transport->transport_type == ISCSI_TCP)
 	complete(&conn->conn_logout_comp);
 
-	iscsi_release_thread_set(conn);
+	if (!strcmp(current->comm, ISCSI_RX_THREAD_NAME)) {
+		if (conn->tx_thread &&
+		    cmpxchg(&conn->tx_thread_active, true, false)) {
+			send_sig(SIGINT, conn->tx_thread, 1);
+			kthread_stop(conn->tx_thread);
+		}
+	} else if (!strcmp(current->comm, ISCSI_TX_THREAD_NAME)) {
+		if (conn->rx_thread &&
+		    cmpxchg(&conn->rx_thread_active, true, false)) {
+			send_sig(SIGINT, conn->rx_thread, 1);
+			kthread_stop(conn->rx_thread);
+		}
+	}
+
+	spin_lock(&iscsit_global->ts_bitmap_lock);
+	bitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,
+			      get_order(1));
+	spin_unlock(&iscsit_global->ts_bitmap_lock);
 
 	iscsit_stop_timers_for_cmds(conn);
 	iscsit_stop_nopin_response_timer(conn);
@@ -4344,7 +4576,7 @@
 
 int iscsit_close_session(struct iscsi_session *sess)
 {
-	struct iscsi_portal_group *tpg = ISCSI_TPG_S(sess);
+	struct iscsi_portal_group *tpg = sess->tpg;
 	struct se_portal_group *se_tpg = &tpg->tpg_se_tpg;
 
 	if (atomic_read(&sess->nconn)) {
@@ -4421,15 +4653,24 @@
 	struct iscsi_conn *conn)
 {
 	struct iscsi_session *sess = conn->sess;
-
-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);
-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);
+	int sleep = 1;
+	/*
+	 * Traditional iscsi/tcp will invoke this logic from TX thread
+	 * context during session logout, so clear tx_thread_active and
+	 * sleep if iscsit_close_connection() has not already occured.
+	 *
+	 * Since iser-target invokes this logic from it's own workqueue,
+	 * always sleep waiting for RX/TX thread shutdown to complete
+	 * within iscsit_close_connection().
+	 */
+	if (conn->conn_transport->transport_type == ISCSI_TCP)
+		sleep = cmpxchg(&conn->tx_thread_active, true, false);
 
 	atomic_set(&conn->conn_logout_remove, 0);
 	complete(&conn->conn_logout_comp);
 
 	iscsit_dec_conn_usage_count(conn);
-	iscsit_stop_session(sess, 1, 1);
+	iscsit_stop_session(sess, sleep, sleep);
 	iscsit_dec_session_usage_count(sess);
 	target_put_session(sess->se_sess);
 }
@@ -4437,13 +4678,15 @@
 static void iscsit_logout_post_handler_samecid(
 	struct iscsi_conn *conn)
 {
-	iscsi_set_thread_clear(conn, ISCSI_CLEAR_TX_THREAD);
-	iscsi_set_thread_set_signal(conn, ISCSI_SIGNAL_TX_THREAD);
+	int sleep = 1;
+
+	if (conn->conn_transport->transport_type == ISCSI_TCP)
+		sleep = cmpxchg(&conn->tx_thread_active, true, false);
 
 	atomic_set(&conn->conn_logout_remove, 0);
 	complete(&conn->conn_logout_comp);
 
-	iscsit_cause_connection_reinstatement(conn, 1);
+	iscsit_cause_connection_reinstatement(conn, sleep);
 	iscsit_dec_conn_usage_count(conn);
 }
 
@@ -4657,6 +4900,7 @@
 	struct iscsi_session *sess;
 	struct se_portal_group *se_tpg = &tpg->tpg_se_tpg;
 	struct se_session *se_sess, *se_sess_tmp;
+	LIST_HEAD(free_list);
 	int session_count = 0;
 
 	spin_lock_bh(&se_tpg->session_lock);
@@ -4678,14 +4922,17 @@
 		}
 		atomic_set(&sess->session_reinstatement, 1);
 		spin_unlock(&sess->conn_lock);
+
+		list_move_tail(&se_sess->sess_list, &free_list);
+	}
 		spin_unlock_bh(&se_tpg->session_lock);
 
-		iscsit_free_session(sess);
-		spin_lock_bh(&se_tpg->session_lock);
+	list_for_each_entry_safe(se_sess, se_sess_tmp, &free_list, sess_list) {
+		sess = (struct iscsi_session *)se_sess->fabric_sess_ptr;
 
+		iscsit_free_session(sess);
 		session_count++;
 	}
-	spin_unlock_bh(&se_tpg->session_lock);
 
 	pr_debug("Released %d iSCSI Session(s) from Target Portal"
 			" Group: %hu\n", session_count, tpg->tpgt);
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_configfs.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_configfs.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_configfs.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_configfs.c	2017-05-02 03:31:56.000000000 +0200
@@ -2,9 +2,7 @@
  * This file contains the configfs implementation for iSCSI Target mode
  * from the LIO-Target Project.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -20,6 +18,7 @@
  ****************************************************************************/
 
 #include <linux/configfs.h>
+#include <linux/ctype.h>
 #include <linux/export.h>
 #include <linux/inet.h>
 #include <target/target_core_base.h>
@@ -78,11 +77,12 @@
 	struct iscsi_tpg_np *tpg_np = container_of(se_tpg_np,
 				struct iscsi_tpg_np, se_tpg_np);
 	struct iscsi_tpg_np *tpg_np_sctp = NULL;
-	char *endptr;
 	u32 op;
 	int ret;
 
-	op = simple_strtoul(page, &endptr, 0);
+	ret = kstrtou32(page, 0, &op);
+	if (ret)
+		return ret;
 	if ((op != 1) && (op != 0)) {
 		pr_err("Illegal value for tpg_enable: %u\n", op);
 		return -EINVAL;
@@ -263,9 +263,9 @@
 		*port_str = '\0'; /* Terminate string for IP */
 		port_str++; /* Skip over ":" */
 
-		ret = strict_strtoul(port_str, 0, &port);
+		ret = kstrtoul(port_str, 0, &port);
 		if (ret < 0) {
-			pr_err("strict_strtoul() failed for port_str: %d\n", ret);
+			pr_err("kstrtoul() failed for port_str: %d\n", ret);
 			return ERR_PTR(ret);
 		}
 		sock_in6 = (struct sockaddr_in6 *)&sockaddr;
@@ -288,9 +288,9 @@
 		*port_str = '\0'; /* Terminate string for IP */
 		port_str++; /* Skip over ":" */
 
-		ret = strict_strtoul(port_str, 0, &port);
+		ret = kstrtoul(port_str, 0, &port);
 		if (ret < 0) {
-			pr_err("strict_strtoul() failed for port_str: %d\n", ret);
+			pr_err("kstrtoul() failed for port_str: %d\n", ret);
 			return ERR_PTR(ret);
 		}
 		sock_in = (struct sockaddr_in *)&sockaddr;
@@ -372,7 +372,7 @@
 	struct iscsi_node_acl *nacl = container_of(se_nacl, struct iscsi_node_acl, \
 					se_node_acl);			\
 									\
-	return sprintf(page, "%u\n", ISCSI_NODE_ATTRIB(nacl)->name);	\
+	return sprintf(page, "%u\n", nacl->node_attrib.name);		\
 }									\
 									\
 static ssize_t iscsi_nacl_attrib_store_##name(				\
@@ -382,11 +382,12 @@
 {									\
 	struct iscsi_node_acl *nacl = container_of(se_nacl, struct iscsi_node_acl, \
 					se_node_acl);			\
-	char *endptr;							\
 	u32 val;							\
 	int ret;							\
 									\
-	val = simple_strtoul(page, &endptr, 0);				\
+	ret = kstrtou32(page, 0, &val);					\
+	if (ret)							\
+		return ret;						\
 	ret = iscsit_na_##name(nacl, val);				\
 	if (ret < 0)							\
 		return ret;						\
@@ -473,7 +474,8 @@
 									\
 	if (!capable(CAP_SYS_ADMIN))					\
 		return -EPERM;						\
-									\
+	if (count >= sizeof(auth->name))				\
+		return -EINVAL;						\
 	snprintf(auth->name, sizeof(auth->name), "%s", page);		\
 	if (!strncmp("NULL", auth->name, 4))				\
 		auth->naf_flags &= ~flags;				\
@@ -789,11 +791,12 @@
 	struct iscsi_portal_group *tpg = container_of(se_tpg,
 			struct iscsi_portal_group, tpg_se_tpg);
 	struct config_item *acl_ci, *tpg_ci, *wwn_ci;
-	char *endptr;
 	u32 cmdsn_depth = 0;
 	int ret;
 
-	cmdsn_depth = simple_strtoul(page, &endptr, 0);
+	ret = kstrtou32(page, 0, &cmdsn_depth);
+	if (ret)
+		return ret;
 	if (cmdsn_depth > TA_DEFAULT_CMDSN_DEPTH_MAX) {
 		pr_err("Passed cmdsn_depth: %u exceeds"
 			" TA_DEFAULT_CMDSN_DEPTH_MAX: %u\n", cmdsn_depth,
@@ -895,7 +898,7 @@
 	if (!se_nacl_new)
 		return ERR_PTR(-ENOMEM);
 
-	cmdsn_depth = ISCSI_TPG_ATTRIB(tpg)->default_cmdsn_depth;
+	cmdsn_depth = tpg->tpg_attrib.default_cmdsn_depth;
 	/*
 	 * se_nacl_new may be released by core_tpg_add_initiator_node_acl()
 	 * when converting a NdoeACL from demo mode -> explict
@@ -918,9 +921,9 @@
 		return ERR_PTR(-ENOMEM);
 	}
 
-	stats_cg->default_groups[0] = &NODE_STAT_GRPS(acl)->iscsi_sess_stats_group;
+	stats_cg->default_groups[0] = &acl->node_stat_grps.iscsi_sess_stats_group;
 	stats_cg->default_groups[1] = NULL;
-	config_group_init_type_name(&NODE_STAT_GRPS(acl)->iscsi_sess_stats_group,
+	config_group_init_type_name(&acl->node_stat_grps.iscsi_sess_stats_group,
 			"iscsi_sess_stats", &iscsi_stat_sess_cit);
 
 	return se_nacl;
@@ -965,7 +968,7 @@
 	if (iscsit_get_tpg(tpg) < 0)					\
 		return -EINVAL;						\
 									\
-	rb = sprintf(page, "%u\n", ISCSI_TPG_ATTRIB(tpg)->name);	\
+	rb = sprintf(page, "%u\n", tpg->tpg_attrib.name);		\
 	iscsit_put_tpg(tpg);						\
 	return rb;							\
 }									\
@@ -977,14 +980,15 @@
 {									\
 	struct iscsi_portal_group *tpg = container_of(se_tpg,		\
 			struct iscsi_portal_group, tpg_se_tpg);	\
-	char *endptr;							\
 	u32 val;							\
 	int ret;							\
 									\
 	if (iscsit_get_tpg(tpg) < 0)					\
 		return -EINVAL;						\
 									\
-	val = simple_strtoul(page, &endptr, 0);				\
+	ret = kstrtou32(page, 0, &val);					\
+	if (ret)							\
+		goto out;						\
 	ret = iscsit_ta_##name(tpg, val);				\
 	if (ret < 0)							\
 		goto out;						\
@@ -1038,6 +1042,16 @@
  */
 DEF_TPG_ATTRIB(prod_mode_write_protect);
 TPG_ATTR(prod_mode_write_protect, S_IRUGO | S_IWUSR);
+/*
+ * Define iscsi_tpg_attrib_s_demo_mode_discovery,
+ */
+DEF_TPG_ATTRIB(demo_mode_discovery);
+TPG_ATTR(demo_mode_discovery, S_IRUGO | S_IWUSR);
+/*
+ * Define iscsi_tpg_attrib_s_default_erl
+ */
+DEF_TPG_ATTRIB(default_erl);
+TPG_ATTR(default_erl, S_IRUGO | S_IWUSR);
 
 static struct configfs_attribute *lio_target_tpg_attrib_attrs[] = {
 	&iscsi_tpg_attrib_authentication.attr,
@@ -1048,11 +1062,138 @@
 	&iscsi_tpg_attrib_cache_dynamic_acls.attr,
 	&iscsi_tpg_attrib_demo_mode_write_protect.attr,
 	&iscsi_tpg_attrib_prod_mode_write_protect.attr,
+	&iscsi_tpg_attrib_demo_mode_discovery.attr,
+	&iscsi_tpg_attrib_default_erl.attr,
 	NULL,
 };
 
 /* End items for lio_target_tpg_attrib_cit */
 
+/* Start items for lio_target_tpg_auth_cit */
+
+#define __DEF_TPG_AUTH_STR(prefix, name, flags)					\
+static ssize_t __iscsi_##prefix##_show_##name(					\
+	struct se_portal_group *se_tpg,						\
+	char *page)								\
+{										\
+	struct iscsi_portal_group *tpg = container_of(se_tpg,			\
+				struct iscsi_portal_group, tpg_se_tpg);		\
+	struct iscsi_node_auth *auth = &tpg->tpg_demo_auth;			\
+										\
+	if (!capable(CAP_SYS_ADMIN))						\
+		return -EPERM;							\
+										\
+	return snprintf(page, PAGE_SIZE, "%s\n", auth->name);			\
+}										\
+										\
+static ssize_t __iscsi_##prefix##_store_##name(					\
+	struct se_portal_group *se_tpg,						\
+	const char *page,							\
+	size_t count)								\
+{										\
+	struct iscsi_portal_group *tpg = container_of(se_tpg,			\
+				struct iscsi_portal_group, tpg_se_tpg);		\
+	struct iscsi_node_auth *auth = &tpg->tpg_demo_auth;			\
+										\
+	if (!capable(CAP_SYS_ADMIN))						\
+		return -EPERM;							\
+										\
+	snprintf(auth->name, sizeof(auth->name), "%s", page);			\
+	if (!(strncmp("NULL", auth->name, 4)))					\
+		auth->naf_flags &= ~flags;					\
+	else									\
+		auth->naf_flags |= flags;					\
+										\
+	if ((auth->naf_flags & NAF_USERID_IN_SET) &&				\
+	    (auth->naf_flags & NAF_PASSWORD_IN_SET))				\
+		auth->authenticate_target = 1;					\
+	else									\
+		auth->authenticate_target = 0;					\
+										\
+	return count;								\
+}
+
+#define __DEF_TPG_AUTH_INT(prefix, name)					\
+static ssize_t __iscsi_##prefix##_show_##name(					\
+	struct se_portal_group *se_tpg,						\
+	char *page)								\
+{										\
+	struct iscsi_portal_group *tpg = container_of(se_tpg,			\
+				struct iscsi_portal_group, tpg_se_tpg);		\
+	struct iscsi_node_auth *auth = &tpg->tpg_demo_auth;			\
+										\
+	if (!capable(CAP_SYS_ADMIN))						\
+		return -EPERM;							\
+										\
+	return snprintf(page, PAGE_SIZE, "%d\n", auth->name);			\
+}
+
+#define DEF_TPG_AUTH_STR(name, flags)						\
+	__DEF_TPG_AUTH_STR(tpg_auth, name, flags)				\
+static ssize_t iscsi_tpg_auth_show_##name(					\
+	struct se_portal_group *se_tpg,						\
+	char *page)								\
+{										\
+	return __iscsi_tpg_auth_show_##name(se_tpg, page);			\
+}										\
+										\
+static ssize_t iscsi_tpg_auth_store_##name(					\
+	struct se_portal_group *se_tpg,						\
+	const char *page,							\
+	size_t count)								\
+{										\
+	return __iscsi_tpg_auth_store_##name(se_tpg, page, count);		\
+}
+
+#define DEF_TPG_AUTH_INT(name)							\
+	__DEF_TPG_AUTH_INT(tpg_auth, name)					\
+static ssize_t iscsi_tpg_auth_show_##name(					\
+	struct se_portal_group *se_tpg,						\
+	char *page)								\
+{										\
+	return __iscsi_tpg_auth_show_##name(se_tpg, page);			\
+}
+
+#define TPG_AUTH_ATTR(_name, _mode) TF_TPG_AUTH_ATTR(iscsi, _name, _mode);
+#define TPG_AUTH_ATTR_RO(_name) TF_TPG_AUTH_ATTR_RO(iscsi, _name);
+
+/*
+ *  * One-way authentication userid
+ *   */
+DEF_TPG_AUTH_STR(userid, NAF_USERID_SET);
+TPG_AUTH_ATTR(userid, S_IRUGO | S_IWUSR);
+/*
+ *  * One-way authentication password
+ *   */
+DEF_TPG_AUTH_STR(password, NAF_PASSWORD_SET);
+TPG_AUTH_ATTR(password, S_IRUGO | S_IWUSR);
+/*
+ *  * Enforce mutual authentication
+ *   */
+DEF_TPG_AUTH_INT(authenticate_target);
+TPG_AUTH_ATTR_RO(authenticate_target);
+/*
+ *  * Mutual authentication userid
+ *   */
+DEF_TPG_AUTH_STR(userid_mutual, NAF_USERID_IN_SET);
+TPG_AUTH_ATTR(userid_mutual, S_IRUGO | S_IWUSR);
+/*
+ *  * Mutual authentication password
+ *   */
+DEF_TPG_AUTH_STR(password_mutual, NAF_PASSWORD_IN_SET);
+TPG_AUTH_ATTR(password_mutual, S_IRUGO | S_IWUSR);
+
+static struct configfs_attribute *lio_target_tpg_auth_attrs[] = {
+	&iscsi_tpg_auth_userid.attr,
+	&iscsi_tpg_auth_password.attr,
+	&iscsi_tpg_auth_authenticate_target.attr,
+	&iscsi_tpg_auth_userid_mutual.attr,
+	&iscsi_tpg_auth_password_mutual.attr,
+	NULL,
+};
+
+/* End items for lio_target_tpg_auth_cit */
+
 /* Start items for lio_target_tpg_param_cit */
 
 #define DEF_TPG_PARAM(name)						\
@@ -1087,13 +1228,14 @@
 	struct iscsi_portal_group *tpg = container_of(se_tpg,		\
 			struct iscsi_portal_group, tpg_se_tpg);		\
 	char *buf;							\
-	int ret;							\
+	int ret, len;							\
 									\
 	buf = kzalloc(PAGE_SIZE, GFP_KERNEL);				\
 	if (!buf)							\
 		return -ENOMEM;						\
-	snprintf(buf, PAGE_SIZE, "%s=%s", __stringify(name), page);	\
-	buf[strlen(buf)-1] = '\0'; /* Kill newline */			\
+	len = snprintf(buf, PAGE_SIZE, "%s=%s", __stringify(name), page);	\
+	if (isspace(buf[len-1]))					\
+		buf[len-1] = '\0'; /* Kill newline */			\
 									\
 	if (iscsit_get_tpg(tpg) < 0) {					\
 		kfree(buf);						\
@@ -1230,11 +1372,12 @@
 {
 	struct iscsi_portal_group *tpg = container_of(se_tpg,
 			struct iscsi_portal_group, tpg_se_tpg);
-	char *endptr;
 	u32 op;
-	int ret = 0;
+	int ret;
 
-	op = simple_strtoul(page, &endptr, 0);
+	ret = kstrtou32(page, 0, &op);
+	if (ret)
+		return ret;
 	if ((op != 1) && (op != 0)) {
 		pr_err("Illegal value for tpg_enable: %u\n", op);
 		return -EINVAL;
@@ -1282,9 +1425,9 @@
 {
 	struct iscsi_portal_group *tpg;
 	struct iscsi_tiqn *tiqn;
-	char *tpgt_str, *end_ptr;
-	int ret = 0;
-	unsigned short int tpgt;
+	char *tpgt_str;
+	int ret;
+	u16 tpgt;
 
 	tiqn = container_of(wwn, struct iscsi_tiqn, tiqn_wwn);
 	/*
@@ -1298,7 +1441,9 @@
 		return NULL;
 	}
 	tpgt_str += 5; /* Skip ahead of "tpgt_" */
-	tpgt = (unsigned short int) simple_strtoul(tpgt_str, &end_ptr, 0);
+	ret = kstrtou16(tpgt_str, 0, &tpgt);
+	if (ret)
+		return NULL;
 
 	tpg = iscsit_alloc_portal_group(tiqn, tpgt);
 	if (!tpg)
@@ -1347,7 +1492,7 @@
 	struct target_fabric_configfs *tf,
 	char *page)
 {
-	return sprintf(page, "RisingTide Systems Linux-iSCSI Target "ISCSIT_VERSION"\n");
+	return sprintf(page, "Datera Inc. iSCSI Target "ISCSIT_VERSION"\n");
 }
 
 TF_WWN_ATTR_RO(lio_target, lio_version);
@@ -1382,21 +1527,21 @@
 		return ERR_PTR(-ENOMEM);
 	}
 
-	stats_cg->default_groups[0] = &WWN_STAT_GRPS(tiqn)->iscsi_instance_group;
-	stats_cg->default_groups[1] = &WWN_STAT_GRPS(tiqn)->iscsi_sess_err_group;
-	stats_cg->default_groups[2] = &WWN_STAT_GRPS(tiqn)->iscsi_tgt_attr_group;
-	stats_cg->default_groups[3] = &WWN_STAT_GRPS(tiqn)->iscsi_login_stats_group;
-	stats_cg->default_groups[4] = &WWN_STAT_GRPS(tiqn)->iscsi_logout_stats_group;
+	stats_cg->default_groups[0] = &tiqn->tiqn_stat_grps.iscsi_instance_group;
+	stats_cg->default_groups[1] = &tiqn->tiqn_stat_grps.iscsi_sess_err_group;
+	stats_cg->default_groups[2] = &tiqn->tiqn_stat_grps.iscsi_tgt_attr_group;
+	stats_cg->default_groups[3] = &tiqn->tiqn_stat_grps.iscsi_login_stats_group;
+	stats_cg->default_groups[4] = &tiqn->tiqn_stat_grps.iscsi_logout_stats_group;
 	stats_cg->default_groups[5] = NULL;
-	config_group_init_type_name(&WWN_STAT_GRPS(tiqn)->iscsi_instance_group,
+	config_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_instance_group,
 			"iscsi_instance", &iscsi_stat_instance_cit);
-	config_group_init_type_name(&WWN_STAT_GRPS(tiqn)->iscsi_sess_err_group,
+	config_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_sess_err_group,
 			"iscsi_sess_err", &iscsi_stat_sess_err_cit);
-	config_group_init_type_name(&WWN_STAT_GRPS(tiqn)->iscsi_tgt_attr_group,
+	config_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_tgt_attr_group,
 			"iscsi_tgt_attr", &iscsi_stat_tgt_attr_cit);
-	config_group_init_type_name(&WWN_STAT_GRPS(tiqn)->iscsi_login_stats_group,
+	config_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_login_stats_group,
 			"iscsi_login_stats", &iscsi_stat_login_cit);
-	config_group_init_type_name(&WWN_STAT_GRPS(tiqn)->iscsi_logout_stats_group,
+	config_group_init_type_name(&tiqn->tiqn_stat_grps.iscsi_logout_stats_group,
 			"iscsi_logout_stats", &iscsi_stat_logout_cit);
 
 	pr_debug("LIO_Target_ConfigFS: REGISTER -> %s\n", tiqn->tiqn);
@@ -1506,10 +1651,12 @@
 {
 	struct iscsi_param *param;
 	struct iscsi_portal_group *discovery_tpg = iscsit_global->discovery_tpg;
-	char *endptr;
 	u32 op;
+	int err;
 
-	op = simple_strtoul(page, &endptr, 0);
+	err = kstrtou32(page, 0, &op);
+	if (err)
+		return -EINVAL;
 	if ((op != 1) && (op != 0)) {
 		pr_err("Illegal value for enforce_discovery_auth:"
 				" %u\n", op);
@@ -1660,13 +1807,12 @@
 	return 0;
 }
 
-static int lio_queue_tm_rsp(struct se_cmd *se_cmd)
+static void lio_queue_tm_rsp(struct se_cmd *se_cmd)
 {
 	struct iscsi_cmd *cmd = container_of(se_cmd, struct iscsi_cmd, se_cmd);
 
 	cmd->i_state = ISTATE_SEND_TASKMGTRSP;
 	iscsit_add_cmd_to_response_queue(cmd, cmd->conn, cmd->i_state);
-	return 0;
 }
 
 static char *lio_tpg_get_endpoint_wwn(struct se_portal_group *se_tpg)
@@ -1687,21 +1833,21 @@
 {
 	struct iscsi_portal_group *tpg = se_tpg->se_tpg_fabric_ptr;
 
-	return ISCSI_TPG_ATTRIB(tpg)->default_cmdsn_depth;
+	return tpg->tpg_attrib.default_cmdsn_depth;
 }
 
 static int lio_tpg_check_demo_mode(struct se_portal_group *se_tpg)
 {
 	struct iscsi_portal_group *tpg = se_tpg->se_tpg_fabric_ptr;
 
-	return ISCSI_TPG_ATTRIB(tpg)->generate_node_acls;
+	return tpg->tpg_attrib.generate_node_acls;
 }
 
 static int lio_tpg_check_demo_mode_cache(struct se_portal_group *se_tpg)
 {
 	struct iscsi_portal_group *tpg = se_tpg->se_tpg_fabric_ptr;
 
-	return ISCSI_TPG_ATTRIB(tpg)->cache_dynamic_acls;
+	return tpg->tpg_attrib.cache_dynamic_acls;
 }
 
 static int lio_tpg_check_demo_mode_write_protect(
@@ -1709,7 +1855,7 @@
 {
 	struct iscsi_portal_group *tpg = se_tpg->se_tpg_fabric_ptr;
 
-	return ISCSI_TPG_ATTRIB(tpg)->demo_mode_write_protect;
+	return tpg->tpg_attrib.demo_mode_write_protect;
 }
 
 static int lio_tpg_check_prod_mode_write_protect(
@@ -1717,7 +1863,7 @@
 {
 	struct iscsi_portal_group *tpg = se_tpg->se_tpg_fabric_ptr;
 
-	return ISCSI_TPG_ATTRIB(tpg)->prod_mode_write_protect;
+	return tpg->tpg_attrib.prod_mode_write_protect;
 }
 
 static void lio_tpg_release_fabric_acl(
@@ -1780,9 +1926,12 @@
 {
 	struct iscsi_node_acl *acl = container_of(se_acl, struct iscsi_node_acl,
 				se_node_acl);
+	struct se_portal_group *se_tpg = se_acl->se_tpg;
+	struct iscsi_portal_group *tpg = container_of(se_tpg,
+				struct iscsi_portal_group, tpg_se_tpg);
 
-	ISCSI_NODE_ATTRIB(acl)->nacl = acl;
-	iscsit_set_default_node_attribues(acl);
+	acl->node_attrib.nacl = acl;
+	iscsit_set_default_node_attribues(acl, tpg);
 }
 
 static int lio_check_stop_free(struct se_cmd *se_cmd)
@@ -1795,7 +1944,7 @@
 	struct iscsi_cmd *cmd = container_of(se_cmd, struct iscsi_cmd, se_cmd);
 
 	pr_debug("Entering lio_release_cmd for se_cmd: %p\n", se_cmd);
-	cmd->release_cmd(cmd);
+	iscsit_release_cmd(cmd);
 }
 
 /* End functions for target_core_fabric_ops */
@@ -1867,16 +2016,17 @@
 	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 	 * sturct config_item_type's
 	 */
-	TF_CIT_TMPL(fabric)->tfc_discovery_cit.ct_attrs = lio_target_discovery_auth_attrs;
-	TF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = lio_target_wwn_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = lio_target_tpg_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = lio_target_tpg_attrib_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = lio_target_tpg_param_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = lio_target_portal_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_base_cit.ct_attrs = lio_target_initiator_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_attrib_cit.ct_attrs = lio_target_nacl_attrib_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_auth_cit.ct_attrs = lio_target_nacl_auth_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_param_cit.ct_attrs = lio_target_nacl_param_attrs;
+	fabric->tf_cit_tmpl.tfc_discovery_cit.ct_attrs = lio_target_discovery_auth_attrs;
+	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = lio_target_wwn_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = lio_target_tpg_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = lio_target_tpg_attrib_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_auth_cit.ct_attrs = lio_target_tpg_auth_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = lio_target_tpg_param_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = lio_target_portal_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs = lio_target_initiator_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = lio_target_nacl_attrib_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = lio_target_nacl_auth_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = lio_target_nacl_param_attrs;
 
 	ret = target_fabric_configfs_register(fabric);
 	if (ret < 0) {
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_core.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_core.h
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_core.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_core.h	2017-05-02 03:31:56.000000000 +0200
@@ -9,7 +9,7 @@
 #include <scsi/iscsi_proto.h>
 #include <target/target_core_base.h>
 
-#define ISCSIT_VERSION			"v4.1.0-rc2"
+#define ISCSIT_VERSION			"v4.1.0"
 #define ISCSI_MAX_DATASN_MISSING_COUNT	16
 #define ISCSI_TX_THREAD_TCP_TIMEOUT	2
 #define ISCSI_RX_THREAD_TCP_TIMEOUT	2
@@ -17,6 +17,9 @@
 #define SECONDS_FOR_ASYNC_TEXT		10
 #define SECONDS_FOR_LOGOUT_COMP		15
 #define WHITE_SPACE			" \t\v\f\n\r"
+#define ISCSIT_MIN_TAGS			16
+#define ISCSIT_EXTRA_TAGS		8
+#define ISCSIT_TCP_BACKLOG		256
 
 /* struct iscsi_node_attrib sanity values */
 #define NA_DATAOUT_TIMEOUT		3
@@ -34,9 +37,6 @@
 #define NA_RANDOM_DATAIN_PDU_OFFSETS	0
 #define NA_RANDOM_DATAIN_SEQ_OFFSETS	0
 #define NA_RANDOM_R2T_OFFSETS		0
-#define NA_DEFAULT_ERL			0
-#define NA_DEFAULT_ERL_MAX		2
-#define NA_DEFAULT_ERL_MIN		0
 
 /* struct iscsi_tpg_attrib sanity values */
 #define TA_AUTHENTICATION		1
@@ -47,7 +47,7 @@
 #define TA_NETIF_TIMEOUT_MAX		15
 #define TA_NETIF_TIMEOUT_MIN		2
 #define TA_GENERATE_NODE_ACLS		0
-#define TA_DEFAULT_CMDSN_DEPTH		16
+#define TA_DEFAULT_CMDSN_DEPTH		64
 #define TA_DEFAULT_CMDSN_DEPTH_MAX	512
 #define TA_DEFAULT_CMDSN_DEPTH_MIN	1
 #define TA_CACHE_DYNAMIC_ACLS		0
@@ -55,6 +55,8 @@
 #define TA_DEMO_MODE_WRITE_PROTECT	1
 /* Disabled by default in production mode w/ explict ACLs */
 #define TA_PROD_MODE_WRITE_PROTECT	0
+#define TA_DEMO_MODE_DISCOVERY		1
+#define TA_DEFAULT_ERL			0
 #define TA_CACHE_CORE_NPS		0
 
 
@@ -132,6 +134,8 @@
 	ICF_CONTIG_MEMORY			= 0x00000020,
 	ICF_ATTACHED_TO_RQUEUE			= 0x00000040,
 	ICF_OOO_CMDSN				= 0x00000080,
+	IFC_SENDTARGETS_ALL			= 0x00000100,
+	IFC_SENDTARGETS_SINGLE			= 0x00000200,
 };
 
 /* struct iscsi_cmd->i_state */
@@ -187,6 +191,7 @@
 	CMDSN_NORMAL_OPERATION		= 0,
 	CMDSN_LOWER_THAN_EXP		= 1,
 	CMDSN_HIGHER_THAN_EXP		= 2,
+	CMDSN_MAXCMDSN_OVERRUN		= 3,
 };
 
 /* Used for iscsi_handle_immediate_data() return values */
@@ -428,6 +433,8 @@
 	u32			tx_size;
 	/* Buffer used for various purposes */
 	void			*buf_ptr;
+	/* Used by SendTargets=[iqn.,eui.] discovery */
+	void			*text_in_ptr;
 	/* See include/linux/dma-mapping.h */
 	enum dma_data_direction	data_direction;
 	/* iSCSI PDU Header + CRC */
@@ -485,7 +492,6 @@
 	u32			first_data_sg_off;
 	u32			kmapped_nents;
 	sense_reason_t		sense_reason;
-	void (*release_cmd)(struct iscsi_cmd *);
 }  ____cacheline_aligned;
 
 struct iscsi_tmr_req {
@@ -528,8 +534,6 @@
 	u32			of_marker;
 	/* Used for calculating OFMarker offset to next PDU */
 	u32			of_marker_offset;
-	/* Complete Bad PDU for sending reject */
-	unsigned char		bad_hdr[ISCSI_HDR_LEN];
 #define IPV6_ADDRESS_SPACE				48
 	unsigned char		login_ip[IPV6_ADDRESS_SPACE];
 	unsigned char		local_ip[IPV6_ADDRESS_SPACE];
@@ -552,9 +556,19 @@
 	struct completion	rx_half_close_comp;
 	/* socket used by this connection */
 	struct socket		*sock;
+	void			(*orig_data_ready)(struct sock *, int);
+	void			(*orig_state_change)(struct sock *);
+#define LOGIN_FLAGS_READ_ACTIVE		1
+#define LOGIN_FLAGS_CLOSED		2
+#define LOGIN_FLAGS_READY		4
+	unsigned long		login_flags;
+	struct delayed_work	login_work;
+	struct delayed_work	login_cleanup_work;
+	struct iscsi_login	*login;
 	struct timer_list	nopin_timer;
 	struct timer_list	nopin_response_timer;
 	struct timer_list	transport_timer;
+	struct task_struct	*login_kworker;
 	/* Spinlock used for add/deleting cmd's from conn_cmd_list */
 	spinlock_t		cmd_lock;
 	spinlock_t		conn_usage_lock;
@@ -582,10 +596,17 @@
 	void			*context;
 	struct iscsi_login_thread_s *login_thread;
 	struct iscsi_portal_group *tpg;
+	struct iscsi_tpg_np	*tpg_np;
 	/* Pointer to parent session */
 	struct iscsi_session	*sess;
 	/* Pointer to thread_set in use for this conn's threads */
 	struct iscsi_thread_set	*thread_set;
+	int			bitmap_id;
+	int			rx_thread_active;
+	struct task_struct	*rx_thread;
+	struct completion	rx_login_comp;
+	int			tx_thread_active;
+	struct task_struct	*tx_thread;
 	/* list_head for session connection list */
 	struct list_head	conn_list;
 } ____cacheline_aligned;
@@ -635,14 +656,13 @@
 	/* Used for session reference counting */
 	int			session_usage_count;
 	int			session_waiting_on_uc;
-	u32			cmd_pdus;
-	u32			rsp_pdus;
-	u64			tx_data_octets;
-	u64			rx_data_octets;
-	u32			conn_digest_errors;
-	u32			conn_timeout_errors;
+	atomic_long_t		cmd_pdus;
+	atomic_long_t		rsp_pdus;
+	atomic_long_t		tx_data_octets;
+	atomic_long_t		rx_data_octets;
+	atomic_long_t		conn_digest_errors;
+	atomic_long_t		conn_timeout_errors;
 	u64			creation_time;
-	spinlock_t		session_stats_lock;
 	/* Number of active connections */
 	atomic_t		nconn;
 	atomic_t		session_continuation;
@@ -680,6 +700,7 @@
 	u8 version_max;
 	u8 login_complete;
 	u8 login_failed;
+	bool zero_tsih;
 	char isid[6];
 	u32 cmd_sn;
 	itt_t init_task_tag;
@@ -692,6 +713,7 @@
 	char *req_buf;
 	char *rsp_buf;
 	struct iscsi_conn *conn;
+	struct iscsi_np *np;
 } ____cacheline_aligned;
 
 struct iscsi_node_attrib {
@@ -738,11 +760,6 @@
 	struct se_node_acl	se_node_acl;
 };
 
-#define NODE_STAT_GRPS(nacl)	(&(nacl)->node_stat_grps)
-
-#define ISCSI_NODE_ATTRIB(t)	(&(t)->node_attrib)
-#define ISCSI_NODE_AUTH(t)	(&(t)->node_auth)
-
 struct iscsi_tpg_attrib {
 	u32			authentication;
 	u32			login_timeout;
@@ -752,6 +769,8 @@
 	u32			default_cmdsn_depth;
 	u32			demo_mode_write_protect;
 	u32			prod_mode_write_protect;
+	u32			demo_mode_discovery;
+	u32			default_erl;
 	struct iscsi_portal_group *tpg;
 };
 
@@ -772,7 +791,6 @@
 	struct __kernel_sockaddr_storage np_sockaddr;
 	struct task_struct	*np_thread;
 	struct timer_list	np_login_timer;
-	struct iscsi_portal_group *np_login_tpg;
 	void			*np_context;
 	struct iscsit_transport *np_transport;
 	struct list_head	np_list;
@@ -787,6 +805,8 @@
 	struct list_head	tpg_np_parent_list;
 	struct se_tpg_np	se_tpg_np;
 	spinlock_t		tpg_np_parent_lock;
+	struct completion	tpg_np_comp;
+	struct kref		tpg_np_kref;
 };
 
 struct iscsi_portal_group {
@@ -808,8 +828,9 @@
 	spinlock_t		tpg_state_lock;
 	struct se_portal_group tpg_se_tpg;
 	struct mutex		tpg_access_lock;
-	struct mutex		np_login_lock;
+	struct semaphore	np_login_sem;
 	struct iscsi_tpg_attrib	tpg_attrib;
+	struct iscsi_node_auth	tpg_demo_auth;
 	/* Pointer to default list of iSCSI parameters for TPG */
 	struct iscsi_param_list	*param_list;
 	struct iscsi_tiqn	*tpg_tiqn;
@@ -817,12 +838,6 @@
 	struct list_head	tpg_list;
 } ____cacheline_aligned;
 
-#define ISCSI_TPG_C(c)		((struct iscsi_portal_group *)(c)->tpg)
-#define ISCSI_TPG_LUN(c, l)  ((iscsi_tpg_list_t *)(c)->tpg->tpg_lun_list_t[l])
-#define ISCSI_TPG_S(s)		((struct iscsi_portal_group *)(s)->tpg)
-#define ISCSI_TPG_ATTRIB(t)	(&(t)->tpg_attrib)
-#define SE_TPG(tpg)		(&(tpg)->tpg_se_tpg)
-
 struct iscsi_wwn_stat_grps {
 	struct config_group	iscsi_stat_group;
 	struct config_group	iscsi_instance_group;
@@ -853,8 +868,6 @@
 	struct iscsi_logout_stats    logout_stats;
 } ____cacheline_aligned;
 
-#define WWN_STAT_GRPS(tiqn)	(&(tiqn)->tiqn_stat_grps)
-
 struct iscsit_global {
 	/* In core shutdown */
 	u32			in_shutdown;
@@ -862,13 +875,20 @@
 	/* Unique identifier used for the authentication daemon */
 	u32			auth_id;
 	u32			inactive_ts;
+#define ISCSIT_BITMAP_BITS	262144
 	/* Thread Set bitmap count */
 	int			ts_bitmap_count;
 	/* Thread Set bitmap pointer */
 	unsigned long		*ts_bitmap;
+	spinlock_t		ts_bitmap_lock;
 	/* Used for iSCSI discovery session authentication */
 	struct iscsi_node_acl	discovery_acl;
 	struct iscsi_portal_group	*discovery_tpg;
+
+	struct list_head        *tiqn_list;
+	struct list_head	*np_list;
+	spinlock_t		*tiqn_lock;
+	spinlock_t		*np_lock;
 };
 
 #endif /* ISCSI_TARGET_CORE_H */
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_datain_values.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_datain_values.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_datain_values.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_datain_values.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains the iSCSI Target DataIN value generation functions.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_device.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_device.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_device.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_device.c	2017-05-02 03:31:56.000000000 +0200
@@ -2,9 +2,7 @@
  * This file contains the iSCSI Virtual Device and Disk Transport
  * agnostic related functions.
  *
- \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_erl0.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_erl0.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_erl0.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_erl0.c	2017-05-02 03:31:56.000000000 +0200
@@ -2,9 +2,7 @@
  * This file contains error recovery level zero functions used by
  * the iSCSI Target driver.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -759,7 +757,7 @@
 static void iscsit_handle_time2retain_timeout(unsigned long data)
 {
 	struct iscsi_session *sess = (struct iscsi_session *) data;
-	struct iscsi_portal_group *tpg = ISCSI_TPG_S(sess);
+	struct iscsi_portal_group *tpg = sess->tpg;
 	struct se_portal_group *se_tpg = &tpg->tpg_se_tpg;
 
 	spin_lock_bh(&se_tpg->session_lock);
@@ -787,7 +785,7 @@
 		tiqn->sess_err_stats.last_sess_failure_type =
 				ISCSI_SESS_ERR_CXN_TIMEOUT;
 		tiqn->sess_err_stats.cxn_timeout_errors++;
-		sess->conn_timeout_errors++;
+		atomic_long_inc(&sess->conn_timeout_errors);
 		spin_unlock(&tiqn->sess_err_stats.lock);
 	}
 	}
@@ -803,9 +801,9 @@
 	 * Only start Time2Retain timer when the associated TPG is still in
 	 * an ACTIVE (eg: not disabled or shutdown) state.
 	 */
-	spin_lock(&ISCSI_TPG_S(sess)->tpg_state_lock);
-	tpg_active = (ISCSI_TPG_S(sess)->tpg_state == TPG_STATE_ACTIVE);
-	spin_unlock(&ISCSI_TPG_S(sess)->tpg_state_lock);
+	spin_lock(&sess->tpg->tpg_state_lock);
+	tpg_active = (sess->tpg->tpg_state == TPG_STATE_ACTIVE);
+	spin_unlock(&sess->tpg->tpg_state_lock);
 
 	if (!tpg_active)
 		return;
@@ -831,7 +829,7 @@
  */
 int iscsit_stop_time2retain_timer(struct iscsi_session *sess)
 {
-	struct iscsi_portal_group *tpg = ISCSI_TPG_S(sess);
+	struct iscsi_portal_group *tpg = sess->tpg;
 	struct se_portal_group *se_tpg = &tpg->tpg_se_tpg;
 
 	if (sess->time2retain_timer_flags & ISCSI_TF_EXPIRED)
@@ -866,7 +864,10 @@
 	}
 	spin_unlock_bh(&conn->state_lock);
 
-	iscsi_thread_set_force_reinstatement(conn);
+	if (conn->tx_thread && conn->tx_thread_active)
+		send_sig(SIGINT, conn->tx_thread, 1);
+	if (conn->rx_thread && conn->rx_thread_active)
+		send_sig(SIGINT, conn->rx_thread, 1);
 
 sleep:
 	wait_for_completion(&conn->conn_wait_rcfr_comp);
@@ -891,10 +892,10 @@
 		return;
 	}
 
-	if (iscsi_thread_set_force_reinstatement(conn) < 0) {
-		spin_unlock_bh(&conn->state_lock);
-		return;
-	}
+	if (conn->tx_thread && conn->tx_thread_active)
+		send_sig(SIGINT, conn->tx_thread, 1);
+	if (conn->rx_thread && conn->rx_thread_active)
+		send_sig(SIGINT, conn->rx_thread, 1);
 
 	atomic_set(&conn->connection_reinstatement, 1);
 	if (!sleep) {
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_erl1.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_erl1.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_erl1.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_erl1.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains error recovery level one used by the iSCSI Target driver.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -509,7 +507,9 @@
 	u32 last_statsn;
 	int found_cmd;
 
-	if (conn->exp_statsn > begrun) {
+	if (!begrun) {
+		begrun = conn->exp_statsn;
+	} else if (conn->exp_statsn > begrun) {
 		pr_err("Got Status SNACK Begrun: 0x%08x, RunLength:"
 			" 0x%08x but already got ExpStatSN: 0x%08x on CID:"
 			" %hu.\n", begrun, runlength, conn->exp_statsn,
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_erl2.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_erl2.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_erl2.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_erl2.c	2017-05-02 03:31:56.000000000 +0200
@@ -2,9 +2,7 @@
  * This file contains error recovery level two functions used by
  * the iSCSI Target driver.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target.h
--- linux-3.10.69/drivers/target/iscsi/iscsi_target.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target.h	2017-05-02 03:31:56.000000000 +0200
@@ -7,13 +7,15 @@
 extern struct iscsi_tiqn *iscsit_add_tiqn(unsigned char *);
 extern void iscsit_del_tiqn(struct iscsi_tiqn *);
 extern int iscsit_access_np(struct iscsi_np *, struct iscsi_portal_group *);
-extern int iscsit_deaccess_np(struct iscsi_np *, struct iscsi_portal_group *);
+extern void iscsit_login_kref_put(struct kref *);
+extern int iscsit_deaccess_np(struct iscsi_np *, struct iscsi_portal_group *,
+				struct iscsi_tpg_np *);
 extern bool iscsit_check_np_match(struct __kernel_sockaddr_storage *,
 				struct iscsi_np *, int);
 extern struct iscsi_np *iscsit_add_np(struct __kernel_sockaddr_storage *,
 				char *, int);
 extern int iscsit_reset_np_thread(struct iscsi_np *, struct iscsi_tpg_np *,
-				struct iscsi_portal_group *);
+				struct iscsi_portal_group *, bool);
 extern int iscsit_del_np(struct iscsi_np *);
 extern int iscsit_reject_cmd(struct iscsi_cmd *cmd, u8, unsigned char *);
 extern void iscsit_set_unsoliticed_dataout(struct iscsi_cmd *);
@@ -37,7 +39,6 @@
 
 extern struct kmem_cache *lio_dr_cache;
 extern struct kmem_cache *lio_ooo_cache;
-extern struct kmem_cache *lio_cmd_cache;
 extern struct kmem_cache *lio_qr_cache;
 extern struct kmem_cache *lio_r2t_cache;
 
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_login.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_login.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_login.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_login.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains the login functions used by the iSCSI Target driver.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -50,6 +48,7 @@
 		pr_err("Unable to allocate memory for struct iscsi_login.\n");
 		return NULL;
 	}
+	conn->login = login;
 	login->conn = conn;
 	login->first_request = 1;
 
@@ -84,6 +83,7 @@
 	init_completion(&conn->conn_logout_comp);
 	init_completion(&conn->rx_half_close_comp);
 	init_completion(&conn->tx_half_close_comp);
+	init_completion(&conn->rx_login_comp);
 	spin_lock_init(&conn->cmd_lock);
 	spin_lock_init(&conn->conn_usage_lock);
 	spin_lock_init(&conn->immed_queue_lock);
@@ -328,7 +328,6 @@
 	}
 
 	sess->creation_time = get_jiffies_64();
-	spin_lock_init(&sess->session_stats_lock);
 	/*
 	 * The FFP CmdSN window values will be allocated from the TPG's
 	 * Initiator Node's ACL once the login has been successfully completed.
@@ -369,15 +368,15 @@
 	 * Assign a new TPG Session Handle.  Note this is protected with
 	 * struct iscsi_portal_group->np_login_sem from iscsit_access_np().
 	 */
-	sess->tsih = ++ISCSI_TPG_S(sess)->ntsih;
+	sess->tsih = ++sess->tpg->ntsih;
 	if (!sess->tsih)
-		sess->tsih = ++ISCSI_TPG_S(sess)->ntsih;
+		sess->tsih = ++sess->tpg->ntsih;
 
 	/*
 	 * Create the default params from user defined values..
 	 */
 	if (iscsi_copy_param_list(&conn->param_list,
-				ISCSI_TPG_C(conn)->param_list, 1) < 0) {
+				conn->tpg->param_list, 1) < 0) {
 		iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
 				ISCSI_LOGIN_STATUS_NO_RESOURCES);
 		return -1;
@@ -436,7 +435,7 @@
 				ISCSI_LOGIN_STATUS_NO_RESOURCES);
 			return -1;
 		}
-		rc = strict_strtoul(param->value, 0, &mrdsl);
+		rc = kstrtoul(param->value, 0, &mrdsl);
 		if (rc < 0) {
 			iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
 				ISCSI_LOGIN_STATUS_NO_RESOURCES);
@@ -580,7 +579,7 @@
 	iscsi_login_set_conn_values(sess, conn, pdu->cid);
 
 	if (iscsi_copy_param_list(&conn->param_list,
-			ISCSI_TPG_C(conn)->param_list, 0) < 0) {
+			conn->tpg->param_list, 0) < 0) {
 		iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
 				ISCSI_LOGIN_STATUS_NO_RESOURCES);
 		return -1;
@@ -683,7 +682,53 @@
 		iscsit_start_nopin_timer(conn);
 }
 
-static int iscsi_post_login_handler(
+int iscsit_start_kthreads(struct iscsi_conn *conn)
+{
+	int ret = 0;
+
+	spin_lock(&iscsit_global->ts_bitmap_lock);
+	conn->bitmap_id = bitmap_find_free_region(iscsit_global->ts_bitmap,
+					ISCSIT_BITMAP_BITS, get_order(1));
+	spin_unlock(&iscsit_global->ts_bitmap_lock);
+
+	if (conn->bitmap_id < 0) {
+		pr_err("bitmap_find_free_region() failed for"
+		       " iscsit_start_kthreads()\n");
+		return -ENOMEM;
+	}
+
+	conn->tx_thread = kthread_run(iscsi_target_tx_thread, conn,
+				      "%s", ISCSI_TX_THREAD_NAME);
+	if (IS_ERR(conn->tx_thread)) {
+		pr_err("Unable to start iscsi_target_tx_thread\n");
+		ret = PTR_ERR(conn->tx_thread);
+		goto out_bitmap;
+	}
+	conn->tx_thread_active = true;
+
+	conn->rx_thread = kthread_run(iscsi_target_rx_thread, conn,
+				      "%s", ISCSI_RX_THREAD_NAME);
+	if (IS_ERR(conn->rx_thread)) {
+		pr_err("Unable to start iscsi_target_rx_thread\n");
+		ret = PTR_ERR(conn->rx_thread);
+		goto out_tx;
+	}
+	conn->rx_thread_active = true;
+
+	return 0;
+out_tx:
+	send_sig(SIGINT, conn->tx_thread, 1);
+	kthread_stop(conn->tx_thread);
+	conn->tx_thread_active = false;
+out_bitmap:
+	spin_lock(&iscsit_global->ts_bitmap_lock);
+	bitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,
+			      get_order(1));
+	spin_unlock(&iscsit_global->ts_bitmap_lock);
+	return ret;
+}
+
+void iscsi_post_login_handler(
 	struct iscsi_np *np,
 	struct iscsi_conn *conn,
 	u8 zero_tsih)
@@ -691,9 +736,8 @@
 	int stop_timer = 0;
 	struct iscsi_session *sess = conn->sess;
 	struct se_session *se_sess = sess->se_sess;
-	struct iscsi_portal_group *tpg = ISCSI_TPG_S(sess);
+	struct iscsi_portal_group *tpg = sess->tpg;
 	struct se_portal_group *se_tpg = &tpg->tpg_se_tpg;
-	struct iscsi_thread_set *ts;
 
 	iscsit_inc_conn_usage_count(conn);
 
@@ -708,7 +752,6 @@
 	/*
 	 * SCSI Initiator -> SCSI Target Port Mapping
 	 */
-	ts = iscsi_get_thread_set();
 	if (!zero_tsih) {
 		iscsi_set_session_parameters(sess->sess_ops,
 				conn->param_list, 0);
@@ -736,8 +779,6 @@
 		spin_unlock_bh(&sess->conn_lock);
 
 		iscsi_post_login_start_timers(conn);
-
-		iscsi_activate_thread_set(conn, ts);
 		/*
 		 * Determine CPU mask to ensure connection's RX and TX kthreads
 		 * are scheduled on the same CPU.
@@ -745,15 +786,20 @@
 		iscsit_thread_get_cpumask(conn);
 		conn->conn_rx_reset_cpumask = 1;
 		conn->conn_tx_reset_cpumask = 1;
-
+		/*
+		 * Wakeup the sleeping iscsi_target_rx_thread() now that
+		 * iscsi_conn is in TARG_CONN_STATE_LOGGED_IN state.
+		 */
+		complete(&conn->rx_login_comp);
 		iscsit_dec_conn_usage_count(conn);
+
 		if (stop_timer) {
 			spin_lock_bh(&se_tpg->session_lock);
 			iscsit_stop_time2retain_timer(sess);
 			spin_unlock_bh(&se_tpg->session_lock);
 		}
 		iscsit_dec_session_usage_count(sess);
-		return 0;
+		return;
 	}
 
 	iscsi_set_session_parameters(sess->sess_ops, conn->param_list, 1);
@@ -795,7 +841,6 @@
 	spin_unlock_bh(&se_tpg->session_lock);
 
 	iscsi_post_login_start_timers(conn);
-	iscsi_activate_thread_set(conn, ts);
 	/*
 	 * Determine CPU mask to ensure connection's RX and TX kthreads
 	 * are scheduled on the same CPU.
@@ -803,10 +848,12 @@
 	iscsit_thread_get_cpumask(conn);
 	conn->conn_rx_reset_cpumask = 1;
 	conn->conn_tx_reset_cpumask = 1;
-
+	/*
+	 * Wakeup the sleeping iscsi_target_rx_thread() now that
+	 * iscsi_conn is in TARG_CONN_STATE_LOGGED_IN state.
+	 */
+	complete(&conn->rx_login_comp);
 	iscsit_dec_conn_usage_count(conn);
-
-	return 0;
 }
 
 static void iscsi_handle_login_thread_timeout(unsigned long data)
@@ -871,7 +918,7 @@
 	struct __kernel_sockaddr_storage *sockaddr)
 {
 	struct socket *sock = NULL;
-	int backlog = 5, ret, opt = 0, len;
+	int backlog = ISCSIT_TCP_BACKLOG, ret, opt = 0, len;
 
 	switch (np->np_network_transport) {
 	case ISCSI_TCP:
@@ -1007,16 +1054,24 @@
 		rc = conn->sock->ops->getname(conn->sock,
 				(struct sockaddr *)&sock_in6, &err, 1);
 		if (!rc) {
-			snprintf(conn->login_ip, sizeof(conn->login_ip), "%pI6c",
+			if (!ipv6_addr_v4mapped(&sock_in6.sin6_addr))
+				snprintf(conn->login_ip, sizeof(conn->login_ip), "[%pI6c]",
 				&sock_in6.sin6_addr.in6_u);
+			else
+				snprintf(conn->login_ip, sizeof(conn->login_ip), "%pI4",
+					&sock_in6.sin6_addr.s6_addr32[3]);
 			conn->login_port = ntohs(sock_in6.sin6_port);
 		}
 
 		rc = conn->sock->ops->getname(conn->sock,
 				(struct sockaddr *)&sock_in6, &err, 0);
 		if (!rc) {
-			snprintf(conn->local_ip, sizeof(conn->local_ip), "%pI6c",
+			if (!ipv6_addr_v4mapped(&sock_in6.sin6_addr))
+				snprintf(conn->local_ip, sizeof(conn->local_ip), "[%pI6c]",
 				&sock_in6.sin6_addr.in6_u);
+			else
+				snprintf(conn->local_ip, sizeof(conn->local_ip), "%pI4",
+					&sock_in6.sin6_addr.s6_addr32[3]);
 			conn->local_port = ntohs(sock_in6.sin6_port);
 		}
 	} else {
@@ -1116,14 +1171,90 @@
 	return 0;
 }
 
+void iscsi_target_login_sess_out(struct iscsi_conn *conn,
+		struct iscsi_np *np, bool zero_tsih, bool new_sess)
+{
+	if (new_sess == false)
+		goto old_sess_out;
+
+	pr_err("iSCSI Login negotiation failed.\n");
+	iscsit_collect_login_stats(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,
+				   ISCSI_LOGIN_STATUS_INIT_ERR);
+	if (!zero_tsih || !conn->sess)
+		goto old_sess_out;
+	if (conn->sess->se_sess)
+		transport_free_session(conn->sess->se_sess);
+	if (conn->sess->session_index != 0) {
+		spin_lock_bh(&sess_idr_lock);
+		idr_remove(&sess_idr, conn->sess->session_index);
+		spin_unlock_bh(&sess_idr_lock);
+	}
+	kfree(conn->sess->sess_ops);
+	kfree(conn->sess);
+
+old_sess_out:
+	iscsi_stop_login_thread_timer(np);
+	/*
+	 * If login negotiation fails check if the Time2Retain timer
+	 * needs to be restarted.
+	 */
+	if (!zero_tsih && conn->sess) {
+		spin_lock_bh(&conn->sess->conn_lock);
+		if (conn->sess->session_state == TARG_SESS_STATE_FAILED) {
+			struct se_portal_group *se_tpg =
+					&conn->tpg->tpg_se_tpg;
+
+			atomic_set(&conn->sess->session_continuation, 0);
+			spin_unlock_bh(&conn->sess->conn_lock);
+			spin_lock_bh(&se_tpg->session_lock);
+			iscsit_start_time2retain_handler(conn->sess);
+			spin_unlock_bh(&se_tpg->session_lock);
+		} else
+			spin_unlock_bh(&conn->sess->conn_lock);
+		iscsit_dec_session_usage_count(conn->sess);
+	}
+
+	if (!IS_ERR(conn->conn_rx_hash.tfm))
+		crypto_free_hash(conn->conn_rx_hash.tfm);
+	if (!IS_ERR(conn->conn_tx_hash.tfm))
+		crypto_free_hash(conn->conn_tx_hash.tfm);
+
+	if (conn->conn_cpumask)
+		free_cpumask_var(conn->conn_cpumask);
+
+	kfree(conn->conn_ops);
+
+	if (conn->param_list) {
+		iscsi_release_param_list(conn->param_list);
+		conn->param_list = NULL;
+	}
+	iscsi_target_nego_release(conn);
+
+	if (conn->sock) {
+		sock_release(conn->sock);
+		conn->sock = NULL;
+	}
+
+	if (conn->conn_transport->iscsit_wait_conn)
+		conn->conn_transport->iscsit_wait_conn(conn);
+
+	if (conn->conn_transport->iscsit_free_conn)
+		conn->conn_transport->iscsit_free_conn(conn);
+
+	iscsit_put_transport(conn->conn_transport);
+	kfree(conn);
+}
+
 static int __iscsi_target_login_thread(struct iscsi_np *np)
 {
 	u8 *buffer, zero_tsih = 0;
-	int ret = 0, rc, stop;
+	int ret = 0, rc;
 	struct iscsi_conn *conn = NULL;
 	struct iscsi_login *login;
 	struct iscsi_portal_group *tpg = NULL;
 	struct iscsi_login_req *pdu;
+	struct iscsi_tpg_np *tpg_np;
+	bool new_sess = false;
 
 	flush_signals(current);
 
@@ -1131,6 +1262,9 @@
 	if (np->np_thread_state == ISCSI_NP_THREAD_RESET) {
 		np->np_thread_state = ISCSI_NP_THREAD_ACTIVE;
 		complete(&np->np_restart_comp);
+	} else if (np->np_thread_state == ISCSI_NP_THREAD_SHUTDOWN) {
+		spin_unlock_bh(&np->np_thread_lock);
+		goto exit;
 	} else {
 		np->np_thread_state = ISCSI_NP_THREAD_ACTIVE;
 	}
@@ -1264,6 +1398,7 @@
 		tpg = conn->tpg;
 		goto new_sess_out;
 	}
+	login->zero_tsih = zero_tsih;
 
 	tpg = conn->tpg;
 	if (!tpg) {
@@ -1279,117 +1414,44 @@
 			goto old_sess_out;
 	}
 
-	if (iscsi_target_start_negotiation(login, conn) < 0)
-		goto new_sess_out;
-
-	if (!conn->sess) {
-		pr_err("struct iscsi_conn session pointer is NULL!\n");
+	ret = iscsi_target_start_negotiation(login, conn);
+	if (ret < 0)
 		goto new_sess_out;
-	}
 
 	iscsi_stop_login_thread_timer(np);
 
-	if (signal_pending(current))
-		goto new_sess_out;
-
-	ret = iscsi_post_login_handler(np, conn, zero_tsih);
+	if (ret == 1) {
+		tpg_np = conn->tpg_np;
 
-	if (ret < 0)
-		goto new_sess_out;
+		iscsi_post_login_handler(np, conn, zero_tsih);
+		iscsit_deaccess_np(np, tpg, tpg_np);
+	}
 
-	iscsit_deaccess_np(np, tpg);
 	tpg = NULL;
+	tpg_np = NULL;
 	/* Get another socket */
 	return 1;
 
 new_sess_out:
-	pr_err("iSCSI Login negotiation failed.\n");
-	iscsit_collect_login_stats(conn, ISCSI_STATUS_CLS_INITIATOR_ERR,
-				  ISCSI_LOGIN_STATUS_INIT_ERR);
-	if (!zero_tsih || !conn->sess)
-		goto old_sess_out;
-	if (conn->sess->se_sess)
-		transport_free_session(conn->sess->se_sess);
-	if (conn->sess->session_index != 0) {
-		spin_lock_bh(&sess_idr_lock);
-		idr_remove(&sess_idr, conn->sess->session_index);
-		spin_unlock_bh(&sess_idr_lock);
-	}
-	kfree(conn->sess->sess_ops);
-	kfree(conn->sess);
+	new_sess = true;
 old_sess_out:
-	iscsi_stop_login_thread_timer(np);
-	/*
-	 * If login negotiation fails check if the Time2Retain timer
-	 * needs to be restarted.
-	 */
-	if (!zero_tsih && conn->sess) {
-		spin_lock_bh(&conn->sess->conn_lock);
-		if (conn->sess->session_state == TARG_SESS_STATE_FAILED) {
-			struct se_portal_group *se_tpg =
-					&ISCSI_TPG_C(conn)->tpg_se_tpg;
-
-			atomic_set(&conn->sess->session_continuation, 0);
-			spin_unlock_bh(&conn->sess->conn_lock);
-			spin_lock_bh(&se_tpg->session_lock);
-			iscsit_start_time2retain_handler(conn->sess);
-			spin_unlock_bh(&se_tpg->session_lock);
-		} else
-			spin_unlock_bh(&conn->sess->conn_lock);
-		iscsit_dec_session_usage_count(conn->sess);
-	}
-
-	if (!IS_ERR(conn->conn_rx_hash.tfm))
-		crypto_free_hash(conn->conn_rx_hash.tfm);
-	if (!IS_ERR(conn->conn_tx_hash.tfm))
-		crypto_free_hash(conn->conn_tx_hash.tfm);
-
-	if (conn->conn_cpumask)
-		free_cpumask_var(conn->conn_cpumask);
-
-	kfree(conn->conn_ops);
-
-	if (conn->param_list) {
-		iscsi_release_param_list(conn->param_list);
-		conn->param_list = NULL;
-	}
-	iscsi_target_nego_release(conn);
-
-	if (conn->sock) {
-		sock_release(conn->sock);
-		conn->sock = NULL;
-	}
-
-	if (conn->conn_transport->iscsit_wait_conn)
-		conn->conn_transport->iscsit_wait_conn(conn);
-
-	if (conn->conn_transport->iscsit_free_conn)
-		conn->conn_transport->iscsit_free_conn(conn);
-
-	iscsit_put_transport(conn->conn_transport);
-
-	kfree(conn);
+	tpg_np = conn->tpg_np;
+	iscsi_target_login_sess_out(conn, np, zero_tsih, new_sess);
+	new_sess = false;
 
 	if (tpg) {
-		iscsit_deaccess_np(np, tpg);
+		iscsit_deaccess_np(np, tpg, tpg_np);
 		tpg = NULL;
+		tpg_np = NULL;
 	}
 
 out:
-	stop = kthread_should_stop();
-	if (!stop && signal_pending(current)) {
-		spin_lock_bh(&np->np_thread_lock);
-		stop = (np->np_thread_state == ISCSI_NP_THREAD_SHUTDOWN);
-		spin_unlock_bh(&np->np_thread_lock);
-	}
-	/* Wait for another socket.. */
-	if (!stop)
 		return 1;
+
 exit:
 	iscsi_stop_login_thread_timer(np);
 	spin_lock_bh(&np->np_thread_lock);
 	np->np_thread_state = ISCSI_NP_THREAD_EXIT;
-	np->np_thread = NULL;
 	spin_unlock_bh(&np->np_thread_lock);
 
 	return 0;
@@ -1402,7 +1464,7 @@
 
 	allow_signal(SIGINT);
 
-	while (!kthread_should_stop()) {
+	while (1) {
 		ret = __iscsi_target_login_thread(np);
 		/*
 		 * We break and exit here unless another sock_accept() call
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_login.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_login.h
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_login.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_login.h	2017-05-02 03:31:56.000000000 +0200
@@ -12,6 +12,10 @@
 extern int iscsit_get_login_rx(struct iscsi_conn *, struct iscsi_login *);
 extern int iscsit_put_login_tx(struct iscsi_conn *, struct iscsi_login *, u32);
 extern void iscsit_free_conn(struct iscsi_np *, struct iscsi_conn *);
+extern int iscsit_start_kthreads(struct iscsi_conn *);
+extern void iscsi_post_login_handler(struct iscsi_np *, struct iscsi_conn *, u8);
+extern void iscsi_target_login_sess_out(struct iscsi_conn *, struct iscsi_np *,
+				bool, bool);
 extern int iscsi_target_login_thread(void *);
 extern int iscsi_login_disable_FIM_keys(struct iscsi_param_list *, struct iscsi_conn *);
 
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_nego.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_nego.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_nego.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_nego.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains main functions related to iSCSI Parameter negotiation.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -19,6 +17,7 @@
  ******************************************************************************/
 
 #include <linux/ctype.h>
+#include <linux/kthread.h>
 #include <scsi/iscsi_proto.h>
 #include <target/target_core_base.h>
 #include <target/target_core_fabric.h>
@@ -112,6 +111,7 @@
 	struct iscsi_session *sess = conn->sess;
 	struct iscsi_node_auth *auth;
 	struct iscsi_node_acl *iscsi_nacl;
+	struct iscsi_portal_group *iscsi_tpg;
 	struct se_node_acl *se_nacl;
 
 	if (!sess->sess_ops->SessionType) {
@@ -132,7 +132,17 @@
 			return -1;
 		}
 
-		auth = ISCSI_NODE_AUTH(iscsi_nacl);
+		if (se_nacl->dynamic_node_acl) {
+			iscsi_tpg = container_of(se_nacl->se_tpg,
+					struct iscsi_portal_group, tpg_se_tpg);
+
+			auth = &iscsi_tpg->tpg_demo_auth;
+		} else {
+			iscsi_nacl = container_of(se_nacl, struct iscsi_node_acl,
+						  se_node_acl);
+
+			auth = &iscsi_nacl->node_auth;
+		}
 	} else {
 		/*
 		 * For SessionType=Discovery
@@ -352,10 +362,24 @@
 		ntohl(login_rsp->statsn), login->rsp_length);
 
 	padding = ((-login->rsp_length) & 3);
+	/*
+	 * Before sending the last login response containing the transition
+	 * bit for full-feature-phase, go ahead and start up TX/RX threads
+	 * now to avoid potential resource allocation failures after the
+	 * final login response has been sent.
+	 */
+	if (login->login_complete) {
+		int rc = iscsit_start_kthreads(conn);
+		if (rc) {
+			iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
+					    ISCSI_LOGIN_STATUS_NO_RESOURCES);
+			return -1;
+		}
+	}
 
 	if (conn->conn_transport->iscsit_put_login_tx(conn, login,
 					login->rsp_length + padding) < 0)
-		return -1;
+		goto err;
 
 	login->rsp_length		= 0;
 	mutex_lock(&sess->cmdsn_mutex);
@@ -364,17 +388,303 @@
 	mutex_unlock(&sess->cmdsn_mutex);
 
 	return 0;
+
+err:
+	if (login->login_complete) {
+		if (conn->rx_thread && conn->rx_thread_active) {
+			send_sig(SIGINT, conn->rx_thread, 1);
+			kthread_stop(conn->rx_thread);
+		}
+		if (conn->tx_thread && conn->tx_thread_active) {
+			send_sig(SIGINT, conn->tx_thread, 1);
+			kthread_stop(conn->tx_thread);
+		}
+		spin_lock(&iscsit_global->ts_bitmap_lock);
+		bitmap_release_region(iscsit_global->ts_bitmap, conn->bitmap_id,
+				      get_order(1));
+		spin_unlock(&iscsit_global->ts_bitmap_lock);
+	}
+	return -1;
 }
 
-static int iscsi_target_do_login_io(struct iscsi_conn *conn, struct iscsi_login *login)
+static void iscsi_target_sk_data_ready(struct sock *sk, int count)
 {
-	if (iscsi_target_do_tx_login_io(conn, login) < 0)
-		return -1;
+	struct iscsi_conn *conn = sk->sk_user_data;
+	bool rc;
 
-	if (conn->conn_transport->iscsit_get_login_rx(conn, login) < 0)
-		return -1;
+	pr_debug("Entering iscsi_target_sk_data_ready: conn: %p\n", conn);
 
-	return 0;
+	write_lock_bh(&sk->sk_callback_lock);
+	if (!sk->sk_user_data) {
+		write_unlock_bh(&sk->sk_callback_lock);
+		return;
+	}
+	if (!test_bit(LOGIN_FLAGS_READY, &conn->login_flags)) {
+		write_unlock_bh(&sk->sk_callback_lock);
+		pr_debug("Got LOGIN_FLAGS_READY=0, conn: %p >>>>\n", conn);
+		return;
+	}
+	if (test_bit(LOGIN_FLAGS_CLOSED, &conn->login_flags)) {
+		write_unlock_bh(&sk->sk_callback_lock);
+		pr_debug("Got LOGIN_FLAGS_CLOSED=1, conn: %p >>>>\n", conn);
+		return;
+	}
+	if (test_and_set_bit(LOGIN_FLAGS_READ_ACTIVE, &conn->login_flags)) {
+		write_unlock_bh(&sk->sk_callback_lock);
+		pr_debug("Got LOGIN_FLAGS_READ_ACTIVE=1, conn: %p >>>>\n", conn);
+		return;
+	}
+
+	rc = schedule_delayed_work(&conn->login_work, 0);
+	if (rc == false) {
+		pr_debug("iscsi_target_sk_data_ready, schedule_delayed_work"
+			 " got false\n");
+	}
+	write_unlock_bh(&sk->sk_callback_lock);
+}
+
+static void iscsi_target_sk_state_change(struct sock *);
+
+static void iscsi_target_set_sock_callbacks(struct iscsi_conn *conn)
+{
+	struct sock *sk;
+
+	if (!conn->sock)
+		return;
+
+	sk = conn->sock->sk;
+	pr_debug("Entering iscsi_target_set_sock_callbacks: conn: %p\n", conn);
+
+	write_lock_bh(&sk->sk_callback_lock);
+	sk->sk_user_data = conn;
+	conn->orig_data_ready = sk->sk_data_ready;
+	conn->orig_state_change = sk->sk_state_change;
+	sk->sk_data_ready = iscsi_target_sk_data_ready;
+	sk->sk_state_change = iscsi_target_sk_state_change;
+	write_unlock_bh(&sk->sk_callback_lock);
+
+	sk->sk_sndtimeo = TA_LOGIN_TIMEOUT * HZ;
+	sk->sk_rcvtimeo = TA_LOGIN_TIMEOUT * HZ;
+}
+
+static void iscsi_target_restore_sock_callbacks(struct iscsi_conn *conn)
+{
+	struct sock *sk;
+
+	if (!conn->sock)
+		return;
+
+	sk = conn->sock->sk;
+	pr_debug("Entering iscsi_target_restore_sock_callbacks: conn: %p\n", conn);
+
+	write_lock_bh(&sk->sk_callback_lock);
+	if (!sk->sk_user_data) {
+		write_unlock_bh(&sk->sk_callback_lock);
+		return;
+	}
+	sk->sk_user_data = NULL;
+	sk->sk_data_ready = conn->orig_data_ready;
+	sk->sk_state_change = conn->orig_state_change;
+	write_unlock_bh(&sk->sk_callback_lock);
+
+	sk->sk_sndtimeo = MAX_SCHEDULE_TIMEOUT;
+	sk->sk_rcvtimeo = MAX_SCHEDULE_TIMEOUT;
+}
+
+static int iscsi_target_do_login(struct iscsi_conn *, struct iscsi_login *);
+
+static bool iscsi_target_sk_state_check(struct sock *sk)
+{
+	if (sk->sk_state == TCP_CLOSE_WAIT || sk->sk_state == TCP_CLOSE) {
+		pr_debug("iscsi_target_sk_state_check: TCP_CLOSE_WAIT|TCP_CLOSE,"
+			"returning FALSE\n");
+		return false;
+	}
+	return true;
+}
+
+static void iscsi_target_login_drop(struct iscsi_conn *conn, struct iscsi_login *login)
+{
+	struct iscsi_np *np = login->np;
+	bool zero_tsih = login->zero_tsih;
+
+	iscsi_remove_failed_auth_entry(conn);
+	iscsi_target_nego_release(conn);
+	iscsi_target_login_sess_out(conn, np, zero_tsih, true);
+}
+
+static void iscsi_target_login_timeout(unsigned long data)
+{
+	struct iscsi_conn *conn = (struct iscsi_conn *)data;
+
+	pr_debug("Entering iscsi_target_login_timeout >>>>>>>>>>>>>>>>>>>\n");
+
+	if (conn->login_kworker) {
+		pr_debug("Sending SIGINT to conn->login_kworker %s/%d\n",
+			 conn->login_kworker->comm, conn->login_kworker->pid);
+		send_sig(SIGINT, conn->login_kworker, 1);
+	}
+}
+
+static void iscsi_target_do_login_rx(struct work_struct *work)
+{
+	struct iscsi_conn *conn = container_of(work,
+				struct iscsi_conn, login_work.work);
+	struct iscsi_login *login = conn->login;
+	struct iscsi_np *np = login->np;
+	struct iscsi_portal_group *tpg = conn->tpg;
+	struct iscsi_tpg_np *tpg_np = conn->tpg_np;
+	struct timer_list login_timer;
+	int rc, zero_tsih = login->zero_tsih;
+	bool state;
+
+	pr_debug("entering iscsi_target_do_login_rx, conn: %p, %s:%d\n",
+			conn, current->comm, current->pid);
+
+	spin_lock(&tpg->tpg_state_lock);
+	state = (tpg->tpg_state == TPG_STATE_ACTIVE);
+	spin_unlock(&tpg->tpg_state_lock);
+
+	if (state == false) {
+		pr_debug("iscsi_target_do_login_rx: tpg_state != TPG_STATE_ACTIVE\n");
+		iscsi_target_restore_sock_callbacks(conn);
+		iscsi_target_login_drop(conn, login);
+		iscsit_deaccess_np(np, tpg, tpg_np);
+		return;
+	}
+
+	if (conn->sock) {
+		struct sock *sk = conn->sock->sk;
+
+		read_lock_bh(&sk->sk_callback_lock);
+		state = iscsi_target_sk_state_check(sk);
+		read_unlock_bh(&sk->sk_callback_lock);
+
+		if (state == false) {
+			pr_debug("iscsi_target_do_login_rx, TCP state CLOSE\n");
+			iscsi_target_restore_sock_callbacks(conn);
+			iscsi_target_login_drop(conn, login);
+			iscsit_deaccess_np(np, tpg, tpg_np);
+			return;
+		}
+	}
+
+	conn->login_kworker = current;
+	allow_signal(SIGINT);
+
+	init_timer(&login_timer);
+	login_timer.expires = (get_jiffies_64() + TA_LOGIN_TIMEOUT * HZ);
+	login_timer.data = (unsigned long)conn;
+	login_timer.function = iscsi_target_login_timeout;
+	add_timer(&login_timer);
+	pr_debug("Starting login_timer for %s/%d\n", current->comm, current->pid);
+
+	rc = conn->conn_transport->iscsit_get_login_rx(conn, login);
+	del_timer_sync(&login_timer);
+	flush_signals(current);
+	conn->login_kworker = NULL;
+
+	if (rc < 0) {
+		iscsi_target_restore_sock_callbacks(conn);
+		iscsi_target_login_drop(conn, login);
+		iscsit_deaccess_np(np, tpg, tpg_np);
+		return;
+	}
+
+	pr_debug("iscsi_target_do_login_rx after rx_login_io, %p, %s:%d\n",
+			conn, current->comm, current->pid);
+
+	rc = iscsi_target_do_login(conn, login);
+	if (rc < 0) {
+		iscsi_target_restore_sock_callbacks(conn);
+		iscsi_target_login_drop(conn, login);
+		iscsit_deaccess_np(np, tpg, tpg_np);
+	} else if (!rc) {
+		if (conn->sock) {
+			struct sock *sk = conn->sock->sk;
+
+			write_lock_bh(&sk->sk_callback_lock);
+			clear_bit(LOGIN_FLAGS_READ_ACTIVE, &conn->login_flags);
+			write_unlock_bh(&sk->sk_callback_lock);
+		}
+	} else if (rc == 1) {
+		iscsi_target_nego_release(conn);
+		iscsi_post_login_handler(np, conn, zero_tsih);
+		iscsit_deaccess_np(np, tpg, tpg_np);
+	}
+}
+
+static void iscsi_target_do_cleanup(struct work_struct *work)
+{
+	struct iscsi_conn *conn = container_of(work,
+				struct iscsi_conn, login_cleanup_work.work);
+	struct sock *sk = conn->sock->sk;
+	struct iscsi_login *login = conn->login;
+	struct iscsi_np *np = login->np;
+	struct iscsi_portal_group *tpg = conn->tpg;
+	struct iscsi_tpg_np *tpg_np = conn->tpg_np;
+
+	pr_debug("Entering iscsi_target_do_cleanup\n");
+
+	cancel_delayed_work_sync(&conn->login_work);
+	conn->orig_state_change(sk);
+
+	iscsi_target_restore_sock_callbacks(conn);
+	iscsi_target_login_drop(conn, login);
+	iscsit_deaccess_np(np, tpg, tpg_np);
+
+	pr_debug("iscsi_target_do_cleanup done()\n");
+}
+
+static void iscsi_target_sk_state_change(struct sock *sk)
+{
+	struct iscsi_conn *conn;
+	void (*orig_state_change)(struct sock *);
+	bool state;
+
+	pr_debug("Entering iscsi_target_sk_state_change\n");
+
+	write_lock_bh(&sk->sk_callback_lock);
+	conn = sk->sk_user_data;
+	if (!conn) {
+		write_unlock_bh(&sk->sk_callback_lock);
+		return;
+	}
+	orig_state_change = conn->orig_state_change;
+
+	if (!test_bit(LOGIN_FLAGS_READY, &conn->login_flags)) {
+		pr_debug("Got LOGIN_FLAGS_READY=0 sk_state_change conn: %p\n",
+			 conn);
+		write_unlock_bh(&sk->sk_callback_lock);
+		orig_state_change(sk);
+		return;
+	}
+	if (test_bit(LOGIN_FLAGS_READ_ACTIVE, &conn->login_flags)) {
+		pr_debug("Got LOGIN_FLAGS_READ_ACTIVE=1 sk_state_change"
+			 " conn: %p\n", conn);
+		write_unlock_bh(&sk->sk_callback_lock);
+		orig_state_change(sk);
+		return;
+	}
+	if (test_and_set_bit(LOGIN_FLAGS_CLOSED, &conn->login_flags)) {
+		pr_debug("Got LOGIN_FLAGS_CLOSED=1 sk_state_change conn: %p\n",
+			 conn);
+		write_unlock_bh(&sk->sk_callback_lock);
+		orig_state_change(sk);
+		return;
+	}
+
+	state = iscsi_target_sk_state_check(sk);
+	write_unlock_bh(&sk->sk_callback_lock);
+
+	pr_debug("iscsi_target_sk_state_change: state: %d\n", state);
+
+	if (!state) {
+		pr_debug("iscsi_target_sk_state_change got failed state\n");
+		schedule_delayed_work(&conn->login_cleanup_work, 0);
+		return;
+	}
+	orig_state_change(sk);
 }
 
 /*
@@ -511,7 +821,7 @@
 		return -1;
 
 	if (!iscsi_check_negotiated_keys(conn->param_list)) {
-		if (ISCSI_TPG_ATTRIB(ISCSI_TPG_C(conn))->authentication &&
+		if (conn->tpg->tpg_attrib.authentication &&
 		    !strncmp(param->value, NONE, 4)) {
 			pr_err("Initiator sent AuthMethod=None but"
 				" Target is enforcing iSCSI Authentication,"
@@ -521,7 +831,7 @@
 			return -1;
 		}
 
-		if (ISCSI_TPG_ATTRIB(ISCSI_TPG_C(conn))->authentication &&
+		if (conn->tpg->tpg_attrib.authentication &&
 		    !login->auth_complete)
 			return 0;
 
@@ -584,7 +894,7 @@
 	}
 
 	if (!login->auth_complete &&
-	     ISCSI_TPG_ATTRIB(ISCSI_TPG_C(conn))->authentication) {
+	     conn->tpg->tpg_attrib.authentication) {
 		pr_err("Initiator is requesting CSG: 1, has not been"
 			 " successfully authenticated, and the Target is"
 			" enforcing iSCSI Authentication, login failed.\n");
@@ -632,10 +942,11 @@
 			if (login_rsp->flags & ISCSI_FLAG_LOGIN_TRANSIT) {
 				login->tsih = conn->sess->tsih;
 				login->login_complete = 1;
+				iscsi_target_restore_sock_callbacks(conn);
 				if (iscsi_target_do_tx_login_io(conn,
 						login) < 0)
 					return -1;
-				return 0;
+				return 1;
 			}
 			break;
 		default:
@@ -645,13 +956,29 @@
 			break;
 		}
 
-		if (iscsi_target_do_login_io(conn, login) < 0)
+		if (iscsi_target_do_tx_login_io(conn, login) < 0)
 			return -1;
 
 		if (login_rsp->flags & ISCSI_FLAG_LOGIN_TRANSIT) {
 			login_rsp->flags &= ~ISCSI_FLAG_LOGIN_TRANSIT;
 			login_rsp->flags &= ~ISCSI_FLAG_LOGIN_NEXT_STAGE_MASK;
 		}
+		break;
+	}
+
+	if (conn->sock) {
+		struct sock *sk = conn->sock->sk;
+		bool state;
+
+		read_lock_bh(&sk->sk_callback_lock);
+		state = iscsi_target_sk_state_check(sk);
+		read_unlock_bh(&sk->sk_callback_lock);
+
+		if (!state) {
+			pr_debug("iscsi_target_do_login() failed state for"
+				 " conn: %p\n", conn);
+			return -1;
+		}
 	}
 
 	return 0;
@@ -684,9 +1011,17 @@
 	char *tmpbuf, *start = NULL, *end = NULL, *key, *value;
 	struct iscsi_session *sess = conn->sess;
 	struct iscsi_tiqn *tiqn;
+	struct iscsi_tpg_np *tpg_np = NULL;
 	struct iscsi_login_req *login_req;
-	u32 payload_length;
-	int sessiontype = 0, ret = 0;
+	struct se_node_acl *se_nacl;
+	u32 payload_length, queue_depth = 0;
+	int sessiontype = 0, ret = 0, tag_num, tag_size;
+
+	INIT_DELAYED_WORK(&conn->login_work, iscsi_target_do_login_rx);
+	INIT_DELAYED_WORK(&conn->login_cleanup_work, iscsi_target_do_cleanup);
+	iscsi_target_set_sock_callbacks(conn);
+
+	login->np = np;
 
 	login_req = (struct iscsi_login_req *) login->req;
 	payload_length = ntoh24(login_req->dlength);
@@ -780,7 +1115,7 @@
 			goto out;
 		}
 		ret = 0;
-		goto out;
+		goto alloc_tags;
 	}
 
 get_target:
@@ -811,7 +1146,7 @@
 	/*
 	 * Locate Target Portal Group from Storage Node.
 	 */
-	conn->tpg = iscsit_get_tpg_from_np(tiqn, np);
+	conn->tpg = iscsit_get_tpg_from_np(tiqn, np, &tpg_np);
 	if (!conn->tpg) {
 		pr_err("Unable to locate Target Portal Group"
 				" on %s\n", tiqn->tiqn);
@@ -821,12 +1156,16 @@
 		ret = -1;
 		goto out;
 	}
+	conn->tpg_np = tpg_np;
 	pr_debug("Located Portal Group Object: %hu\n", conn->tpg->tpgt);
 	/*
 	 * Setup crc32c modules from libcrypto
 	 */
 	if (iscsi_login_setup_crypto(conn) < 0) {
 		pr_err("iscsi_login_setup_crypto() failed\n");
+		kref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);
+		iscsit_put_tiqn_for_login(tiqn);
+		conn->tpg = NULL;
 		ret = -1;
 		goto out;
 	}
@@ -835,11 +1174,12 @@
 	 * process login attempt.
 	 */
 	if (iscsit_access_np(np, conn->tpg) < 0) {
+		kref_put(&tpg_np->tpg_np_kref, iscsit_login_kref_put);
 		iscsit_put_tiqn_for_login(tiqn);
 		iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
 				ISCSI_LOGIN_STATUS_SVC_UNAVAILABLE);
-		ret = -1;
 		conn->tpg = NULL;
+		ret = -1;
 		goto out;
 	}
 
@@ -872,8 +1212,27 @@
 		ret = -1;
 		goto out;
 	}
+	se_nacl = sess->se_sess->se_node_acl;
+	queue_depth = se_nacl->queue_depth;
+	/*
+	 * Setup pre-allocated tags based upon allowed per NodeACL CmdSN
+	 * depth for non immediate commands, plus extra tags for immediate
+	 * commands.
+	 *
+	 * Also enforce a ISCSIT_MIN_TAGS to prevent unnecessary contention
+	 * in per-cpu-ida tag allocation logic + small queue_depth.
+	 */
+alloc_tags:
+	tag_num = max_t(u32, ISCSIT_MIN_TAGS, queue_depth);
+	tag_num = (tag_num * 2) + ISCSIT_EXTRA_TAGS;
+	tag_size = sizeof(struct iscsi_cmd) + conn->conn_transport->priv_size;
 
-	ret = 0;
+	ret = transport_alloc_session_tags(sess->se_sess, tag_num, tag_size);
+	if (ret < 0) {
+		iscsit_tx_login_rsp(conn, ISCSI_STATUS_CLS_TARGET_ERR,
+				    ISCSI_LOGIN_STATUS_NO_RESOURCES);
+		ret = -1;
+	}
 out:
 	kfree(tmpbuf);
 	return ret;
@@ -886,10 +1245,23 @@
 	int ret;
 
 	ret = iscsi_target_do_login(conn, login);
-	if (ret != 0)
+	if (!ret) {
+		if (conn->sock) {
+			struct sock *sk = conn->sock->sk;
+
+			write_lock_bh(&sk->sk_callback_lock);
+			set_bit(LOGIN_FLAGS_READY, &conn->login_flags);
+			write_unlock_bh(&sk->sk_callback_lock);
+		}
+	} else if (ret < 0) {
+		cancel_delayed_work_sync(&conn->login_work);
+		cancel_delayed_work_sync(&conn->login_cleanup_work);
+		iscsi_target_restore_sock_callbacks(conn);
 		iscsi_remove_failed_auth_entry(conn);
-
+	}
+	if (ret != 0)
 	iscsi_target_nego_release(conn);
+
 	return ret;
 }
 
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_nodeattrib.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_nodeattrib.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_nodeattrib.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_nodeattrib.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains the main functions related to Initiator Node Attributes.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -35,7 +33,8 @@
 }
 
 void iscsit_set_default_node_attribues(
-	struct iscsi_node_acl *acl)
+	struct iscsi_node_acl *acl,
+	struct iscsi_portal_group *tpg)
 {
 	struct iscsi_node_attrib *a = &acl->node_attrib;
 
@@ -46,7 +45,7 @@
 	a->random_datain_pdu_offsets = NA_RANDOM_DATAIN_PDU_OFFSETS;
 	a->random_datain_seq_offsets = NA_RANDOM_DATAIN_SEQ_OFFSETS;
 	a->random_r2t_offsets = NA_RANDOM_R2T_OFFSETS;
-	a->default_erl = NA_DEFAULT_ERL;
+	a->default_erl = tpg->tpg_attrib.default_erl;
 }
 
 int iscsit_na_dataout_timeout(
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_nodeattrib.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_nodeattrib.h
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_nodeattrib.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_nodeattrib.h	2017-05-02 03:31:56.000000000 +0200
@@ -1,7 +1,8 @@
 #ifndef ISCSI_TARGET_NODEATTRIB_H
 #define ISCSI_TARGET_NODEATTRIB_H
 
-extern void iscsit_set_default_node_attribues(struct iscsi_node_acl *);
+extern void iscsit_set_default_node_attribues(struct iscsi_node_acl *,
+					      struct iscsi_portal_group *);
 extern int iscsit_na_dataout_timeout(struct iscsi_node_acl *, u32);
 extern int iscsit_na_dataout_timeout_retries(struct iscsi_node_acl *, u32);
 extern int iscsit_na_nopin_timeout(struct iscsi_node_acl *, u32);
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_parameters.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_parameters.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_parameters.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_parameters.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains main functions related to iSCSI Parameter negotiation.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -1182,7 +1180,7 @@
 			unsigned long long tmp;
 			int rc;
 
-			rc = strict_strtoull(param->value, 0, &tmp);
+			rc = kstrtoull(param->value, 0, &tmp);
 			if (rc < 0)
 				return -1;
 
@@ -1799,9 +1797,6 @@
 		 * this key is not sent over the wire.
 		 */
 		if (!strcmp(param->name, MAXXMITDATASEGMENTLENGTH)) {
-			if (param_list->iser == true)
-				continue;
-
 			ops->MaxXmitDataSegmentLength =
 				simple_strtoul(param->value, &tmpptr, 0);
 			pr_debug("MaxXmitDataSegmentLength:     %s\n",
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_seq_pdu_list.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_seq_pdu_list.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_seq_pdu_list.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_seq_pdu_list.c	2017-05-02 03:31:56.000000000 +0200
@@ -2,9 +2,7 @@
  * This file contains main functions related to iSCSI DataSequenceInOrder=No
  * and DataPDUInOrder=No.
  *
- \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_stat.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_stat.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_stat.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_stat.c	2017-05-02 03:31:56.000000000 +0200
@@ -2,9 +2,7 @@
  * Modern ConfigFS group context specific iSCSI statistics based on original
  * iscsi_target_mib.c code
  *
- * Copyright (c) 2011 Rising Tide Systems
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * Copyright (c) 2011-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -177,7 +175,7 @@
 static ssize_t iscsi_stat_instance_show_attr_vendor(
 	struct iscsi_wwn_stat_grps *igrps, char *page)
 {
-	return snprintf(page, PAGE_SIZE, "RisingTide Systems iSCSI-Target\n");
+	return snprintf(page, PAGE_SIZE, "Datera, Inc. iSCSI-Target\n");
 }
 ISCSI_STAT_INSTANCE_ATTR_RO(vendor);
 
@@ -432,13 +430,7 @@
 	int ret;
 
 	spin_lock(&lstat->lock);
-	if (lstat->last_intr_fail_ip_family == AF_INET6) {
-		ret = snprintf(page, PAGE_SIZE, "[%s]\n",
-			       lstat->last_intr_fail_ip_addr);
-	} else {
-		ret = snprintf(page, PAGE_SIZE, "%s\n",
-			       lstat->last_intr_fail_ip_addr);
-	}
+	ret = snprintf(page, PAGE_SIZE, "%s\n", lstat->last_intr_fail_ip_addr);
 	spin_unlock(&lstat->lock);
 
 	return ret;
@@ -800,7 +792,8 @@
 	if (se_sess) {
 		sess = se_sess->fabric_sess_ptr;
 		if (sess)
-			ret = snprintf(page, PAGE_SIZE, "%u\n", sess->cmd_pdus);
+			ret = snprintf(page, PAGE_SIZE, "%lu\n",
+				       atomic_long_read(&sess->cmd_pdus));
 	}
 	spin_unlock_bh(&se_nacl->nacl_sess_lock);
 
@@ -823,7 +816,8 @@
 	if (se_sess) {
 		sess = se_sess->fabric_sess_ptr;
 		if (sess)
-			ret = snprintf(page, PAGE_SIZE, "%u\n", sess->rsp_pdus);
+			ret = snprintf(page, PAGE_SIZE, "%lu\n",
+				       atomic_long_read(&sess->rsp_pdus));
 	}
 	spin_unlock_bh(&se_nacl->nacl_sess_lock);
 
@@ -846,8 +840,8 @@
 	if (se_sess) {
 		sess = se_sess->fabric_sess_ptr;
 		if (sess)
-			ret = snprintf(page, PAGE_SIZE, "%llu\n",
-				(unsigned long long)sess->tx_data_octets);
+			ret = snprintf(page, PAGE_SIZE, "%lu\n",
+				       atomic_long_read(&sess->tx_data_octets));
 	}
 	spin_unlock_bh(&se_nacl->nacl_sess_lock);
 
@@ -870,8 +864,8 @@
 	if (se_sess) {
 		sess = se_sess->fabric_sess_ptr;
 		if (sess)
-			ret = snprintf(page, PAGE_SIZE, "%llu\n",
-				(unsigned long long)sess->rx_data_octets);
+			ret = snprintf(page, PAGE_SIZE, "%lu\n",
+				       atomic_long_read(&sess->rx_data_octets));
 	}
 	spin_unlock_bh(&se_nacl->nacl_sess_lock);
 
@@ -894,8 +888,8 @@
 	if (se_sess) {
 		sess = se_sess->fabric_sess_ptr;
 		if (sess)
-			ret = snprintf(page, PAGE_SIZE, "%u\n",
-					sess->conn_digest_errors);
+			ret = snprintf(page, PAGE_SIZE, "%lu\n",
+				       atomic_long_read(&sess->conn_digest_errors));
 	}
 	spin_unlock_bh(&se_nacl->nacl_sess_lock);
 
@@ -918,8 +912,8 @@
 	if (se_sess) {
 		sess = se_sess->fabric_sess_ptr;
 		if (sess)
-			ret = snprintf(page, PAGE_SIZE, "%u\n",
-					sess->conn_timeout_errors);
+			ret = snprintf(page, PAGE_SIZE, "%lu\n",
+				       atomic_long_read(&sess->conn_timeout_errors));
 	}
 	spin_unlock_bh(&se_nacl->nacl_sess_lock);
 
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_tmr.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_tmr.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_tmr.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_tmr.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains the iSCSI Target specific Task Management functions.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_tpg.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_tpg.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_tpg.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_tpg.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains iSCSI Target Portal Group related functions.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -49,7 +47,7 @@
 	INIT_LIST_HEAD(&tpg->tpg_gnp_list);
 	INIT_LIST_HEAD(&tpg->tpg_list);
 	mutex_init(&tpg->tpg_access_lock);
-	mutex_init(&tpg->np_login_lock);
+	sema_init(&tpg->np_login_sem, 1);
 	spin_lock_init(&tpg->tpg_state_lock);
 	spin_lock_init(&tpg->tpg_np_lock);
 
@@ -129,7 +127,8 @@
 
 struct iscsi_portal_group *iscsit_get_tpg_from_np(
 	struct iscsi_tiqn *tiqn,
-	struct iscsi_np *np)
+	struct iscsi_np *np,
+	struct iscsi_tpg_np **tpg_np_out)
 {
 	struct iscsi_portal_group *tpg = NULL;
 	struct iscsi_tpg_np *tpg_np;
@@ -147,6 +146,8 @@
 		spin_lock(&tpg->tpg_np_lock);
 		list_for_each_entry(tpg_np, &tpg->tpg_gnp_list, tpg_np_list) {
 			if (tpg_np->tpg_np == np) {
+				*tpg_np_out = tpg_np;
+				kref_get(&tpg_np->tpg_np_kref);
 				spin_unlock(&tpg->tpg_np_lock);
 				spin_unlock(&tiqn->tiqn_tpg_lock);
 				return tpg;
@@ -185,11 +186,12 @@
 
 	if (shutdown)
 		tpg_np->tpg_np->enabled = false;
-	iscsit_reset_np_thread(tpg_np->tpg_np, tpg_np, tpg);
+	iscsit_reset_np_thread(tpg_np->tpg_np, tpg_np, tpg, shutdown);
 }
 
 void iscsit_clear_tpg_np_login_threads(
-	struct iscsi_portal_group *tpg)
+	struct iscsi_portal_group *tpg,
+	bool shutdown)
 {
 	struct iscsi_tpg_np *tpg_np;
 
@@ -200,7 +202,7 @@
 			continue;
 		}
 		spin_unlock(&tpg->tpg_np_lock);
-		iscsit_clear_tpg_np_login_thread(tpg_np, tpg, false);
+		iscsit_clear_tpg_np_login_thread(tpg_np, tpg, shutdown);
 		spin_lock(&tpg->tpg_np_lock);
 	}
 	spin_unlock(&tpg->tpg_np_lock);
@@ -223,6 +225,8 @@
 	a->cache_dynamic_acls = TA_CACHE_DYNAMIC_ACLS;
 	a->demo_mode_write_protect = TA_DEMO_MODE_WRITE_PROTECT;
 	a->prod_mode_write_protect = TA_PROD_MODE_WRITE_PROTECT;
+	a->demo_mode_discovery = TA_DEMO_MODE_DISCOVERY;
+	a->default_erl = TA_DEFAULT_ERL;
 }
 
 int iscsit_tpg_add_portal_group(struct iscsi_tiqn *tiqn, struct iscsi_portal_group *tpg)
@@ -237,7 +241,7 @@
 	if (iscsi_create_default_params(&tpg->param_list) < 0)
 		goto err_out;
 
-	ISCSI_TPG_ATTRIB(tpg)->tpg = tpg;
+	tpg->tpg_attrib.tpg = tpg;
 
 	spin_lock(&tpg->tpg_state_lock);
 	tpg->tpg_state	= TPG_STATE_INACTIVE;
@@ -271,6 +275,8 @@
 	tpg->tpg_state = TPG_STATE_INACTIVE;
 	spin_unlock(&tpg->tpg_state_lock);
 
+	iscsit_clear_tpg_np_login_threads(tpg, true);
+
 	if (iscsit_release_sessions_for_tpg(tpg, force) < 0) {
 		pr_err("Unable to delete iSCSI Target Portal Group:"
 			" %hu while active sessions exist, and force=0\n",
@@ -328,7 +334,7 @@
 		return -EINVAL;
 	}
 
-	if (ISCSI_TPG_ATTRIB(tpg)->authentication) {
+	if (tpg->tpg_attrib.authentication) {
 		if (!strcmp(param->value, NONE)) {
 			ret = iscsi_update_param_value(param, CHAP);
 			if (ret)
@@ -371,7 +377,7 @@
 	tpg->tpg_state = TPG_STATE_INACTIVE;
 	spin_unlock(&tpg->tpg_state_lock);
 
-	iscsit_clear_tpg_np_login_threads(tpg);
+	iscsit_clear_tpg_np_login_threads(tpg, false);
 
 	if (iscsit_release_sessions_for_tpg(tpg, force) < 0) {
 		spin_lock(&tpg->tpg_state_lock);
@@ -493,6 +499,8 @@
 	INIT_LIST_HEAD(&tpg_np->tpg_np_child_list);
 	INIT_LIST_HEAD(&tpg_np->tpg_np_parent_list);
 	spin_lock_init(&tpg_np->tpg_np_parent_lock);
+	init_completion(&tpg_np->tpg_np_comp);
+	kref_init(&tpg_np->tpg_np_kref);
 	tpg_np->tpg_np		= np;
 	tpg_np->tpg		= tpg;
 
@@ -816,3 +824,39 @@
 
 	return 0;
 }
+
+int iscsit_ta_demo_mode_discovery(
+	struct iscsi_portal_group *tpg,
+	u32 flag)
+{
+	struct iscsi_tpg_attrib *a = &tpg->tpg_attrib;
+
+	if ((flag != 0) && (flag != 1)) {
+		pr_err("Illegal value %d\n", flag);
+		return -EINVAL;
+	}
+
+	a->demo_mode_discovery = flag;
+	pr_debug("iSCSI_TPG[%hu] - Demo Mode Discovery bit:"
+		" %s\n", tpg->tpgt, (a->demo_mode_discovery) ?
+		"ON" : "OFF");
+
+	return 0;
+}
+
+int iscsit_ta_default_erl(
+	struct iscsi_portal_group *tpg,
+	u32 default_erl)
+{
+	struct iscsi_tpg_attrib *a = &tpg->tpg_attrib;
+
+	if ((default_erl != 0) && (default_erl != 1) && (default_erl != 2)) {
+		pr_err("Illegal value for default_erl: %u\n", default_erl);
+		return -EINVAL;
+	}
+
+	a->default_erl = default_erl;
+	pr_debug("iSCSI_TPG[%hu] - DefaultERL: %u\n", tpg->tpgt, a->default_erl);
+
+	return 0;
+}
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_tpg.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_tpg.h
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_tpg.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_tpg.h	2017-05-02 03:31:56.000000000 +0200
@@ -5,10 +5,10 @@
 extern int iscsit_load_discovery_tpg(void);
 extern void iscsit_release_discovery_tpg(void);
 extern struct iscsi_portal_group *iscsit_get_tpg_from_np(struct iscsi_tiqn *,
-			struct iscsi_np *);
+			struct iscsi_np *, struct iscsi_tpg_np **);
 extern int iscsit_get_tpg(struct iscsi_portal_group *);
 extern void iscsit_put_tpg(struct iscsi_portal_group *);
-extern void iscsit_clear_tpg_np_login_threads(struct iscsi_portal_group *);
+extern void iscsit_clear_tpg_np_login_threads(struct iscsi_portal_group *, bool);
 extern void iscsit_tpg_dump_params(struct iscsi_portal_group *);
 extern int iscsit_tpg_add_portal_group(struct iscsi_tiqn *, struct iscsi_portal_group *);
 extern int iscsit_tpg_del_portal_group(struct iscsi_tiqn *, struct iscsi_portal_group *,
@@ -37,5 +37,7 @@
 extern int iscsit_ta_cache_dynamic_acls(struct iscsi_portal_group *, u32);
 extern int iscsit_ta_demo_mode_write_protect(struct iscsi_portal_group *, u32);
 extern int iscsit_ta_prod_mode_write_protect(struct iscsi_portal_group *, u32);
+extern int iscsit_ta_demo_mode_discovery(struct iscsi_portal_group *, u32);
+extern int iscsit_ta_default_erl(struct iscsi_portal_group *, u32);
 
 #endif /* ISCSI_TARGET_TPG_H */
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_tq.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_tq.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_tq.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_tq.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains the iSCSI Login Thread and Thread Queue functions.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -26,36 +24,22 @@
 #include "iscsi_target_tq.h"
 #include "iscsi_target.h"
 
-static LIST_HEAD(active_ts_list);
 static LIST_HEAD(inactive_ts_list);
-static DEFINE_SPINLOCK(active_ts_lock);
 static DEFINE_SPINLOCK(inactive_ts_lock);
 static DEFINE_SPINLOCK(ts_bitmap_lock);
 
-static void iscsi_add_ts_to_active_list(struct iscsi_thread_set *ts)
-{
-	spin_lock(&active_ts_lock);
-	list_add_tail(&ts->ts_list, &active_ts_list);
-	iscsit_global->active_ts++;
-	spin_unlock(&active_ts_lock);
-}
-
 static void iscsi_add_ts_to_inactive_list(struct iscsi_thread_set *ts)
 {
+	if (!list_empty(&ts->ts_list)) {
+		WARN_ON(1);
+		return;
+	}
 	spin_lock(&inactive_ts_lock);
 	list_add_tail(&ts->ts_list, &inactive_ts_list);
 	iscsit_global->inactive_ts++;
 	spin_unlock(&inactive_ts_lock);
 }
 
-static void iscsi_del_ts_from_active_list(struct iscsi_thread_set *ts)
-{
-	spin_lock(&active_ts_lock);
-	list_del(&ts->ts_list);
-	iscsit_global->active_ts--;
-	spin_unlock(&active_ts_lock);
-}
-
 static struct iscsi_thread_set *iscsi_get_ts_from_inactive_list(void)
 {
 	struct iscsi_thread_set *ts;
@@ -68,7 +52,7 @@
 
 	ts = list_first_entry(&inactive_ts_list, struct iscsi_thread_set, ts_list);
 
-	list_del(&ts->ts_list);
+	list_del_init(&ts->ts_list);
 	iscsit_global->inactive_ts--;
 	spin_unlock(&inactive_ts_lock);
 
@@ -105,12 +89,11 @@
 		ts->status = ISCSI_THREAD_SET_FREE;
 		INIT_LIST_HEAD(&ts->ts_list);
 		spin_lock_init(&ts->ts_state_lock);
-		init_completion(&ts->rx_post_start_comp);
-		init_completion(&ts->tx_post_start_comp);
 		init_completion(&ts->rx_restart_comp);
 		init_completion(&ts->tx_restart_comp);
 		init_completion(&ts->rx_start_comp);
 		init_completion(&ts->tx_start_comp);
+		sema_init(&ts->ts_activate_sem, 0);
 
 		ts->create_threads = 1;
 		ts->tx_thread = kthread_run(iscsi_target_tx_thread, ts, "%s",
@@ -139,25 +122,24 @@
 	return allocated_thread_pair_count;
 }
 
-void iscsi_deallocate_thread_sets(void)
+static void iscsi_deallocate_thread_one(struct iscsi_thread_set *ts)
 {
-	u32 released_count = 0;
-	struct iscsi_thread_set *ts = NULL;
-
-	while ((ts = iscsi_get_ts_from_inactive_list())) {
-
 		spin_lock_bh(&ts->ts_state_lock);
 		ts->status = ISCSI_THREAD_SET_DIE;
-		spin_unlock_bh(&ts->ts_state_lock);
 
 		if (ts->rx_thread) {
-			send_sig(SIGINT, ts->rx_thread, 1);
+		complete(&ts->rx_start_comp);
+		spin_unlock_bh(&ts->ts_state_lock);
 			kthread_stop(ts->rx_thread);
+		spin_lock_bh(&ts->ts_state_lock);
 		}
 		if (ts->tx_thread) {
-			send_sig(SIGINT, ts->tx_thread, 1);
+		complete(&ts->tx_start_comp);
+		spin_unlock_bh(&ts->ts_state_lock);
 			kthread_stop(ts->tx_thread);
+		spin_lock_bh(&ts->ts_state_lock);
 		}
+	spin_unlock_bh(&ts->ts_state_lock);
 		/*
 		 * Release this thread_id in the thread_set_bitmap
 		 */
@@ -166,8 +148,18 @@
 				ts->thread_id, get_order(1));
 		spin_unlock(&ts_bitmap_lock);
 
-		released_count++;
 		kfree(ts);
+}
+
+void iscsi_deallocate_thread_sets(void)
+{
+	struct iscsi_thread_set *ts = NULL;
+	u32 released_count = 0;
+
+	while ((ts = iscsi_get_ts_from_inactive_list())) {
+
+		iscsi_deallocate_thread_one(ts);
+		released_count++;
 	}
 
 	if (released_count)
@@ -187,74 +179,37 @@
 		if (!ts)
 			break;
 
-		spin_lock_bh(&ts->ts_state_lock);
-		ts->status = ISCSI_THREAD_SET_DIE;
-		spin_unlock_bh(&ts->ts_state_lock);
-
-		if (ts->rx_thread) {
-			send_sig(SIGINT, ts->rx_thread, 1);
-			kthread_stop(ts->rx_thread);
-		}
-		if (ts->tx_thread) {
-			send_sig(SIGINT, ts->tx_thread, 1);
-			kthread_stop(ts->tx_thread);
-		}
-		/*
-		 * Release this thread_id in the thread_set_bitmap
-		 */
-		spin_lock(&ts_bitmap_lock);
-		bitmap_release_region(iscsit_global->ts_bitmap,
-				ts->thread_id, get_order(1));
-		spin_unlock(&ts_bitmap_lock);
-
+		iscsi_deallocate_thread_one(ts);
 		released_count++;
-		kfree(ts);
 	}
 
-	if (released_count) {
+	if (released_count)
 		pr_debug("Stopped %d thread set(s) (%d total threads)."
 			"\n", released_count, released_count * 2);
-	}
 }
 
 void iscsi_activate_thread_set(struct iscsi_conn *conn, struct iscsi_thread_set *ts)
 {
-	iscsi_add_ts_to_active_list(ts);
-
 	spin_lock_bh(&ts->ts_state_lock);
 	conn->thread_set = ts;
 	ts->conn = conn;
+	ts->status = ISCSI_THREAD_SET_ACTIVE;
 	spin_unlock_bh(&ts->ts_state_lock);
-	/*
-	 * Start up the RX thread and wait on rx_post_start_comp.  The RX
-	 * Thread will then do the same for the TX Thread in
-	 * iscsi_rx_thread_pre_handler().
-	 */
+
 	complete(&ts->rx_start_comp);
-	wait_for_completion(&ts->rx_post_start_comp);
+	complete(&ts->tx_start_comp);
+
+	down(&ts->ts_activate_sem);
 }
 
 struct iscsi_thread_set *iscsi_get_thread_set(void)
 {
-	int allocate_ts = 0;
-	struct completion comp;
-	struct iscsi_thread_set *ts = NULL;
-	/*
-	 * If no inactive thread set is available on the first call to
-	 * iscsi_get_ts_from_inactive_list(), sleep for a second and
-	 * try again.  If still none are available after two attempts,
-	 * allocate a set ourselves.
-	 */
+	struct iscsi_thread_set *ts;
+
 get_set:
 	ts = iscsi_get_ts_from_inactive_list();
 	if (!ts) {
-		if (allocate_ts == 2)
 			iscsi_allocate_thread_sets(1);
-
-		init_completion(&comp);
-		wait_for_completion_timeout(&comp, 1 * HZ);
-
-		allocate_ts++;
 		goto get_set;
 	}
 
@@ -263,6 +218,7 @@
 	ts->thread_count = 2;
 	init_completion(&ts->rx_restart_comp);
 	init_completion(&ts->tx_restart_comp);
+	sema_init(&ts->ts_activate_sem, 0);
 
 	return ts;
 }
@@ -400,7 +356,8 @@
 static int iscsi_signal_thread_pre_handler(struct iscsi_thread_set *ts)
 {
 	spin_lock_bh(&ts->ts_state_lock);
-	if ((ts->status == ISCSI_THREAD_SET_DIE) || signal_pending(current)) {
+	if (ts->status == ISCSI_THREAD_SET_DIE || kthread_should_stop() ||
+	    signal_pending(current)) {
 		spin_unlock_bh(&ts->ts_state_lock);
 		return -1;
 	}
@@ -419,11 +376,11 @@
 		goto sleep;
 	}
 
+	if (ts->status != ISCSI_THREAD_SET_DIE)
 	flush_signals(current);
 
 	if (ts->delay_inactive && (--ts->thread_count == 0)) {
 		spin_unlock_bh(&ts->ts_state_lock);
-		iscsi_del_ts_from_active_list(ts);
 
 		if (!iscsit_global->in_shutdown)
 			iscsi_deallocate_extra_thread_sets();
@@ -446,18 +403,19 @@
 	if (iscsi_signal_thread_pre_handler(ts) < 0)
 		return NULL;
 
+	iscsi_check_to_add_additional_sets();
+
+	spin_lock_bh(&ts->ts_state_lock);
 	if (!ts->conn) {
 		pr_err("struct iscsi_thread_set->conn is NULL for"
-			" thread_id: %d, going back to sleep\n", ts->thread_id);
-		goto sleep;
+			" RX thread_id: %s/%d\n", current->comm, current->pid);
+		spin_unlock_bh(&ts->ts_state_lock);
+		return NULL;
 	}
-	iscsi_check_to_add_additional_sets();
-	/*
-	 * The RX Thread starts up the TX Thread and sleeps.
-	 */
 	ts->thread_clear |= ISCSI_CLEAR_RX_THREAD;
-	complete(&ts->tx_start_comp);
-	wait_for_completion(&ts->tx_post_start_comp);
+	spin_unlock_bh(&ts->ts_state_lock);
+
+	up(&ts->ts_activate_sem);
 
 	return ts->conn;
 }
@@ -472,11 +430,11 @@
 		goto sleep;
 	}
 
+	if (ts->status != ISCSI_THREAD_SET_DIE)
 	flush_signals(current);
 
 	if (ts->delay_inactive && (--ts->thread_count == 0)) {
 		spin_unlock_bh(&ts->ts_state_lock);
-		iscsi_del_ts_from_active_list(ts);
 
 		if (!iscsit_global->in_shutdown)
 			iscsi_deallocate_extra_thread_sets();
@@ -498,27 +456,20 @@
 	if (iscsi_signal_thread_pre_handler(ts) < 0)
 		return NULL;
 
-	if (!ts->conn) {
-		pr_err("struct iscsi_thread_set->conn is NULL for "
-			" thread_id: %d, going back to sleep\n",
-			ts->thread_id);
-		goto sleep;
-	}
-
 	iscsi_check_to_add_additional_sets();
-	/*
-	 * From the TX thread, up the tx_post_start_comp that the RX Thread is
-	 * sleeping on in iscsi_rx_thread_pre_handler(), then up the
-	 * rx_post_start_comp that iscsi_activate_thread_set() is sleeping on.
-	 */
-	ts->thread_clear |= ISCSI_CLEAR_TX_THREAD;
-	complete(&ts->tx_post_start_comp);
-	complete(&ts->rx_post_start_comp);
 
 	spin_lock_bh(&ts->ts_state_lock);
-	ts->status = ISCSI_THREAD_SET_ACTIVE;
+	if (!ts->conn) {
+		pr_err("struct iscsi_thread_set->conn is NULL for"
+			" TX thread_id: %s/%d\n", current->comm, current->pid);
+		spin_unlock_bh(&ts->ts_state_lock);
+		return NULL;
+	}
+	ts->thread_clear |= ISCSI_CLEAR_TX_THREAD;
 	spin_unlock_bh(&ts->ts_state_lock);
 
+	up(&ts->ts_activate_sem);
+
 	return ts->conn;
 }
 
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_tq.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_tq.h
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_tq.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_tq.h	2017-05-02 03:31:56.000000000 +0200
@@ -64,10 +64,6 @@
 	struct iscsi_conn	*conn;
 	/* used for controlling ts state accesses */
 	spinlock_t	ts_state_lock;
-	/* Used for rx side post startup */
-	struct completion	rx_post_start_comp;
-	/* Used for tx side post startup */
-	struct completion	tx_post_start_comp;
 	/* used for restarting thread queue */
 	struct completion	rx_restart_comp;
 	/* used for restarting thread queue */
@@ -82,6 +78,7 @@
 	struct task_struct	*tx_thread;
 	/* struct iscsi_thread_set in list list head*/
 	struct list_head	ts_list;
+	struct semaphore	ts_activate_sem;
 };
 
 #endif   /*** ISCSI_THREAD_QUEUE_H ***/
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_util.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_util.c
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_util.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_util.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,9 +1,7 @@
 /*******************************************************************************
  * This file contains the iSCSI Target specific utility functions.
  *
- * \u00a9 Copyright 2007-2011 RisingTide Systems LLC.
- *
- * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
+ * (c) Copyright 2007-2013 Datera, Inc.
  *
  * Author: Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -19,6 +17,7 @@
  ******************************************************************************/
 
 #include <linux/list.h>
+#include <linux/percpu_ida.h>
 #include <scsi/scsi_tcq.h>
 #include <scsi/iscsi_proto.h>
 #include <target/target_core_base.h>
@@ -149,31 +148,25 @@
 	spin_unlock_bh(&cmd->r2t_lock);
 }
 
-struct iscsi_cmd *iscsit_alloc_cmd(struct iscsi_conn *conn, gfp_t gfp_mask)
-{
-	struct iscsi_cmd *cmd;
-
-	cmd = kmem_cache_zalloc(lio_cmd_cache, gfp_mask);
-	if (!cmd)
-		return NULL;
-
-	cmd->release_cmd = &iscsit_release_cmd;
-	return cmd;
-}
-
 /*
  * May be called from software interrupt (timer) context for allocating
  * iSCSI NopINs.
  */
-struct iscsi_cmd *iscsit_allocate_cmd(struct iscsi_conn *conn, gfp_t gfp_mask)
+struct iscsi_cmd *iscsit_allocate_cmd(struct iscsi_conn *conn, int state)
 {
 	struct iscsi_cmd *cmd;
+	struct se_session *se_sess = conn->sess->se_sess;
+	int size, tag;
 
-	cmd = conn->conn_transport->iscsit_alloc_cmd(conn, gfp_mask);
-	if (!cmd) {
-		pr_err("Unable to allocate memory for struct iscsi_cmd.\n");
+	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, state);
+	if (tag < 0)
 		return NULL;
-	}
+
+	size = sizeof(struct iscsi_cmd) + conn->conn_transport->priv_size;
+	cmd = (struct iscsi_cmd *)(se_sess->sess_cmd_map + (tag * size));
+	memset(cmd, 0, size);
+
+	cmd->se_cmd.map_tag = tag;
 	cmd->conn = conn;
 	INIT_LIST_HEAD(&cmd->i_conn_node);
 	INIT_LIST_HEAD(&cmd->datain_list);
@@ -252,9 +245,9 @@
 	 */
 	if (iscsi_sna_gt(cmdsn, sess->max_cmd_sn)) {
 		pr_err("Received CmdSN: 0x%08x is greater than"
-		       " MaxCmdSN: 0x%08x, protocol error.\n", cmdsn,
+		       " MaxCmdSN: 0x%08x, ignoring.\n", cmdsn,
 		       sess->max_cmd_sn);
-		ret = CMDSN_ERROR_CANNOT_RECOVER;
+		ret = CMDSN_MAXCMDSN_OVERRUN;
 
 	} else if (cmdsn == sess->exp_cmd_sn) {
 		sess->exp_cmd_sn++;
@@ -313,14 +306,16 @@
 		ret = CMDSN_HIGHER_THAN_EXP;
 		break;
 	case CMDSN_LOWER_THAN_EXP:
+	case CMDSN_MAXCMDSN_OVERRUN:
+	default:
 		cmd->i_state = ISTATE_REMOVE;
 		iscsit_add_cmd_to_immediate_queue(cmd, conn, cmd->i_state);
-		ret = cmdsn_ret;
-		break;
-	default:
-		reason = ISCSI_REASON_PROTOCOL_ERROR;
-		reject = true;
-		ret = cmdsn_ret;
+		/*
+		 * Existing callers for iscsit_sequence_cmd() will silently
+		 * ignore commands with CMDSN_LOWER_THAN_EXP, so force this
+		 * return for CMDSN_MAXCMDSN_OVERRUN as well..
+		 */
+		ret = CMDSN_LOWER_THAN_EXP;
 		break;
 	}
 	mutex_unlock(&conn->sess->cmdsn_mutex);
@@ -689,14 +684,26 @@
 
 void iscsit_release_cmd(struct iscsi_cmd *cmd)
 {
+	struct iscsi_session *sess;
+	struct se_cmd *se_cmd = &cmd->se_cmd;
+
+	if (cmd->conn)
+		sess = cmd->conn->sess;
+	else
+		sess = cmd->sess;
+
+	BUG_ON(!sess || !sess->se_sess);
+
 	kfree(cmd->buf_ptr);
 	kfree(cmd->pdu_list);
 	kfree(cmd->seq_list);
 	kfree(cmd->tmr_req);
 	kfree(cmd->iov_data);
+	kfree(cmd->text_in_ptr);
 
-	kmem_cache_free(lio_cmd_cache, cmd);
+	percpu_ida_free(&sess->se_sess->sess_tag_pool, se_cmd->map_tag);
 }
+EXPORT_SYMBOL(iscsit_release_cmd);
 
 static void __iscsit_free_cmd(struct iscsi_cmd *cmd, bool scsi_cmd,
 			      bool check_queues)
@@ -760,7 +767,7 @@
 		/* Fall-through */
 	default:
 		__iscsit_free_cmd(cmd, false, shutdown);
-		cmd->release_cmd(cmd);
+		iscsit_release_cmd(cmd);
 		break;
 	}
 }
@@ -922,7 +929,7 @@
 	u8 state;
 	struct iscsi_cmd *cmd;
 
-	cmd = iscsit_allocate_cmd(conn, GFP_ATOMIC);
+	cmd = iscsit_allocate_cmd(conn, TASK_RUNNING);
 	if (!cmd)
 		return -1;
 
@@ -978,7 +985,7 @@
 		tiqn->sess_err_stats.last_sess_failure_type =
 				ISCSI_SESS_ERR_CXN_TIMEOUT;
 		tiqn->sess_err_stats.cxn_timeout_errors++;
-		conn->sess->conn_timeout_errors++;
+		atomic_long_inc(&conn->sess->conn_timeout_errors);
 		spin_unlock_bh(&tiqn->sess_err_stats.lock);
 	}
 	}
diff -rubB --new-file linux-3.10.69/drivers/target/iscsi/iscsi_target_util.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_util.h
--- linux-3.10.69/drivers/target/iscsi/iscsi_target_util.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/iscsi/iscsi_target_util.h	2017-05-02 03:31:56.000000000 +0200
@@ -9,7 +9,7 @@
 extern void iscsit_free_r2t(struct iscsi_r2t *, struct iscsi_cmd *);
 extern void iscsit_free_r2ts_from_list(struct iscsi_cmd *);
 extern struct iscsi_cmd *iscsit_alloc_cmd(struct iscsi_conn *, gfp_t);
-extern struct iscsi_cmd *iscsit_allocate_cmd(struct iscsi_conn *, gfp_t);
+extern struct iscsi_cmd *iscsit_allocate_cmd(struct iscsi_conn *, int);
 extern struct iscsi_seq *iscsit_get_seq_holder_for_datain(struct iscsi_cmd *, u32);
 extern struct iscsi_seq *iscsit_get_seq_holder_for_r2t(struct iscsi_cmd *);
 extern struct iscsi_r2t *iscsit_get_holder_for_r2tsn(struct iscsi_cmd *, u32);
diff -rubB --new-file linux-3.10.69/drivers/target/Kconfig F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/Kconfig
--- linux-3.10.69/drivers/target/Kconfig	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/Kconfig	2017-05-02 03:31:56.000000000 +0200
@@ -3,6 +3,7 @@
 	tristate "Generic Target Core Mod (TCM) and ConfigFS Infrastructure"
 	depends on SCSI && BLOCK
 	select CONFIGFS_FS
+	select CRC_T10DIF
 	default n
 	help
 	Say Y or M here to enable the TCM Storage Engine and ConfigFS enabled
@@ -13,6 +14,7 @@
 
 config TCM_IBLOCK
 	tristate "TCM/IBLOCK Subsystem Plugin for Linux/BLOCK"
+	select BLK_DEV_INTEGRITY
 	help
 	Say Y here to enable the TCM/IBLOCK subsystem plugin for non-buffered
 	access to Linux/Block devices using BIO
diff -rubB --new-file linux-3.10.69/drivers/target/loopback/tcm_loop.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/loopback/tcm_loop.c
--- linux-3.10.69/drivers/target/loopback/tcm_loop.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/loopback/tcm_loop.c	2017-05-02 03:31:56.000000000 +0200
@@ -3,7 +3,7 @@
  * This file contains the Linux/SCSI LLD virtual SCSI initiator driver
  * for emulated SAS initiator ports
  *
- * © Copyright 2011 RisingTide Systems LLC.
+ * © Copyright 2011-2013 Datera, Inc.
  *
  * Licensed to the Linux Foundation under the General Public License (GPL) version 2.
  *
@@ -135,21 +135,29 @@
 	return sdev->queue_depth;
 }
 
+static int tcm_loop_change_queue_type(struct scsi_device *sdev, int tag)
+{
+	if (sdev->tagged_supported) {
+		scsi_set_tag_type(sdev, tag);
+
+		if (tag)
+			scsi_activate_tcq(sdev, sdev->queue_depth);
+		else
+			scsi_deactivate_tcq(sdev, sdev->queue_depth);
+	} else
+		tag = 0;
+
+	return tag;
+}
+
 /*
  * Locate the SAM Task Attr from struct scsi_cmnd *
  */
-static int tcm_loop_sam_attr(struct scsi_cmnd *sc)
+static int tcm_loop_sam_attr(struct scsi_cmnd *sc, int tag)
 {
-	if (sc->device->tagged_supported) {
-		switch (sc->tag) {
-		case HEAD_OF_QUEUE_TAG:
-			return MSG_HEAD_TAG;
-		case ORDERED_QUEUE_TAG:
+	if (sc->device->tagged_supported &&
+	    sc->device->ordered_tags && tag >= 0)
 			return MSG_ORDERED_TAG;
-		default:
-			break;
-		}
-	}
 
 	return MSG_SIMPLE_TAG;
 }
@@ -178,7 +186,10 @@
 		set_host_byte(sc, DID_NO_CONNECT);
 		goto out_done;
 	}
-
+	if (tl_tpg->tl_transport_status == TCM_TRANSPORT_OFFLINE) {
+		set_host_byte(sc, DID_TRANSPORT_DISRUPTED);
+		goto out_done;
+	}
 	tl_nexus = tl_tpg->tl_nexus;
 	if (!tl_nexus) {
 		scmd_printk(KERN_ERR, sc, "TCM_Loop I_T Nexus"
@@ -196,10 +207,11 @@
 	}
 	rc = target_submit_cmd_map_sgls(se_cmd, tl_nexus->se_sess, sc->cmnd,
 			&tl_cmd->tl_sense_buf[0], tl_cmd->sc->device->lun,
-			scsi_bufflen(sc), tcm_loop_sam_attr(sc),
+			scsi_bufflen(sc), tcm_loop_sam_attr(sc, tl_cmd->sc_cmd_tag),
 			sc->sc_data_direction, 0,
 			scsi_sglist(sc), scsi_sg_count(sc),
-			sgl_bidi, sgl_bidi_count);
+			sgl_bidi, sgl_bidi_count,
+			scsi_prot_sglist(sc), scsi_prot_sg_count(sc));
 	if (rc < 0) {
 		set_host_byte(sc, DID_NO_CONNECT);
 		goto out_done;
@@ -233,6 +245,7 @@
 	}
 
 	tl_cmd->sc = sc;
+	tl_cmd->sc_cmd_tag = sc->request->tag;
 	INIT_WORK(&tl_cmd->work, tcm_loop_submission_work);
 	queue_work(tcm_loop_workqueue, &tl_cmd->work);
 	return 0;
@@ -242,26 +255,17 @@
  * Called from SCSI EH process context to issue a LUN_RESET TMR
  * to struct scsi_device
  */
-static int tcm_loop_device_reset(struct scsi_cmnd *sc)
+static int tcm_loop_issue_tmr(struct tcm_loop_tpg *tl_tpg,
+			      int lun, int task, enum tcm_tmreq_table tmr)
 {
 	struct se_cmd *se_cmd = NULL;
-	struct se_portal_group *se_tpg;
 	struct se_session *se_sess;
-	struct tcm_loop_cmd *tl_cmd = NULL;
-	struct tcm_loop_hba *tl_hba;
+	struct se_portal_group *se_tpg;
 	struct tcm_loop_nexus *tl_nexus;
+	struct tcm_loop_cmd *tl_cmd = NULL;
 	struct tcm_loop_tmr *tl_tmr = NULL;
-	struct tcm_loop_tpg *tl_tpg;
-	int ret = FAILED, rc;
-	/*
-	 * Locate the tcm_loop_hba_t pointer
-	 */
-	tl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);
-	/*
-	 * Locate the tl_tpg and se_tpg pointers from TargetID in sc->device->id
-	 */
-	tl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];
-	se_tpg = &tl_tpg->tl_se_tpg;
+	int ret = TMR_FUNCTION_FAILED, rc;
+
 	/*
 	 * Locate the tl_nexus and se_sess pointers
 	 */
@@ -269,14 +273,13 @@
 	if (!tl_nexus) {
 		pr_err("Unable to perform device reset without"
 				" active I_T Nexus\n");
-		return FAILED;
+		return ret;
 	}
-	se_sess = tl_nexus->se_sess;
 
 	tl_cmd = kmem_cache_zalloc(tcm_loop_cmd_cache, GFP_KERNEL);
 	if (!tl_cmd) {
 		pr_err("Unable to allocate memory for tl_cmd\n");
-		return FAILED;
+		return ret;
 	}
 
 	tl_tmr = kzalloc(sizeof(struct tcm_loop_tmr), GFP_KERNEL);
@@ -287,6 +290,8 @@
 	init_waitqueue_head(&tl_tmr->tl_tmr_wait);
 
 	se_cmd = &tl_cmd->tl_se_cmd;
+	se_tpg = &tl_tpg->tl_se_tpg;
+	se_sess = tl_tpg->tl_nexus->se_sess;
 	/*
 	 * Initialize struct se_cmd descriptor from target_core_mod infrastructure
 	 */
@@ -294,17 +299,23 @@
 				DMA_NONE, MSG_SIMPLE_TAG,
 				&tl_cmd->tl_sense_buf[0]);
 
-	rc = core_tmr_alloc_req(se_cmd, tl_tmr, TMR_LUN_RESET, GFP_KERNEL);
+	rc = core_tmr_alloc_req(se_cmd, tl_tmr, tmr, GFP_KERNEL);
 	if (rc < 0)
 		goto release;
+
+	if (tmr == TMR_ABORT_TASK)
+		se_cmd->se_tmr_req->ref_task_tag = task;
+
 	/*
-	 * Locate the underlying TCM struct se_lun from sc->device->lun
+	 * Locate the underlying TCM struct se_lun
 	 */
-	if (transport_lookup_tmr_lun(se_cmd, sc->device->lun) < 0)
+	if (transport_lookup_tmr_lun(se_cmd, lun) < 0) {
+		ret = TMR_LUN_DOES_NOT_EXIST;
 		goto release;
+	}
 	/*
-	 * Queue the TMR to TCM Core and sleep waiting for tcm_loop_queue_tm_rsp()
-	 * to wake us up.
+	 * Queue the TMR to TCM Core and sleep waiting for
+	 * tcm_loop_queue_tm_rsp() to wake us up.
 	 */
 	transport_generic_handle_tmr(se_cmd);
 	wait_event(tl_tmr->tl_tmr_wait, atomic_read(&tl_tmr->tmr_complete));
@@ -312,8 +323,7 @@
 	 * The TMR LUN_RESET has completed, check the response status and
 	 * then release allocations.
 	 */
-	ret = (se_cmd->se_tmr_req->response == TMR_FUNCTION_COMPLETE) ?
-		SUCCESS : FAILED;
+	ret = se_cmd->se_tmr_req->response;
 release:
 	if (se_cmd)
 		transport_generic_free_cmd(se_cmd, 1);
@@ -323,6 +333,68 @@
 	return ret;
 }
 
+static int tcm_loop_abort_task(struct scsi_cmnd *sc)
+{
+	struct tcm_loop_hba *tl_hba;
+	struct tcm_loop_tpg *tl_tpg;
+	int ret = FAILED;
+
+	/*
+	 * Locate the tcm_loop_hba_t pointer
+	 */
+	tl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);
+	tl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];
+	ret = tcm_loop_issue_tmr(tl_tpg, sc->device->lun,
+				 sc->request->tag, TMR_ABORT_TASK);
+	return (ret == TMR_FUNCTION_COMPLETE) ? SUCCESS : FAILED;
+}
+
+/*
+ * Called from SCSI EH process context to issue a LUN_RESET TMR
+ * to struct scsi_device
+ */
+static int tcm_loop_device_reset(struct scsi_cmnd *sc)
+{
+	struct tcm_loop_hba *tl_hba;
+	struct tcm_loop_tpg *tl_tpg;
+	int ret = FAILED;
+
+	/*
+	 * Locate the tcm_loop_hba_t pointer
+	 */
+	tl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);
+	tl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];
+
+	ret = tcm_loop_issue_tmr(tl_tpg, sc->device->lun,
+				 0, TMR_LUN_RESET);
+	return (ret == TMR_FUNCTION_COMPLETE) ? SUCCESS : FAILED;
+}
+
+static int tcm_loop_target_reset(struct scsi_cmnd *sc)
+{
+	struct tcm_loop_hba *tl_hba;
+	struct tcm_loop_tpg *tl_tpg;
+
+	/*
+	 * Locate the tcm_loop_hba_t pointer
+	 */
+	tl_hba = *(struct tcm_loop_hba **)shost_priv(sc->device->host);
+	if (!tl_hba) {
+		pr_err("Unable to perform device reset without"
+				" active I_T Nexus\n");
+		return FAILED;
+	}
+	/*
+	 * Locate the tl_tpg pointer from TargetID in sc->device->id
+	 */
+	tl_tpg = &tl_hba->tl_hba_tpgs[sc->device->id];
+	if (tl_tpg) {
+		tl_tpg->tl_transport_status = TCM_TRANSPORT_ONLINE;
+		return SUCCESS;
+	}
+	return FAILED;
+}
+
 static int tcm_loop_slave_alloc(struct scsi_device *sd)
 {
 	set_bit(QUEUE_FLAG_BIDI, &sd->request_queue->queue_flags);
@@ -331,6 +403,15 @@
 
 static int tcm_loop_slave_configure(struct scsi_device *sd)
 {
+	if (sd->tagged_supported) {
+		scsi_activate_tcq(sd, sd->queue_depth);
+		scsi_adjust_queue_depth(sd, MSG_SIMPLE_TAG,
+					sd->host->cmd_per_lun);
+	} else {
+		scsi_adjust_queue_depth(sd, 0,
+					sd->host->cmd_per_lun);
+	}
+
 	return 0;
 }
 
@@ -340,7 +421,10 @@
 	.name			= "TCM_Loopback",
 	.queuecommand		= tcm_loop_queuecommand,
 	.change_queue_depth	= tcm_loop_change_queue_depth,
+	.change_queue_type	= tcm_loop_change_queue_type,
+	.eh_abort_handler = tcm_loop_abort_task,
 	.eh_device_reset_handler = tcm_loop_device_reset,
+	.eh_target_reset_handler = tcm_loop_target_reset,
 	.can_queue		= 1024,
 	.this_id		= -1,
 	.sg_tablesize		= 256,
@@ -356,7 +440,7 @@
 {
 	struct tcm_loop_hba *tl_hba;
 	struct Scsi_Host *sh;
-	int error;
+	int error, host_prot;
 
 	tl_hba = to_tcm_loop_hba(dev);
 
@@ -380,6 +464,13 @@
 	sh->max_channel = 0;
 	sh->max_cmd_len = TL_SCSI_MAX_CMD_LEN;
 
+	host_prot = SHOST_DIF_TYPE1_PROTECTION | SHOST_DIF_TYPE2_PROTECTION |
+		    SHOST_DIF_TYPE3_PROTECTION | SHOST_DIX_TYPE1_PROTECTION |
+		    SHOST_DIX_TYPE2_PROTECTION | SHOST_DIX_TYPE3_PROTECTION;
+
+	scsi_host_set_prot(sh, host_prot);
+	scsi_host_set_guard(sh, SHOST_DIX_GUARD_CRC);
+
 	error = scsi_add_host(sh, &tl_hba->dev);
 	if (error) {
 		pr_err("%s: scsi_add_host failed\n", __func__);
@@ -699,7 +790,10 @@
 
 static u32 tcm_loop_get_task_tag(struct se_cmd *se_cmd)
 {
-	return 1;
+	struct tcm_loop_cmd *tl_cmd = container_of(se_cmd,
+			struct tcm_loop_cmd, tl_se_cmd);
+
+	return tl_cmd->sc_cmd_tag;
 }
 
 static int tcm_loop_get_cmd_state(struct se_cmd *se_cmd)
@@ -786,7 +880,7 @@
 	return 0;
 }
 
-static int tcm_loop_queue_tm_rsp(struct se_cmd *se_cmd)
+static void tcm_loop_queue_tm_rsp(struct se_cmd *se_cmd)
 {
 	struct se_tmr_req *se_tmr = se_cmd->se_tmr_req;
 	struct tcm_loop_tmr *tl_tmr = se_tmr->fabric_tmr_ptr;
@@ -796,7 +890,6 @@
 	 */
 	atomic_set(&tl_tmr->tmr_complete, 1);
 	wake_up(&tl_tmr->tl_tmr_wait);
-	return 0;
 }
 
 static char *tcm_loop_dump_proto_id(struct tcm_loop_hba *tl_hba)
@@ -1061,14 +1154,62 @@
 
 TF_TPG_BASE_ATTR(tcm_loop, nexus, S_IRUGO | S_IWUSR);
 
+static ssize_t tcm_loop_tpg_show_transport_status(
+	struct se_portal_group *se_tpg,
+	char *page)
+{
+	struct tcm_loop_tpg *tl_tpg = container_of(se_tpg,
+			struct tcm_loop_tpg, tl_se_tpg);
+	const char *status = NULL;
+	ssize_t ret = -EINVAL;
+
+	switch (tl_tpg->tl_transport_status) {
+	case TCM_TRANSPORT_ONLINE:
+		status = "online";
+		break;
+	case TCM_TRANSPORT_OFFLINE:
+		status = "offline";
+		break;
+	default:
+		break;
+	}
+
+	if (status)
+		ret = snprintf(page, PAGE_SIZE, "%s\n", status);
+
+	return ret;
+}
+
+static ssize_t tcm_loop_tpg_store_transport_status(
+	struct se_portal_group *se_tpg,
+	const char *page,
+	size_t count)
+{
+	struct tcm_loop_tpg *tl_tpg = container_of(se_tpg,
+			struct tcm_loop_tpg, tl_se_tpg);
+
+	if (!strncmp(page, "online", 6)) {
+		tl_tpg->tl_transport_status = TCM_TRANSPORT_ONLINE;
+		return count;
+	}
+	if (!strncmp(page, "offline", 7)) {
+		tl_tpg->tl_transport_status = TCM_TRANSPORT_OFFLINE;
+		return count;
+	}
+	return -EINVAL;
+}
+
+TF_TPG_BASE_ATTR(tcm_loop, transport_status, S_IRUGO | S_IWUSR);
+
 static struct configfs_attribute *tcm_loop_tpg_attrs[] = {
 	&tcm_loop_tpg_nexus.attr,
+	&tcm_loop_tpg_transport_status.attr,
 	NULL,
 };
 
 /* Start items for tcm_loop_naa_cit */
 
-struct se_portal_group *tcm_loop_make_naa_tpg(
+static struct se_portal_group *tcm_loop_make_naa_tpg(
 	struct se_wwn *wwn,
 	struct config_group *group,
 	const char *name)
@@ -1113,7 +1254,7 @@
 	return &tl_tpg->tl_se_tpg;
 }
 
-void tcm_loop_drop_naa_tpg(
+static void tcm_loop_drop_naa_tpg(
 	struct se_portal_group *se_tpg)
 {
 	struct se_wwn *wwn = se_tpg->se_tpg_wwn;
@@ -1145,7 +1286,7 @@
 
 /* Start items for tcm_loop_cit */
 
-struct se_wwn *tcm_loop_make_scsi_hba(
+static struct se_wwn *tcm_loop_make_scsi_hba(
 	struct target_fabric_configfs *tf,
 	struct config_group *group,
 	const char *name)
@@ -1215,7 +1356,7 @@
 	return ERR_PTR(ret);
 }
 
-void tcm_loop_drop_scsi_hba(
+static void tcm_loop_drop_scsi_hba(
 	struct se_wwn *wwn)
 {
 	struct tcm_loop_hba *tl_hba = container_of(wwn,
@@ -1334,11 +1475,11 @@
 	/*
 	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 	 */
-	TF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = tcm_loop_wwn_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = tcm_loop_tpg_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = tcm_loop_wwn_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = tcm_loop_tpg_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = NULL;
 	/*
 	 * Once fabric->tf_ops has been setup, now register the fabric for
 	 * use within TCM
diff -rubB --new-file linux-3.10.69/drivers/target/loopback/tcm_loop.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/loopback/tcm_loop.h
--- linux-3.10.69/drivers/target/loopback/tcm_loop.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/loopback/tcm_loop.h	2017-05-02 03:31:56.000000000 +0200
@@ -10,6 +10,8 @@
 struct tcm_loop_cmd {
 	/* State of Linux/SCSI CDB+Data descriptor */
 	u32 sc_cmd_state;
+	/* Tagged command queueing */
+	u32 sc_cmd_tag;
 	/* Pointer to the CDB+Data descriptor from Linux/SCSI subsystem */
 	struct scsi_cmnd *sc;
 	/* The TCM I/O descriptor that is accessed via container_of() */
@@ -35,8 +37,12 @@
 	struct se_node_acl se_node_acl;
 };
 
+#define TCM_TRANSPORT_ONLINE 0
+#define TCM_TRANSPORT_OFFLINE 1
+
 struct tcm_loop_tpg {
 	unsigned short tl_tpgt;
+	unsigned short tl_transport_status;
 	atomic_t tl_tpg_port_count;
 	struct se_portal_group tl_se_tpg;
 	struct tcm_loop_hba *tl_hba;
diff -rubB --new-file linux-3.10.69/drivers/target/Makefile F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/Makefile
--- linux-3.10.69/drivers/target/Makefile	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/Makefile	2017-05-02 03:31:56.000000000 +0200
@@ -13,7 +13,8 @@
 				   target_core_spc.o \
 				   target_core_ua.o \
 				   target_core_rd.o \
-				   target_core_stat.o
+				   target_core_stat.o \
+				   target_core_xcopy.o
 
 obj-$(CONFIG_TARGET_CORE)	+= target_core_mod.o
 
diff -rubB --new-file linux-3.10.69/drivers/target/sbp/sbp_target.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/sbp/sbp_target.c
--- linux-3.10.69/drivers/target/sbp/sbp_target.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/sbp/sbp_target.c	2017-05-02 03:31:56.000000000 +0200
@@ -1842,9 +1842,8 @@
 	return sbp_send_sense(req);
 }
 
-static int sbp_queue_tm_rsp(struct se_cmd *se_cmd)
+static void sbp_queue_tm_rsp(struct se_cmd *se_cmd)
 {
-	return 0;
 }
 
 static int sbp_check_stop_free(struct se_cmd *se_cmd)
@@ -2557,15 +2556,15 @@
 	/*
 	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 	 */
-	TF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = sbp_wwn_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = sbp_tpg_base_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = sbp_tpg_attrib_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_base_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_auth_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_param_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = sbp_wwn_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = sbp_tpg_base_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = sbp_tpg_attrib_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = NULL;
 
 	ret = target_fabric_configfs_register(fabric);
 	if (ret < 0) {
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_alua.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_alua.c
--- linux-3.10.69/drivers/target/target_core_alua.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_alua.c	2017-05-02 03:31:56.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * This file contains SPC-3 compliant asymmetric logical unit assigntment (ALUA)
  *
- * (c) Copyright 2009-2012 RisingTide Systems LLC.
+ * (c) Copyright 2009-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -41,10 +41,13 @@
 #include "target_core_alua.h"
 #include "target_core_ua.h"
 
-static sense_reason_t core_alua_check_transition(int state, int *primary);
+static sense_reason_t core_alua_check_transition(int state, int valid,
+						 int *primary);
 static int core_alua_set_tg_pt_secondary_state(
 		struct t10_alua_tg_pt_gp_member *tg_pt_gp_mem,
-		struct se_port *port, int explict, int offline);
+		struct se_port *port, int explicit, int offline);
+
+static char *core_alua_dump_state(int state);
 
 static u16 alua_lu_gps_counter;
 static u32 alua_lu_gps_count;
@@ -55,6 +58,86 @@
 struct t10_alua_lu_gp *default_lu_gp;
 
 /*
+ * REPORT REFERRALS
+ *
+ * See sbc3r35 section 5.23
+ */
+sense_reason_t
+target_emulate_report_referrals(struct se_cmd *cmd)
+{
+	struct se_device *dev = cmd->se_dev;
+	struct t10_alua_lba_map *map;
+	struct t10_alua_lba_map_member *map_mem;
+	unsigned char *buf;
+	u32 rd_len = 0, off;
+
+	if (cmd->data_length < 4) {
+		pr_warn("REPORT REFERRALS allocation length %u too"
+			" small\n", cmd->data_length);
+		return TCM_INVALID_CDB_FIELD;
+	}
+
+	buf = transport_kmap_data_sg(cmd);
+	if (!buf)
+		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+
+	off = 4;
+	spin_lock(&dev->t10_alua.lba_map_lock);
+	if (list_empty(&dev->t10_alua.lba_map_list)) {
+		spin_unlock(&dev->t10_alua.lba_map_lock);
+		transport_kunmap_data_sg(cmd);
+
+		return TCM_UNSUPPORTED_SCSI_OPCODE;
+	}
+
+	list_for_each_entry(map, &dev->t10_alua.lba_map_list,
+			    lba_map_list) {
+		int desc_num = off + 3;
+		int pg_num;
+
+		off += 4;
+		if (cmd->data_length > off)
+			put_unaligned_be64(map->lba_map_first_lba, &buf[off]);
+		off += 8;
+		if (cmd->data_length > off)
+			put_unaligned_be64(map->lba_map_last_lba, &buf[off]);
+		off += 8;
+		rd_len += 20;
+		pg_num = 0;
+		list_for_each_entry(map_mem, &map->lba_map_mem_list,
+				    lba_map_mem_list) {
+			int alua_state = map_mem->lba_map_mem_alua_state;
+			int alua_pg_id = map_mem->lba_map_mem_alua_pg_id;
+
+			if (cmd->data_length > off)
+				buf[off] = alua_state & 0x0f;
+			off += 2;
+			if (cmd->data_length > off)
+				buf[off] = (alua_pg_id >> 8) & 0xff;
+			off++;
+			if (cmd->data_length > off)
+				buf[off] = (alua_pg_id & 0xff);
+			off++;
+			rd_len += 4;
+			pg_num++;
+		}
+		if (cmd->data_length > desc_num)
+			buf[desc_num] = pg_num;
+	}
+	spin_unlock(&dev->t10_alua.lba_map_lock);
+
+	/*
+	 * Set the RETURN DATA LENGTH set in the header of the DataIN Payload
+	 */
+	put_unaligned_be16(rd_len, &buf[2]);
+
+	transport_kunmap_data_sg(cmd);
+
+	target_complete_cmd(cmd, GOOD);
+	return 0;
+}
+
+/*
  * REPORT_TARGET_PORT_GROUPS
  *
  * See spc4r17 section 6.27
@@ -117,12 +200,7 @@
 		/*
 		 * Set supported ASYMMETRIC ACCESS State bits
 		 */
-		buf[off] = 0x80; /* T_SUP */
-		buf[off] |= 0x40; /* O_SUP */
-		buf[off] |= 0x8; /* U_SUP */
-		buf[off] |= 0x4; /* S_SUP */
-		buf[off] |= 0x2; /* AN_SUP */
-		buf[off++] |= 0x1; /* AO_SUP */
+		buf[off++] |= tg_pt_gp->tg_pt_gp_alua_supported_states;
 		/*
 		 * TARGET PORT GROUP
 		 */
@@ -175,7 +253,7 @@
 	if (ext_hdr != 0) {
 		buf[4] = 0x10;
 		/*
-		 * Set the implict transition time (in seconds) for the application
+		 * Set the implicit transition time (in seconds) for the application
 		 * client to use as a base for it's transition timeout value.
 		 *
 		 * Use the current tg_pt_gp_mem -> tg_pt_gp membership from the LUN
@@ -188,7 +266,7 @@
 			spin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);
 			tg_pt_gp = tg_pt_gp_mem->tg_pt_gp;
 			if (tg_pt_gp)
-				buf[5] = tg_pt_gp->tg_pt_gp_implict_trans_secs;
+				buf[5] = tg_pt_gp->tg_pt_gp_implicit_trans_secs;
 			spin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);
 		}
 	}
@@ -199,7 +277,7 @@
 }
 
 /*
- * SET_TARGET_PORT_GROUPS for explict ALUA operation.
+ * SET_TARGET_PORT_GROUPS for explicit ALUA operation.
  *
  * See spc4r17 section 6.35
  */
@@ -215,7 +293,7 @@
 	unsigned char *ptr;
 	sense_reason_t rc = TCM_NO_SENSE;
 	u32 len = 4; /* Skip over RESERVED area in header */
-	int alua_access_state, primary = 0;
+	int alua_access_state, primary = 0, valid_states;
 	u16 tg_pt_id, rtpi;
 
 	if (!l_port)
@@ -232,7 +310,7 @@
 		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 
 	/*
-	 * Determine if explict ALUA via SET_TARGET_PORT_GROUPS is allowed
+	 * Determine if explicit ALUA via SET_TARGET_PORT_GROUPS is allowed
 	 * for the local tg_pt_gp.
 	 */
 	l_tg_pt_gp_mem = l_port->sep_alua_tg_pt_gp_mem;
@@ -251,12 +329,13 @@
 	}
 	spin_unlock(&l_tg_pt_gp_mem->tg_pt_gp_mem_lock);
 
-	if (!(l_tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICT_ALUA)) {
+	if (!(l_tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICIT_ALUA)) {
 		pr_debug("Unable to process SET_TARGET_PORT_GROUPS"
-				" while TPGS_EXPLICT_ALUA is disabled\n");
+				" while TPGS_EXPLICIT_ALUA is disabled\n");
 		rc = TCM_UNSUPPORTED_SCSI_OPCODE;
 		goto out;
 	}
+	valid_states = l_tg_pt_gp->tg_pt_gp_alua_supported_states;
 
 	ptr = &buf[4]; /* Skip over RESERVED area in header */
 
@@ -268,7 +347,8 @@
 		 * the state is a primary or secondary target port asymmetric
 		 * access state.
 		 */
-		rc = core_alua_check_transition(alua_access_state, &primary);
+		rc = core_alua_check_transition(alua_access_state,
+						valid_states, &primary);
 		if (rc) {
 			/*
 			 * If the SET TARGET PORT GROUPS attempts to establish
@@ -330,7 +410,7 @@
 			spin_unlock(&dev->t10_alua.tg_pt_gps_lock);
 		} else {
 			/*
-			 * Extact the RELATIVE TARGET PORT IDENTIFIER to identify
+			 * Extract the RELATIVE TARGET PORT IDENTIFIER to identify
 			 * the Target Port in question for the the incoming
 			 * SET_TARGET_PORT_GROUPS op.
 			 */
@@ -391,6 +471,81 @@
 	return 0;
 }
 
+static inline int core_alua_state_lba_dependent(
+	struct se_cmd *cmd,
+	struct t10_alua_tg_pt_gp *tg_pt_gp,
+	u8 *alua_ascq)
+{
+	struct se_device *dev = cmd->se_dev;
+	u64 segment_size, segment_mult, sectors, lba;
+
+	/* Only need to check for cdb actually containing LBAs */
+	if (!(cmd->se_cmd_flags & SCF_SCSI_DATA_CDB))
+		return 0;
+
+	spin_lock(&dev->t10_alua.lba_map_lock);
+	segment_size = dev->t10_alua.lba_map_segment_size;
+	segment_mult = dev->t10_alua.lba_map_segment_multiplier;
+	sectors = cmd->data_length / dev->dev_attrib.block_size;
+
+	lba = cmd->t_task_lba;
+	while (lba < cmd->t_task_lba + sectors) {
+		struct t10_alua_lba_map *cur_map = NULL, *map;
+		struct t10_alua_lba_map_member *map_mem;
+
+		list_for_each_entry(map, &dev->t10_alua.lba_map_list,
+				    lba_map_list) {
+			u64 start_lba, last_lba;
+			u64 first_lba = map->lba_map_first_lba;
+
+			if (segment_mult) {
+				u64 tmp = lba;
+				start_lba = do_div(tmp, segment_size * segment_mult);
+
+				last_lba = first_lba + segment_size - 1;
+				if (start_lba >= first_lba &&
+				    start_lba <= last_lba) {
+					lba += segment_size;
+					cur_map = map;
+					break;
+				}
+			} else {
+				last_lba = map->lba_map_last_lba;
+				if (lba >= first_lba && lba <= last_lba) {
+					lba = last_lba + 1;
+					cur_map = map;
+					break;
+				}
+			}
+		}
+		if (!cur_map) {
+			spin_unlock(&dev->t10_alua.lba_map_lock);
+			*alua_ascq = ASCQ_04H_ALUA_TG_PT_UNAVAILABLE;
+			return 1;
+		}
+		list_for_each_entry(map_mem, &cur_map->lba_map_mem_list,
+				    lba_map_mem_list) {
+			if (map_mem->lba_map_mem_alua_pg_id !=
+			    tg_pt_gp->tg_pt_gp_id)
+				continue;
+			switch(map_mem->lba_map_mem_alua_state) {
+			case ALUA_ACCESS_STATE_STANDBY:
+				spin_unlock(&dev->t10_alua.lba_map_lock);
+				*alua_ascq = ASCQ_04H_ALUA_TG_PT_STANDBY;
+				return 1;
+			case ALUA_ACCESS_STATE_UNAVAILABLE:
+				spin_unlock(&dev->t10_alua.lba_map_lock);
+				*alua_ascq = ASCQ_04H_ALUA_TG_PT_UNAVAILABLE;
+				return 1;
+			default:
+				break;
+			}
+		}
+	}
+	spin_unlock(&dev->t10_alua.lba_map_lock);
+	return 0;
+}
+
 static inline int core_alua_state_standby(
 	struct se_cmd *cmd,
 	unsigned char *cdb,
@@ -496,7 +651,7 @@
 	u8 *alua_ascq)
 {
 	/*
-	 * Allowed CDBs for ALUA_ACCESS_STATE_TRANSITIO as defined by
+	 * Allowed CDBs for ALUA_ACCESS_STATE_TRANSITION as defined by
 	 * spc4r17 section 5.9.2.5
 	 */
 	switch (cdb[0]) {
@@ -524,9 +679,9 @@
 }
 
 /*
- * return 1: Is used to signal LUN not accecsable, and check condition/not ready
+ * return 1: Is used to signal LUN not accessible, and check condition/not ready
  * return 0: Used to signal success
- * reutrn -1: Used to signal failure, and invalid cdb field
+ * return -1: Used to signal failure, and invalid cdb field
  */
 sense_reason_t
 target_alua_state_check(struct se_cmd *cmd)
@@ -566,18 +721,21 @@
 	 * a ALUA logical unit group.
 	 */
 	tg_pt_gp_mem = port->sep_alua_tg_pt_gp_mem;
+	if (!tg_pt_gp_mem)
+		return 0;
+
 	spin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);
 	tg_pt_gp = tg_pt_gp_mem->tg_pt_gp;
 	out_alua_state = atomic_read(&tg_pt_gp->tg_pt_gp_alua_access_state);
 	nonop_delay_msecs = tg_pt_gp->tg_pt_gp_nonop_delay_msecs;
 	spin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);
 	/*
-	 * Process ALUA_ACCESS_STATE_ACTIVE_OPTMIZED in a separate conditional
+	 * Process ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED in a separate conditional
 	 * statement so the compiler knows explicitly to check this case first.
 	 * For the Optimized ALUA access state case, we want to process the
 	 * incoming fabric cmd ASAP..
 	 */
-	if (out_alua_state == ALUA_ACCESS_STATE_ACTIVE_OPTMIZED)
+	if (out_alua_state == ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED)
 		return 0;
 
 	switch (out_alua_state) {
@@ -594,6 +752,9 @@
 	case ALUA_ACCESS_STATE_TRANSITION:
 		ret = core_alua_state_transition(cmd, cdb, &alua_ascq);
 		break;
+	case ALUA_ACCESS_STATE_LBA_DEPENDENT:
+		ret = core_alua_state_lba_dependent(cmd, tg_pt_gp, &alua_ascq);
+		break;
 	/*
 	 * OFFLINE is a secondary ALUA target port group access state, that is
 	 * handled above with struct se_port->sep_tg_pt_secondary_offline=1
@@ -626,20 +787,39 @@
 }
 
 /*
- * Check implict and explict ALUA state change request.
+ * Check implicit and explicit ALUA state change request.
  */
 static sense_reason_t
-core_alua_check_transition(int state, int *primary)
+core_alua_check_transition(int state, int valid, int *primary)
 {
-	switch (state) {
-	case ALUA_ACCESS_STATE_ACTIVE_OPTMIZED:
-	case ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:
-	case ALUA_ACCESS_STATE_STANDBY:
-	case ALUA_ACCESS_STATE_UNAVAILABLE:
 		/*
 		 * OPTIMIZED, NON-OPTIMIZED, STANDBY and UNAVAILABLE are
 		 * defined as primary target port asymmetric access states.
 		 */
+	switch (state) {
+	case ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED:
+		if (!(valid & ALUA_AO_SUP))
+			goto not_supported;
+		*primary = 1;
+		break;
+	case ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:
+		if (!(valid & ALUA_AN_SUP))
+			goto not_supported;
+		*primary = 1;
+		break;
+	case ALUA_ACCESS_STATE_STANDBY:
+		if (!(valid & ALUA_S_SUP))
+			goto not_supported;
+		*primary = 1;
+		break;
+	case ALUA_ACCESS_STATE_UNAVAILABLE:
+		if (!(valid & ALUA_U_SUP))
+			goto not_supported;
+		*primary = 1;
+		break;
+	case ALUA_ACCESS_STATE_LBA_DEPENDENT:
+		if (!(valid & ALUA_LBD_SUP))
+			goto not_supported;
 		*primary = 1;
 		break;
 	case ALUA_ACCESS_STATE_OFFLINE:
@@ -647,29 +827,46 @@
 		 * OFFLINE state is defined as a secondary target port
 		 * asymmetric access state.
 		 */
+		if (!(valid & ALUA_O_SUP))
+			goto not_supported;
 		*primary = 0;
 		break;
+	case ALUA_ACCESS_STATE_TRANSITION:
+		/*
+		 * Transitioning is set internally, and
+		 * cannot be selected manually.
+		 */
+		goto not_supported;
 	default:
 		pr_err("Unknown ALUA access state: 0x%02x\n", state);
 		return TCM_INVALID_PARAMETER_LIST;
 	}
 
 	return 0;
+
+not_supported:
+	pr_err("ALUA access state %s not supported",
+	       core_alua_dump_state(state));
+	return TCM_INVALID_PARAMETER_LIST;
 }
 
 static char *core_alua_dump_state(int state)
 {
 	switch (state) {
-	case ALUA_ACCESS_STATE_ACTIVE_OPTMIZED:
+	case ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED:
 		return "Active/Optimized";
 	case ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:
 		return "Active/NonOptimized";
+	case ALUA_ACCESS_STATE_LBA_DEPENDENT:
+		return "LBA Dependent";
 	case ALUA_ACCESS_STATE_STANDBY:
 		return "Standby";
 	case ALUA_ACCESS_STATE_UNAVAILABLE:
 		return "Unavailable";
 	case ALUA_ACCESS_STATE_OFFLINE:
 		return "Offline";
+	case ALUA_ACCESS_STATE_TRANSITION:
+		return "Transitioning";
 	default:
 		return "Unknown";
 	}
@@ -682,10 +879,10 @@
 	switch (status) {
 	case ALUA_STATUS_NONE:
 		return "None";
-	case ALUA_STATUS_ALTERED_BY_EXPLICT_STPG:
-		return "Altered by Explict STPG";
-	case ALUA_STATUS_ALTERED_BY_IMPLICT_ALUA:
-		return "Altered by Implict ALUA";
+	case ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG:
+		return "Altered by Explicit STPG";
+	case ALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA:
+		return "Altered by Implicit ALUA";
 	default:
 		return "Unknown";
 	}
@@ -746,58 +943,49 @@
  * Called with tg_pt_gp->tg_pt_gp_md_mutex held
  */
 static int core_alua_update_tpg_primary_metadata(
-	struct t10_alua_tg_pt_gp *tg_pt_gp,
-	int primary_state,
-	unsigned char *md_buf)
+	struct t10_alua_tg_pt_gp *tg_pt_gp)
 {
+	unsigned char *md_buf;
 	struct t10_wwn *wwn = &tg_pt_gp->tg_pt_gp_dev->t10_wwn;
 	char path[ALUA_METADATA_PATH_LEN];
-	int len;
+	int len, rc;
+
+	md_buf = kzalloc(ALUA_MD_BUF_LEN, GFP_KERNEL);
+	if (!md_buf) {
+		pr_err("Unable to allocate buf for ALUA metadata\n");
+		return -ENOMEM;
+	}
 
 	memset(path, 0, ALUA_METADATA_PATH_LEN);
 
-	len = snprintf(md_buf, tg_pt_gp->tg_pt_gp_md_buf_len,
+	len = snprintf(md_buf, ALUA_MD_BUF_LEN,
 			"tg_pt_gp_id=%hu\n"
 			"alua_access_state=0x%02x\n"
 			"alua_access_status=0x%02x\n",
-			tg_pt_gp->tg_pt_gp_id, primary_state,
+			tg_pt_gp->tg_pt_gp_id,
+			tg_pt_gp->tg_pt_gp_alua_pending_state,
 			tg_pt_gp->tg_pt_gp_alua_access_status);
 
 	snprintf(path, ALUA_METADATA_PATH_LEN,
 		"/var/target/alua/tpgs_%s/%s", &wwn->unit_serial[0],
 		config_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item));
 
-	return core_alua_write_tpg_metadata(path, md_buf, len);
+	rc = core_alua_write_tpg_metadata(path, md_buf, len);
+	kfree(md_buf);
+	return rc;
 }
 
-static int core_alua_do_transition_tg_pt(
-	struct t10_alua_tg_pt_gp *tg_pt_gp,
-	struct se_port *l_port,
-	struct se_node_acl *nacl,
-	unsigned char *md_buf,
-	int new_state,
-	int explict)
+static void core_alua_do_transition_tg_pt_work(struct work_struct *work)
 {
+	struct t10_alua_tg_pt_gp *tg_pt_gp = container_of(work,
+		struct t10_alua_tg_pt_gp, tg_pt_gp_transition_work.work);
+	struct se_device *dev = tg_pt_gp->tg_pt_gp_dev;
 	struct se_dev_entry *se_deve;
 	struct se_lun_acl *lacl;
 	struct se_port *port;
 	struct t10_alua_tg_pt_gp_member *mem;
-	int old_state = 0;
-	/*
-	 * Save the old primary ALUA access state, and set the current state
-	 * to ALUA_ACCESS_STATE_TRANSITION.
-	 */
-	old_state = atomic_read(&tg_pt_gp->tg_pt_gp_alua_access_state);
-	atomic_set(&tg_pt_gp->tg_pt_gp_alua_access_state,
-			ALUA_ACCESS_STATE_TRANSITION);
-	tg_pt_gp->tg_pt_gp_alua_access_status = (explict) ?
-				ALUA_STATUS_ALTERED_BY_EXPLICT_STPG :
-				ALUA_STATUS_ALTERED_BY_IMPLICT_ALUA;
-	/*
-	 * Check for the optional ALUA primary state transition delay
-	 */
-	if (tg_pt_gp->tg_pt_gp_trans_delay_msecs != 0)
-		msleep_interruptible(tg_pt_gp->tg_pt_gp_trans_delay_msecs);
+	bool explicit = (tg_pt_gp->tg_pt_gp_alua_access_status ==
+			 ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG);
 
 	spin_lock(&tg_pt_gp->tg_pt_gp_lock);
 	list_for_each_entry(mem, &tg_pt_gp->tg_pt_gp_mem_list,
@@ -808,7 +996,7 @@
 		 * change, a device server shall establish a unit attention
 		 * condition for the initiator port associated with every I_T
 		 * nexus with the additional sense code set to ASYMMETRIC
-		 * ACCESS STATE CHAGED.
+		 * ACCESS STATE CHANGED.
 		 *
 		 * After an explicit target port asymmetric access state
 		 * change, a device server shall establish a unit attention
@@ -827,14 +1015,17 @@
 			lacl = se_deve->se_lun_acl;
 			/*
 			 * se_deve->se_lun_acl pointer may be NULL for a
-			 * entry created without explict Node+MappedLUN ACLs
+			 * entry created without explicit Node+MappedLUN ACLs
 			 */
 			if (!lacl)
 				continue;
 
-			if (explict &&
-			   (nacl != NULL) && (nacl == lacl->se_lun_nacl) &&
-			   (l_port != NULL) && (l_port == port))
+			if ((tg_pt_gp->tg_pt_gp_alua_access_status ==
+			     ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG) &&
+			   (tg_pt_gp->tg_pt_gp_alua_nacl != NULL) &&
+			    (tg_pt_gp->tg_pt_gp_alua_nacl == lacl->se_lun_nacl) &&
+			   (tg_pt_gp->tg_pt_gp_alua_port != NULL) &&
+			    (tg_pt_gp->tg_pt_gp_alua_port == port))
 				continue;
 
 			core_scsi3_ua_allocate(lacl->se_lun_nacl,
@@ -862,20 +1053,102 @@
 	 */
 	if (tg_pt_gp->tg_pt_gp_write_metadata) {
 		mutex_lock(&tg_pt_gp->tg_pt_gp_md_mutex);
-		core_alua_update_tpg_primary_metadata(tg_pt_gp,
-					new_state, md_buf);
+		core_alua_update_tpg_primary_metadata(tg_pt_gp);
 		mutex_unlock(&tg_pt_gp->tg_pt_gp_md_mutex);
 	}
 	/*
 	 * Set the current primary ALUA access state to the requested new state
 	 */
-	atomic_set(&tg_pt_gp->tg_pt_gp_alua_access_state, new_state);
+	atomic_set(&tg_pt_gp->tg_pt_gp_alua_access_state,
+		   tg_pt_gp->tg_pt_gp_alua_pending_state);
 
 	pr_debug("Successful %s ALUA transition TG PT Group: %s ID: %hu"
-		" from primary access state %s to %s\n", (explict) ? "explict" :
-		"implict", config_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item),
-		tg_pt_gp->tg_pt_gp_id, core_alua_dump_state(old_state),
-		core_alua_dump_state(new_state));
+		" from primary access state %s to %s\n", (explicit) ? "explicit" :
+		"implicit", config_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item),
+		tg_pt_gp->tg_pt_gp_id,
+		core_alua_dump_state(tg_pt_gp->tg_pt_gp_alua_previous_state),
+		core_alua_dump_state(tg_pt_gp->tg_pt_gp_alua_pending_state));
+	spin_lock(&dev->t10_alua.tg_pt_gps_lock);
+	atomic_dec(&tg_pt_gp->tg_pt_gp_ref_cnt);
+	smp_mb__after_atomic_dec();
+	spin_unlock(&dev->t10_alua.tg_pt_gps_lock);
+
+	if (tg_pt_gp->tg_pt_gp_transition_complete)
+		complete(tg_pt_gp->tg_pt_gp_transition_complete);
+}
+
+static int core_alua_do_transition_tg_pt(
+	struct t10_alua_tg_pt_gp *tg_pt_gp,
+	int new_state,
+	int explicit)
+{
+	struct se_device *dev = tg_pt_gp->tg_pt_gp_dev;
+	DECLARE_COMPLETION_ONSTACK(wait);
+
+	/* Nothing to be done here */
+	if (atomic_read(&tg_pt_gp->tg_pt_gp_alua_access_state) == new_state)
+		return 0;
+
+	if (new_state == ALUA_ACCESS_STATE_TRANSITION)
+		return -EAGAIN;
+
+	/*
+	 * Flush any pending transitions
+	 */
+	if (!explicit && tg_pt_gp->tg_pt_gp_implicit_trans_secs &&
+	    atomic_read(&tg_pt_gp->tg_pt_gp_alua_access_state) ==
+	    ALUA_ACCESS_STATE_TRANSITION) {
+		/* Just in case */
+		tg_pt_gp->tg_pt_gp_alua_pending_state = new_state;
+		tg_pt_gp->tg_pt_gp_transition_complete = &wait;
+		flush_delayed_work(&tg_pt_gp->tg_pt_gp_transition_work);
+		wait_for_completion(&wait);
+		tg_pt_gp->tg_pt_gp_transition_complete = NULL;
+		return 0;
+	}
+
+	/*
+	 * Save the old primary ALUA access state, and set the current state
+	 * to ALUA_ACCESS_STATE_TRANSITION.
+	 */
+	tg_pt_gp->tg_pt_gp_alua_previous_state =
+		atomic_read(&tg_pt_gp->tg_pt_gp_alua_access_state);
+	tg_pt_gp->tg_pt_gp_alua_pending_state = new_state;
+
+	atomic_set(&tg_pt_gp->tg_pt_gp_alua_access_state,
+			ALUA_ACCESS_STATE_TRANSITION);
+	tg_pt_gp->tg_pt_gp_alua_access_status = (explicit) ?
+				ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG :
+				ALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA;
+
+	/*
+	 * Check for the optional ALUA primary state transition delay
+	 */
+	if (tg_pt_gp->tg_pt_gp_trans_delay_msecs != 0)
+		msleep_interruptible(tg_pt_gp->tg_pt_gp_trans_delay_msecs);
+
+	/*
+	 * Take a reference for workqueue item
+	 */
+	spin_lock(&dev->t10_alua.tg_pt_gps_lock);
+	atomic_inc(&tg_pt_gp->tg_pt_gp_ref_cnt);
+	smp_mb__after_atomic_inc();
+	spin_unlock(&dev->t10_alua.tg_pt_gps_lock);
+
+	if (!explicit && tg_pt_gp->tg_pt_gp_implicit_trans_secs) {
+		unsigned long transition_tmo;
+
+		transition_tmo = tg_pt_gp->tg_pt_gp_implicit_trans_secs * HZ;
+		queue_delayed_work(tg_pt_gp->tg_pt_gp_dev->tmr_wq,
+				   &tg_pt_gp->tg_pt_gp_transition_work,
+				   transition_tmo);
+	} else {
+		tg_pt_gp->tg_pt_gp_transition_complete = &wait;
+		queue_delayed_work(tg_pt_gp->tg_pt_gp_dev->tmr_wq,
+				   &tg_pt_gp->tg_pt_gp_transition_work, 0);
+		wait_for_completion(&wait);
+		tg_pt_gp->tg_pt_gp_transition_complete = NULL;
+	}
 
 	return 0;
 }
@@ -886,26 +1159,18 @@
 	struct se_port *l_port,
 	struct se_node_acl *l_nacl,
 	int new_state,
-	int explict)
+	int explicit)
 {
 	struct se_device *dev;
-	struct se_port *port;
-	struct se_node_acl *nacl;
 	struct t10_alua_lu_gp *lu_gp;
 	struct t10_alua_lu_gp_member *lu_gp_mem, *local_lu_gp_mem;
 	struct t10_alua_tg_pt_gp *tg_pt_gp;
-	unsigned char *md_buf;
-	int primary;
+	int primary, valid_states, rc = 0;
 
-	if (core_alua_check_transition(new_state, &primary) != 0)
+	valid_states = l_tg_pt_gp->tg_pt_gp_alua_supported_states;
+	if (core_alua_check_transition(new_state, valid_states, &primary) != 0)
 		return -EINVAL;
 
-	md_buf = kzalloc(l_tg_pt_gp->tg_pt_gp_md_buf_len, GFP_KERNEL);
-	if (!md_buf) {
-		pr_err("Unable to allocate buf for ALUA metadata\n");
-		return -ENOMEM;
-	}
-
 	local_lu_gp_mem = l_dev->dev_alua_lu_gp_mem;
 	spin_lock(&local_lu_gp_mem->lu_gp_mem_lock);
 	lu_gp = local_lu_gp_mem->lu_gp;
@@ -922,12 +1187,13 @@
 		 * core_alua_do_transition_tg_pt() will always return
 		 * success.
 		 */
-		core_alua_do_transition_tg_pt(l_tg_pt_gp, l_port, l_nacl,
-					md_buf, new_state, explict);
+		l_tg_pt_gp->tg_pt_gp_alua_port = l_port;
+		l_tg_pt_gp->tg_pt_gp_alua_nacl = l_nacl;
+		rc = core_alua_do_transition_tg_pt(l_tg_pt_gp,
+						   new_state, explicit);
 		atomic_dec(&lu_gp->lu_gp_ref_cnt);
 		smp_mb__after_atomic_dec();
-		kfree(md_buf);
-		return 0;
+		return rc;
 	}
 	/*
 	 * For all other LU groups aside from 'default_lu_gp', walk all of
@@ -952,7 +1218,7 @@
 				continue;
 			/*
 			 * If the target behavior port asymmetric access state
-			 * is changed for any target port group accessiable via
+			 * is changed for any target port group accessible via
 			 * a logical unit within a LU group, the target port
 			 * behavior group asymmetric access states for the same
 			 * target port group accessible via other logical units
@@ -962,11 +1228,11 @@
 				continue;
 
 			if (l_tg_pt_gp == tg_pt_gp) {
-				port = l_port;
-				nacl = l_nacl;
+				tg_pt_gp->tg_pt_gp_alua_port = l_port;
+				tg_pt_gp->tg_pt_gp_alua_nacl = l_nacl;
 			} else {
-				port = NULL;
-				nacl = NULL;
+				tg_pt_gp->tg_pt_gp_alua_port = NULL;
+				tg_pt_gp->tg_pt_gp_alua_nacl = NULL;
 			}
 			atomic_inc(&tg_pt_gp->tg_pt_gp_ref_cnt);
 			smp_mb__after_atomic_inc();
@@ -975,12 +1241,14 @@
 			 * core_alua_do_transition_tg_pt() will always return
 			 * success.
 			 */
-			core_alua_do_transition_tg_pt(tg_pt_gp, port,
-					nacl, md_buf, new_state, explict);
+			rc = core_alua_do_transition_tg_pt(tg_pt_gp,
+					new_state, explicit);
 
 			spin_lock(&dev->t10_alua.tg_pt_gps_lock);
 			atomic_dec(&tg_pt_gp->tg_pt_gp_ref_cnt);
 			smp_mb__after_atomic_dec();
+			if (rc)
+				break;
 		}
 		spin_unlock(&dev->t10_alua.tg_pt_gps_lock);
 
@@ -990,16 +1258,18 @@
 	}
 	spin_unlock(&lu_gp->lu_gp_lock);
 
+	if (!rc) {
 	pr_debug("Successfully processed LU Group: %s all ALUA TG PT"
 		" Group IDs: %hu %s transition to primary state: %s\n",
 		config_item_name(&lu_gp->lu_gp_group.cg_item),
-		l_tg_pt_gp->tg_pt_gp_id, (explict) ? "explict" : "implict",
+			 l_tg_pt_gp->tg_pt_gp_id,
+			 (explicit) ? "explicit" : "implicit",
 		core_alua_dump_state(new_state));
+	}
 
 	atomic_dec(&lu_gp->lu_gp_ref_cnt);
 	smp_mb__after_atomic_dec();
-	kfree(md_buf);
-	return 0;
+	return rc;
 }
 
 /*
@@ -1007,13 +1277,18 @@
  */
 static int core_alua_update_tpg_secondary_metadata(
 	struct t10_alua_tg_pt_gp_member *tg_pt_gp_mem,
-	struct se_port *port,
-	unsigned char *md_buf,
-	u32 md_buf_len)
+	struct se_port *port)
 {
+	unsigned char *md_buf;
 	struct se_portal_group *se_tpg = port->sep_tpg;
 	char path[ALUA_METADATA_PATH_LEN], wwn[ALUA_SECONDARY_METADATA_WWN_LEN];
-	int len;
+	int len, rc;
+
+	md_buf = kzalloc(ALUA_MD_BUF_LEN, GFP_KERNEL);
+	if (!md_buf) {
+		pr_err("Unable to allocate buf for ALUA metadata\n");
+		return -ENOMEM;
+	}
 
 	memset(path, 0, ALUA_METADATA_PATH_LEN);
 	memset(wwn, 0, ALUA_SECONDARY_METADATA_WWN_LEN);
@@ -1025,7 +1300,7 @@
 		snprintf(wwn+len, ALUA_SECONDARY_METADATA_WWN_LEN-len, "+%hu",
 				se_tpg->se_tpg_tfo->tpg_get_tag(se_tpg));
 
-	len = snprintf(md_buf, md_buf_len, "alua_tg_pt_offline=%d\n"
+	len = snprintf(md_buf, ALUA_MD_BUF_LEN, "alua_tg_pt_offline=%d\n"
 			"alua_tg_pt_status=0x%02x\n",
 			atomic_read(&port->sep_tg_pt_secondary_offline),
 			port->sep_tg_pt_secondary_stat);
@@ -1034,18 +1309,19 @@
 			se_tpg->se_tpg_tfo->get_fabric_name(), wwn,
 			port->sep_lun->unpacked_lun);
 
-	return core_alua_write_tpg_metadata(path, md_buf, len);
+	rc = core_alua_write_tpg_metadata(path, md_buf, len);
+	kfree(md_buf);
+
+	return rc;
 }
 
 static int core_alua_set_tg_pt_secondary_state(
 	struct t10_alua_tg_pt_gp_member *tg_pt_gp_mem,
 	struct se_port *port,
-	int explict,
+	int explicit,
 	int offline)
 {
 	struct t10_alua_tg_pt_gp *tg_pt_gp;
-	unsigned char *md_buf;
-	u32 md_buf_len;
 	int trans_delay_msecs;
 
 	spin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);
@@ -1066,14 +1342,13 @@
 	else
 		atomic_set(&port->sep_tg_pt_secondary_offline, 0);
 
-	md_buf_len = tg_pt_gp->tg_pt_gp_md_buf_len;
-	port->sep_tg_pt_secondary_stat = (explict) ?
-			ALUA_STATUS_ALTERED_BY_EXPLICT_STPG :
-			ALUA_STATUS_ALTERED_BY_IMPLICT_ALUA;
+	port->sep_tg_pt_secondary_stat = (explicit) ?
+			ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG :
+			ALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA;
 
 	pr_debug("Successful %s ALUA transition TG PT Group: %s ID: %hu"
-		" to secondary access state: %s\n", (explict) ? "explict" :
-		"implict", config_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item),
+		" to secondary access state: %s\n", (explicit) ? "explicit" :
+		"implicit", config_item_name(&tg_pt_gp->tg_pt_gp_group.cg_item),
 		tg_pt_gp->tg_pt_gp_id, (offline) ? "OFFLINE" : "ONLINE");
 
 	spin_unlock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);
@@ -1088,23 +1363,115 @@
 	 * secondary state and status
 	 */
 	if (port->sep_tg_pt_secondary_write_md) {
-		md_buf = kzalloc(md_buf_len, GFP_KERNEL);
-		if (!md_buf) {
-			pr_err("Unable to allocate md_buf for"
-				" secondary ALUA access metadata\n");
-			return -ENOMEM;
-		}
 		mutex_lock(&port->sep_tg_pt_md_mutex);
-		core_alua_update_tpg_secondary_metadata(tg_pt_gp_mem, port,
-				md_buf, md_buf_len);
+		core_alua_update_tpg_secondary_metadata(tg_pt_gp_mem, port);
 		mutex_unlock(&port->sep_tg_pt_md_mutex);
+	}
 
-		kfree(md_buf);
+	return 0;
+}
+
+struct t10_alua_lba_map *
+core_alua_allocate_lba_map(struct list_head *list,
+			   u64 first_lba, u64 last_lba)
+{
+	struct t10_alua_lba_map *lba_map;
+
+	lba_map = kmem_cache_zalloc(t10_alua_lba_map_cache, GFP_KERNEL);
+	if (!lba_map) {
+		pr_err("Unable to allocate struct t10_alua_lba_map\n");
+		return ERR_PTR(-ENOMEM);
+	}
+	INIT_LIST_HEAD(&lba_map->lba_map_mem_list);
+	lba_map->lba_map_first_lba = first_lba;
+	lba_map->lba_map_last_lba = last_lba;
+
+	list_add_tail(&lba_map->lba_map_list, list);
+	return lba_map;
+}
+
+int
+core_alua_allocate_lba_map_mem(struct t10_alua_lba_map *lba_map,
+			       int pg_id, int state)
+{
+	struct t10_alua_lba_map_member *lba_map_mem;
+
+	list_for_each_entry(lba_map_mem, &lba_map->lba_map_mem_list,
+			    lba_map_mem_list) {
+		if (lba_map_mem->lba_map_mem_alua_pg_id == pg_id) {
+			pr_err("Duplicate pg_id %d in lba_map\n", pg_id);
+			return -EINVAL;
+		}
+	}
+
+	lba_map_mem = kmem_cache_zalloc(t10_alua_lba_map_mem_cache, GFP_KERNEL);
+	if (!lba_map_mem) {
+		pr_err("Unable to allocate struct t10_alua_lba_map_mem\n");
+		return -ENOMEM;
 	}
+	lba_map_mem->lba_map_mem_alua_state = state;
+	lba_map_mem->lba_map_mem_alua_pg_id = pg_id;
 
+	list_add_tail(&lba_map_mem->lba_map_mem_list,
+		      &lba_map->lba_map_mem_list);
 	return 0;
 }
 
+void
+core_alua_free_lba_map(struct list_head *lba_list)
+{
+	struct t10_alua_lba_map *lba_map, *lba_map_tmp;
+	struct t10_alua_lba_map_member *lba_map_mem, *lba_map_mem_tmp;
+
+	list_for_each_entry_safe(lba_map, lba_map_tmp, lba_list,
+				 lba_map_list) {
+		list_for_each_entry_safe(lba_map_mem, lba_map_mem_tmp,
+					 &lba_map->lba_map_mem_list,
+					 lba_map_mem_list) {
+			list_del(&lba_map_mem->lba_map_mem_list);
+			kmem_cache_free(t10_alua_lba_map_mem_cache,
+					lba_map_mem);
+		}
+		list_del(&lba_map->lba_map_list);
+		kmem_cache_free(t10_alua_lba_map_cache, lba_map);
+	}
+}
+
+void
+core_alua_set_lba_map(struct se_device *dev, struct list_head *lba_map_list,
+		      int segment_size, int segment_mult)
+{
+	struct list_head old_lba_map_list;
+	struct t10_alua_tg_pt_gp *tg_pt_gp;
+	int activate = 0, supported;
+
+	INIT_LIST_HEAD(&old_lba_map_list);
+	spin_lock(&dev->t10_alua.lba_map_lock);
+	dev->t10_alua.lba_map_segment_size = segment_size;
+	dev->t10_alua.lba_map_segment_multiplier = segment_mult;
+	list_splice_init(&dev->t10_alua.lba_map_list, &old_lba_map_list);
+	if (lba_map_list) {
+		list_splice_init(lba_map_list, &dev->t10_alua.lba_map_list);
+		activate = 1;
+	}
+	spin_unlock(&dev->t10_alua.lba_map_lock);
+	spin_lock(&dev->t10_alua.tg_pt_gps_lock);
+	list_for_each_entry(tg_pt_gp, &dev->t10_alua.tg_pt_gps_list,
+			    tg_pt_gp_list) {
+
+		if (!tg_pt_gp->tg_pt_gp_valid_id)
+			continue;
+		supported = tg_pt_gp->tg_pt_gp_alua_supported_states;
+		if (activate)
+			supported |= ALUA_LBD_SUP;
+		else
+			supported &= ~ALUA_LBD_SUP;
+		tg_pt_gp->tg_pt_gp_alua_supported_states = supported;
+	}
+	spin_unlock(&dev->t10_alua.tg_pt_gps_lock);
+	core_alua_free_lba_map(&old_lba_map_list);
+}
+
 struct t10_alua_lu_gp *
 core_alua_allocate_lu_gp(const char *name, int def_group)
 {
@@ -1238,7 +1605,7 @@
 		 * struct se_device is released via core_alua_free_lu_gp_mem().
 		 *
 		 * If the passed lu_gp does NOT match the default_lu_gp, assume
-		 * we want to re-assocate a given lu_gp_mem with default_lu_gp.
+		 * we want to re-associate a given lu_gp_mem with default_lu_gp.
 		 */
 		spin_lock(&lu_gp_mem->lu_gp_mem_lock);
 		if (lu_gp != default_lu_gp)
@@ -1357,21 +1724,29 @@
 	mutex_init(&tg_pt_gp->tg_pt_gp_md_mutex);
 	spin_lock_init(&tg_pt_gp->tg_pt_gp_lock);
 	atomic_set(&tg_pt_gp->tg_pt_gp_ref_cnt, 0);
+	INIT_DELAYED_WORK(&tg_pt_gp->tg_pt_gp_transition_work,
+			  core_alua_do_transition_tg_pt_work);
 	tg_pt_gp->tg_pt_gp_dev = dev;
-	tg_pt_gp->tg_pt_gp_md_buf_len = ALUA_MD_BUF_LEN;
 	atomic_set(&tg_pt_gp->tg_pt_gp_alua_access_state,
-		ALUA_ACCESS_STATE_ACTIVE_OPTMIZED);
+		ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED);
 	/*
-	 * Enable both explict and implict ALUA support by default
+	 * Enable both explicit and implicit ALUA support by default
 	 */
 	tg_pt_gp->tg_pt_gp_alua_access_type =
-			TPGS_EXPLICT_ALUA | TPGS_IMPLICT_ALUA;
+			TPGS_EXPLICIT_ALUA | TPGS_IMPLICIT_ALUA;
 	/*
 	 * Set the default Active/NonOptimized Delay in milliseconds
 	 */
 	tg_pt_gp->tg_pt_gp_nonop_delay_msecs = ALUA_DEFAULT_NONOP_DELAY_MSECS;
 	tg_pt_gp->tg_pt_gp_trans_delay_msecs = ALUA_DEFAULT_TRANS_DELAY_MSECS;
-	tg_pt_gp->tg_pt_gp_implict_trans_secs = ALUA_DEFAULT_IMPLICT_TRANS_SECS;
+	tg_pt_gp->tg_pt_gp_implicit_trans_secs = ALUA_DEFAULT_IMPLICIT_TRANS_SECS;
+
+	/*
+	 * Enable all supported states
+	 */
+	tg_pt_gp->tg_pt_gp_alua_supported_states =
+	    ALUA_T_SUP | ALUA_O_SUP |
+	    ALUA_U_SUP | ALUA_S_SUP | ALUA_AN_SUP | ALUA_AO_SUP;
 
 	if (def_group) {
 		spin_lock(&dev->t10_alua.tg_pt_gps_lock);
@@ -1471,7 +1846,7 @@
 	 * been called from target_core_alua_drop_tg_pt_gp().
 	 *
 	 * Here we remove *tg_pt_gp from the global list so that
-	 * no assications *OR* explict ALUA via SET_TARGET_PORT_GROUPS
+	 * no associations *OR* explicit ALUA via SET_TARGET_PORT_GROUPS
 	 * can be made while we are releasing struct t10_alua_tg_pt_gp.
 	 */
 	spin_lock(&dev->t10_alua.tg_pt_gps_lock);
@@ -1479,6 +1854,8 @@
 	dev->t10_alua.alua_tg_pt_gps_counter--;
 	spin_unlock(&dev->t10_alua.tg_pt_gps_lock);
 
+	flush_delayed_work(&tg_pt_gp->tg_pt_gp_transition_work);
+
 	/*
 	 * Allow a struct t10_alua_tg_pt_gp_member * referenced by
 	 * core_alua_get_tg_pt_gp_by_name() in
@@ -1507,7 +1884,7 @@
 		 * core_alua_free_tg_pt_gp_mem().
 		 *
 		 * If the passed tg_pt_gp does NOT match the default_tg_pt_gp,
-		 * assume we want to re-assocate a given tg_pt_gp_mem with
+		 * assume we want to re-associate a given tg_pt_gp_mem with
 		 * default_tg_pt_gp.
 		 */
 		spin_lock(&tg_pt_gp_mem->tg_pt_gp_mem_lock);
@@ -1746,13 +2123,13 @@
 	struct t10_alua_tg_pt_gp *tg_pt_gp,
 	char *page)
 {
-	if ((tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICT_ALUA) &&
-	    (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICT_ALUA))
-		return sprintf(page, "Implict and Explict\n");
-	else if (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICT_ALUA)
-		return sprintf(page, "Implict\n");
-	else if (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICT_ALUA)
-		return sprintf(page, "Explict\n");
+	if ((tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICIT_ALUA) &&
+	    (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICIT_ALUA))
+		return sprintf(page, "Implicit and Explicit\n");
+	else if (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICIT_ALUA)
+		return sprintf(page, "Implicit\n");
+	else if (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICIT_ALUA)
+		return sprintf(page, "Explicit\n");
 	else
 		return sprintf(page, "None\n");
 }
@@ -1765,10 +2142,10 @@
 	unsigned long tmp;
 	int ret;
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
 		pr_err("Unable to extract alua_access_type\n");
-		return -EINVAL;
+		return ret;
 	}
 	if ((tmp != 0) && (tmp != 1) && (tmp != 2) && (tmp != 3)) {
 		pr_err("Illegal value for alua_access_type:"
@@ -1777,11 +2154,11 @@
 	}
 	if (tmp == 3)
 		tg_pt_gp->tg_pt_gp_alua_access_type =
-			TPGS_IMPLICT_ALUA | TPGS_EXPLICT_ALUA;
+			TPGS_IMPLICIT_ALUA | TPGS_EXPLICIT_ALUA;
 	else if (tmp == 2)
-		tg_pt_gp->tg_pt_gp_alua_access_type = TPGS_EXPLICT_ALUA;
+		tg_pt_gp->tg_pt_gp_alua_access_type = TPGS_EXPLICIT_ALUA;
 	else if (tmp == 1)
-		tg_pt_gp->tg_pt_gp_alua_access_type = TPGS_IMPLICT_ALUA;
+		tg_pt_gp->tg_pt_gp_alua_access_type = TPGS_IMPLICIT_ALUA;
 	else
 		tg_pt_gp->tg_pt_gp_alua_access_type = 0;
 
@@ -1803,10 +2180,10 @@
 	unsigned long tmp;
 	int ret;
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
 		pr_err("Unable to extract nonop_delay_msecs\n");
-		return -EINVAL;
+		return ret;
 	}
 	if (tmp > ALUA_MAX_NONOP_DELAY_MSECS) {
 		pr_err("Passed nonop_delay_msecs: %lu, exceeds"
@@ -1834,10 +2211,10 @@
 	unsigned long tmp;
 	int ret;
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
 		pr_err("Unable to extract trans_delay_msecs\n");
-		return -EINVAL;
+		return ret;
 	}
 	if (tmp > ALUA_MAX_TRANS_DELAY_MSECS) {
 		pr_err("Passed trans_delay_msecs: %lu, exceeds"
@@ -1850,14 +2227,14 @@
 	return count;
 }
 
-ssize_t core_alua_show_implict_trans_secs(
+ssize_t core_alua_show_implicit_trans_secs(
 	struct t10_alua_tg_pt_gp *tg_pt_gp,
 	char *page)
 {
-	return sprintf(page, "%d\n", tg_pt_gp->tg_pt_gp_implict_trans_secs);
+	return sprintf(page, "%d\n", tg_pt_gp->tg_pt_gp_implicit_trans_secs);
 }
 
-ssize_t core_alua_store_implict_trans_secs(
+ssize_t core_alua_store_implicit_trans_secs(
 	struct t10_alua_tg_pt_gp *tg_pt_gp,
 	const char *page,
 	size_t count)
@@ -1865,18 +2242,18 @@
 	unsigned long tmp;
 	int ret;
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
-		pr_err("Unable to extract implict_trans_secs\n");
-		return -EINVAL;
+		pr_err("Unable to extract implicit_trans_secs\n");
+		return ret;
 	}
-	if (tmp > ALUA_MAX_IMPLICT_TRANS_SECS) {
-		pr_err("Passed implict_trans_secs: %lu, exceeds"
-			" ALUA_MAX_IMPLICT_TRANS_SECS: %d\n", tmp,
-			ALUA_MAX_IMPLICT_TRANS_SECS);
+	if (tmp > ALUA_MAX_IMPLICIT_TRANS_SECS) {
+		pr_err("Passed implicit_trans_secs: %lu, exceeds"
+			" ALUA_MAX_IMPLICIT_TRANS_SECS: %d\n", tmp,
+			ALUA_MAX_IMPLICIT_TRANS_SECS);
 		return  -EINVAL;
 	}
-	tg_pt_gp->tg_pt_gp_implict_trans_secs = (int)tmp;
+	tg_pt_gp->tg_pt_gp_implicit_trans_secs = (int)tmp;
 
 	return count;
 }
@@ -1896,10 +2273,10 @@
 	unsigned long tmp;
 	int ret;
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
 		pr_err("Unable to extract preferred ALUA value\n");
-		return -EINVAL;
+		return ret;
 	}
 	if ((tmp != 0) && (tmp != 1)) {
 		pr_err("Illegal value for preferred ALUA: %lu\n", tmp);
@@ -1931,10 +2308,10 @@
 	if (!lun->lun_sep)
 		return -ENODEV;
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
 		pr_err("Unable to extract alua_tg_pt_offline value\n");
-		return -EINVAL;
+		return ret;
 	}
 	if ((tmp != 0) && (tmp != 1)) {
 		pr_err("Illegal value for alua_tg_pt_offline: %lu\n",
@@ -1970,14 +2347,14 @@
 	unsigned long tmp;
 	int ret;
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
 		pr_err("Unable to extract alua_tg_pt_status\n");
-		return -EINVAL;
+		return ret;
 	}
 	if ((tmp != ALUA_STATUS_NONE) &&
-	    (tmp != ALUA_STATUS_ALTERED_BY_EXPLICT_STPG) &&
-	    (tmp != ALUA_STATUS_ALTERED_BY_IMPLICT_ALUA)) {
+	    (tmp != ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG) &&
+	    (tmp != ALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA)) {
 		pr_err("Illegal value for alua_tg_pt_status: %lu\n",
 				tmp);
 		return -EINVAL;
@@ -2003,10 +2380,10 @@
 	unsigned long tmp;
 	int ret;
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
 		pr_err("Unable to extract alua_tg_pt_write_md\n");
-		return -EINVAL;
+		return ret;
 	}
 	if ((tmp != 0) && (tmp != 1)) {
 		pr_err("Illegal value for alua_tg_pt_write_md:"
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_alua.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_alua.h
--- linux-3.10.69/drivers/target/target_core_alua.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_alua.h	2017-05-02 03:31:56.000000000 +0200
@@ -7,29 +7,41 @@
  * from spc4r17 section 6.4.2 Table 135
  */
 #define TPGS_NO_ALUA				0x00
-#define TPGS_IMPLICT_ALUA			0x10
-#define TPGS_EXPLICT_ALUA			0x20
+#define TPGS_IMPLICIT_ALUA			0x10
+#define TPGS_EXPLICIT_ALUA			0x20
 
 /*
  * ASYMMETRIC ACCESS STATE field
  *
- * from spc4r17 section 6.27 Table 245
+ * from spc4r36j section 6.37 Table 307
  */
-#define ALUA_ACCESS_STATE_ACTIVE_OPTMIZED	0x0
+#define ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED	0x0
 #define ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED	0x1
 #define ALUA_ACCESS_STATE_STANDBY		0x2
 #define ALUA_ACCESS_STATE_UNAVAILABLE		0x3
+#define ALUA_ACCESS_STATE_LBA_DEPENDENT		0x4
 #define ALUA_ACCESS_STATE_OFFLINE		0xe
 #define ALUA_ACCESS_STATE_TRANSITION		0xf
 
 /*
+ * from spc4r36j section 6.37 Table 306
+ */
+#define ALUA_T_SUP		0x80
+#define ALUA_O_SUP		0x40
+#define ALUA_LBD_SUP		0x10
+#define ALUA_U_SUP		0x08
+#define ALUA_S_SUP		0x04
+#define ALUA_AN_SUP		0x02
+#define ALUA_AO_SUP		0x01
+
+/*
  * REPORT_TARGET_PORT_GROUP STATUS CODE
  *
  * from spc4r17 section 6.27 Table 246
  */
 #define ALUA_STATUS_NONE				0x00
-#define ALUA_STATUS_ALTERED_BY_EXPLICT_STPG		0x01
-#define ALUA_STATUS_ALTERED_BY_IMPLICT_ALUA		0x02
+#define ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG		0x01
+#define ALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA		0x02
 
 /*
  * From spc4r17, Table D.1: ASC and ASCQ Assignement
@@ -46,17 +58,17 @@
 #define ALUA_DEFAULT_NONOP_DELAY_MSECS			100
 #define ALUA_MAX_NONOP_DELAY_MSECS			10000 /* 10 seconds */
 /*
- * Used for implict and explict ALUA transitional delay, that is disabled
+ * Used for implicit and explicit ALUA transitional delay, that is disabled
  * by default, and is intended to be used for debugging client side ALUA code.
  */
 #define ALUA_DEFAULT_TRANS_DELAY_MSECS			0
 #define ALUA_MAX_TRANS_DELAY_MSECS			30000 /* 30 seconds */
 /*
- * Used for the recommended application client implict transition timeout
+ * Used for the recommended application client implicit transition timeout
  * in seconds, returned by the REPORT_TARGET_PORT_GROUPS w/ extended header.
  */
-#define ALUA_DEFAULT_IMPLICT_TRANS_SECS			0
-#define ALUA_MAX_IMPLICT_TRANS_SECS			255
+#define ALUA_DEFAULT_IMPLICIT_TRANS_SECS			0
+#define ALUA_MAX_IMPLICIT_TRANS_SECS			255
 /*
  * Used by core_alua_update_tpg_primary_metadata() and
  * core_alua_update_tpg_secondary_metadata()
@@ -67,18 +79,30 @@
  */
 #define ALUA_SECONDARY_METADATA_WWN_LEN			256
 
+/* Used by core_alua_update_tpg_(primary,secondary)_metadata */
+#define ALUA_MD_BUF_LEN					1024
+
 extern struct kmem_cache *t10_alua_lu_gp_cache;
 extern struct kmem_cache *t10_alua_lu_gp_mem_cache;
 extern struct kmem_cache *t10_alua_tg_pt_gp_cache;
 extern struct kmem_cache *t10_alua_tg_pt_gp_mem_cache;
+extern struct kmem_cache *t10_alua_lba_map_cache;
+extern struct kmem_cache *t10_alua_lba_map_mem_cache;
 
 extern sense_reason_t target_emulate_report_target_port_groups(struct se_cmd *);
 extern sense_reason_t target_emulate_set_target_port_groups(struct se_cmd *);
+extern sense_reason_t target_emulate_report_referrals(struct se_cmd *);
 extern int core_alua_check_nonop_delay(struct se_cmd *);
 extern int core_alua_do_port_transition(struct t10_alua_tg_pt_gp *,
 				struct se_device *, struct se_port *,
 				struct se_node_acl *, int, int);
 extern char *core_alua_dump_status(int);
+extern struct t10_alua_lba_map *core_alua_allocate_lba_map(
+				struct list_head *, u64, u64);
+extern int core_alua_allocate_lba_map_mem(struct t10_alua_lba_map *, int, int);
+extern void core_alua_free_lba_map(struct list_head *);
+extern void core_alua_set_lba_map(struct se_device *, struct list_head *,
+				int, int);
 extern struct t10_alua_lu_gp *core_alua_allocate_lu_gp(const char *, int);
 extern int core_alua_set_lu_gp_id(struct t10_alua_lu_gp *, u16);
 extern void core_alua_free_lu_gp(struct t10_alua_lu_gp *);
@@ -113,9 +137,9 @@
 					char *);
 extern ssize_t core_alua_store_trans_delay_msecs(struct t10_alua_tg_pt_gp *,
 					const char *, size_t);
-extern ssize_t core_alua_show_implict_trans_secs(struct t10_alua_tg_pt_gp *,
+extern ssize_t core_alua_show_implicit_trans_secs(struct t10_alua_tg_pt_gp *,
 					char *);
-extern ssize_t core_alua_store_implict_trans_secs(struct t10_alua_tg_pt_gp *,
+extern ssize_t core_alua_store_implicit_trans_secs(struct t10_alua_tg_pt_gp *,
 					const char *, size_t);
 extern ssize_t core_alua_show_preferred_bit(struct t10_alua_tg_pt_gp *,
 					char *);
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_configfs.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_configfs.c
--- linux-3.10.69/drivers/target/target_core_configfs.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_configfs.c	2017-05-02 03:31:56.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * This file contains ConfigFS logic for the Generic Target Engine project.
  *
- * (c) Copyright 2008-2012 RisingTide Systems LLC.
+ * (c) Copyright 2008-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -48,6 +48,7 @@
 #include "target_core_alua.h"
 #include "target_core_pr.h"
 #include "target_core_rd.h"
+#include "target_core_xcopy.h"
 
 extern struct t10_alua_lu_gp *default_lu_gp;
 
@@ -176,16 +177,16 @@
 	 * struct target_fabric_configfs *tf will contain a usage reference.
 	 */
 	pr_debug("Target_Core_ConfigFS: REGISTER tfc_wwn_cit -> %p\n",
-			&TF_CIT_TMPL(tf)->tfc_wwn_cit);
+			&tf->tf_cit_tmpl.tfc_wwn_cit);
 
 	tf->tf_group.default_groups = tf->tf_default_groups;
 	tf->tf_group.default_groups[0] = &tf->tf_disc_group;
 	tf->tf_group.default_groups[1] = NULL;
 
 	config_group_init_type_name(&tf->tf_group, name,
-			&TF_CIT_TMPL(tf)->tfc_wwn_cit);
+			&tf->tf_cit_tmpl.tfc_wwn_cit);
 	config_group_init_type_name(&tf->tf_disc_group, "discovery_auth",
-			&TF_CIT_TMPL(tf)->tfc_discovery_cit);
+			&tf->tf_cit_tmpl.tfc_discovery_cit);
 
 	pr_debug("Target_Core_ConfigFS: REGISTER -> Allocated Fabric:"
 			" %s\n", tf->tf_group.cg_item.ci_name);
@@ -268,7 +269,7 @@
 	},
 };
 
-static struct configfs_subsystem *target_core_subsystem[] = {
+struct configfs_subsystem *target_core_subsystem[] = {
 	&target_core_fabrics,
 	NULL,
 };
@@ -577,9 +578,9 @@
 	unsigned long val;						\
 	int ret;							\
 									\
-	ret = strict_strtoul(page, 0, &val);				\
+	ret = kstrtoul(page, 0, &val);				\
 	if (ret < 0) {							\
-		pr_err("strict_strtoul() failed with"		\
+		pr_err("kstrtoul() failed with"		\
 			" ret: %d\n", ret);				\
 		return -EINVAL;						\
 	}								\
@@ -636,6 +637,21 @@
 DEF_DEV_ATTRIB(emulate_tpws);
 SE_DEV_ATTR(emulate_tpws, S_IRUGO | S_IWUSR);
 
+DEF_DEV_ATTRIB(emulate_caw);
+SE_DEV_ATTR(emulate_caw, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB(emulate_3pc);
+SE_DEV_ATTR(emulate_3pc, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB(pi_prot_type);
+SE_DEV_ATTR(pi_prot_type, S_IRUGO | S_IWUSR);
+
+DEF_DEV_ATTRIB_RO(hw_pi_prot_type);
+SE_DEV_ATTR_RO(hw_pi_prot_type);
+
+DEF_DEV_ATTRIB(pi_prot_format);
+SE_DEV_ATTR(pi_prot_format, S_IRUGO | S_IWUSR);
+
 DEF_DEV_ATTRIB(enforce_pr_isids);
 SE_DEV_ATTR(enforce_pr_isids, S_IRUGO | S_IWUSR);
 
@@ -693,6 +709,11 @@
 	&target_core_dev_attrib_emulate_tas.attr,
 	&target_core_dev_attrib_emulate_tpu.attr,
 	&target_core_dev_attrib_emulate_tpws.attr,
+	&target_core_dev_attrib_emulate_caw.attr,
+	&target_core_dev_attrib_emulate_3pc.attr,
+	&target_core_dev_attrib_pi_prot_type.attr,
+	&target_core_dev_attrib_hw_pi_prot_type.attr,
+	&target_core_dev_attrib_pi_prot_format.attr,
 	&target_core_dev_attrib_enforce_pr_isids.attr,
 	&target_core_dev_attrib_is_nonrot.attr,
 	&target_core_dev_attrib_emulate_rest_reord.attr,
@@ -983,7 +1004,6 @@
 	struct se_node_acl *se_nacl;
 	struct t10_pr_registration *pr_reg;
 	char i_buf[PR_REG_ISID_ID_LEN];
-	int prf_isid;
 
 	memset(i_buf, 0, PR_REG_ISID_ID_LEN);
 
@@ -992,12 +1012,11 @@
 		return sprintf(page, "No SPC-3 Reservation holder\n");
 
 	se_nacl = pr_reg->pr_reg_nacl;
-	prf_isid = core_pr_dump_initiator_port(pr_reg, &i_buf[0],
-				PR_REG_ISID_ID_LEN);
+	core_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);
 
 	return sprintf(page, "SPC-3 Reservation: %s Initiator: %s%s\n",
 		se_nacl->se_tpg->se_tpg_tfo->get_fabric_name(),
-		se_nacl->initiatorname, (prf_isid) ? &i_buf[0] : "");
+		se_nacl->initiatorname, i_buf);
 }
 
 static ssize_t target_core_dev_pr_show_spc2_res(struct se_device *dev,
@@ -1116,7 +1135,7 @@
 	unsigned char buf[384];
 	char i_buf[PR_REG_ISID_ID_LEN];
 	ssize_t len = 0;
-	int reg_count = 0, prf_isid;
+	int reg_count = 0;
 
 	len += sprintf(page+len, "SPC-3 PR Registrations:\n");
 
@@ -1127,12 +1146,11 @@
 		memset(buf, 0, 384);
 		memset(i_buf, 0, PR_REG_ISID_ID_LEN);
 		tfo = pr_reg->pr_reg_nacl->se_tpg->se_tpg_tfo;
-		prf_isid = core_pr_dump_initiator_port(pr_reg, &i_buf[0],
+		core_pr_dump_initiator_port(pr_reg, i_buf,
 					PR_REG_ISID_ID_LEN);
 		sprintf(buf, "%s Node: %s%s Key: 0x%016Lx PRgen: 0x%08x\n",
 			tfo->get_fabric_name(),
-			pr_reg->pr_reg_nacl->initiatorname, (prf_isid) ?
-			&i_buf[0] : "", pr_reg->pr_res_key,
+			pr_reg->pr_reg_nacl->initiatorname, i_buf, pr_reg->pr_res_key,
 			pr_reg->pr_res_generation);
 
 		if (len + strlen(buf) >= PAGE_SIZE)
@@ -1313,9 +1331,9 @@
 				ret = -ENOMEM;
 				goto out;
 			}
-			ret = strict_strtoull(arg_p, 0, &tmp_ll);
+			ret = kstrtoull(arg_p, 0, &tmp_ll);
 			if (ret < 0) {
-				pr_err("strict_strtoull() failed for"
+				pr_err("kstrtoull() failed for"
 					" sa_res_key=\n");
 				goto out;
 			}
@@ -1735,6 +1753,176 @@
 	.store	= target_core_store_alua_lu_gp,
 };
 
+static ssize_t target_core_show_dev_lba_map(void *p, char *page)
+{
+	struct se_device *dev = p;
+	struct t10_alua_lba_map *map;
+	struct t10_alua_lba_map_member *mem;
+	char *b = page;
+	int bl = 0;
+	char state;
+
+	spin_lock(&dev->t10_alua.lba_map_lock);
+	if (!list_empty(&dev->t10_alua.lba_map_list))
+	    bl += sprintf(b + bl, "%u %u\n",
+			  dev->t10_alua.lba_map_segment_size,
+			  dev->t10_alua.lba_map_segment_multiplier);
+	list_for_each_entry(map, &dev->t10_alua.lba_map_list, lba_map_list) {
+		bl += sprintf(b + bl, "%llu %llu",
+			      map->lba_map_first_lba, map->lba_map_last_lba);
+		list_for_each_entry(mem, &map->lba_map_mem_list,
+				    lba_map_mem_list) {
+			switch (mem->lba_map_mem_alua_state) {
+			case ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED:
+				state = 'O';
+				break;
+			case ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED:
+				state = 'A';
+				break;
+			case ALUA_ACCESS_STATE_STANDBY:
+				state = 'S';
+				break;
+			case ALUA_ACCESS_STATE_UNAVAILABLE:
+				state = 'U';
+				break;
+			default:
+				state = '.';
+				break;
+			}
+			bl += sprintf(b + bl, " %d:%c",
+				      mem->lba_map_mem_alua_pg_id, state);
+		}
+		bl += sprintf(b + bl, "\n");
+	}
+	spin_unlock(&dev->t10_alua.lba_map_lock);
+	return bl;
+}
+
+static ssize_t target_core_store_dev_lba_map(
+	void *p,
+	const char *page,
+	size_t count)
+{
+	struct se_device *dev = p;
+	struct t10_alua_lba_map *lba_map = NULL;
+	struct list_head lba_list;
+	char *map_entries, *ptr;
+	char state;
+	int pg_num = -1, pg;
+	int ret = 0, num = 0, pg_id, alua_state;
+	unsigned long start_lba = -1, end_lba = -1;
+	unsigned long segment_size = -1, segment_mult = -1;
+
+	map_entries = kstrdup(page, GFP_KERNEL);
+	if (!map_entries)
+		return -ENOMEM;
+
+	INIT_LIST_HEAD(&lba_list);
+	while ((ptr = strsep(&map_entries, "\n")) != NULL) {
+		if (!*ptr)
+			continue;
+
+		if (num == 0) {
+			if (sscanf(ptr, "%lu %lu\n",
+				   &segment_size, &segment_mult) != 2) {
+				pr_err("Invalid line %d\n", num);
+				ret = -EINVAL;
+				break;
+			}
+			num++;
+			continue;
+		}
+		if (sscanf(ptr, "%lu %lu", &start_lba, &end_lba) != 2) {
+			pr_err("Invalid line %d\n", num);
+			ret = -EINVAL;
+			break;
+		}
+		ptr = strchr(ptr, ' ');
+		if (!ptr) {
+			pr_err("Invalid line %d, missing end lba\n", num);
+			ret = -EINVAL;
+			break;
+		}
+		ptr++;
+		ptr = strchr(ptr, ' ');
+		if (!ptr) {
+			pr_err("Invalid line %d, missing state definitions\n",
+			       num);
+			ret = -EINVAL;
+			break;
+		}
+		ptr++;
+		lba_map = core_alua_allocate_lba_map(&lba_list,
+						     start_lba, end_lba);
+		if (IS_ERR(lba_map)) {
+			ret = PTR_ERR(lba_map);
+			break;
+		}
+		pg = 0;
+		while (sscanf(ptr, "%d:%c", &pg_id, &state) == 2) {
+			switch (state) {
+			case 'O':
+				alua_state = ALUA_ACCESS_STATE_ACTIVE_OPTIMIZED;
+				break;
+			case 'A':
+				alua_state = ALUA_ACCESS_STATE_ACTIVE_NON_OPTIMIZED;
+				break;
+			case 'S':
+				alua_state = ALUA_ACCESS_STATE_STANDBY;
+				break;
+			case 'U':
+				alua_state = ALUA_ACCESS_STATE_UNAVAILABLE;
+				break;
+			default:
+				pr_err("Invalid ALUA state '%c'\n", state);
+				ret = -EINVAL;
+				goto out;
+			}
+
+			ret = core_alua_allocate_lba_map_mem(lba_map,
+							     pg_id, alua_state);
+			if (ret) {
+				pr_err("Invalid target descriptor %d:%c "
+				       "at line %d\n",
+				       pg_id, state, num);
+				break;
+			}
+			pg++;
+			ptr = strchr(ptr, ' ');
+			if (ptr)
+				ptr++;
+			else
+				break;
+		}
+		if (pg_num == -1)
+		    pg_num = pg;
+		else if (pg != pg_num) {
+			pr_err("Only %d from %d port groups definitions "
+			       "at line %d\n", pg, pg_num, num);
+			ret = -EINVAL;
+			break;
+		}
+		num++;
+	}
+out:
+	if (ret) {
+		core_alua_free_lba_map(&lba_list);
+		count = ret;
+	} else
+		core_alua_set_lba_map(dev, &lba_list,
+				      segment_size, segment_mult);
+	kfree(map_entries);
+	return count;
+}
+
+static struct target_core_configfs_attribute target_core_attr_dev_lba_map = {
+	.attr	= { .ca_owner = THIS_MODULE,
+		    .ca_name = "lba_map",
+		    .ca_mode = S_IRUGO | S_IWUSR },
+	.show	= target_core_show_dev_lba_map,
+	.store	= target_core_store_dev_lba_map,
+};
+
 static struct configfs_attribute *lio_core_dev_attrs[] = {
 	&target_core_attr_dev_info.attr,
 	&target_core_attr_dev_control.attr,
@@ -1742,6 +1930,7 @@
 	&target_core_attr_dev_udev_path.attr,
 	&target_core_attr_dev_enable.attr,
 	&target_core_attr_dev_alua_lu_gp.attr,
+	&target_core_attr_dev_lba_map.attr,
 	NULL,
 };
 
@@ -1839,11 +2028,11 @@
 	unsigned long lu_gp_id;
 	int ret;
 
-	ret = strict_strtoul(page, 0, &lu_gp_id);
+	ret = kstrtoul(page, 0, &lu_gp_id);
 	if (ret < 0) {
-		pr_err("strict_strtoul() returned %d for"
+		pr_err("kstrtoul() returned %d for"
 			" lu_gp_id\n", ret);
-		return -EINVAL;
+		return ret;
 	}
 	if (lu_gp_id > 0x0000ffff) {
 		pr_err("ALUA lu_gp_id: %lu exceeds maximum:"
@@ -2030,7 +2219,7 @@
 	int new_state, ret;
 
 	if (!tg_pt_gp->tg_pt_gp_valid_id) {
-		pr_err("Unable to do implict ALUA on non valid"
+		pr_err("Unable to do implicit ALUA on non valid"
 			" tg_pt_gp ID: %hu\n", tg_pt_gp->tg_pt_gp_valid_id);
 		return -EINVAL;
 	}
@@ -2040,17 +2229,24 @@
 		return -ENODEV;
 	}
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
 		pr_err("Unable to extract new ALUA access state from"
 				" %s\n", page);
-		return -EINVAL;
+		return ret;
 	}
 	new_state = (int)tmp;
 
-	if (!(tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICT_ALUA)) {
-		pr_err("Unable to process implict configfs ALUA"
-			" transition while TPGS_IMPLICT_ALUA is disabled\n");
+	if (!(tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_IMPLICIT_ALUA)) {
+		pr_err("Unable to process implicit configfs ALUA"
+			" transition while TPGS_IMPLICIT_ALUA is disabled\n");
+		return -EINVAL;
+	}
+	if (tg_pt_gp->tg_pt_gp_alua_access_type & TPGS_EXPLICIT_ALUA &&
+	    new_state == ALUA_ACCESS_STATE_LBA_DEPENDENT) {
+		/* LBA DEPENDENT is only allowed with implicit ALUA */
+		pr_err("Unable to process implicit configfs ALUA transition"
+		       " while explicit ALUA management is enabled\n");
 		return -EINVAL;
 	}
 
@@ -2087,17 +2283,17 @@
 		return -EINVAL;
 	}
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
 		pr_err("Unable to extract new ALUA access status"
 				" from %s\n", page);
-		return -EINVAL;
+		return ret;
 	}
 	new_status = (int)tmp;
 
 	if ((new_status != ALUA_STATUS_NONE) &&
-	    (new_status != ALUA_STATUS_ALTERED_BY_EXPLICT_STPG) &&
-	    (new_status != ALUA_STATUS_ALTERED_BY_IMPLICT_ALUA)) {
+	    (new_status != ALUA_STATUS_ALTERED_BY_EXPLICIT_STPG) &&
+	    (new_status != ALUA_STATUS_ALTERED_BY_IMPLICIT_ALUA)) {
 		pr_err("Illegal ALUA access status: 0x%02x\n",
 				new_status);
 		return -EINVAL;
@@ -2130,6 +2326,90 @@
 SE_DEV_ALUA_TG_PT_ATTR(alua_access_type, S_IRUGO | S_IWUSR);
 
 /*
+ * alua_supported_states
+ */
+
+#define SE_DEV_ALUA_SUPPORT_STATE_SHOW(_name, _var, _bit)		\
+static ssize_t target_core_alua_tg_pt_gp_show_attr_alua_support_##_name( \
+	struct t10_alua_tg_pt_gp *t, char *p)				\
+{									\
+	return sprintf(p, "%d\n", !!(t->_var & _bit));			\
+}
+
+#define SE_DEV_ALUA_SUPPORT_STATE_STORE(_name, _var, _bit)		\
+static ssize_t target_core_alua_tg_pt_gp_store_attr_alua_support_##_name(\
+	struct t10_alua_tg_pt_gp *t, const char *p, size_t c)		\
+{									\
+	unsigned long tmp;						\
+	int ret;							\
+									\
+	if (!t->tg_pt_gp_valid_id) {					\
+		pr_err("Unable to do set ##_name ALUA state on non"	\
+		       " valid tg_pt_gp ID: %hu\n",			\
+		       t->tg_pt_gp_valid_id);				\
+		return -EINVAL;						\
+	}								\
+									\
+	ret = kstrtoul(p, 0, &tmp);					\
+	if (ret < 0) {							\
+		pr_err("Invalid value '%s', must be '0' or '1'\n", p);	\
+		return -EINVAL;						\
+	}								\
+	if (tmp > 1) {							\
+		pr_err("Invalid value '%ld', must be '0' or '1'\n", tmp); \
+		return -EINVAL;						\
+	}								\
+	if (tmp)							\
+		t->_var |= _bit;					\
+	else								\
+		t->_var &= ~_bit;					\
+									\
+	return c;							\
+}
+
+SE_DEV_ALUA_SUPPORT_STATE_SHOW(transitioning,
+			       tg_pt_gp_alua_supported_states, ALUA_T_SUP);
+SE_DEV_ALUA_SUPPORT_STATE_STORE(transitioning,
+				tg_pt_gp_alua_supported_states, ALUA_T_SUP);
+SE_DEV_ALUA_TG_PT_ATTR(alua_support_transitioning, S_IRUGO | S_IWUSR);
+
+SE_DEV_ALUA_SUPPORT_STATE_SHOW(offline,
+			       tg_pt_gp_alua_supported_states, ALUA_O_SUP);
+SE_DEV_ALUA_SUPPORT_STATE_STORE(offline,
+				tg_pt_gp_alua_supported_states, ALUA_O_SUP);
+SE_DEV_ALUA_TG_PT_ATTR(alua_support_offline, S_IRUGO | S_IWUSR);
+
+SE_DEV_ALUA_SUPPORT_STATE_SHOW(lba_dependent,
+			       tg_pt_gp_alua_supported_states, ALUA_LBD_SUP);
+SE_DEV_ALUA_SUPPORT_STATE_STORE(lba_dependent,
+				tg_pt_gp_alua_supported_states, ALUA_LBD_SUP);
+SE_DEV_ALUA_TG_PT_ATTR(alua_support_lba_dependent, S_IRUGO);
+
+SE_DEV_ALUA_SUPPORT_STATE_SHOW(unavailable,
+			       tg_pt_gp_alua_supported_states, ALUA_U_SUP);
+SE_DEV_ALUA_SUPPORT_STATE_STORE(unavailable,
+				tg_pt_gp_alua_supported_states, ALUA_U_SUP);
+SE_DEV_ALUA_TG_PT_ATTR(alua_support_unavailable, S_IRUGO | S_IWUSR);
+
+SE_DEV_ALUA_SUPPORT_STATE_SHOW(standby,
+			       tg_pt_gp_alua_supported_states, ALUA_S_SUP);
+SE_DEV_ALUA_SUPPORT_STATE_STORE(standby,
+				tg_pt_gp_alua_supported_states, ALUA_S_SUP);
+SE_DEV_ALUA_TG_PT_ATTR(alua_support_standby, S_IRUGO | S_IWUSR);
+
+SE_DEV_ALUA_SUPPORT_STATE_SHOW(active_optimized,
+			       tg_pt_gp_alua_supported_states, ALUA_AO_SUP);
+SE_DEV_ALUA_SUPPORT_STATE_STORE(active_optimized,
+				tg_pt_gp_alua_supported_states, ALUA_AO_SUP);
+SE_DEV_ALUA_TG_PT_ATTR(alua_support_active_optimized, S_IRUGO | S_IWUSR);
+
+SE_DEV_ALUA_SUPPORT_STATE_SHOW(active_nonoptimized,
+			       tg_pt_gp_alua_supported_states, ALUA_AN_SUP);
+SE_DEV_ALUA_SUPPORT_STATE_STORE(active_nonoptimized,
+				tg_pt_gp_alua_supported_states, ALUA_AN_SUP);
+SE_DEV_ALUA_TG_PT_ATTR(alua_support_active_nonoptimized, S_IRUGO | S_IWUSR);
+
+/*
  * alua_write_metadata
  */
 static ssize_t target_core_alua_tg_pt_gp_show_attr_alua_write_metadata(
@@ -2147,10 +2427,10 @@
 	unsigned long tmp;
 	int ret;
 
-	ret = strict_strtoul(page, 0, &tmp);
+	ret = kstrtoul(page, 0, &tmp);
 	if (ret < 0) {
 		pr_err("Unable to extract alua_write_metadata\n");
-		return -EINVAL;
+		return ret;
 	}
 
 	if ((tmp != 0) && (tmp != 1)) {
@@ -2209,24 +2489,24 @@
 SE_DEV_ALUA_TG_PT_ATTR(trans_delay_msecs, S_IRUGO | S_IWUSR);
 
 /*
- * implict_trans_secs
+ * implicit_trans_secs
  */
-static ssize_t target_core_alua_tg_pt_gp_show_attr_implict_trans_secs(
+static ssize_t target_core_alua_tg_pt_gp_show_attr_implicit_trans_secs(
 	struct t10_alua_tg_pt_gp *tg_pt_gp,
 	char *page)
 {
-	return core_alua_show_implict_trans_secs(tg_pt_gp, page);
+	return core_alua_show_implicit_trans_secs(tg_pt_gp, page);
 }
 
-static ssize_t target_core_alua_tg_pt_gp_store_attr_implict_trans_secs(
+static ssize_t target_core_alua_tg_pt_gp_store_attr_implicit_trans_secs(
 	struct t10_alua_tg_pt_gp *tg_pt_gp,
 	const char *page,
 	size_t count)
 {
-	return core_alua_store_implict_trans_secs(tg_pt_gp, page, count);
+	return core_alua_store_implicit_trans_secs(tg_pt_gp, page, count);
 }
 
-SE_DEV_ALUA_TG_PT_ATTR(implict_trans_secs, S_IRUGO | S_IWUSR);
+SE_DEV_ALUA_TG_PT_ATTR(implicit_trans_secs, S_IRUGO | S_IWUSR);
 
 /*
  * preferred
@@ -2271,11 +2551,11 @@
 	unsigned long tg_pt_gp_id;
 	int ret;
 
-	ret = strict_strtoul(page, 0, &tg_pt_gp_id);
+	ret = kstrtoul(page, 0, &tg_pt_gp_id);
 	if (ret < 0) {
-		pr_err("strict_strtoul() returned %d for"
+		pr_err("kstrtoul() returned %d for"
 			" tg_pt_gp_id\n", ret);
-		return -EINVAL;
+		return ret;
 	}
 	if (tg_pt_gp_id > 0x0000ffff) {
 		pr_err("ALUA tg_pt_gp_id: %lu exceeds maximum:"
@@ -2349,10 +2629,17 @@
 	&target_core_alua_tg_pt_gp_alua_access_state.attr,
 	&target_core_alua_tg_pt_gp_alua_access_status.attr,
 	&target_core_alua_tg_pt_gp_alua_access_type.attr,
+	&target_core_alua_tg_pt_gp_alua_support_transitioning.attr,
+	&target_core_alua_tg_pt_gp_alua_support_offline.attr,
+	&target_core_alua_tg_pt_gp_alua_support_lba_dependent.attr,
+	&target_core_alua_tg_pt_gp_alua_support_unavailable.attr,
+	&target_core_alua_tg_pt_gp_alua_support_standby.attr,
+	&target_core_alua_tg_pt_gp_alua_support_active_nonoptimized.attr,
+	&target_core_alua_tg_pt_gp_alua_support_active_optimized.attr,
 	&target_core_alua_tg_pt_gp_alua_write_metadata.attr,
 	&target_core_alua_tg_pt_gp_nonop_delay_msecs.attr,
 	&target_core_alua_tg_pt_gp_trans_delay_msecs.attr,
-	&target_core_alua_tg_pt_gp_implict_trans_secs.attr,
+	&target_core_alua_tg_pt_gp_implicit_trans_secs.attr,
 	&target_core_alua_tg_pt_gp_preferred.attr,
 	&target_core_alua_tg_pt_gp_tg_pt_gp_id.attr,
 	&target_core_alua_tg_pt_gp_members.attr,
@@ -2684,10 +2971,10 @@
 	if (transport->pmode_enable_hba == NULL)
 		return -EINVAL;
 
-	ret = strict_strtoul(page, 0, &mode_flag);
+	ret = kstrtoul(page, 0, &mode_flag);
 	if (ret < 0) {
 		pr_err("Unable to extract hba mode flag: %d\n", ret);
-		return -EINVAL;
+		return ret;
 	}
 
 	if (hba->dev_count) {
@@ -2775,11 +3062,11 @@
 		str++; /* Skip to start of plugin dependent ID */
 	}
 
-	ret = strict_strtoul(str, 0, &plugin_dep_id);
+	ret = kstrtoul(str, 0, &plugin_dep_id);
 	if (ret < 0) {
-		pr_err("strict_strtoul() returned %d for"
+		pr_err("kstrtoul() returned %d for"
 				" plugin_dep_id\n", ret);
-		return ERR_PTR(-EINVAL);
+		return ERR_PTR(ret);
 	}
 	/*
 	 * Load up TCM subsystem plugins if they have not already been loaded.
@@ -2845,7 +3132,7 @@
 	 * and ALUA Logical Unit Group and Target Port Group infrastructure.
 	 */
 	target_cg = &subsys->su_group;
-	target_cg->default_groups = kmalloc(sizeof(struct config_group) * 2,
+	target_cg->default_groups = kmalloc(sizeof(struct config_group *) * 2,
 				GFP_KERNEL);
 	if (!target_cg->default_groups) {
 		pr_err("Unable to allocate target_cg->default_groups\n");
@@ -2935,6 +3222,10 @@
 	if (ret < 0)
 		goto out;
 
+	ret = target_xcopy_setup_pt();
+	if (ret < 0)
+		goto out;
+
 	return 0;
 
 out:
@@ -3007,6 +3298,7 @@
 
 	core_dev_release_virtual_lun0();
 	rd_module_exit();
+	target_xcopy_release_pt();
 	release_se_kmem_caches();
 }
 
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_device.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_device.c
--- linux-3.10.69/drivers/target/target_core_device.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_device.c	2017-05-02 03:31:56.000000000 +0200
@@ -4,7 +4,7 @@
  * This file contains the TCM Virtual Device and Disk Transport
  * agnostic related functions.
  *
- * (c) Copyright 2003-2012 RisingTide Systems LLC.
+ * (c) Copyright 2003-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -47,6 +47,9 @@
 #include "target_core_pr.h"
 #include "target_core_ua.h"
 
+DEFINE_MUTEX(g_device_mutex);
+LIST_HEAD(g_device_list);
+
 static struct se_hba *lun0_hba;
 /* not static, needed by tpg.c */
 struct se_device *g_lun0_dev;
@@ -89,6 +92,9 @@
 		se_cmd->pr_res_key = deve->pr_res_key;
 		se_cmd->orig_fe_lun = unpacked_lun;
 		se_cmd->se_cmd_flags |= SCF_SE_LUN_CMD;
+
+		percpu_ref_get(&se_lun->lun_ref);
+		se_cmd->lun_ref_active = true;
 	}
 	spin_unlock_irqrestore(&se_sess->se_node_acl->device_list_lock, flags);
 
@@ -116,24 +122,20 @@
 		se_cmd->se_lun = &se_sess->se_tpg->tpg_virt_lun0;
 		se_cmd->orig_fe_lun = 0;
 		se_cmd->se_cmd_flags |= SCF_SE_LUN_CMD;
+
+		percpu_ref_get(&se_lun->lun_ref);
+		se_cmd->lun_ref_active = true;
 	}
 
 	/* Directly associate cmd with se_dev */
 	se_cmd->se_dev = se_lun->lun_se_dev;
 
-	/* TODO: get rid of this and use atomics for stats */
 	dev = se_lun->lun_se_dev;
-	spin_lock_irqsave(&dev->stats_lock, flags);
-	dev->num_cmds++;
+	atomic_long_inc(&dev->num_cmds);
 	if (se_cmd->data_direction == DMA_TO_DEVICE)
-		dev->write_bytes += se_cmd->data_length;
+		atomic_long_add(se_cmd->data_length, &dev->write_bytes);
 	else if (se_cmd->data_direction == DMA_FROM_DEVICE)
-		dev->read_bytes += se_cmd->data_length;
-	spin_unlock_irqrestore(&dev->stats_lock, flags);
-
-	spin_lock_irqsave(&se_lun->lun_cmd_lock, flags);
-	list_add_tail(&se_cmd->se_lun_node, &se_lun->lun_cmd_list);
-	spin_unlock_irqrestore(&se_lun->lun_cmd_lock, flags);
+		atomic_long_add(se_cmd->data_length, &dev->read_bytes);
 
 	return 0;
 }
@@ -311,14 +313,14 @@
 	deve = nacl->device_list[mapped_lun];
 
 	/*
-	 * Check if the call is handling demo mode -> explict LUN ACL
+	 * Check if the call is handling demo mode -> explicit LUN ACL
 	 * transition.  This transition must be for the same struct se_lun
 	 * + mapped_lun that was setup in demo mode..
 	 */
 	if (deve->lun_flags & TRANSPORT_LUNFLAGS_INITIATOR_ACCESS) {
 		if (deve->se_lun_acl != NULL) {
 			pr_err("struct se_dev_entry->se_lun_acl"
-			       " already set for demo mode -> explict"
+			       " already set for demo mode -> explicit"
 			       " LUN ACL transition\n");
 			spin_unlock_irq(&nacl->device_list_lock);
 			return -EINVAL;
@@ -326,7 +328,7 @@
 		if (deve->se_lun != lun) {
 			pr_err("struct se_dev_entry->se_lun does"
 			       " match passed struct se_lun for demo mode"
-			       " -> explict LUN ACL transition\n");
+			       " -> explicit LUN ACL transition\n");
 			spin_unlock_irq(&nacl->device_list_lock);
 			return -EINVAL;
 		}
@@ -891,6 +893,120 @@
 	return 0;
 }
 
+int se_dev_set_emulate_caw(struct se_device *dev, int flag)
+{
+	if (flag != 0 && flag != 1) {
+		pr_err("Illegal value %d\n", flag);
+		return -EINVAL;
+	}
+	dev->dev_attrib.emulate_caw = flag;
+	pr_debug("dev[%p]: SE Device CompareAndWrite (AtomicTestandSet): %d\n",
+		 dev, flag);
+
+	return 0;
+}
+
+int se_dev_set_emulate_3pc(struct se_device *dev, int flag)
+{
+	if (flag != 0 && flag != 1) {
+		pr_err("Illegal value %d\n", flag);
+		return -EINVAL;
+	}
+	dev->dev_attrib.emulate_3pc = flag;
+	pr_debug("dev[%p]: SE Device 3rd Party Copy (EXTENDED_COPY): %d\n",
+		dev, flag);
+
+	return 0;
+}
+
+int se_dev_set_pi_prot_type(struct se_device *dev, int flag)
+{
+	int rc, old_prot = dev->dev_attrib.pi_prot_type;
+
+	if (flag != 0 && flag != 1 && flag != 2 && flag != 3) {
+		pr_err("Illegal value %d for pi_prot_type\n", flag);
+		return -EINVAL;
+	}
+	if (flag == 2) {
+		pr_err("DIF TYPE2 protection currently not supported\n");
+		return -ENOSYS;
+	}
+	if (dev->dev_attrib.hw_pi_prot_type) {
+		pr_warn("DIF protection enabled on underlying hardware,"
+			" ignoring\n");
+		return 0;
+	}
+	if (!dev->transport->init_prot || !dev->transport->free_prot) {
+		/* 0 is only allowed value for non-supporting backends */
+		if (flag == 0)
+			return 0;
+
+		pr_err("DIF protection not supported by backend: %s\n",
+		       dev->transport->name);
+		return -ENOSYS;
+	}
+	if (!(dev->dev_flags & DF_CONFIGURED)) {
+		pr_err("DIF protection requires device to be configured\n");
+		return -ENODEV;
+	}
+	if (dev->export_count) {
+		pr_err("dev[%p]: Unable to change SE Device PROT type while"
+		       " export_count is %d\n", dev, dev->export_count);
+		return -EINVAL;
+	}
+
+	dev->dev_attrib.pi_prot_type = flag;
+
+	if (flag && !old_prot) {
+		rc = dev->transport->init_prot(dev);
+		if (rc) {
+			dev->dev_attrib.pi_prot_type = old_prot;
+			return rc;
+		}
+
+	} else if (!flag && old_prot) {
+		dev->transport->free_prot(dev);
+	}
+	pr_debug("dev[%p]: SE Device Protection Type: %d\n", dev, flag);
+
+	return 0;
+}
+
+int se_dev_set_pi_prot_format(struct se_device *dev, int flag)
+{
+	int rc;
+
+	if (!flag)
+		return 0;
+
+	if (flag != 1) {
+		pr_err("Illegal value %d for pi_prot_format\n", flag);
+		return -EINVAL;
+	}
+	if (!dev->transport->format_prot) {
+		pr_err("DIF protection format not supported by backend %s\n",
+		       dev->transport->name);
+		return -ENOSYS;
+	}
+	if (!(dev->dev_flags & DF_CONFIGURED)) {
+		pr_err("DIF protection format requires device to be configured\n");
+		return -ENODEV;
+	}
+	if (dev->export_count) {
+		pr_err("dev[%p]: Unable to format SE Device PROT type while"
+		       " export_count is %d\n", dev, dev->export_count);
+		return -EINVAL;
+	}
+
+	rc = dev->transport->format_prot(dev);
+	if (rc)
+		return rc;
+
+	pr_debug("dev[%p]: SE Device Protection Format complete\n", dev);
+
+	return 0;
+}
+
 int se_dev_set_enforce_pr_isids(struct se_device *dev, int flag)
 {
 	if ((flag != 0) && (flag != 1)) {
@@ -1090,23 +1206,23 @@
 struct se_lun *core_dev_add_lun(
 	struct se_portal_group *tpg,
 	struct se_device *dev,
-	u32 lun)
+	u32 unpacked_lun)
 {
-	struct se_lun *lun_p;
+	struct se_lun *lun;
 	int rc;
 
-	lun_p = core_tpg_pre_addlun(tpg, lun);
-	if (IS_ERR(lun_p))
-		return lun_p;
+	lun = core_tpg_alloc_lun(tpg, unpacked_lun);
+	if (IS_ERR(lun))
+		return lun;
 
-	rc = core_tpg_post_addlun(tpg, lun_p,
+	rc = core_tpg_add_lun(tpg, lun,
 				TRANSPORT_LUNFLAGS_READ_WRITE, dev);
 	if (rc < 0)
 		return ERR_PTR(rc);
 
 	pr_debug("%s_TPG[%u]_LUN[%u] - Activated %s Logical Unit from"
 		" CORE HBA: %u\n", tpg->se_tpg_tfo->get_fabric_name(),
-		tpg->se_tpg_tfo->tpg_get_tag(tpg), lun_p->unpacked_lun,
+		tpg->se_tpg_tfo->tpg_get_tag(tpg), lun->unpacked_lun,
 		tpg->se_tpg_tfo->get_fabric_name(), dev->se_hba->hba_id);
 	/*
 	 * Update LUN maps for dynamically added initiators when
@@ -1127,7 +1243,7 @@
 		spin_unlock_irq(&tpg->acl_node_lock);
 	}
 
-	return lun_p;
+	return lun;
 }
 
 /*      core_dev_del_lun():
@@ -1385,6 +1501,7 @@
 struct se_device *target_alloc_device(struct se_hba *hba, const char *name)
 {
 	struct se_device *dev;
+	struct se_lun *xcopy_lun;
 
 	dev = hba->transport->alloc_device(hba, name);
 	if (!dev)
@@ -1393,6 +1510,7 @@
 	dev->dev_link_magic = SE_DEV_LINK_MAGIC;
 	dev->se_hba = hba;
 	dev->transport = hba->transport;
+	dev->prot_length = sizeof(struct se_dif_v1_tuple);
 
 	INIT_LIST_HEAD(&dev->dev_list);
 	INIT_LIST_HEAD(&dev->dev_sep_list);
@@ -1400,13 +1518,14 @@
 	INIT_LIST_HEAD(&dev->delayed_cmd_list);
 	INIT_LIST_HEAD(&dev->state_list);
 	INIT_LIST_HEAD(&dev->qf_cmd_list);
-	spin_lock_init(&dev->stats_lock);
+	INIT_LIST_HEAD(&dev->g_dev_node);
 	spin_lock_init(&dev->execute_task_lock);
 	spin_lock_init(&dev->delayed_cmd_lock);
 	spin_lock_init(&dev->dev_reservation_lock);
 	spin_lock_init(&dev->se_port_lock);
 	spin_lock_init(&dev->se_tmr_lock);
 	spin_lock_init(&dev->qf_cmd_lock);
+	sema_init(&dev->caw_sem, 1);
 	atomic_set(&dev->dev_ordered_id, 0);
 	INIT_LIST_HEAD(&dev->t10_wwn.t10_vpd_list);
 	spin_lock_init(&dev->t10_wwn.t10_vpd_lock);
@@ -1416,8 +1535,9 @@
 	spin_lock_init(&dev->t10_pr.aptpl_reg_lock);
 	INIT_LIST_HEAD(&dev->t10_alua.tg_pt_gps_list);
 	spin_lock_init(&dev->t10_alua.tg_pt_gps_lock);
+	INIT_LIST_HEAD(&dev->t10_alua.lba_map_list);
+	spin_lock_init(&dev->t10_alua.lba_map_lock);
 
-	dev->t10_pr.pr_aptpl_buf_len = PR_APTPL_BUF_LEN;
 	dev->t10_wwn.t10_dev = dev;
 	dev->t10_alua.t10_dev = dev;
 
@@ -1431,6 +1551,9 @@
 	dev->dev_attrib.emulate_tas = DA_EMULATE_TAS;
 	dev->dev_attrib.emulate_tpu = DA_EMULATE_TPU;
 	dev->dev_attrib.emulate_tpws = DA_EMULATE_TPWS;
+	dev->dev_attrib.emulate_caw = DA_EMULATE_CAW;
+	dev->dev_attrib.emulate_3pc = DA_EMULATE_3PC;
+	dev->dev_attrib.pi_prot_type = TARGET_DIF_TYPE0_PROT;
 	dev->dev_attrib.enforce_pr_isids = DA_ENFORCE_PR_ISIDS;
 	dev->dev_attrib.is_nonrot = DA_IS_NONROT;
 	dev->dev_attrib.emulate_rest_reord = DA_EMULATE_REST_REORD;
@@ -1443,6 +1566,14 @@
 	dev->dev_attrib.max_write_same_len = DA_MAX_WRITE_SAME_LEN;
 	dev->dev_attrib.fabric_max_sectors = DA_FABRIC_MAX_SECTORS;
 
+	xcopy_lun = &dev->xcopy_lun;
+	xcopy_lun->lun_se_dev = dev;
+	init_completion(&xcopy_lun->lun_shutdown_comp);
+	INIT_LIST_HEAD(&xcopy_lun->lun_acl_list);
+	spin_lock_init(&xcopy_lun->lun_acl_lock);
+	spin_lock_init(&xcopy_lun->lun_sep_lock);
+	init_completion(&xcopy_lun->lun_ref_comp);
+
 	return dev;
 }
 
@@ -1460,8 +1591,6 @@
 	ret = dev->transport->configure_device(dev);
 	if (ret)
 		goto out;
-	dev->dev_flags |= DF_CONFIGURED;
-
 	/*
 	 * XXX: there is not much point to have two different values here..
 	 */
@@ -1518,6 +1647,13 @@
 	spin_lock(&hba->device_lock);
 	hba->dev_count++;
 	spin_unlock(&hba->device_lock);
+
+	mutex_lock(&g_device_mutex);
+	list_add_tail(&dev->g_dev_node, &g_device_list);
+	mutex_unlock(&g_device_mutex);
+
+	dev->dev_flags |= DF_CONFIGURED;
+
 	return 0;
 
 out_free_alua:
@@ -1536,15 +1672,23 @@
 	if (dev->dev_flags & DF_CONFIGURED) {
 		destroy_workqueue(dev->tmr_wq);
 
+		mutex_lock(&g_device_mutex);
+		list_del(&dev->g_dev_node);
+		mutex_unlock(&g_device_mutex);
+
 		spin_lock(&hba->device_lock);
 		hba->dev_count--;
 		spin_unlock(&hba->device_lock);
 	}
 
 	core_alua_free_lu_gp_mem(dev);
+	core_alua_set_lba_map(dev, NULL, 0, 0);
 	core_scsi3_free_all_registrations(dev);
 	se_release_vpd_for_dev(dev);
 
+	if (dev->transport->free_prot)
+		dev->transport->free_prot(dev);
+
 	dev->transport->free_device(dev);
 }
 
@@ -1552,7 +1696,7 @@
 {
 	struct se_hba *hba;
 	struct se_device *dev;
-	char buf[16];
+	char buf[] = "rd_pages=8,rd_nullio=1";
 	int ret;
 
 	hba = core_alloc_hba("rd_mcp", 0, HBA_FLAGS_INTERNAL_USE);
@@ -1565,8 +1709,6 @@
 		goto out_free_hba;
 	}
 
-	memset(buf, 0, 16);
-	sprintf(buf, "rd_pages=8");
 	hba->transport->set_configfs_dev_params(dev, buf, sizeof(buf));
 
 	ret = target_configure_device(dev);
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_fabric_configfs.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_fabric_configfs.c
--- linux-3.10.69/drivers/target/target_core_fabric_configfs.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_fabric_configfs.c	2017-05-02 03:31:56.000000000 +0200
@@ -4,7 +4,7 @@
  * This file contains generic fabric module configfs infrastructure for
  * TCM v4.x code
  *
- * (c) Copyright 2010-2012 RisingTide Systems LLC.
+ * (c) Copyright 2010-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@linux-iscsi.org>
 *
@@ -189,9 +189,11 @@
 	struct se_node_acl *se_nacl = lacl->se_lun_nacl;
 	struct se_portal_group *se_tpg = se_nacl->se_tpg;
 	unsigned long op;
+	int ret;
 
-	if (strict_strtoul(page, 0, &op))
-		return -EINVAL;
+	ret = kstrtoul(page, 0, &op);
+	if (ret)
+		return ret;
 
 	if ((op != 1) && (op != 0))
 		return -EINVAL;
@@ -350,7 +352,10 @@
 	 * Determine the Mapped LUN value.  This is what the SCSI Initiator
 	 * Port will actually see.
 	 */
-	if (strict_strtoul(buf + 4, 0, &mapped_lun) || mapped_lun > UINT_MAX) {
+	ret = kstrtoul(buf + 4, 0, &mapped_lun);
+	if (ret)
+		goto out;
+	if (mapped_lun > UINT_MAX) {
 		ret = -EINVAL;
 		goto out;
 	}
@@ -380,9 +385,9 @@
 	}
 
 	config_group_init_type_name(&lacl->se_lun_group, name,
-			&TF_CIT_TMPL(tf)->tfc_tpg_mappedlun_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_mappedlun_cit);
 	config_group_init_type_name(&lacl->ml_stat_grps.stat_group,
-			"statistics", &TF_CIT_TMPL(tf)->tfc_tpg_mappedlun_stat_cit);
+			"statistics", &tf->tf_cit_tmpl.tfc_tpg_mappedlun_stat_cit);
 	lacl_cg->default_groups[0] = &lacl->ml_stat_grps.stat_group;
 	lacl_cg->default_groups[1] = NULL;
 
@@ -499,16 +504,16 @@
 	nacl_cg->default_groups[4] = NULL;
 
 	config_group_init_type_name(&se_nacl->acl_group, name,
-			&TF_CIT_TMPL(tf)->tfc_tpg_nacl_base_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_nacl_base_cit);
 	config_group_init_type_name(&se_nacl->acl_attrib_group, "attrib",
-			&TF_CIT_TMPL(tf)->tfc_tpg_nacl_attrib_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit);
 	config_group_init_type_name(&se_nacl->acl_auth_group, "auth",
-			&TF_CIT_TMPL(tf)->tfc_tpg_nacl_auth_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_nacl_auth_cit);
 	config_group_init_type_name(&se_nacl->acl_param_group, "param",
-			&TF_CIT_TMPL(tf)->tfc_tpg_nacl_param_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_nacl_param_cit);
 	config_group_init_type_name(&se_nacl->acl_fabric_stat_group,
 			"fabric_statistics",
-			&TF_CIT_TMPL(tf)->tfc_tpg_nacl_stat_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_nacl_stat_cit);
 
 	return &se_nacl->acl_group;
 }
@@ -590,7 +595,7 @@
 
 	se_tpg_np->tpg_np_parent = se_tpg;
 	config_group_init_type_name(&se_tpg_np->tpg_np_group, name,
-			&TF_CIT_TMPL(tf)->tfc_tpg_np_base_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_np_base_cit);
 
 	return &se_tpg_np->tpg_np_group;
 }
@@ -875,7 +880,10 @@
 				" \"lun_$LUN_NUMBER\"\n");
 		return ERR_PTR(-EINVAL);
 	}
-	if (strict_strtoul(name + 4, 0, &unpacked_lun) || unpacked_lun > UINT_MAX)
+	errno = kstrtoul(name + 4, 0, &unpacked_lun);
+	if (errno)
+		return ERR_PTR(errno);
+	if (unpacked_lun > UINT_MAX)
 		return ERR_PTR(-EINVAL);
 
 	lun = core_get_lun_from_tpg(se_tpg, unpacked_lun);
@@ -891,14 +899,14 @@
 	}
 
 	config_group_init_type_name(&lun->lun_group, name,
-			&TF_CIT_TMPL(tf)->tfc_tpg_port_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_port_cit);
 	config_group_init_type_name(&lun->port_stat_grps.stat_group,
-			"statistics", &TF_CIT_TMPL(tf)->tfc_tpg_port_stat_cit);
+			"statistics", &tf->tf_cit_tmpl.tfc_tpg_port_stat_cit);
 	lun_cg->default_groups[0] = &lun->port_stat_grps.stat_group;
 	lun_cg->default_groups[1] = NULL;
 
 	port_stat_grp = &lun->port_stat_grps.stat_group;
-	port_stat_grp->default_groups =  kzalloc(sizeof(struct config_group) * 3,
+	port_stat_grp->default_groups =  kzalloc(sizeof(struct config_group *) * 4,
 				GFP_KERNEL);
 	if (!port_stat_grp->default_groups) {
 		pr_err("Unable to allocate port_stat_grp->default_groups\n");
@@ -965,6 +973,19 @@
 
 /* End of tfc_tpg_attrib_cit */
 
+/* Start of tfc_tpg_auth_cit */
+
+CONFIGFS_EATTR_OPS(target_fabric_tpg_auth, se_portal_group, tpg_auth_group);
+
+static struct configfs_item_operations target_fabric_tpg_auth_item_ops = {
+	.show_attribute		= target_fabric_tpg_auth_attr_show,
+	.store_attribute	= target_fabric_tpg_auth_attr_store,
+};
+
+TF_CIT_SETUP(tpg_auth, &target_fabric_tpg_auth_item_ops, NULL, NULL);
+
+/* End of tfc_tpg_attrib_cit */
+
 /* Start of tfc_tpg_param_cit */
 
 CONFIGFS_EATTR_OPS(target_fabric_tpg_param, se_portal_group, tpg_param_group);
@@ -1030,21 +1051,24 @@
 	se_tpg->tpg_group.default_groups[1] = &se_tpg->tpg_np_group;
 	se_tpg->tpg_group.default_groups[2] = &se_tpg->tpg_acl_group;
 	se_tpg->tpg_group.default_groups[3] = &se_tpg->tpg_attrib_group;
-	se_tpg->tpg_group.default_groups[4] = &se_tpg->tpg_param_group;
-	se_tpg->tpg_group.default_groups[5] = NULL;
+	se_tpg->tpg_group.default_groups[4] = &se_tpg->tpg_auth_group;
+	se_tpg->tpg_group.default_groups[5] = &se_tpg->tpg_param_group;
+	se_tpg->tpg_group.default_groups[6] = NULL;
 
 	config_group_init_type_name(&se_tpg->tpg_group, name,
-			&TF_CIT_TMPL(tf)->tfc_tpg_base_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_base_cit);
 	config_group_init_type_name(&se_tpg->tpg_lun_group, "lun",
-			&TF_CIT_TMPL(tf)->tfc_tpg_lun_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_lun_cit);
 	config_group_init_type_name(&se_tpg->tpg_np_group, "np",
-			&TF_CIT_TMPL(tf)->tfc_tpg_np_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_np_cit);
 	config_group_init_type_name(&se_tpg->tpg_acl_group, "acls",
-			&TF_CIT_TMPL(tf)->tfc_tpg_nacl_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_nacl_cit);
 	config_group_init_type_name(&se_tpg->tpg_attrib_group, "attrib",
-			&TF_CIT_TMPL(tf)->tfc_tpg_attrib_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_attrib_cit);
+	config_group_init_type_name(&se_tpg->tpg_auth_group, "auth",
+			&tf->tf_cit_tmpl.tfc_tpg_auth_cit);
 	config_group_init_type_name(&se_tpg->tpg_param_group, "param",
-			&TF_CIT_TMPL(tf)->tfc_tpg_param_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_param_cit);
 
 	return &se_tpg->tpg_group;
 }
@@ -1131,9 +1155,9 @@
 	wwn->wwn_group.default_groups[1] = NULL;
 
 	config_group_init_type_name(&wwn->wwn_group, name,
-			&TF_CIT_TMPL(tf)->tfc_tpg_cit);
+			&tf->tf_cit_tmpl.tfc_tpg_cit);
 	config_group_init_type_name(&wwn->fabric_stat_group, "fabric_statistics",
-			&TF_CIT_TMPL(tf)->tfc_wwn_fabric_stats_cit);
+			&tf->tf_cit_tmpl.tfc_wwn_fabric_stats_cit);
 
 	return &wwn->wwn_group;
 }
@@ -1202,6 +1226,7 @@
 	target_fabric_setup_tpg_np_cit(tf);
 	target_fabric_setup_tpg_np_base_cit(tf);
 	target_fabric_setup_tpg_attrib_cit(tf);
+	target_fabric_setup_tpg_auth_cit(tf);
 	target_fabric_setup_tpg_param_cit(tf);
 	target_fabric_setup_tpg_nacl_cit(tf);
 	target_fabric_setup_tpg_nacl_base_cit(tf);
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_fabric_lib.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_fabric_lib.c
--- linux-3.10.69/drivers/target/target_core_fabric_lib.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_fabric_lib.c	2017-05-02 03:31:56.000000000 +0200
@@ -4,7 +4,7 @@
  * This file contains generic high level protocol identifier and PR
  * handlers for TCM fabric modules
  *
- * (c) Copyright 2010-2012 RisingTide Systems LLC.
+ * (c) Copyright 2010-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_file.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_file.c
--- linux-3.10.69/drivers/target/target_core_file.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_file.c	2017-05-02 03:31:56.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * This file contains the Storage Engine <-> FILEIO transport specific functions
  *
- * (c) Copyright 2005-2012 RisingTide Systems LLC.
+ * (c) Copyright 2005-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -257,6 +257,64 @@
 	kfree(fd_dev);
 }
 
+static int fd_do_prot_rw(struct se_cmd *cmd, struct fd_prot *fd_prot,
+			 int is_write)
+{
+	struct se_device *se_dev = cmd->se_dev;
+	struct fd_dev *dev = FD_DEV(se_dev);
+	struct file *prot_fd = dev->fd_prot_file;
+	loff_t pos = (cmd->t_task_lba * se_dev->prot_length);
+	unsigned char *buf;
+	u32 prot_size;
+	int rc, ret = 1;
+
+	prot_size = (cmd->data_length / se_dev->dev_attrib.block_size) *
+		     se_dev->prot_length;
+
+	if (!is_write) {
+		fd_prot->prot_buf = kzalloc(prot_size, GFP_KERNEL);
+		if (!fd_prot->prot_buf) {
+			pr_err("Unable to allocate fd_prot->prot_buf\n");
+			return -ENOMEM;
+		}
+		buf = fd_prot->prot_buf;
+
+		fd_prot->prot_sg_nents = 1;
+		fd_prot->prot_sg = kzalloc(sizeof(struct scatterlist),
+					   GFP_KERNEL);
+		if (!fd_prot->prot_sg) {
+			pr_err("Unable to allocate fd_prot->prot_sg\n");
+			kfree(fd_prot->prot_buf);
+			return -ENOMEM;
+		}
+		sg_init_table(fd_prot->prot_sg, fd_prot->prot_sg_nents);
+		sg_set_buf(fd_prot->prot_sg, buf, prot_size);
+	}
+
+	if (is_write) {
+		rc = kernel_write(prot_fd, fd_prot->prot_buf, prot_size, pos);
+		if (rc < 0 || prot_size != rc) {
+			pr_err("kernel_write() for fd_do_prot_rw failed:"
+			       " %d\n", rc);
+			ret = -EINVAL;
+		}
+	} else {
+		rc = kernel_read(prot_fd, pos, fd_prot->prot_buf, prot_size);
+		if (rc < 0) {
+			pr_err("kernel_read() for fd_do_prot_rw failed:"
+			       " %d\n", rc);
+			ret = -EINVAL;
+		}
+	}
+
+	if (is_write || ret < 0) {
+		kfree(fd_prot->prot_sg);
+		kfree(fd_prot->prot_buf);
+	}
+
+	return ret;
+}
+
 static int fd_do_rw(struct se_cmd *cmd, struct scatterlist *sgl,
 		u32 sgl_nents, int is_write)
 {
@@ -547,12 +605,12 @@
 }
 
 static sense_reason_t
-fd_execute_rw(struct se_cmd *cmd)
+fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,
+	      enum dma_data_direction data_direction)
 {
-	struct scatterlist *sgl = cmd->t_data_sg;
-	u32 sgl_nents = cmd->t_data_nents;
-	enum dma_data_direction data_direction = cmd->data_direction;
 	struct se_device *dev = cmd->se_dev;
+	struct fd_prot fd_prot;
+	sense_reason_t rc;
 	int ret = 0;
 	/*
 	 * We are currently limited by the number of iovecs (2048) per
@@ -569,11 +627,51 @@
 	 * physical memory addresses to struct iovec virtual memory.
 	 */
 	if (data_direction == DMA_FROM_DEVICE) {
+		memset(&fd_prot, 0, sizeof(struct fd_prot));
+
+		if (cmd->prot_type) {
+			ret = fd_do_prot_rw(cmd, &fd_prot, false);
+			if (ret < 0)
+				return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+		}
+
 		ret = fd_do_rw(cmd, sgl, sgl_nents, 0);
+
+		if (ret > 0 && cmd->prot_type) {
+			u32 sectors = cmd->data_length / dev->dev_attrib.block_size;
+
+			rc = sbc_dif_verify_read(cmd, cmd->t_task_lba, sectors,
+						 0, fd_prot.prot_sg, 0);
+			if (rc) {
+				kfree(fd_prot.prot_sg);
+				kfree(fd_prot.prot_buf);
+				return rc;
+			}
+			kfree(fd_prot.prot_sg);
+			kfree(fd_prot.prot_buf);
+		}
 	} else {
+		memset(&fd_prot, 0, sizeof(struct fd_prot));
+
+		if (cmd->prot_type) {
+			u32 sectors = cmd->data_length / dev->dev_attrib.block_size;
+
+			ret = fd_do_prot_rw(cmd, &fd_prot, false);
+			if (ret < 0)
+				return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+
+			rc = sbc_dif_verify_write(cmd, cmd->t_task_lba, sectors,
+						  0, fd_prot.prot_sg, 0);
+			if (rc) {
+				kfree(fd_prot.prot_sg);
+				kfree(fd_prot.prot_buf);
+				return rc;
+			}
+		}
+
 		ret = fd_do_rw(cmd, sgl, sgl_nents, 1);
 		/*
-		 * Perform implict vfs_fsync_range() for fd_do_writev() ops
+		 * Perform implicit vfs_fsync_range() for fd_do_writev() ops
 		 * for SCSI WRITEs with Forced Unit Access (FUA) set.
 		 * Allow this to happen independent of WCE=0 setting.
 		 */
@@ -587,10 +685,19 @@
 
 			vfs_fsync_range(fd_dev->fd_file, start, end, 1);
 		}
-	}
 
+		if (ret > 0 && cmd->prot_type) {
+			ret = fd_do_prot_rw(cmd, &fd_prot, true);
 	if (ret < 0)
 		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+		}
+	}
+
+	if (ret < 0) {
+		kfree(fd_prot.prot_sg);
+		kfree(fd_prot.prot_buf);
+		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+	}
 
 	if (ret)
 		target_complete_cmd(cmd, SAM_STAT_GOOD);
@@ -644,10 +751,10 @@
 				ret = -ENOMEM;
 				break;
 			}
-			ret = strict_strtoull(arg_p, 0, &fd_dev->fd_dev_size);
+			ret = kstrtoull(arg_p, 0, &fd_dev->fd_dev_size);
 			kfree(arg_p);
 			if (ret < 0) {
-				pr_err("strict_strtoull() failed for"
+				pr_err("kstrtoull() failed for"
 						" fd_dev_size=\n");
 				goto out;
 			}
@@ -711,6 +818,140 @@
 		       dev->dev_attrib.block_size);
 }
 
+static int fd_init_prot(struct se_device *dev)
+{
+	struct fd_dev *fd_dev = FD_DEV(dev);
+	struct file *prot_file, *file = fd_dev->fd_file;
+	struct inode *inode;
+	int ret, flags = O_RDWR | O_CREAT | O_LARGEFILE | O_DSYNC;
+	char buf[FD_MAX_DEV_PROT_NAME];
+
+	if (!file) {
+		pr_err("Unable to locate fd_dev->fd_file\n");
+		return -ENODEV;
+	}
+
+	inode = file->f_mapping->host;
+	if (S_ISBLK(inode->i_mode)) {
+		pr_err("FILEIO Protection emulation only supported on"
+		       " !S_ISBLK\n");
+		return -ENOSYS;
+	}
+
+	if (fd_dev->fbd_flags & FDBD_HAS_BUFFERED_IO_WCE)
+		flags &= ~O_DSYNC;
+
+	snprintf(buf, FD_MAX_DEV_PROT_NAME, "%s.protection",
+		 fd_dev->fd_dev_name);
+
+	prot_file = filp_open(buf, flags, 0600);
+	if (IS_ERR(prot_file)) {
+		pr_err("filp_open(%s) failed\n", buf);
+		ret = PTR_ERR(prot_file);
+		return ret;
+	}
+	fd_dev->fd_prot_file = prot_file;
+
+	return 0;
+}
+
+static void fd_init_format_buf(struct se_device *dev, unsigned char *buf,
+			       u32 unit_size, u32 *ref_tag, u16 app_tag,
+			       bool inc_reftag)
+{
+	unsigned char *p = buf;
+	int i;
+
+	for (i = 0; i < unit_size; i += dev->prot_length) {
+		*((u16 *)&p[0]) = 0xffff;
+		*((__be16 *)&p[2]) = cpu_to_be16(app_tag);
+		*((__be32 *)&p[4]) = cpu_to_be32(*ref_tag);
+
+		if (inc_reftag)
+			(*ref_tag)++;
+
+		p += dev->prot_length;
+	}
+}
+
+static int fd_format_prot(struct se_device *dev)
+{
+	struct fd_dev *fd_dev = FD_DEV(dev);
+	struct file *prot_fd = fd_dev->fd_prot_file;
+	sector_t prot_length, prot;
+	unsigned char *buf;
+	loff_t pos = 0;
+	u32 ref_tag = 0;
+	int unit_size = FDBD_FORMAT_UNIT_SIZE * dev->dev_attrib.block_size;
+	int rc, ret = 0, size, len;
+	bool inc_reftag = false;
+
+	if (!dev->dev_attrib.pi_prot_type) {
+		pr_err("Unable to format_prot while pi_prot_type == 0\n");
+		return -ENODEV;
+	}
+	if (!prot_fd) {
+		pr_err("Unable to locate fd_dev->fd_prot_file\n");
+		return -ENODEV;
+	}
+
+	switch (dev->dev_attrib.pi_prot_type) {
+	case TARGET_DIF_TYPE3_PROT:
+		ref_tag = 0xffffffff;
+		break;
+	case TARGET_DIF_TYPE2_PROT:
+	case TARGET_DIF_TYPE1_PROT:
+		inc_reftag = true;
+		break;
+	default:
+		break;
+	}
+
+	buf = vzalloc(unit_size);
+	if (!buf) {
+		pr_err("Unable to allocate FILEIO prot buf\n");
+		return -ENOMEM;
+	}
+
+	prot_length = (dev->transport->get_blocks(dev) + 1) * dev->prot_length;
+	size = prot_length;
+
+	pr_debug("Using FILEIO prot_length: %llu\n",
+		 (unsigned long long)prot_length);
+
+	for (prot = 0; prot < prot_length; prot += unit_size) {
+
+		fd_init_format_buf(dev, buf, unit_size, &ref_tag, 0xffff,
+				   inc_reftag);
+
+		len = min(unit_size, size);
+
+		rc = kernel_write(prot_fd, buf, len, pos);
+		if (rc != len) {
+			pr_err("vfs_write to prot file failed: %d\n", rc);
+			ret = -ENODEV;
+			goto out;
+		}
+		pos += len;
+		size -= len;
+	}
+
+out:
+	vfree(buf);
+	return ret;
+}
+
+static void fd_free_prot(struct se_device *dev)
+{
+	struct fd_dev *fd_dev = FD_DEV(dev);
+
+	if (!fd_dev->fd_prot_file)
+		return;
+
+	filp_close(fd_dev->fd_prot_file, NULL);
+	fd_dev->fd_prot_file = NULL;
+}
+
 static struct sbc_ops fd_sbc_ops = {
 	.execute_rw		= fd_execute_rw,
 	.execute_sync_cache	= fd_execute_sync_cache,
@@ -741,6 +982,9 @@
 	.show_configfs_dev_params = fd_show_configfs_dev_params,
 	.get_device_type	= sbc_get_device_type,
 	.get_blocks		= fd_get_blocks,
+	.init_prot		= fd_init_prot,
+	.format_prot		= fd_format_prot,
+	.free_prot		= fd_free_prot,
 };
 
 static int __init fileio_module_init(void)
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_file.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_file.h
--- linux-3.10.69/drivers/target/target_core_file.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_file.h	2017-05-02 03:31:56.000000000 +0200
@@ -4,6 +4,7 @@
 #define FD_VERSION		"4.0"
 
 #define FD_MAX_DEV_NAME		256
+#define FD_MAX_DEV_PROT_NAME	FD_MAX_DEV_NAME + 16
 #define FD_DEVICE_QUEUE_DEPTH	32
 #define FD_MAX_DEVICE_QUEUE_DEPTH 128
 #define FD_BLOCKSIZE		512
@@ -18,6 +19,13 @@
 #define FBDF_HAS_PATH		0x01
 #define FBDF_HAS_SIZE		0x02
 #define FDBD_HAS_BUFFERED_IO_WCE 0x04
+#define FDBD_FORMAT_UNIT_SIZE	2048
+
+struct fd_prot {
+	unsigned char	*prot_buf;
+	struct scatterlist *prot_sg;
+	u32 prot_sg_nents;
+};
 
 struct fd_dev {
 	struct se_device dev;
@@ -32,6 +40,7 @@
 	u32		fd_block_size;
 	unsigned long long fd_dev_size;
 	struct file	*fd_file;
+	struct file	*fd_prot_file;
 	/* FILEIO HBA device is connected to */
 	struct fd_host *fd_host;
 } ____cacheline_aligned;
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_hba.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_hba.c
--- linux-3.10.69/drivers/target/target_core_hba.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_hba.c	2017-05-02 03:31:56.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * This file contains the TCM HBA Transport related functions.
  *
- * (c) Copyright 2003-2012 RisingTide Systems LLC.
+ * (c) Copyright 2003-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_iblock.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_iblock.c
--- linux-3.10.69/drivers/target/target_core_iblock.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_iblock.c	2017-05-02 03:31:56.000000000 +0200
@@ -4,7 +4,7 @@
  * This file contains the Storage Engine  <-> Linux BlockIO transport
  * specific functions.
  *
- * (c) Copyright 2003-2012 RisingTide Systems LLC.
+ * (c) Copyright 2003-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -91,6 +91,7 @@
 	struct iblock_dev *ib_dev = IBLOCK_DEV(dev);
 	struct request_queue *q;
 	struct block_device *bd = NULL;
+	struct blk_integrity *bi;
 	fmode_t mode;
 	int ret = -ENOMEM;
 
@@ -155,8 +156,40 @@
 	if (blk_queue_nonrot(q))
 		dev->dev_attrib.is_nonrot = 1;
 
+	bi = bdev_get_integrity(bd);
+	if (bi) {
+		struct bio_set *bs = ib_dev->ibd_bio_set;
+
+		if (!strcmp(bi->name, "T10-DIF-TYPE3-IP") ||
+		    !strcmp(bi->name, "T10-DIF-TYPE1-IP")) {
+			pr_err("IBLOCK export of blk_integrity: %s not"
+			       " supported\n", bi->name);
+			ret = -ENOSYS;
+			goto out_blkdev_put;
+		}
+
+		if (!strcmp(bi->name, "T10-DIF-TYPE3-CRC")) {
+			dev->dev_attrib.pi_prot_type = TARGET_DIF_TYPE3_PROT;
+		} else if (!strcmp(bi->name, "T10-DIF-TYPE1-CRC")) {
+			dev->dev_attrib.pi_prot_type = TARGET_DIF_TYPE1_PROT;
+		}
+
+		if (dev->dev_attrib.pi_prot_type) {
+			if (bioset_integrity_create(bs, IBLOCK_BIO_POOL_SIZE) < 0) {
+				pr_err("Unable to allocate bioset for PI\n");
+				ret = -ENOMEM;
+				goto out_blkdev_put;
+			}
+			pr_debug("IBLOCK setup BIP bs->bio_integrity_pool: %p\n",
+				 bs->bio_integrity_pool);
+		}
+		dev->dev_attrib.hw_pi_prot_type = dev->dev_attrib.pi_prot_type;
+	}
+
 	return 0;
 
+out_blkdev_put:
+	blkdev_put(ib_dev->ibd_bd, FMODE_WRITE|FMODE_READ|FMODE_EXCL);
 out_free_bioset:
 	bioset_free(ib_dev->ibd_bio_set);
 	ib_dev->ibd_bio_set = NULL;
@@ -536,10 +570,10 @@
 				ret = -ENOMEM;
 				break;
 			}
-			ret = strict_strtoul(arg_p, 0, &tmp_readonly);
+			ret = kstrtoul(arg_p, 0, &tmp_readonly);
 			kfree(arg_p);
 			if (ret < 0) {
-				pr_err("strict_strtoul() failed for"
+				pr_err("kstrtoul() failed for"
 						" readonly=\n");
 				goto out;
 			}
@@ -586,15 +620,58 @@
 	return bl;
 }
 
+static int
+iblock_alloc_bip(struct se_cmd *cmd, struct bio *bio)
+{
+	struct se_device *dev = cmd->se_dev;
+	struct blk_integrity *bi;
+	struct bio_integrity_payload *bip;
+	struct iblock_dev *ib_dev = IBLOCK_DEV(dev);
+	struct scatterlist *sg;
+	int i, rc;
+
+	bi = bdev_get_integrity(ib_dev->ibd_bd);
+	if (!bi) {
+		pr_err("Unable to locate bio_integrity\n");
+		return -ENODEV;
+	}
+
+	bip = bio_integrity_alloc(bio, GFP_NOIO, cmd->t_prot_nents);
+	if (!bip) {
+		pr_err("Unable to allocate bio_integrity_payload\n");
+		return -ENOMEM;
+	}
+
+	bip->bip_size = (cmd->data_length / dev->dev_attrib.block_size) *
+			 dev->prot_length;
+	bip->bip_sector = bio->bi_sector;
+
+	pr_debug("IBLOCK BIP Size: %u Sector: %llu\n", bip->bip_size,
+		 (unsigned long long)bip->bip_sector);
+
+	for_each_sg(cmd->t_prot_sg, sg, cmd->t_prot_nents, i) {
+
+		rc = bio_integrity_add_page(bio, sg_page(sg), sg->length,
+					    sg->offset);
+		if (rc != sg->length) {
+			pr_err("bio_integrity_add_page() failed; %d\n", rc);
+			return -ENOMEM;
+		}
+
+		pr_debug("Added bio integrity page: %p length: %d offset; %d\n",
+			 sg_page(sg), sg->length, sg->offset);
+	}
+
+	return 0;
+}
+
 static sense_reason_t
-iblock_execute_rw(struct se_cmd *cmd)
+iblock_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,
+		  enum dma_data_direction data_direction)
 {
-	struct scatterlist *sgl = cmd->t_data_sg;
-	u32 sgl_nents = cmd->t_data_nents;
-	enum dma_data_direction data_direction = cmd->data_direction;
 	struct se_device *dev = cmd->se_dev;
 	struct iblock_req *ibr;
-	struct bio *bio;
+	struct bio *bio, *bio_start;
 	struct bio_list list;
 	struct scatterlist *sg;
 	u32 sg_num = sgl_nents;
@@ -657,6 +734,7 @@
 	if (!bio)
 		goto fail_free_ibr;
 
+	bio_start = bio;
 	bio_list_init(&list);
 	bio_list_add(&list, bio);
 
@@ -690,6 +768,12 @@
 		sg_num--;
 	}
 
+	if (cmd->prot_type) {
+		int rc = iblock_alloc_bip(cmd, bio_start);
+		if (rc)
+			goto fail_put_bios;
+	}
+
 	iblock_submit_bios(&list, rw);
 	iblock_complete_cmd(cmd);
 	return 0;
@@ -712,6 +796,45 @@
 	return iblock_emulate_read_cap_with_block_size(dev, bd, q);
 }
 
+static sector_t iblock_get_alignment_offset_lbas(struct se_device *dev)
+{
+	struct iblock_dev *ib_dev = IBLOCK_DEV(dev);
+	struct block_device *bd = ib_dev->ibd_bd;
+	int ret;
+
+	ret = bdev_alignment_offset(bd);
+	if (ret == -1)
+		return 0;
+
+	/* convert offset-bytes to offset-lbas */
+	return ret / bdev_logical_block_size(bd);
+}
+
+static unsigned int iblock_get_lbppbe(struct se_device *dev)
+{
+	struct iblock_dev *ib_dev = IBLOCK_DEV(dev);
+	struct block_device *bd = ib_dev->ibd_bd;
+	int logs_per_phys = bdev_physical_block_size(bd) / bdev_logical_block_size(bd);
+
+	return ilog2(logs_per_phys);
+}
+
+static unsigned int iblock_get_io_min(struct se_device *dev)
+{
+	struct iblock_dev *ib_dev = IBLOCK_DEV(dev);
+	struct block_device *bd = ib_dev->ibd_bd;
+
+	return bdev_io_min(bd);
+}
+
+static unsigned int iblock_get_io_opt(struct se_device *dev)
+{
+	struct iblock_dev *ib_dev = IBLOCK_DEV(dev);
+	struct block_device *bd = ib_dev->ibd_bd;
+
+	return bdev_io_opt(bd);
+}
+
 static struct sbc_ops iblock_sbc_ops = {
 	.execute_rw		= iblock_execute_rw,
 	.execute_sync_cache	= iblock_execute_sync_cache,
@@ -726,7 +849,7 @@
 	return sbc_parse_cdb(cmd, &iblock_sbc_ops);
 }
 
-bool iblock_get_write_cache(struct se_device *dev)
+static bool iblock_get_write_cache(struct se_device *dev)
 {
 	struct iblock_dev *ib_dev = IBLOCK_DEV(dev);
 	struct block_device *bd = ib_dev->ibd_bd;
@@ -751,6 +874,10 @@
 	.show_configfs_dev_params = iblock_show_configfs_dev_params,
 	.get_device_type	= sbc_get_device_type,
 	.get_blocks		= iblock_get_blocks,
+	.get_alignment_offset_lbas = iblock_get_alignment_offset_lbas,
+	.get_lbppbe		= iblock_get_lbppbe,
+	.get_io_min		= iblock_get_io_min,
+	.get_io_opt		= iblock_get_io_opt,
 	.get_write_cache	= iblock_get_write_cache,
 };
 
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_internal.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_internal.h
--- linux-3.10.69/drivers/target/target_core_internal.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_internal.h	2017-05-02 03:31:56.000000000 +0200
@@ -33,6 +33,10 @@
 int	se_dev_set_emulate_tas(struct se_device *, int);
 int	se_dev_set_emulate_tpu(struct se_device *, int);
 int	se_dev_set_emulate_tpws(struct se_device *, int);
+int	se_dev_set_emulate_caw(struct se_device *, int);
+int	se_dev_set_emulate_3pc(struct se_device *, int);
+int	se_dev_set_pi_prot_type(struct se_device *, int);
+int	se_dev_set_pi_prot_format(struct se_device *, int);
 int	se_dev_set_enforce_pr_isids(struct se_device *, int);
 int	se_dev_set_is_nonrot(struct se_device *, int);
 int	se_dev_set_emulate_rest_reord(struct se_device *dev, int);
@@ -73,13 +77,11 @@
 
 struct se_node_acl *__core_tpg_get_initiator_node_acl(struct se_portal_group *tpg,
 		const char *);
-struct se_node_acl *core_tpg_get_initiator_node_acl(struct se_portal_group *tpg,
-		unsigned char *);
 void	core_tpg_add_node_to_devs(struct se_node_acl *, struct se_portal_group *);
 void	core_tpg_wait_for_nacl_pr_ref(struct se_node_acl *);
-struct se_lun *core_tpg_pre_addlun(struct se_portal_group *, u32);
-int	core_tpg_post_addlun(struct se_portal_group *, struct se_lun *,
-		u32, void *);
+struct se_lun *core_tpg_alloc_lun(struct se_portal_group *, u32);
+int	core_tpg_add_lun(struct se_portal_group *, struct se_lun *,
+		u32, struct se_device *);
 struct se_lun *core_tpg_pre_dellun(struct se_portal_group *, u32 unpacked_lun);
 int	core_tpg_post_dellun(struct se_portal_group *, struct se_lun *);
 
@@ -100,7 +102,7 @@
 int	transport_dump_vpd_ident_type(struct t10_vpd *, unsigned char *, int);
 int	transport_dump_vpd_ident(struct t10_vpd *, unsigned char *, int);
 bool	target_stop_cmd(struct se_cmd *cmd, unsigned long *flags);
-int	transport_clear_lun_from_sessions(struct se_lun *);
+int	transport_clear_lun_ref(struct se_lun *);
 void	transport_send_task_abort(struct se_cmd *);
 sense_reason_t	target_cmd_size_check(struct se_cmd *cmd, unsigned int size);
 void	target_qf_do_work(struct work_struct *work);
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_pr.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_pr.c
--- linux-3.10.69/drivers/target/target_core_pr.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_pr.c	2017-05-02 03:31:56.000000000 +0200
@@ -4,7 +4,7 @@
  * This file contains SPC-3 compliant persistent reservations and
  * legacy SPC-2 reservations with compatible reservation handling (CRH=1)
  *
- * (c) Copyright 2009-2012 RisingTide Systems LLC.
+ * (c) Copyright 2009-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -53,20 +53,30 @@
 	struct list_head dest_list;
 };
 
-int core_pr_dump_initiator_port(
+void core_pr_dump_initiator_port(
 	struct t10_pr_registration *pr_reg,
 	char *buf,
 	u32 size)
 {
 	if (!pr_reg->isid_present_at_reg)
-		return 0;
+		buf[0] = '\0';
 
-	snprintf(buf, size, ",i,0x%s", &pr_reg->pr_reg_isid[0]);
-	return 1;
+	snprintf(buf, size, ",i,0x%s", pr_reg->pr_reg_isid);
 }
 
+enum register_type {
+	REGISTER,
+	REGISTER_AND_IGNORE_EXISTING_KEY,
+	REGISTER_AND_MOVE,
+};
+
+enum preempt_type {
+	PREEMPT,
+	PREEMPT_AND_ABORT,
+};
+
 static void __core_scsi3_complete_pro_release(struct se_device *, struct se_node_acl *,
-			struct t10_pr_registration *, int);
+					      struct t10_pr_registration *, int, int);
 
 static sense_reason_t
 target_scsi2_reservation_check(struct se_cmd *cmd)
@@ -464,7 +474,7 @@
 	 * statement.
 	 */
 	if (!ret && !other_cdb) {
-		pr_debug("Allowing explict CDB: 0x%02x for %s"
+		pr_debug("Allowing explicit CDB: 0x%02x for %s"
 			" reservation holder\n", cdb[0],
 			core_scsi3_pr_dump_type(pr_reg_type));
 
@@ -497,7 +507,7 @@
 			 */
 
 			if (!registered_nexus) {
-				pr_debug("Allowing implict CDB: 0x%02x"
+				pr_debug("Allowing implicit CDB: 0x%02x"
 					" for %s reservation on unregistered"
 					" nexus\n", cdb[0],
 					core_scsi3_pr_dump_type(pr_reg_type));
@@ -512,7 +522,19 @@
 			 * allow commands from registered nexuses.
 			 */
 
-			pr_debug("Allowing implict CDB: 0x%02x for %s"
+			pr_debug("Allowing implicit CDB: 0x%02x for %s"
+				" reservation\n", cdb[0],
+				core_scsi3_pr_dump_type(pr_reg_type));
+
+			return 0;
+		}
+       } else if (we && registered_nexus) {
+               /*
+                * Reads are allowed for Write Exclusive locks
+                * from all registrants.
+                */
+               if (cmd->data_direction == DMA_FROM_DEVICE) {
+                       pr_debug("Allowing READ CDB: 0x%02x for %s"
 				" reservation\n", cdb[0],
 				core_scsi3_pr_dump_type(pr_reg_type));
 
@@ -596,14 +618,6 @@
 		return NULL;
 	}
 
-	pr_reg->pr_aptpl_buf = kzalloc(dev->t10_pr.pr_aptpl_buf_len,
-					GFP_ATOMIC);
-	if (!pr_reg->pr_aptpl_buf) {
-		pr_err("Unable to allocate pr_reg->pr_aptpl_buf\n");
-		kmem_cache_free(t10_pr_reg_cache, pr_reg);
-		return NULL;
-	}
-
 	INIT_LIST_HEAD(&pr_reg->pr_reg_list);
 	INIT_LIST_HEAD(&pr_reg->pr_reg_abort_list);
 	INIT_LIST_HEAD(&pr_reg->pr_reg_aptpl_list);
@@ -681,7 +695,7 @@
 					alua_port_list) {
 			/*
 			 * This pointer will be NULL for demo mode MappedLUNs
-			 * that have not been make explict via a ConfigFS
+			 * that have not been make explicit via a ConfigFS
 			 * MappedLUN group for the SCSI Initiator Node ACL.
 			 */
 			if (!deve_tmp->se_lun_acl)
@@ -794,7 +808,6 @@
 		pr_err("Unable to allocate struct t10_pr_registration\n");
 		return -ENOMEM;
 	}
-	pr_reg->pr_aptpl_buf = kzalloc(pr_tmpl->pr_aptpl_buf_len, GFP_KERNEL);
 
 	INIT_LIST_HEAD(&pr_reg->pr_reg_list);
 	INIT_LIST_HEAD(&pr_reg->pr_reg_abort_list);
@@ -848,11 +861,9 @@
 	struct t10_pr_registration *pr_reg)
 {
 	char i_buf[PR_REG_ISID_ID_LEN];
-	int prf_isid;
 
 	memset(i_buf, 0, PR_REG_ISID_ID_LEN);
-	prf_isid = core_pr_dump_initiator_port(pr_reg, &i_buf[0],
-				PR_REG_ISID_ID_LEN);
+	core_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);
 
 	spin_lock(&dev->dev_reservation_lock);
 	dev->dev_pr_res_holder = pr_reg;
@@ -865,11 +876,11 @@
 		(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);
 	pr_debug("SPC-3 PR [%s] RESERVE Node: %s%s\n",
 		tpg->se_tpg_tfo->get_fabric_name(), node_acl->initiatorname,
-		(prf_isid) ? &i_buf[0] : "");
+		i_buf);
 }
 
 static void __core_scsi3_add_registration(struct se_device *, struct se_node_acl *,
-				struct t10_pr_registration *, int, int);
+				struct t10_pr_registration *, enum register_type, int);
 
 static int __core_scsi3_check_aptpl_registration(
 	struct se_device *dev,
@@ -962,21 +973,19 @@
 	struct se_device *dev,
 	struct se_node_acl *nacl,
 	struct t10_pr_registration *pr_reg,
-	int register_type)
+	enum register_type register_type)
 {
 	struct se_portal_group *se_tpg = nacl->se_tpg;
 	char i_buf[PR_REG_ISID_ID_LEN];
-	int prf_isid;
 
 	memset(&i_buf[0], 0, PR_REG_ISID_ID_LEN);
-	prf_isid = core_pr_dump_initiator_port(pr_reg, &i_buf[0],
-				PR_REG_ISID_ID_LEN);
+	core_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);
 
 	pr_debug("SPC-3 PR [%s] Service Action: REGISTER%s Initiator"
-		" Node: %s%s\n", tfo->get_fabric_name(), (register_type == 2) ?
-		"_AND_MOVE" : (register_type == 1) ?
+		" Node: %s%s\n", tfo->get_fabric_name(), (register_type == REGISTER_AND_MOVE) ?
+		"_AND_MOVE" : (register_type == REGISTER_AND_IGNORE_EXISTING_KEY) ?
 		"_AND_IGNORE_EXISTING_KEY" : "", nacl->initiatorname,
-		(prf_isid) ? i_buf : "");
+		i_buf);
 	pr_debug("SPC-3 PR [%s] registration on Target Port: %s,0x%04x\n",
 		 tfo->get_fabric_name(), tfo->tpg_get_wwn(se_tpg),
 		tfo->tpg_get_tag(se_tpg));
@@ -998,7 +1007,7 @@
 	struct se_device *dev,
 	struct se_node_acl *nacl,
 	struct t10_pr_registration *pr_reg,
-	int register_type,
+	enum register_type register_type,
 	int register_move)
 {
 	struct target_core_fabric_ops *tfo = nacl->se_tpg->se_tpg_tfo;
@@ -1064,7 +1073,7 @@
 	u64 sa_res_key,
 	int all_tg_pt,
 	int aptpl,
-	int register_type,
+	enum register_type register_type,
 	int register_move)
 {
 	struct t10_pr_registration *pr_reg;
@@ -1161,7 +1170,7 @@
 	smp_mb__after_atomic_dec();
 }
 
-static int core_scsi3_check_implict_release(
+static int core_scsi3_check_implicit_release(
 	struct se_device *dev,
 	struct t10_pr_registration *pr_reg)
 {
@@ -1177,7 +1186,7 @@
 	}
 	if (pr_res_holder == pr_reg) {
 		/*
-		 * Perform an implict RELEASE if the registration that
+		 * Perform an implicit RELEASE if the registration that
 		 * is being released is holding the reservation.
 		 *
 		 * From spc4r17, section 5.7.11.1:
@@ -1189,13 +1198,13 @@
 		 *    service action with the SERVICE ACTION RESERVATION KEY
 		 *    field set to zero (see 5.7.11.3).
 		 */
-		__core_scsi3_complete_pro_release(dev, nacl, pr_reg, 0);
+		__core_scsi3_complete_pro_release(dev, nacl, pr_reg, 0, 1);
 		ret = 1;
 		/*
 		 * For 'All Registrants' reservation types, all existing
 		 * registrations are still processed as reservation holders
 		 * in core_scsi3_pr_seq_non_holder() after the initial
-		 * reservation holder is implictly released here.
+		 * reservation holder is implicitly released here.
 		 */
 	} else if (pr_reg->pr_reg_all_tg_pt &&
 		  (!strcmp(pr_res_holder->pr_reg_nacl->initiatorname,
@@ -1225,14 +1234,13 @@
 			pr_reg->pr_reg_nacl->se_tpg->se_tpg_tfo;
 	struct t10_reservation *pr_tmpl = &dev->t10_pr;
 	char i_buf[PR_REG_ISID_ID_LEN];
-	int prf_isid;
 
 	memset(i_buf, 0, PR_REG_ISID_ID_LEN);
-	prf_isid = core_pr_dump_initiator_port(pr_reg, &i_buf[0],
-				PR_REG_ISID_ID_LEN);
+	core_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);
 
 	pr_reg->pr_reg_deve->def_pr_registered = 0;
 	pr_reg->pr_reg_deve->pr_res_key = 0;
+	if (!list_empty(&pr_reg->pr_reg_list))
 	list_del(&pr_reg->pr_reg_list);
 	/*
 	 * Caller accessing *pr_reg using core_scsi3_locate_pr_reg(),
@@ -1257,7 +1265,7 @@
 	pr_debug("SPC-3 PR [%s] Service Action: UNREGISTER Initiator"
 		" Node: %s%s\n", tfo->get_fabric_name(),
 		pr_reg->pr_reg_nacl->initiatorname,
-		(prf_isid) ? &i_buf[0] : "");
+		i_buf);
 	pr_debug("SPC-3 PR [%s] for %s TCM Subsystem %s Object Target"
 		" Port(s)\n", tfo->get_fabric_name(),
 		(pr_reg->pr_reg_all_tg_pt) ? "ALL" : "SINGLE",
@@ -1269,7 +1277,6 @@
 	if (!preempt_and_abort_list) {
 		pr_reg->pr_reg_deve = NULL;
 		pr_reg->pr_reg_nacl = NULL;
-		kfree(pr_reg->pr_aptpl_buf);
 		kmem_cache_free(t10_pr_reg_cache, pr_reg);
 		return;
 	}
@@ -1286,6 +1293,7 @@
 {
 	struct t10_reservation *pr_tmpl = &dev->t10_pr;
 	struct t10_pr_registration *pr_reg, *pr_reg_tmp, *pr_res_holder;
+	bool free_reg = false;
 	/*
 	 * If the passed se_node_acl matches the reservation holder,
 	 * release the reservation.
@@ -1293,13 +1301,18 @@
 	spin_lock(&dev->dev_reservation_lock);
 	pr_res_holder = dev->dev_pr_res_holder;
 	if ((pr_res_holder != NULL) &&
-	    (pr_res_holder->pr_reg_nacl == nacl))
-		__core_scsi3_complete_pro_release(dev, nacl, pr_res_holder, 0);
+	    (pr_res_holder->pr_reg_nacl == nacl)) {
+		__core_scsi3_complete_pro_release(dev, nacl, pr_res_holder, 0, 1);
+		free_reg = true;
+	}
 	spin_unlock(&dev->dev_reservation_lock);
 	/*
 	 * Release any registration associated with the struct se_node_acl.
 	 */
 	spin_lock(&pr_tmpl->registration_lock);
+	if (pr_res_holder && free_reg)
+		__core_scsi3_free_registration(dev, pr_res_holder, NULL, 0);
+
 	list_for_each_entry_safe(pr_reg, pr_reg_tmp,
 			&pr_tmpl->registration_list, pr_reg_list) {
 
@@ -1322,7 +1335,7 @@
 	if (pr_res_holder != NULL) {
 		struct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;
 		__core_scsi3_complete_pro_release(dev, pr_res_nacl,
-				pr_res_holder, 0);
+						  pr_res_holder, 0, 0);
 	}
 	spin_unlock(&dev->dev_reservation_lock);
 
@@ -1338,7 +1351,6 @@
 	list_for_each_entry_safe(pr_reg, pr_reg_tmp, &pr_tmpl->aptpl_reg_list,
 				pr_reg_aptpl_list) {
 		list_del(&pr_reg->pr_reg_aptpl_list);
-		kfree(pr_reg->pr_aptpl_buf);
 		kmem_cache_free(t10_pr_reg_cache, pr_reg);
 	}
 	spin_unlock(&pr_tmpl->aptpl_reg_lock);
@@ -1453,7 +1465,7 @@
 	char *iport_ptr = NULL, dest_iport[64], i_buf[PR_REG_ISID_ID_LEN];
 	sense_reason_t ret;
 	u32 tpdl, tid_len = 0;
-	int dest_local_nexus, prf_isid;
+	int dest_local_nexus;
 	u32 dest_rtpi = 0;
 
 	memset(dest_iport, 0, 64);
@@ -1764,8 +1776,7 @@
 		kfree(tidh);
 
 		memset(i_buf, 0, PR_REG_ISID_ID_LEN);
-		prf_isid = core_pr_dump_initiator_port(dest_pr_reg, &i_buf[0],
-						PR_REG_ISID_ID_LEN);
+		core_pr_dump_initiator_port(dest_pr_reg, i_buf, PR_REG_ISID_ID_LEN);
 
 		__core_scsi3_add_registration(cmd->se_dev, dest_node_acl,
 					dest_pr_reg, 0, 0);
@@ -1773,8 +1784,7 @@
 		pr_debug("SPC-3 PR [%s] SPEC_I_PT: Successfully"
 			" registered Transport ID for Node: %s%s Mapped LUN:"
 			" %u\n", dest_tpg->se_tpg_tfo->get_fabric_name(),
-			dest_node_acl->initiatorname, (prf_isid) ?
-			&i_buf[0] : "", dest_se_deve->mapped_lun);
+			dest_node_acl->initiatorname, i_buf, dest_se_deve->mapped_lun);
 
 		if (dest_local_nexus)
 			continue;
@@ -1813,7 +1823,6 @@
 			kmem_cache_free(t10_pr_reg_cache, pr_reg_tmp);
 		}
 
-		kfree(dest_pr_reg->pr_aptpl_buf);
 		kmem_cache_free(t10_pr_reg_cache, dest_pr_reg);
 
 		if (dest_local_nexus)
@@ -1826,14 +1835,10 @@
 	return ret;
 }
 
-/*
- * Called with struct se_device->dev_reservation_lock held
- */
-static int __core_scsi3_update_aptpl_buf(
+static int core_scsi3_update_aptpl_buf(
 	struct se_device *dev,
 	unsigned char *buf,
-	u32 pr_aptpl_buf_len,
-	int clear_aptpl_metadata)
+	u32 pr_aptpl_buf_len)
 {
 	struct se_lun *lun;
 	struct se_portal_group *tpg;
@@ -1841,20 +1846,13 @@
 	unsigned char tmp[512], isid_buf[32];
 	ssize_t len = 0;
 	int reg_count = 0;
+	int ret = 0;
 
-	memset(buf, 0, pr_aptpl_buf_len);
-	/*
-	 * Called to clear metadata once APTPL has been deactivated.
-	 */
-	if (clear_aptpl_metadata) {
-		snprintf(buf, pr_aptpl_buf_len,
-				"No Registrations or Reservations\n");
-		return 0;
-	}
+	spin_lock(&dev->dev_reservation_lock);
+	spin_lock(&dev->t10_pr.registration_lock);
 	/*
 	 * Walk the registration list..
 	 */
-	spin_lock(&dev->t10_pr.registration_lock);
 	list_for_each_entry(pr_reg, &dev->t10_pr.registration_list,
 			pr_reg_list) {
 
@@ -1898,10 +1896,10 @@
 		}
 
 		if ((len + strlen(tmp) >= pr_aptpl_buf_len)) {
-			pr_err("Unable to update renaming"
-				" APTPL metadata\n");
-			spin_unlock(&dev->t10_pr.registration_lock);
-			return -EMSGSIZE;
+			pr_err("Unable to update renaming APTPL metadata,"
+			       " reallocating larger buffer\n");
+			ret = -EMSGSIZE;
+			goto out;
 		}
 		len += sprintf(buf+len, "%s", tmp);
 
@@ -1916,50 +1914,34 @@
 			lun->lun_sep->sep_rtpi, lun->unpacked_lun, reg_count);
 
 		if ((len + strlen(tmp) >= pr_aptpl_buf_len)) {
-			pr_err("Unable to update renaming"
-				" APTPL metadata\n");
-			spin_unlock(&dev->t10_pr.registration_lock);
-			return -EMSGSIZE;
+			pr_err("Unable to update renaming APTPL metadata,"
+			       " reallocating larger buffer\n");
+			ret = -EMSGSIZE;
+			goto out;
 		}
 		len += sprintf(buf+len, "%s", tmp);
 		reg_count++;
 	}
-	spin_unlock(&dev->t10_pr.registration_lock);
 
 	if (!reg_count)
 		len += sprintf(buf+len, "No Registrations or Reservations");
 
-	return 0;
-}
-
-static int core_scsi3_update_aptpl_buf(
-	struct se_device *dev,
-	unsigned char *buf,
-	u32 pr_aptpl_buf_len,
-	int clear_aptpl_metadata)
-{
-	int ret;
-
-	spin_lock(&dev->dev_reservation_lock);
-	ret = __core_scsi3_update_aptpl_buf(dev, buf, pr_aptpl_buf_len,
-				clear_aptpl_metadata);
+out:
+	spin_unlock(&dev->t10_pr.registration_lock);
 	spin_unlock(&dev->dev_reservation_lock);
 
 	return ret;
 }
 
-/*
- * Called with struct se_device->aptpl_file_mutex held
- */
 static int __core_scsi3_write_aptpl_to_file(
 	struct se_device *dev,
-	unsigned char *buf,
-	u32 pr_aptpl_buf_len)
+	unsigned char *buf)
 {
 	struct t10_wwn *wwn = &dev->t10_wwn;
 	struct file *file;
 	int flags = O_RDWR | O_CREAT | O_TRUNC;
 	char path[512];
+	u32 pr_aptpl_buf_len;
 	int ret;
 
 	memset(path, 0, 512);
@@ -1978,8 +1960,7 @@
 		return PTR_ERR(file);
 	}
 
-	if (!pr_aptpl_buf_len)
-		pr_aptpl_buf_len = (strlen(&buf[0]) + 1); /* Add extra for NULL */
+	pr_aptpl_buf_len = (strlen(buf) + 1); /* Add extra for NULL */
 
 	ret = kernel_write(file, buf, pr_aptpl_buf_len, 0);
 
@@ -1990,57 +1971,62 @@
 	return (ret < 0) ? -EIO : 0;
 }
 
-static int
-core_scsi3_update_and_write_aptpl(struct se_device *dev, unsigned char *in_buf,
-		u32 in_pr_aptpl_buf_len)
+/*
+ * Clear the APTPL metadata if APTPL has been disabled, otherwise
+ * write out the updated metadata to struct file for this SCSI device.
+ */
+static sense_reason_t core_scsi3_update_and_write_aptpl(struct se_device *dev, bool aptpl)
 {
-	unsigned char null_buf[64], *buf;
-	u32 pr_aptpl_buf_len;
-	int clear_aptpl_metadata = 0;
-	int ret;
+	unsigned char *buf;
+	int rc, len = PR_APTPL_BUF_LEN;
 
-	/*
-	 * Can be called with a NULL pointer from PROUT service action CLEAR
-	 */
-	if (!in_buf) {
-		memset(null_buf, 0, 64);
-		buf = &null_buf[0];
-		/*
-		 * This will clear the APTPL metadata to:
-		 * "No Registrations or Reservations" status
-		 */
-		pr_aptpl_buf_len = 64;
-		clear_aptpl_metadata = 1;
-	} else {
-		buf = in_buf;
-		pr_aptpl_buf_len = in_pr_aptpl_buf_len;
+	if (!aptpl) {
+		char *null_buf = "No Registrations or Reservations\n";
+
+		rc = __core_scsi3_write_aptpl_to_file(dev, null_buf);
+		dev->t10_pr.pr_aptpl_active = 0;
+		pr_debug("SPC-3 PR: Set APTPL Bit Deactivated\n");
+
+		if (rc)
+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+
+		return 0;
 	}
+retry:
+	buf = vzalloc(len);
+	if (!buf)
+		return TCM_OUT_OF_RESOURCES;
 
-	ret = core_scsi3_update_aptpl_buf(dev, buf, pr_aptpl_buf_len,
-				clear_aptpl_metadata);
-	if (ret != 0)
-		return ret;
+	rc = core_scsi3_update_aptpl_buf(dev, buf, len);
+	if (rc < 0) {
+		vfree(buf);
+		len *= 2;
+		goto retry;
+	}
 
-	/*
-	 * __core_scsi3_write_aptpl_to_file() will call strlen()
-	 * on the passed buf to determine pr_aptpl_buf_len.
-	 */
-	return __core_scsi3_write_aptpl_to_file(dev, buf, 0);
+	rc = __core_scsi3_write_aptpl_to_file(dev, buf);
+	if (rc != 0) {
+		pr_err("SPC-3 PR: Could not update APTPL\n");
+		vfree(buf);
+		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+	}
+	dev->t10_pr.pr_aptpl_active = 1;
+	vfree(buf);
+	pr_debug("SPC-3 PR: Set APTPL Bit Activated\n");
+	return 0;
 }
 
 static sense_reason_t
 core_scsi3_emulate_pro_register(struct se_cmd *cmd, u64 res_key, u64 sa_res_key,
-		int aptpl, int all_tg_pt, int spec_i_pt, int ignore_key)
+		bool aptpl, bool all_tg_pt, bool spec_i_pt, enum register_type register_type)
 {
 	struct se_session *se_sess = cmd->se_sess;
 	struct se_device *dev = cmd->se_dev;
 	struct se_dev_entry *se_deve;
 	struct se_lun *se_lun = cmd->se_lun;
 	struct se_portal_group *se_tpg;
-	struct t10_pr_registration *pr_reg, *pr_reg_p, *pr_reg_tmp, *pr_reg_e;
+	struct t10_pr_registration *pr_reg, *pr_reg_p, *pr_reg_tmp;
 	struct t10_reservation *pr_tmpl = &dev->t10_pr;
-	/* Used for APTPL metadata w/ UNREGISTER */
-	unsigned char *pr_aptpl_buf = NULL;
 	unsigned char isid_buf[PR_REG_ISID_LEN], *isid_ptr = NULL;
 	sense_reason_t ret = TCM_NO_SENSE;
 	int pr_holder = 0, type;
@@ -2061,8 +2047,8 @@
 	/*
 	 * Follow logic from spc4r17 Section 5.7.7, Register Behaviors Table 47
 	 */
-	pr_reg_e = core_scsi3_locate_pr_reg(dev, se_sess->se_node_acl, se_sess);
-	if (!pr_reg_e) {
+	pr_reg = core_scsi3_locate_pr_reg(dev, se_sess->se_node_acl, se_sess);
+	if (!pr_reg) {
 		if (res_key) {
 			pr_warn("SPC-3 PR: Reservation Key non-zero"
 				" for SA REGISTER, returning CONFLICT\n");
@@ -2083,7 +2069,7 @@
 			if (core_scsi3_alloc_registration(cmd->se_dev,
 					se_sess->se_node_acl, se_deve, isid_ptr,
 					sa_res_key, all_tg_pt, aptpl,
-					ignore_key, 0)) {
+					register_type, 0)) {
 				pr_err("Unable to allocate"
 					" struct t10_pr_registration\n");
 				return TCM_INVALID_PARAMETER_LIST;
@@ -2102,97 +2088,69 @@
 			if (ret != 0)
 				return ret;
 		}
-		/*
-		 * Nothing left to do for the APTPL=0 case.
-		 */
-		if (!aptpl) {
-			pr_tmpl->pr_aptpl_active = 0;
-			core_scsi3_update_and_write_aptpl(cmd->se_dev, NULL, 0);
-			pr_debug("SPC-3 PR: Set APTPL Bit Deactivated for"
-					" REGISTER\n");
-			return 0;
-		}
-		/*
-		 * Locate the newly allocated local I_T Nexus *pr_reg, and
-		 * update the APTPL metadata information using its
-		 * preallocated *pr_reg->pr_aptpl_buf.
-		 */
-		pr_reg = core_scsi3_locate_pr_reg(cmd->se_dev,
-				se_sess->se_node_acl, se_sess);
-
-		if (core_scsi3_update_and_write_aptpl(cmd->se_dev,
-				&pr_reg->pr_aptpl_buf[0],
-				pr_tmpl->pr_aptpl_buf_len)) {
-			pr_tmpl->pr_aptpl_active = 1;
-			pr_debug("SPC-3 PR: Set APTPL Bit Activated for REGISTER\n");
-		}
 
-		goto out_put_pr_reg;
+		return core_scsi3_update_and_write_aptpl(dev, aptpl);
 	}
 
-	/*
-	 * Locate the existing *pr_reg via struct se_node_acl pointers
-	 */
-	pr_reg = pr_reg_e;
-	type = pr_reg->pr_res_type;
+	/* ok, existing registration */
 
-	if (!ignore_key) {
-		if (res_key != pr_reg->pr_res_key) {
+	if ((register_type == REGISTER) && (res_key != pr_reg->pr_res_key)) {
 			pr_err("SPC-3 PR REGISTER: Received"
 				" res_key: 0x%016Lx does not match"
 				" existing SA REGISTER res_key:"
 				" 0x%016Lx\n", res_key,
 				pr_reg->pr_res_key);
 			ret = TCM_RESERVATION_CONFLICT;
-			goto out_put_pr_reg;
-		}
+		goto out;
 	}
 
 	if (spec_i_pt) {
-		pr_err("SPC-3 PR UNREGISTER: SPEC_I_PT"
-			" set while sa_res_key=0\n");
+		pr_err("SPC-3 PR REGISTER: SPEC_I_PT"
+			" set on a registered nexus\n");
 		ret = TCM_INVALID_PARAMETER_LIST;
-		goto out_put_pr_reg;
+		goto out;
 	}
 
 	/*
 	 * An existing ALL_TG_PT=1 registration being released
 	 * must also set ALL_TG_PT=1 in the incoming PROUT.
 	 */
-	if (pr_reg->pr_reg_all_tg_pt && !(all_tg_pt)) {
-		pr_err("SPC-3 PR UNREGISTER: ALL_TG_PT=1"
+	if (pr_reg->pr_reg_all_tg_pt && !all_tg_pt) {
+		pr_err("SPC-3 PR REGISTER: ALL_TG_PT=1"
 			" registration exists, but ALL_TG_PT=1 bit not"
 			" present in received PROUT\n");
 		ret = TCM_INVALID_CDB_FIELD;
-		goto out_put_pr_reg;
+		goto out;
 	}
 
 	/*
-	 * Allocate APTPL metadata buffer used for UNREGISTER ops
+	 * sa_res_key=1 Change Reservation Key for registered I_T Nexus.
 	 */
-	if (aptpl) {
-		pr_aptpl_buf = kzalloc(pr_tmpl->pr_aptpl_buf_len,
-					GFP_KERNEL);
-		if (!pr_aptpl_buf) {
-			pr_err("Unable to allocate"
-				" pr_aptpl_buf\n");
-			ret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
-			goto out_put_pr_reg;
-		}
-	}
+	if (sa_res_key) {
+		/*
+		 * Increment PRgeneration counter for struct se_device"
+		 * upon a successful REGISTER, see spc4r17 section 6.3.2
+		 * READ_KEYS service action.
+		 */
+		pr_reg->pr_res_generation = core_scsi3_pr_generation(cmd->se_dev);
+		pr_reg->pr_res_key = sa_res_key;
+		pr_debug("SPC-3 PR [%s] REGISTER%s: Changed Reservation"
+			 " Key for %s to: 0x%016Lx PRgeneration:"
+			 " 0x%08x\n", cmd->se_tfo->get_fabric_name(),
+			 (register_type == REGISTER_AND_IGNORE_EXISTING_KEY) ? "_AND_IGNORE_EXISTING_KEY" : "",
+			 pr_reg->pr_reg_nacl->initiatorname,
+			 pr_reg->pr_res_key, pr_reg->pr_res_generation);
 
+	} else {
 	/*
-	 * sa_res_key=0 Unregister Reservation Key for registered I_T
-	 * Nexus sa_res_key=1 Change Reservation Key for registered I_T
-	 * Nexus.
+		 * sa_res_key=0 Unregister Reservation Key for registered I_T Nexus.
 	 */
-	if (!sa_res_key) {
-		pr_holder = core_scsi3_check_implict_release(
-				cmd->se_dev, pr_reg);
+		type = pr_reg->pr_res_type;
+		pr_holder = core_scsi3_check_implicit_release(cmd->se_dev,
+							      pr_reg);
 		if (pr_holder < 0) {
-			kfree(pr_aptpl_buf);
 			ret = TCM_RESERVATION_CONFLICT;
-			goto out_put_pr_reg;
+			goto out;
 		}
 
 		spin_lock(&pr_tmpl->registration_lock);
@@ -2224,6 +2182,7 @@
 		 * Release the calling I_T Nexus registration now..
 		 */
 		__core_scsi3_free_registration(cmd->se_dev, pr_reg, NULL, 1);
+		pr_reg = NULL;
 
 		/*
 		 * From spc4r17, section 5.7.11.3 Unregistering
@@ -2250,60 +2209,14 @@
 					ASCQ_2AH_RESERVATIONS_RELEASED);
 			}
 		}
-		spin_unlock(&pr_tmpl->registration_lock);
-
-		if (!aptpl) {
-			pr_tmpl->pr_aptpl_active = 0;
-			core_scsi3_update_and_write_aptpl(dev, NULL, 0);
-			pr_debug("SPC-3 PR: Set APTPL Bit Deactivated"
-					" for UNREGISTER\n");
-			return 0;
-		}
-
-		if (!core_scsi3_update_and_write_aptpl(dev, &pr_aptpl_buf[0],
-				pr_tmpl->pr_aptpl_buf_len)) {
-			pr_tmpl->pr_aptpl_active = 1;
-			pr_debug("SPC-3 PR: Set APTPL Bit Activated"
-					" for UNREGISTER\n");
-		}
-
-		goto out_free_aptpl_buf;
-	}
-
-	/*
-	 * Increment PRgeneration counter for struct se_device"
-	 * upon a successful REGISTER, see spc4r17 section 6.3.2
-	 * READ_KEYS service action.
-	 */
-	pr_reg->pr_res_generation = core_scsi3_pr_generation(cmd->se_dev);
-	pr_reg->pr_res_key = sa_res_key;
-	pr_debug("SPC-3 PR [%s] REGISTER%s: Changed Reservation"
-		" Key for %s to: 0x%016Lx PRgeneration:"
-		" 0x%08x\n", cmd->se_tfo->get_fabric_name(),
-		(ignore_key) ? "_AND_IGNORE_EXISTING_KEY" : "",
-		pr_reg->pr_reg_nacl->initiatorname,
-		pr_reg->pr_res_key, pr_reg->pr_res_generation);
 
-	if (!aptpl) {
-		pr_tmpl->pr_aptpl_active = 0;
-		core_scsi3_update_and_write_aptpl(dev, NULL, 0);
-		pr_debug("SPC-3 PR: Set APTPL Bit Deactivated"
-				" for REGISTER\n");
-		ret = 0;
-		goto out_put_pr_reg;
+		spin_unlock(&pr_tmpl->registration_lock);
 	}
 
-	if (!core_scsi3_update_and_write_aptpl(dev, &pr_aptpl_buf[0],
-						pr_tmpl->pr_aptpl_buf_len)) {
-		pr_tmpl->pr_aptpl_active = 1;
-		pr_debug("SPC-3 PR: Set APTPL Bit Activated"
-			" for REGISTER\n");
-	}
+	ret = core_scsi3_update_and_write_aptpl(dev, aptpl);
 
-out_free_aptpl_buf:
-	kfree(pr_aptpl_buf);
-	ret = 0;
-out_put_pr_reg:
+out:
+	if (pr_reg)
 	core_scsi3_put_pr_reg(pr_reg);
 	return ret;
 }
@@ -2340,7 +2253,6 @@
 	struct t10_reservation *pr_tmpl = &dev->t10_pr;
 	char i_buf[PR_REG_ISID_ID_LEN];
 	sense_reason_t ret;
-	int prf_isid;
 
 	memset(i_buf, 0, PR_REG_ISID_ID_LEN);
 
@@ -2397,6 +2309,7 @@
 	spin_lock(&dev->dev_reservation_lock);
 	pr_res_holder = dev->dev_pr_res_holder;
 	if (pr_res_holder) {
+		int pr_res_type = pr_res_holder->pr_res_type;
 		/*
 		 * From spc4r17 Section 5.7.9: Reserving:
 		 *
@@ -2407,7 +2320,9 @@
 		 * the logical unit, then the command shall be completed with
 		 * RESERVATION CONFLICT status.
 		 */
-		if (pr_res_holder != pr_reg) {
+		if ((pr_res_holder != pr_reg) &&
+		    (pr_res_type != PR_TYPE_WRITE_EXCLUSIVE_ALLREG) &&
+		    (pr_res_type != PR_TYPE_EXCLUSIVE_ACCESS_ALLREG)) {
 			struct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;
 			pr_err("SPC-3 PR: Attempted RESERVE from"
 				" [%s]: %s while reservation already held by"
@@ -2466,8 +2381,7 @@
 	pr_reg->pr_res_type = type;
 	pr_reg->pr_res_holder = 1;
 	dev->dev_pr_res_holder = pr_reg;
-	prf_isid = core_pr_dump_initiator_port(pr_reg, &i_buf[0],
-				PR_REG_ISID_ID_LEN);
+	core_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);
 
 	pr_debug("SPC-3 PR [%s] Service Action: RESERVE created new"
 		" reservation holder TYPE: %s ALL_TG_PT: %d\n",
@@ -2476,17 +2390,11 @@
 	pr_debug("SPC-3 PR [%s] RESERVE Node: %s%s\n",
 			cmd->se_tfo->get_fabric_name(),
 			se_sess->se_node_acl->initiatorname,
-			(prf_isid) ? &i_buf[0] : "");
+			i_buf);
 	spin_unlock(&dev->dev_reservation_lock);
 
-	if (pr_tmpl->pr_aptpl_active) {
-		if (!core_scsi3_update_and_write_aptpl(cmd->se_dev,
-				&pr_reg->pr_aptpl_buf[0],
-				pr_tmpl->pr_aptpl_buf_len)) {
-			pr_debug("SPC-3 PR: Updated APTPL metadata"
-					" for RESERVE\n");
-		}
-	}
+	if (pr_tmpl->pr_aptpl_active)
+		core_scsi3_update_and_write_aptpl(cmd->se_dev, true);
 
 	ret = 0;
 out_put_pr_reg:
@@ -2520,28 +2428,62 @@
 	struct se_device *dev,
 	struct se_node_acl *se_nacl,
 	struct t10_pr_registration *pr_reg,
-	int explict)
+	int explicit,
+	int unreg)
 {
 	struct target_core_fabric_ops *tfo = se_nacl->se_tpg->se_tpg_tfo;
 	char i_buf[PR_REG_ISID_ID_LEN];
-	int prf_isid;
+	int pr_res_type = 0, pr_res_scope = 0;
 
 	memset(i_buf, 0, PR_REG_ISID_ID_LEN);
-	prf_isid = core_pr_dump_initiator_port(pr_reg, &i_buf[0],
-				PR_REG_ISID_ID_LEN);
+	core_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);
 	/*
 	 * Go ahead and release the current PR reservation holder.
-	 */
+	 * If an All Registrants reservation is currently active and
+	 * a unregister operation is requested, replace the current
+	 * dev_pr_res_holder with another active registration.
+	 */
+	if (dev->dev_pr_res_holder) {
+		pr_res_type = dev->dev_pr_res_holder->pr_res_type;
+		pr_res_scope = dev->dev_pr_res_holder->pr_res_scope;
+		dev->dev_pr_res_holder->pr_res_type = 0;
+		dev->dev_pr_res_holder->pr_res_scope = 0;
+		dev->dev_pr_res_holder->pr_res_holder = 0;
 	dev->dev_pr_res_holder = NULL;
+	}
+	if (!unreg)
+		goto out;
 
+	spin_lock(&dev->t10_pr.registration_lock);
+	list_del_init(&pr_reg->pr_reg_list);
+	/*
+	 * If the I_T nexus is a reservation holder, the persistent reservation
+	 * is of an all registrants type, and the I_T nexus is the last remaining
+	 * registered I_T nexus, then the device server shall also release the
+	 * persistent reservation.
+	 */
+	if (!list_empty(&dev->t10_pr.registration_list) &&
+	    ((pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG) ||
+	     (pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG))) {
+		dev->dev_pr_res_holder =
+			list_entry(dev->t10_pr.registration_list.next,
+				   struct t10_pr_registration, pr_reg_list);
+		dev->dev_pr_res_holder->pr_res_type = pr_res_type;
+		dev->dev_pr_res_holder->pr_res_scope = pr_res_scope;
+		dev->dev_pr_res_holder->pr_res_holder = 1;
+	}
+	spin_unlock(&dev->t10_pr.registration_lock);
+out:
+	if (!dev->dev_pr_res_holder) {
 	pr_debug("SPC-3 PR [%s] Service Action: %s RELEASE cleared"
 		" reservation holder TYPE: %s ALL_TG_PT: %d\n",
-		tfo->get_fabric_name(), (explict) ? "explict" : "implict",
-		core_scsi3_pr_dump_type(pr_reg->pr_res_type),
+			tfo->get_fabric_name(), (explicit) ? "explicit" :
+			"implicit", core_scsi3_pr_dump_type(pr_res_type),
 		(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);
+	}
 	pr_debug("SPC-3 PR [%s] RELEASE Node: %s%s\n",
 		tfo->get_fabric_name(), se_nacl->initiatorname,
-		(prf_isid) ? &i_buf[0] : "");
+		i_buf);
 	/*
 	 * Clear TYPE and SCOPE for the next PROUT Service Action: RESERVE
 	 */
@@ -2669,7 +2611,7 @@
 	 *    server shall not establish a unit attention condition.
 	 */
 	__core_scsi3_complete_pro_release(dev, se_sess->se_node_acl,
-			pr_reg, 1);
+					  pr_reg, 1, 0);
 
 	spin_unlock(&dev->dev_reservation_lock);
 
@@ -2702,12 +2644,9 @@
 	spin_unlock(&pr_tmpl->registration_lock);
 
 write_aptpl:
-	if (pr_tmpl->pr_aptpl_active) {
-		if (!core_scsi3_update_and_write_aptpl(cmd->se_dev,
-			&pr_reg->pr_aptpl_buf[0], pr_tmpl->pr_aptpl_buf_len)) {
-			pr_debug("SPC-3 PR: Updated APTPL metadata for RELEASE\n");
-		}
-	}
+	if (pr_tmpl->pr_aptpl_active)
+		core_scsi3_update_and_write_aptpl(cmd->se_dev, true);
+
 out_put_pr_reg:
 	core_scsi3_put_pr_reg(pr_reg);
 	return ret;
@@ -2760,7 +2699,7 @@
 	if (pr_res_holder) {
 		struct se_node_acl *pr_res_nacl = pr_res_holder->pr_reg_nacl;
 		__core_scsi3_complete_pro_release(dev, pr_res_nacl,
-			pr_res_holder, 0);
+						  pr_res_holder, 0, 0);
 	}
 	spin_unlock(&dev->dev_reservation_lock);
 	/*
@@ -2791,11 +2730,7 @@
 	pr_debug("SPC-3 PR [%s] Service Action: CLEAR complete\n",
 		cmd->se_tfo->get_fabric_name());
 
-	if (pr_tmpl->pr_aptpl_active) {
-		core_scsi3_update_and_write_aptpl(cmd->se_dev, NULL, 0);
-		pr_debug("SPC-3 PR: Updated APTPL metadata"
-				" for CLEAR\n");
-	}
+	core_scsi3_update_and_write_aptpl(cmd->se_dev, false);
 
 	core_scsi3_pr_generation(dev);
 	return 0;
@@ -2810,22 +2745,20 @@
 	struct list_head *preempt_and_abort_list,
 	int type,
 	int scope,
-	int abort)
+	enum preempt_type preempt_type)
 {
 	struct se_node_acl *nacl = pr_reg->pr_reg_nacl;
 	struct target_core_fabric_ops *tfo = nacl->se_tpg->se_tpg_tfo;
 	char i_buf[PR_REG_ISID_ID_LEN];
-	int prf_isid;
 
 	memset(i_buf, 0, PR_REG_ISID_ID_LEN);
-	prf_isid = core_pr_dump_initiator_port(pr_reg, &i_buf[0],
-				PR_REG_ISID_ID_LEN);
+	core_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);
 	/*
-	 * Do an implict RELEASE of the existing reservation.
+	 * Do an implicit RELEASE of the existing reservation.
 	 */
 	if (dev->dev_pr_res_holder)
 		__core_scsi3_complete_pro_release(dev, nacl,
-				dev->dev_pr_res_holder, 0);
+						  dev->dev_pr_res_holder, 0, 0);
 
 	dev->dev_pr_res_holder = pr_reg;
 	pr_reg->pr_res_holder = 1;
@@ -2834,12 +2767,12 @@
 
 	pr_debug("SPC-3 PR [%s] Service Action: PREEMPT%s created new"
 		" reservation holder TYPE: %s ALL_TG_PT: %d\n",
-		tfo->get_fabric_name(), (abort) ? "_AND_ABORT" : "",
+		tfo->get_fabric_name(), (preempt_type == PREEMPT_AND_ABORT) ? "_AND_ABORT" : "",
 		core_scsi3_pr_dump_type(type),
 		(pr_reg->pr_reg_all_tg_pt) ? 1 : 0);
 	pr_debug("SPC-3 PR [%s] PREEMPT%s from Node: %s%s\n",
-		tfo->get_fabric_name(), (abort) ? "_AND_ABORT" : "",
-		nacl->initiatorname, (prf_isid) ? &i_buf[0] : "");
+		tfo->get_fabric_name(), (preempt_type == PREEMPT_AND_ABORT) ? "_AND_ABORT" : "",
+		nacl->initiatorname, i_buf);
 	/*
 	 * For PREEMPT_AND_ABORT, add the preempting reservation's
 	 * struct t10_pr_registration to the list that will be compared
@@ -2869,14 +2802,13 @@
 
 		pr_reg->pr_reg_deve = NULL;
 		pr_reg->pr_reg_nacl = NULL;
-		kfree(pr_reg->pr_aptpl_buf);
 		kmem_cache_free(t10_pr_reg_cache, pr_reg);
 	}
 }
 
 static sense_reason_t
 core_scsi3_pro_preempt(struct se_cmd *cmd, int type, int scope, u64 res_key,
-		u64 sa_res_key, int abort)
+		u64 sa_res_key, enum preempt_type preempt_type)
 {
 	struct se_device *dev = cmd->se_dev;
 	struct se_node_acl *pr_reg_nacl;
@@ -2896,7 +2828,7 @@
 	if (!pr_reg_n) {
 		pr_err("SPC-3 PR: Unable to locate"
 			" PR_REGISTERED *pr_reg for PREEMPT%s\n",
-			(abort) ? "_AND_ABORT" : "");
+			(preempt_type == PREEMPT_AND_ABORT) ? "_AND_ABORT" : "");
 		return TCM_RESERVATION_CONFLICT;
 	}
 	if (pr_reg_n->pr_res_key != res_key) {
@@ -2965,7 +2897,7 @@
 				pr_reg_nacl = pr_reg->pr_reg_nacl;
 				pr_res_mapped_lun = pr_reg->pr_res_mapped_lun;
 				__core_scsi3_free_registration(dev, pr_reg,
-					(abort) ? &preempt_and_abort_list :
+					(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list :
 						NULL, calling_it_nexus);
 				released_regs++;
 			} else {
@@ -2975,7 +2907,7 @@
 				 * 5.7.11.4 Preempting, Table 52 and Figure 7.
 				 *
 				 * For a ZERO SA Reservation key, release
-				 * all other registrations and do an implict
+				 * all other registrations and do an implicit
 				 * release of active persistent reservation.
 				 *
 				 * For a non-ZERO SA Reservation key, only
@@ -2993,7 +2925,7 @@
 				pr_reg_nacl = pr_reg->pr_reg_nacl;
 				pr_res_mapped_lun = pr_reg->pr_res_mapped_lun;
 				__core_scsi3_free_registration(dev, pr_reg,
-					(abort) ? &preempt_and_abort_list :
+					(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list :
 						NULL, 0);
 				released_regs++;
 			}
@@ -3022,24 +2954,17 @@
 		 */
 		if (pr_res_holder && all_reg && !(sa_res_key)) {
 			__core_scsi3_complete_pro_preempt(dev, pr_reg_n,
-				(abort) ? &preempt_and_abort_list : NULL,
-				type, scope, abort);
+				(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list : NULL,
+				type, scope, preempt_type);
 
-			if (abort)
+			if (preempt_type == PREEMPT_AND_ABORT)
 				core_scsi3_release_preempt_and_abort(
 					&preempt_and_abort_list, pr_reg_n);
 		}
 		spin_unlock(&dev->dev_reservation_lock);
 
-		if (pr_tmpl->pr_aptpl_active) {
-			if (!core_scsi3_update_and_write_aptpl(cmd->se_dev,
-					&pr_reg_n->pr_aptpl_buf[0],
-					pr_tmpl->pr_aptpl_buf_len)) {
-				pr_debug("SPC-3 PR: Updated APTPL"
-					" metadata for  PREEMPT%s\n", (abort) ?
-					"_AND_ABORT" : "");
-			}
-		}
+		if (pr_tmpl->pr_aptpl_active)
+			core_scsi3_update_and_write_aptpl(cmd->se_dev, true);
 
 		core_scsi3_put_pr_reg(pr_reg_n);
 		core_scsi3_pr_generation(cmd->se_dev);
@@ -3078,7 +3003,7 @@
 	if (pr_reg_n != pr_res_holder)
 		__core_scsi3_complete_pro_release(dev,
 				pr_res_holder->pr_reg_nacl,
-				dev->dev_pr_res_holder, 0);
+						  dev->dev_pr_res_holder, 0, 0);
 	/*
 	 * b) Remove the registrations for all I_T nexuses identified
 	 *    by the SERVICE ACTION RESERVATION KEY field, except the
@@ -3103,7 +3028,7 @@
 		pr_reg_nacl = pr_reg->pr_reg_nacl;
 		pr_res_mapped_lun = pr_reg->pr_res_mapped_lun;
 		__core_scsi3_free_registration(dev, pr_reg,
-				(abort) ? &preempt_and_abort_list : NULL,
+				(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list : NULL,
 				calling_it_nexus);
 		/*
 		 * e) Establish a unit attention condition for the initiator
@@ -3120,8 +3045,8 @@
 	 *    I_T nexus using the contents of the SCOPE and TYPE fields;
 	 */
 	__core_scsi3_complete_pro_preempt(dev, pr_reg_n,
-			(abort) ? &preempt_and_abort_list : NULL,
-			type, scope, abort);
+			(preempt_type == PREEMPT_AND_ABORT) ? &preempt_and_abort_list : NULL,
+			type, scope, preempt_type);
 	/*
 	 * d) Process tasks as defined in 5.7.1;
 	 * e) See above..
@@ -3161,20 +3086,14 @@
 	 * been removed from the primary pr_reg list), except the
 	 * new persistent reservation holder, the calling Initiator Port.
 	 */
-	if (abort) {
+	if (preempt_type == PREEMPT_AND_ABORT) {
 		core_tmr_lun_reset(dev, NULL, &preempt_and_abort_list, cmd);
 		core_scsi3_release_preempt_and_abort(&preempt_and_abort_list,
 						pr_reg_n);
 	}
 
-	if (pr_tmpl->pr_aptpl_active) {
-		if (!core_scsi3_update_and_write_aptpl(cmd->se_dev,
-				&pr_reg_n->pr_aptpl_buf[0],
-				pr_tmpl->pr_aptpl_buf_len)) {
-			pr_debug("SPC-3 PR: Updated APTPL metadata for PREEMPT"
-				"%s\n", abort ? "_AND_ABORT" : "");
-		}
-	}
+	if (pr_tmpl->pr_aptpl_active)
+		core_scsi3_update_and_write_aptpl(cmd->se_dev, true);
 
 	core_scsi3_put_pr_reg(pr_reg_n);
 	core_scsi3_pr_generation(cmd->se_dev);
@@ -3183,7 +3102,7 @@
 
 static sense_reason_t
 core_scsi3_emulate_pro_preempt(struct se_cmd *cmd, int type, int scope,
-		u64 res_key, u64 sa_res_key, int abort)
+		u64 res_key, u64 sa_res_key, enum preempt_type preempt_type)
 {
 	switch (type) {
 	case PR_TYPE_WRITE_EXCLUSIVE:
@@ -3193,10 +3112,10 @@
 	case PR_TYPE_WRITE_EXCLUSIVE_ALLREG:
 	case PR_TYPE_EXCLUSIVE_ACCESS_ALLREG:
 		return core_scsi3_pro_preempt(cmd, type, scope, res_key,
-					      sa_res_key, abort);
+					      sa_res_key, preempt_type);
 	default:
 		pr_err("SPC-3 PR: Unknown Service Action PREEMPT%s"
-			" Type: 0x%02x\n", (abort) ? "_AND_ABORT" : "", type);
+			" Type: 0x%02x\n", (preempt_type == PREEMPT_AND_ABORT) ? "_AND_ABORT" : "", type);
 		return TCM_INVALID_CDB_FIELD;
 	}
 }
@@ -3220,7 +3139,7 @@
 	unsigned char *initiator_str;
 	char *iport_ptr = NULL, dest_iport[64], i_buf[PR_REG_ISID_ID_LEN];
 	u32 tid_len, tmp_tid_len;
-	int new_reg = 0, type, scope, matching_iname, prf_isid;
+	int new_reg = 0, type, scope, matching_iname;
 	sense_reason_t ret;
 	unsigned short rtpi;
 	unsigned char proto_ident;
@@ -3554,7 +3473,7 @@
 	 *    holder (i.e., the I_T nexus on which the
 	 */
 	__core_scsi3_complete_pro_release(dev, pr_res_nacl,
-			dev->dev_pr_res_holder, 0);
+					  dev->dev_pr_res_holder, 0, 0);
 	/*
 	 * g) Move the persistent reservation to the specified I_T nexus using
 	 *    the same scope and type as the persistent reservation released in
@@ -3564,8 +3483,7 @@
 	dest_pr_reg->pr_res_holder = 1;
 	dest_pr_reg->pr_res_type = type;
 	pr_reg->pr_res_scope = scope;
-	prf_isid = core_pr_dump_initiator_port(pr_reg, &i_buf[0],
-				PR_REG_ISID_ID_LEN);
+	core_pr_dump_initiator_port(pr_reg, i_buf, PR_REG_ISID_ID_LEN);
 	/*
 	 * Increment PRGeneration for existing registrations..
 	 */
@@ -3581,7 +3499,7 @@
 	pr_debug("SPC-3 PR Successfully moved reservation from"
 		" %s Fabric Node: %s%s -> %s Fabric Node: %s %s\n",
 		tf_ops->get_fabric_name(), pr_reg_nacl->initiatorname,
-		(prf_isid) ? &i_buf[0] : "", dest_tf_ops->get_fabric_name(),
+		i_buf, dest_tf_ops->get_fabric_name(),
 		dest_node_acl->initiatorname, (iport_ptr != NULL) ?
 		iport_ptr : "");
 	/*
@@ -3602,24 +3520,7 @@
 	} else
 		core_scsi3_put_pr_reg(pr_reg);
 
-	/*
-	 * Clear the APTPL metadata if APTPL has been disabled, otherwise
-	 * write out the updated metadata to struct file for this SCSI device.
-	 */
-	if (!aptpl) {
-		pr_tmpl->pr_aptpl_active = 0;
-		core_scsi3_update_and_write_aptpl(cmd->se_dev, NULL, 0);
-		pr_debug("SPC-3 PR: Set APTPL Bit Deactivated for"
-				" REGISTER_AND_MOVE\n");
-	} else {
-		pr_tmpl->pr_aptpl_active = 1;
-		if (!core_scsi3_update_and_write_aptpl(cmd->se_dev,
-				&dest_pr_reg->pr_aptpl_buf[0],
-				pr_tmpl->pr_aptpl_buf_len)) {
-			pr_debug("SPC-3 PR: Set APTPL Bit Activated for"
-					" REGISTER_AND_MOVE\n");
-		}
-	}
+	core_scsi3_update_and_write_aptpl(cmd->se_dev, aptpl);
 
 	transport_kunmap_data_sg(cmd);
 
@@ -3752,7 +3653,7 @@
 	switch (sa) {
 	case PRO_REGISTER:
 		ret = core_scsi3_emulate_pro_register(cmd,
-			res_key, sa_res_key, aptpl, all_tg_pt, spec_i_pt, 0);
+			res_key, sa_res_key, aptpl, all_tg_pt, spec_i_pt, REGISTER);
 		break;
 	case PRO_RESERVE:
 		ret = core_scsi3_emulate_pro_reserve(cmd, type, scope, res_key);
@@ -3765,15 +3666,15 @@
 		break;
 	case PRO_PREEMPT:
 		ret = core_scsi3_emulate_pro_preempt(cmd, type, scope,
-					res_key, sa_res_key, 0);
+					res_key, sa_res_key, PREEMPT);
 		break;
 	case PRO_PREEMPT_AND_ABORT:
 		ret = core_scsi3_emulate_pro_preempt(cmd, type, scope,
-					res_key, sa_res_key, 1);
+					res_key, sa_res_key, PREEMPT_AND_ABORT);
 		break;
 	case PRO_REGISTER_AND_IGNORE_EXISTING_KEY:
 		ret = core_scsi3_emulate_pro_register(cmd,
-			0, sa_res_key, aptpl, all_tg_pt, spec_i_pt, 1);
+			0, sa_res_key, aptpl, all_tg_pt, spec_i_pt, REGISTER_AND_IGNORE_EXISTING_KEY);
 		break;
 	case PRO_REGISTER_AND_MOVE:
 		ret = core_scsi3_emulate_pro_register_and_move(cmd, res_key,
@@ -4012,7 +3913,8 @@
 	unsigned char *buf;
 	u32 add_desc_len = 0, add_len = 0, desc_len, exp_desc_len;
 	u32 off = 8; /* off into first Full Status descriptor */
-	int format_code = 0;
+	int format_code = 0, pr_res_type = 0, pr_res_scope = 0;
+	bool all_reg = false;
 
 	if (cmd->data_length < 8) {
 		pr_err("PRIN SA READ_FULL_STATUS SCSI Data Length: %u"
@@ -4029,6 +3931,19 @@
 	buf[2] = ((dev->t10_pr.pr_generation >> 8) & 0xff);
 	buf[3] = (dev->t10_pr.pr_generation & 0xff);
 
+	spin_lock(&dev->dev_reservation_lock);
+	if (dev->dev_pr_res_holder) {
+		struct t10_pr_registration *pr_holder = dev->dev_pr_res_holder;
+
+		if (pr_holder->pr_res_type == PR_TYPE_WRITE_EXCLUSIVE_ALLREG ||
+		    pr_holder->pr_res_type == PR_TYPE_EXCLUSIVE_ACCESS_ALLREG) {
+			all_reg = true;
+			pr_res_type = pr_holder->pr_res_type;
+			pr_res_scope = pr_holder->pr_res_scope;
+		}
+	}
+	spin_unlock(&dev->dev_reservation_lock);
+
 	spin_lock(&pr_tmpl->registration_lock);
 	list_for_each_entry_safe(pr_reg, pr_reg_tmp,
 			&pr_tmpl->registration_list, pr_reg_list) {
@@ -4078,14 +3993,20 @@
 		 * reservation holder for PR_HOLDER bit.
 		 *
 		 * Also, if this registration is the reservation
-		 * holder, fill in SCOPE and TYPE in the next byte.
+		 * holder or there is an All Registrants reservation
+		 * active, fill in SCOPE and TYPE in the next byte.
 		 */
 		if (pr_reg->pr_res_holder) {
 			buf[off++] |= 0x01;
 			buf[off++] = (pr_reg->pr_res_scope & 0xf0) |
 				     (pr_reg->pr_res_type & 0x0f);
-		} else
+		} else if (all_reg) {
+			buf[off++] |= 0x01;
+			buf[off++] = (pr_res_scope & 0xf0) |
+				     (pr_res_type & 0x0f);
+		} else {
 			off += 2;
+		}
 
 		off += 4; /* Skip over reserved area */
 		/*
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_pr.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_pr.h
--- linux-3.10.69/drivers/target/target_core_pr.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_pr.h	2017-05-02 03:31:56.000000000 +0200
@@ -43,9 +43,14 @@
 #define PR_APTPL_MAX_IPORT_LEN			256
 #define PR_APTPL_MAX_TPORT_LEN			256
 
+/*
+ *  Function defined in target_core_spc.c
+ */
+void spc_parse_naa_6h_vendor_specific(struct se_device *, unsigned char *);
+
 extern struct kmem_cache *t10_pr_reg_cache;
 
-extern int core_pr_dump_initiator_port(struct t10_pr_registration *,
+extern void core_pr_dump_initiator_port(struct t10_pr_registration *,
 			char *, u32);
 extern sense_reason_t target_scsi2_reservation_release(struct se_cmd *);
 extern sense_reason_t target_scsi2_reservation_reserve(struct se_cmd *);
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_pscsi.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_pscsi.c
--- linux-3.10.69/drivers/target/target_core_pscsi.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_pscsi.c	2017-05-02 03:31:56.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * This file contains the generic target mode <-> Linux SCSI subsystem plugin.
  *
- * (c) Copyright 2003-2012 RisingTide Systems LLC.
+ * (c) Copyright 2003-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -520,6 +520,7 @@
 					" pdv_host_id: %d\n", pdv->pdv_host_id);
 				return -EINVAL;
 			}
+			pdv->pdv_lld_host = sh;
 		}
 	} else {
 		if (phv->phv_mode == PHV_VIRTUAL_HOST_ID) {
@@ -602,6 +603,8 @@
 		if ((phv->phv_mode == PHV_LLD_SCSI_HOST_NO) &&
 		    (phv->phv_lld_host != NULL))
 			scsi_host_put(phv->phv_lld_host);
+		else if (pdv->pdv_lld_host)
+			scsi_host_put(pdv->pdv_lld_host);
 
 		if ((sd->type == TYPE_DISK) || (sd->type == TYPE_ROM))
 			scsi_device_put(sd);
@@ -1050,9 +1053,8 @@
 		req = blk_get_request(pdv->pdv_sd->request_queue,
 				(data_direction == DMA_TO_DEVICE),
 				GFP_KERNEL);
-		if (!req || IS_ERR(req)) {
-			pr_err("PSCSI: blk_get_request() failed: %ld\n",
-					req ? IS_ERR(req) : -ENOMEM);
+		if (!req) {
+			pr_err("PSCSI: blk_get_request() failed\n");
 			ret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 			goto fail;
 		}
@@ -1112,7 +1114,7 @@
 	struct pscsi_dev_virt *pdv = PSCSI_DEV(dev);
 	struct scsi_device *sd = pdv->pdv_sd;
 
-	return sd->type;
+	return (sd) ? sd->type : TYPE_NO_LUN;
 }
 
 static sector_t pscsi_get_blocks(struct se_device *dev)
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_pscsi.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_pscsi.h
--- linux-3.10.69/drivers/target/target_core_pscsi.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_pscsi.h	2017-05-02 03:31:56.000000000 +0200
@@ -45,6 +45,7 @@
 	int	pdv_lun_id;
 	struct block_device *pdv_bd;
 	struct scsi_device *pdv_sd;
+	struct Scsi_Host *pdv_lld_host;
 } ____cacheline_aligned;
 
 typedef enum phv_modes {
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_rd.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_rd.c
--- linux-3.10.69/drivers/target/target_core_rd.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_rd.c	2017-05-02 03:31:56.000000000 +0200
@@ -4,7 +4,7 @@
  * This file contains the Storage Engine <-> Ramdisk transport
  * specific functions.
  *
- * (c) Copyright 2003-2012 RisingTide Systems LLC.
+ * (c) Copyright 2003-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -27,7 +27,6 @@
 #include <linux/string.h>
 #include <linux/parser.h>
 #include <linux/timer.h>
-#include <linux/blkdev.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
 #include <scsi/scsi.h>
@@ -79,23 +78,14 @@
 	hba->hba_ptr = NULL;
 }
 
-/*	rd_release_device_space():
- *
- *
- */
-static void rd_release_device_space(struct rd_dev *rd_dev)
+static u32 rd_release_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
+				 u32 sg_table_count)
 {
-	u32 i, j, page_count = 0, sg_per_table;
-	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
+	u32 i, j, page_count = 0, sg_per_table;
 
-	if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)
-		return;
-
-	sg_table = rd_dev->sg_table_array;
-
-	for (i = 0; i < rd_dev->sg_table_count; i++) {
+	for (i = 0; i < sg_table_count; i++) {
 		sg = sg_table[i].sg_table;
 		sg_per_table = sg_table[i].rd_sg_count;
 
@@ -106,16 +96,28 @@
 				page_count++;
 			}
 		}
-
 		kfree(sg);
 	}
 
+	kfree(sg_table);
+	return page_count;
+}
+
+static void rd_release_device_space(struct rd_dev *rd_dev)
+{
+	u32 page_count;
+
+	if (!rd_dev->sg_table_array || !rd_dev->sg_table_count)
+		return;
+
+	page_count = rd_release_sgl_table(rd_dev, rd_dev->sg_table_array,
+					  rd_dev->sg_table_count);
+
 	pr_debug("CORE_RD[%u] - Released device space for Ramdisk"
 		" Device ID: %u, pages %u in %u tables total bytes %lu\n",
 		rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,
 		rd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);
 
-	kfree(sg_table);
 	rd_dev->sg_table_array = NULL;
 	rd_dev->sg_table_count = 0;
 }
@@ -125,33 +127,15 @@
  *
  *
  */
-static int rd_build_device_space(struct rd_dev *rd_dev)
+static int rd_allocate_sgl_table(struct rd_dev *rd_dev, struct rd_dev_sg_table *sg_table,
+				 u32 total_sg_needed, unsigned char init_payload)
 {
-	u32 i = 0, j, page_offset = 0, sg_per_table, sg_tables, total_sg_needed;
+	u32 i = 0, j, page_offset = 0, sg_per_table;
 	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
 				sizeof(struct scatterlist));
-	struct rd_dev_sg_table *sg_table;
 	struct page *pg;
 	struct scatterlist *sg;
-
-	if (rd_dev->rd_page_count <= 0) {
-		pr_err("Illegal page count: %u for Ramdisk device\n",
-			rd_dev->rd_page_count);
-		return -EINVAL;
-	}
-	total_sg_needed = rd_dev->rd_page_count;
-
-	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
-
-	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
-	if (!sg_table) {
-		pr_err("Unable to allocate memory for Ramdisk"
-			" scatterlist tables\n");
-		return -ENOMEM;
-	}
-
-	rd_dev->sg_table_array = sg_table;
-	rd_dev->sg_table_count = sg_tables;
+	unsigned char *p;
 
 	while (total_sg_needed) {
 		sg_per_table = (total_sg_needed > max_sg_per_table) ?
@@ -182,12 +166,55 @@
 			}
 			sg_assign_page(&sg[j], pg);
 			sg[j].length = PAGE_SIZE;
+
+			p = kmap(pg);
+			memset(p, init_payload, PAGE_SIZE);
+			kunmap(pg);
 		}
 
 		page_offset += sg_per_table;
 		total_sg_needed -= sg_per_table;
 	}
 
+	return 0;
+}
+
+static int rd_build_device_space(struct rd_dev *rd_dev)
+{
+	struct rd_dev_sg_table *sg_table;
+	u32 sg_tables, total_sg_needed;
+	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
+				sizeof(struct scatterlist));
+	int rc;
+
+	if (rd_dev->rd_page_count <= 0) {
+		pr_err("Illegal page count: %u for Ramdisk device\n",
+		       rd_dev->rd_page_count);
+		return -EINVAL;
+	}
+
+	/* Don't need backing pages for NULLIO */
+	if (rd_dev->rd_flags & RDF_NULLIO)
+		return 0;
+
+	total_sg_needed = rd_dev->rd_page_count;
+
+	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
+
+	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
+	if (!sg_table) {
+		pr_err("Unable to allocate memory for Ramdisk"
+		       " scatterlist tables\n");
+		return -ENOMEM;
+	}
+
+	rd_dev->sg_table_array = sg_table;
+	rd_dev->sg_table_count = sg_tables;
+
+	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0x00);
+	if (rc)
+		return rc;
+
 	pr_debug("CORE_RD[%u] - Built Ramdisk Device ID: %u space of"
 		" %u pages in %u tables\n", rd_dev->rd_host->rd_host_id,
 		rd_dev->rd_dev_id, rd_dev->rd_page_count,
@@ -196,6 +223,66 @@
 	return 0;
 }
 
+static void rd_release_prot_space(struct rd_dev *rd_dev)
+{
+	u32 page_count;
+
+	if (!rd_dev->sg_prot_array || !rd_dev->sg_prot_count)
+		return;
+
+	page_count = rd_release_sgl_table(rd_dev, rd_dev->sg_prot_array,
+					  rd_dev->sg_prot_count);
+
+	pr_debug("CORE_RD[%u] - Released protection space for Ramdisk"
+		 " Device ID: %u, pages %u in %u tables total bytes %lu\n",
+		 rd_dev->rd_host->rd_host_id, rd_dev->rd_dev_id, page_count,
+		 rd_dev->sg_table_count, (unsigned long)page_count * PAGE_SIZE);
+
+	rd_dev->sg_prot_array = NULL;
+	rd_dev->sg_prot_count = 0;
+}
+
+static int rd_build_prot_space(struct rd_dev *rd_dev, int prot_length, int block_size)
+{
+	struct rd_dev_sg_table *sg_table;
+	u32 total_sg_needed, sg_tables;
+	u32 max_sg_per_table = (RD_MAX_ALLOCATION_SIZE /
+				sizeof(struct scatterlist));
+	int rc;
+
+	if (rd_dev->rd_flags & RDF_NULLIO)
+		return 0;
+	/*
+	 * prot_length=8byte dif data
+	 * tot sg needed = rd_page_count * (PGSZ/block_size) *
+	 * 		   (prot_length/block_size) + pad
+	 * PGSZ canceled each other.
+	 */
+	total_sg_needed = (rd_dev->rd_page_count * prot_length / block_size) + 1;
+
+	sg_tables = (total_sg_needed / max_sg_per_table) + 1;
+
+	sg_table = kzalloc(sg_tables * sizeof(struct rd_dev_sg_table), GFP_KERNEL);
+	if (!sg_table) {
+		pr_err("Unable to allocate memory for Ramdisk protection"
+		       " scatterlist tables\n");
+		return -ENOMEM;
+	}
+
+	rd_dev->sg_prot_array = sg_table;
+	rd_dev->sg_prot_count = sg_tables;
+
+	rc = rd_allocate_sgl_table(rd_dev, sg_table, total_sg_needed, 0xff);
+	if (rc)
+		return rc;
+
+	pr_debug("CORE_RD[%u] - Built Ramdisk Device ID: %u prot space of"
+		 " %u pages in %u tables\n", rd_dev->rd_host->rd_host_id,
+		 rd_dev->rd_dev_id, total_sg_needed, rd_dev->sg_prot_count);
+
+	return 0;
+}
+
 static struct se_device *rd_alloc_device(struct se_hba *hba, const char *name)
 {
 	struct rd_dev *rd_dev;
@@ -274,12 +361,30 @@
 	return NULL;
 }
 
+static struct rd_dev_sg_table *rd_get_prot_table(struct rd_dev *rd_dev, u32 page)
+{
+	struct rd_dev_sg_table *sg_table;
+	u32 i, sg_per_table = (RD_MAX_ALLOCATION_SIZE /
+				sizeof(struct scatterlist));
+
+	i = page / sg_per_table;
+	if (i < rd_dev->sg_prot_count) {
+		sg_table = &rd_dev->sg_prot_array[i];
+		if ((sg_table->page_start_offset <= page) &&
+		     (sg_table->page_end_offset >= page))
+			return sg_table;
+	}
+
+	pr_err("Unable to locate struct prot rd_dev_sg_table for page: %u\n",
+			page);
+
+	return NULL;
+}
+
 static sense_reason_t
-rd_execute_rw(struct se_cmd *cmd)
+rd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,
+	      enum dma_data_direction data_direction)
 {
-	struct scatterlist *sgl = cmd->t_data_sg;
-	u32 sgl_nents = cmd->t_data_nents;
-	enum dma_data_direction data_direction = cmd->data_direction;
 	struct se_device *se_dev = cmd->se_dev;
 	struct rd_dev *dev = RD_DEV(se_dev);
 	struct rd_dev_sg_table *table;
@@ -290,6 +395,7 @@
 	u32 rd_page;
 	u32 src_len;
 	u64 tmp;
+	sense_reason_t rc;
 
 	if (dev->rd_flags & RDF_NULLIO) {
 		target_complete_cmd(cmd, SAM_STAT_GOOD);
@@ -312,6 +418,28 @@
 			data_direction == DMA_FROM_DEVICE ? "Read" : "Write",
 			cmd->t_task_lba, rd_size, rd_page, rd_offset);
 
+	if (cmd->prot_type && data_direction == DMA_TO_DEVICE) {
+		struct rd_dev_sg_table *prot_table;
+		struct scatterlist *prot_sg;
+		u32 sectors = cmd->data_length / se_dev->dev_attrib.block_size;
+		u32 prot_offset, prot_page;
+
+		tmp = cmd->t_task_lba * se_dev->prot_length;
+		prot_offset = do_div(tmp, PAGE_SIZE);
+		prot_page = tmp;
+
+		prot_table = rd_get_prot_table(dev, prot_page);
+		if (!prot_table)
+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+
+		prot_sg = &prot_table->sg_table[prot_page - prot_table->page_start_offset];
+
+		rc = sbc_dif_verify_write(cmd, cmd->t_task_lba, sectors, 0,
+					  prot_sg, prot_offset);
+		if (rc)
+			return rc;
+	}
+
 	src_len = PAGE_SIZE - rd_offset;
 	sg_miter_start(&m, sgl, sgl_nents,
 			data_direction == DMA_FROM_DEVICE ?
@@ -373,6 +501,28 @@
 	}
 	sg_miter_stop(&m);
 
+	if (cmd->prot_type && data_direction == DMA_FROM_DEVICE) {
+		struct rd_dev_sg_table *prot_table;
+		struct scatterlist *prot_sg;
+		u32 sectors = cmd->data_length / se_dev->dev_attrib.block_size;
+		u32 prot_offset, prot_page;
+
+		tmp = cmd->t_task_lba * se_dev->prot_length;
+		prot_offset = do_div(tmp, PAGE_SIZE);
+		prot_page = tmp;
+
+		prot_table = rd_get_prot_table(dev, prot_page);
+		if (!prot_table)
+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+
+		prot_sg = &prot_table->sg_table[prot_page - prot_table->page_start_offset];
+
+		rc = sbc_dif_verify_read(cmd, cmd->t_task_lba, sectors, 0,
+					 prot_sg, prot_offset);
+		if (rc)
+			return rc;
+	}
+
 	target_complete_cmd(cmd, SAM_STAT_GOOD);
 	return 0;
 }
@@ -454,6 +604,24 @@
 	return blocks_long;
 }
 
+static int rd_init_prot(struct se_device *dev)
+{
+	struct rd_dev *rd_dev = RD_DEV(dev);
+
+        if (!dev->dev_attrib.pi_prot_type)
+		return 0;
+
+	return rd_build_prot_space(rd_dev, dev->prot_length,
+				   dev->dev_attrib.block_size);
+}
+
+static void rd_free_prot(struct se_device *dev)
+{
+	struct rd_dev *rd_dev = RD_DEV(dev);
+
+	rd_release_prot_space(rd_dev);
+}
+
 static struct sbc_ops rd_sbc_ops = {
 	.execute_rw		= rd_execute_rw,
 };
@@ -479,6 +647,8 @@
 	.show_configfs_dev_params = rd_show_configfs_dev_params,
 	.get_device_type	= sbc_get_device_type,
 	.get_blocks		= rd_get_blocks,
+	.init_prot		= rd_init_prot,
+	.free_prot		= rd_free_prot,
 };
 
 int __init rd_module_init(void)
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_rd.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_rd.h
--- linux-3.10.69/drivers/target/target_core_rd.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_rd.h	2017-05-02 03:31:56.000000000 +0200
@@ -33,8 +33,12 @@
 	u32		rd_page_count;
 	/* Number of SG tables in sg_table_array */
 	u32		sg_table_count;
+	/* Number of SG tables in sg_prot_array */
+	u32		sg_prot_count;
 	/* Array of rd_dev_sg_table_t containing scatterlists */
 	struct rd_dev_sg_table *sg_table_array;
+	/* Array of rd_dev_sg_table containing protection scatterlists */
+	struct rd_dev_sg_table *sg_prot_array;
 	/* Ramdisk HBA device is connected to */
 	struct rd_host *rd_host;
 } ____cacheline_aligned;
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_sbc.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_sbc.c
--- linux-3.10.69/drivers/target/target_core_sbc.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_sbc.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * SCSI Block Commands (SBC) parsing and emulation.
  *
- * (c) Copyright 2002-2012 RisingTide Systems LLC.
+ * (c) Copyright 2002-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -23,8 +23,10 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/ratelimit.h>
+#include <linux/crc-t10dif.h>
 #include <asm/unaligned.h>
 #include <scsi/scsi.h>
+#include <scsi/scsi_tcq.h>
 
 #include <target/target_core_base.h>
 #include <target/target_core_backend.h>
@@ -32,17 +34,33 @@
 
 #include "target_core_internal.h"
 #include "target_core_ua.h"
-
+#include "target_core_alua.h"
 
 static sense_reason_t
 sbc_emulate_readcapacity(struct se_cmd *cmd)
 {
 	struct se_device *dev = cmd->se_dev;
+	unsigned char *cdb = cmd->t_task_cdb;
 	unsigned long long blocks_long = dev->transport->get_blocks(dev);
 	unsigned char *rbuf;
 	unsigned char buf[8];
 	u32 blocks;
 
+	/*
+	 * SBC-2 says:
+	 *   If the PMI bit is set to zero and the LOGICAL BLOCK
+	 *   ADDRESS field is not set to zero, the device server shall
+	 *   terminate the command with CHECK CONDITION status with
+	 *   the sense key set to ILLEGAL REQUEST and the additional
+	 *   sense code set to INVALID FIELD IN CDB.
+	 *
+	 * In SBC-3, these fields are obsolete, but some SCSI
+	 * compliance tests actually check this, so we might as well
+	 * follow SBC-2.
+	 */
+	if (!(cdb[8] & 1) && !!(cdb[2] | cdb[3] | cdb[4] | cdb[5]))
+		return TCM_INVALID_CDB_FIELD;
+
 	if (blocks_long >= 0x00000000ffffffff)
 		blocks = 0xffffffff;
 	else
@@ -89,11 +107,26 @@
 	buf[10] = (dev->dev_attrib.block_size >> 8) & 0xff;
 	buf[11] = dev->dev_attrib.block_size & 0xff;
 	/*
+	 * Set P_TYPE and PROT_EN bits for DIF support
+	 */
+	if (dev->dev_attrib.pi_prot_type)
+		buf[12] = (dev->dev_attrib.pi_prot_type - 1) << 1 | 0x1;
+
+	if (dev->transport->get_lbppbe)
+		buf[13] = dev->transport->get_lbppbe(dev) & 0x0f;
+
+	if (dev->transport->get_alignment_offset_lbas) {
+		u16 lalba = dev->transport->get_alignment_offset_lbas(dev);
+		buf[14] = (lalba >> 8) & 0x3f;
+		buf[15] = lalba & 0xff;
+	}
+
+	/*
 	 * Set Thin Provisioning Enable bit following sbc3r22 in section
 	 * READ CAPACITY (16) byte 14 if emulate_tpu or emulate_tpws is enabled.
 	 */
 	if (dev->dev_attrib.emulate_tpu || dev->dev_attrib.emulate_tpws)
-		buf[14] = 0x80;
+		buf[14] |= 0x80;
 
 	rbuf = transport_kmap_data_sg(cmd);
 	if (rbuf) {
@@ -233,6 +266,8 @@
 static sense_reason_t
 sbc_setup_write_same(struct se_cmd *cmd, unsigned char *flags, struct sbc_ops *ops)
 {
+	struct se_device *dev = cmd->se_dev;
+	sector_t end_lba = dev->transport->get_blocks(dev) + 1;
 	unsigned int sectors = sbc_get_write_same_sectors(cmd);
 
 	if ((flags[0] & 0x04) || (flags[0] & 0x02)) {
@@ -247,6 +282,21 @@
 		return TCM_INVALID_CDB_FIELD;
 	}
 	/*
+	 * Sanity check for LBA wrap and request past end of device.
+	 */
+	if (((cmd->t_task_lba + sectors) < cmd->t_task_lba) ||
+	    ((cmd->t_task_lba + sectors) > end_lba)) {
+		pr_err("WRITE_SAME exceeds last lba %llu (lba %llu, sectors %u)\n",
+		       (unsigned long long)end_lba, cmd->t_task_lba, sectors);
+		return TCM_ADDRESS_OUT_OF_RANGE;
+	}
+
+	/* We always have ANC_SUP == 0 so setting ANCHOR is always an error */
+	if (flags[0] & 0x10) {
+		pr_warn("WRITE SAME with ANCHOR not supported\n");
+		return TCM_INVALID_CDB_FIELD;
+	}
+	/*
 	 * Special case for WRITE_SAME w/ UNMAP=1 that ends up getting
 	 * translated into block discard requests within backend code.
 	 */
@@ -264,13 +314,13 @@
 	return 0;
 }
 
-static void xdreadwrite_callback(struct se_cmd *cmd)
+static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success)
 {
 	unsigned char *buf, *addr;
 	struct scatterlist *sg;
 	unsigned int offset;
-	int i;
-	int count;
+	sense_reason_t ret = TCM_NO_SENSE;
+	int i, count;
 	/*
 	 * From sbc3r22.pdf section 5.48 XDWRITEREAD (10) command
 	 *
@@ -285,7 +335,7 @@
 	buf = kmalloc(cmd->data_length, GFP_KERNEL);
 	if (!buf) {
 		pr_err("Unable to allocate xor_callback buf\n");
-		return;
+		return TCM_OUT_OF_RESOURCES;
 	}
 	/*
 	 * Copy the scatterlist WRITE buffer located at cmd->t_data_sg
@@ -304,8 +354,10 @@
 	offset = 0;
 	for_each_sg(cmd->t_bidi_data_sg, sg, cmd->t_bidi_data_nents, count) {
 		addr = kmap_atomic(sg_page(sg));
-		if (!addr)
+		if (!addr) {
+			ret = TCM_OUT_OF_RESOURCES;
 			goto out;
+		}
 
 		for (i = 0; i < sg->length; i++)
 			*(addr + sg->offset + i) ^= *(buf + offset + i);
@@ -316,6 +368,261 @@
 
 out:
 	kfree(buf);
+	return ret;
+}
+
+static sense_reason_t
+sbc_execute_rw(struct se_cmd *cmd)
+{
+	return cmd->execute_rw(cmd, cmd->t_data_sg, cmd->t_data_nents,
+			       cmd->data_direction);
+}
+
+static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)
+{
+	struct se_device *dev = cmd->se_dev;
+
+	/*
+	 * Only set SCF_COMPARE_AND_WRITE_POST to force a response fall-through
+	 * within target_complete_ok_work() if the command was successfully
+	 * sent to the backend driver.
+	 */
+	spin_lock_irq(&cmd->t_state_lock);
+	if ((cmd->transport_state & CMD_T_SENT) && !cmd->scsi_status)
+		cmd->se_cmd_flags |= SCF_COMPARE_AND_WRITE_POST;
+	spin_unlock_irq(&cmd->t_state_lock);
+
+	/*
+	 * Unlock ->caw_sem originally obtained during sbc_compare_and_write()
+	 * before the original READ I/O submission.
+	 */
+	up(&dev->caw_sem);
+
+	return TCM_NO_SENSE;
+}
+
+static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success)
+{
+	struct se_device *dev = cmd->se_dev;
+	struct scatterlist *write_sg = NULL, *sg;
+	unsigned char *buf = NULL, *addr;
+	struct sg_mapping_iter m;
+	unsigned int offset = 0, len;
+	unsigned int nlbas = cmd->t_task_nolb;
+	unsigned int block_size = dev->dev_attrib.block_size;
+	unsigned int compare_len = (nlbas * block_size);
+	sense_reason_t ret = TCM_NO_SENSE;
+	int rc, i;
+
+	/*
+	 * Handle early failure in transport_generic_request_failure(),
+	 * which will not have taken ->caw_sem yet..
+	 */
+	if (!success && (!cmd->t_data_sg || !cmd->t_bidi_data_sg))
+		return TCM_NO_SENSE;
+	/*
+	 * Handle special case for zero-length COMPARE_AND_WRITE
+	 */
+	if (!cmd->data_length)
+		goto out;
+	/*
+	 * Immediately exit + release dev->caw_sem if command has already
+	 * been failed with a non-zero SCSI status.
+	 */
+	if (cmd->scsi_status) {
+		pr_err("compare_and_write_callback: non zero scsi_status:"
+			" 0x%02x\n", cmd->scsi_status);
+		goto out;
+	}
+
+	buf = kzalloc(cmd->data_length, GFP_KERNEL);
+	if (!buf) {
+		pr_err("Unable to allocate compare_and_write buf\n");
+		ret = TCM_OUT_OF_RESOURCES;
+		goto out;
+	}
+
+	write_sg = kmalloc(sizeof(struct scatterlist) * cmd->t_data_nents,
+			   GFP_KERNEL);
+	if (!write_sg) {
+		pr_err("Unable to allocate compare_and_write sg\n");
+		ret = TCM_OUT_OF_RESOURCES;
+		goto out;
+	}
+	sg_init_table(write_sg, cmd->t_data_nents);
+	/*
+	 * Setup verify and write data payloads from total NumberLBAs.
+	 */
+	rc = sg_copy_to_buffer(cmd->t_data_sg, cmd->t_data_nents, buf,
+			       cmd->data_length);
+	if (!rc) {
+		pr_err("sg_copy_to_buffer() failed for compare_and_write\n");
+		ret = TCM_OUT_OF_RESOURCES;
+		goto out;
+	}
+	/*
+	 * Compare against SCSI READ payload against verify payload
+	 */
+	for_each_sg(cmd->t_bidi_data_sg, sg, cmd->t_bidi_data_nents, i) {
+		addr = (unsigned char *)kmap_atomic(sg_page(sg));
+		if (!addr) {
+			ret = TCM_OUT_OF_RESOURCES;
+			goto out;
+		}
+
+		len = min(sg->length, compare_len);
+
+		if (memcmp(addr, buf + offset, len)) {
+			pr_warn("Detected MISCOMPARE for addr: %p buf: %p\n",
+				addr, buf + offset);
+			kunmap_atomic(addr);
+			goto miscompare;
+		}
+		kunmap_atomic(addr);
+
+		offset += len;
+		compare_len -= len;
+		if (!compare_len)
+			break;
+	}
+
+	i = 0;
+	len = cmd->t_task_nolb * block_size;
+	sg_miter_start(&m, cmd->t_data_sg, cmd->t_data_nents, SG_MITER_TO_SG);
+	/*
+	 * Currently assumes NoLB=1 and SGLs are PAGE_SIZE..
+	 */
+	while (len) {
+		sg_miter_next(&m);
+
+		if (block_size < PAGE_SIZE) {
+			sg_set_page(&write_sg[i], m.page, block_size,
+				    block_size);
+		} else {
+			sg_miter_next(&m);
+			sg_set_page(&write_sg[i], m.page, block_size,
+				    0);
+		}
+		len -= block_size;
+		i++;
+	}
+	sg_miter_stop(&m);
+	/*
+	 * Save the original SGL + nents values before updating to new
+	 * assignments, to be released in transport_free_pages() ->
+	 * transport_reset_sgl_orig()
+	 */
+	cmd->t_data_sg_orig = cmd->t_data_sg;
+	cmd->t_data_sg = write_sg;
+	cmd->t_data_nents_orig = cmd->t_data_nents;
+	cmd->t_data_nents = 1;
+
+	cmd->sam_task_attr = MSG_HEAD_TAG;
+	cmd->transport_complete_callback = compare_and_write_post;
+	/*
+	 * Now reset ->execute_cmd() to the normal sbc_execute_rw() handler
+	 * for submitting the adjusted SGL to write instance user-data.
+	 */
+	cmd->execute_cmd = sbc_execute_rw;
+
+	spin_lock_irq(&cmd->t_state_lock);
+	cmd->t_state = TRANSPORT_PROCESSING;
+	cmd->transport_state |= CMD_T_ACTIVE|CMD_T_BUSY|CMD_T_SENT;
+	spin_unlock_irq(&cmd->t_state_lock);
+
+	__target_execute_cmd(cmd);
+
+	kfree(buf);
+	return ret;
+
+miscompare:
+	pr_warn("Target/%s: Send MISCOMPARE check condition and sense\n",
+		dev->transport->name);
+	ret = TCM_MISCOMPARE_VERIFY;
+out:
+	/*
+	 * In the MISCOMPARE or failure case, unlock ->caw_sem obtained in
+	 * sbc_compare_and_write() before the original READ I/O submission.
+	 */
+	up(&dev->caw_sem);
+	kfree(write_sg);
+	kfree(buf);
+	return ret;
+}
+
+static sense_reason_t
+sbc_compare_and_write(struct se_cmd *cmd)
+{
+	struct se_device *dev = cmd->se_dev;
+	sense_reason_t ret;
+	int rc;
+	/*
+	 * Submit the READ first for COMPARE_AND_WRITE to perform the
+	 * comparision using SGLs at cmd->t_bidi_data_sg..
+	 */
+	rc = down_interruptible(&dev->caw_sem);
+	if ((rc != 0) || signal_pending(current)) {
+		cmd->transport_complete_callback = NULL;
+		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+	}
+	/*
+	 * Reset cmd->data_length to individual block_size in order to not
+	 * confuse backend drivers that depend on this value matching the
+	 * size of the I/O being submitted.
+	 */
+	cmd->data_length = cmd->t_task_nolb * dev->dev_attrib.block_size;
+
+	ret = cmd->execute_rw(cmd, cmd->t_bidi_data_sg, cmd->t_bidi_data_nents,
+			      DMA_FROM_DEVICE);
+	if (ret) {
+		cmd->transport_complete_callback = NULL;
+		up(&dev->caw_sem);
+		return ret;
+	}
+	/*
+	 * Unlock of dev->caw_sem to occur in compare_and_write_callback()
+	 * upon MISCOMPARE, or in compare_and_write_done() upon completion
+	 * of WRITE instance user-data.
+	 */
+	return TCM_NO_SENSE;
+}
+
+static bool
+sbc_check_prot(struct se_device *dev, struct se_cmd *cmd, unsigned char *cdb,
+	       u32 sectors)
+{
+	if (!cmd->t_prot_sg || !cmd->t_prot_nents)
+		return true;
+
+	switch (dev->dev_attrib.pi_prot_type) {
+	case TARGET_DIF_TYPE3_PROT:
+		if (!(cdb[1] & 0xe0))
+			return true;
+
+		cmd->reftag_seed = 0xffffffff;
+		break;
+	case TARGET_DIF_TYPE2_PROT:
+		if (cdb[1] & 0xe0)
+			return false;
+
+		cmd->reftag_seed = cmd->t_task_lba;
+		break;
+	case TARGET_DIF_TYPE1_PROT:
+		if (!(cdb[1] & 0xe0))
+			return true;
+
+		cmd->reftag_seed = cmd->t_task_lba;
+		break;
+	case TARGET_DIF_TYPE0_PROT:
+	default:
+		return true;
+	}
+
+	cmd->prot_type = dev->dev_attrib.pi_prot_type;
+	cmd->prot_length = dev->prot_length * sectors;
+	cmd->prot_handover = PROT_SEPERATED;
+
+	return true;
 }
 
 sense_reason_t
@@ -332,56 +639,88 @@
 		sectors = transport_get_sectors_6(cdb);
 		cmd->t_task_lba = transport_lba_21(cdb);
 		cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
-		cmd->execute_cmd = ops->execute_rw;
+		cmd->execute_rw = ops->execute_rw;
+		cmd->execute_cmd = sbc_execute_rw;
 		break;
 	case READ_10:
 		sectors = transport_get_sectors_10(cdb);
 		cmd->t_task_lba = transport_lba_32(cdb);
+
+		if (!sbc_check_prot(dev, cmd, cdb, sectors))
+			return TCM_UNSUPPORTED_SCSI_OPCODE;
+
 		cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
-		cmd->execute_cmd = ops->execute_rw;
+		cmd->execute_rw = ops->execute_rw;
+		cmd->execute_cmd = sbc_execute_rw;
 		break;
 	case READ_12:
 		sectors = transport_get_sectors_12(cdb);
 		cmd->t_task_lba = transport_lba_32(cdb);
+
+		if (!sbc_check_prot(dev, cmd, cdb, sectors))
+			return TCM_UNSUPPORTED_SCSI_OPCODE;
+
 		cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
-		cmd->execute_cmd = ops->execute_rw;
+		cmd->execute_rw = ops->execute_rw;
+		cmd->execute_cmd = sbc_execute_rw;
 		break;
 	case READ_16:
 		sectors = transport_get_sectors_16(cdb);
 		cmd->t_task_lba = transport_lba_64(cdb);
+
+		if (!sbc_check_prot(dev, cmd, cdb, sectors))
+			return TCM_UNSUPPORTED_SCSI_OPCODE;
+
 		cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
-		cmd->execute_cmd = ops->execute_rw;
+		cmd->execute_rw = ops->execute_rw;
+		cmd->execute_cmd = sbc_execute_rw;
 		break;
 	case WRITE_6:
 		sectors = transport_get_sectors_6(cdb);
 		cmd->t_task_lba = transport_lba_21(cdb);
 		cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
-		cmd->execute_cmd = ops->execute_rw;
+		cmd->execute_rw = ops->execute_rw;
+		cmd->execute_cmd = sbc_execute_rw;
 		break;
 	case WRITE_10:
 	case WRITE_VERIFY:
 		sectors = transport_get_sectors_10(cdb);
 		cmd->t_task_lba = transport_lba_32(cdb);
+
+		if (!sbc_check_prot(dev, cmd, cdb, sectors))
+			return TCM_UNSUPPORTED_SCSI_OPCODE;
+
 		if (cdb[1] & 0x8)
 			cmd->se_cmd_flags |= SCF_FUA;
 		cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
-		cmd->execute_cmd = ops->execute_rw;
+		cmd->execute_rw = ops->execute_rw;
+		cmd->execute_cmd = sbc_execute_rw;
 		break;
 	case WRITE_12:
 		sectors = transport_get_sectors_12(cdb);
 		cmd->t_task_lba = transport_lba_32(cdb);
+
+		if (!sbc_check_prot(dev, cmd, cdb, sectors))
+			return TCM_UNSUPPORTED_SCSI_OPCODE;
+
 		if (cdb[1] & 0x8)
 			cmd->se_cmd_flags |= SCF_FUA;
 		cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
-		cmd->execute_cmd = ops->execute_rw;
+		cmd->execute_rw = ops->execute_rw;
+		cmd->execute_cmd = sbc_execute_rw;
 		break;
 	case WRITE_16:
 		sectors = transport_get_sectors_16(cdb);
 		cmd->t_task_lba = transport_lba_64(cdb);
+
+		if (!sbc_check_prot(dev, cmd, cdb, sectors))
+			return TCM_UNSUPPORTED_SCSI_OPCODE;
+
 		if (cdb[1] & 0x8)
 			cmd->se_cmd_flags |= SCF_FUA;
 		cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB;
-		cmd->execute_cmd = ops->execute_rw;
+		cmd->execute_rw = ops->execute_rw;
+		cmd->execute_cmd = sbc_execute_rw;
 		break;
 	case XDWRITEREAD_10:
 		if (cmd->data_direction != DMA_TO_DEVICE ||
@@ -395,7 +734,8 @@
 		/*
 		 * Setup BIDI XOR callback to be run after I/O completion.
 		 */
-		cmd->execute_cmd = ops->execute_rw;
+		cmd->execute_rw = ops->execute_rw;
+		cmd->execute_cmd = sbc_execute_rw;
 		cmd->transport_complete_callback = &xdreadwrite_callback;
 		if (cdb[1] & 0x8)
 			cmd->se_cmd_flags |= SCF_FUA;
@@ -418,7 +758,8 @@
 			 * Setup BIDI XOR callback to be run during after I/O
 			 * completion.
 			 */
-			cmd->execute_cmd = ops->execute_rw;
+			cmd->execute_rw = ops->execute_rw;
+			cmd->execute_cmd = sbc_execute_rw;
 			cmd->transport_complete_callback = &xdreadwrite_callback;
 			if (cdb[1] & 0x8)
 				cmd->se_cmd_flags |= SCF_FUA;
@@ -445,6 +786,28 @@
 		}
 		break;
 	}
+	case COMPARE_AND_WRITE:
+		sectors = cdb[13];
+		/*
+		 * Currently enforce COMPARE_AND_WRITE for a single sector
+		 */
+		if (sectors > 1) {
+			pr_err("COMPARE_AND_WRITE contains NoLB: %u greater"
+			       " than 1\n", sectors);
+			return TCM_INVALID_CDB_FIELD;
+		}
+		/*
+		 * Double size because we have two buffers, note that
+		 * zero is not an error..
+		 */
+		size = 2 * sbc_get_size(cmd, sectors);
+		cmd->t_task_lba = get_unaligned_be64(&cdb[2]);
+		cmd->t_task_nolb = sectors;
+		cmd->se_cmd_flags |= SCF_SCSI_DATA_CDB | SCF_COMPARE_AND_WRITE;
+		cmd->execute_rw = ops->execute_rw;
+		cmd->execute_cmd = sbc_compare_and_write;
+		cmd->transport_complete_callback = compare_and_write_callback;
+		break;
 	case READ_CAPACITY:
 		size = READ_CAP_LEN;
 		cmd->execute_cmd = sbc_emulate_readcapacity;
@@ -454,6 +817,9 @@
 		case SAI_READ_CAPACITY_16:
 			cmd->execute_cmd = sbc_emulate_readcapacity_16;
 			break;
+		case SAI_REPORT_REFERRALS:
+			cmd->execute_cmd = target_emulate_report_referrals;
+			break;
 		default:
 			pr_err("Unsupported SA: 0x%02x\n",
 				cmd->t_task_cdb[1] & 0x1f);
@@ -562,13 +928,15 @@
 		unsigned long long end_lba;
 
 		end_lba = dev->transport->get_blocks(dev) + 1;
-		if (cmd->t_task_lba + sectors > end_lba) {
+		if (((cmd->t_task_lba + sectors) < cmd->t_task_lba) ||
+		    ((cmd->t_task_lba + sectors) > end_lba)) {
 			pr_err("cmd exceeds last lba %llu "
 				"(lba %llu, sectors %u)\n",
 				end_lba, cmd->t_task_lba, sectors);
-			return TCM_INVALID_CDB_FIELD;
+			return TCM_ADDRESS_OUT_OF_RANGE;
 		}
 
+		if (!(cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE))
 		size = sbc_get_size(cmd, sectors);
 	}
 
@@ -666,3 +1034,195 @@
 	return ret;
 }
 EXPORT_SYMBOL(sbc_execute_unmap);
+
+static sense_reason_t
+sbc_dif_v1_verify(struct se_device *dev, struct se_dif_v1_tuple *sdt,
+		  const void *p, sector_t sector, unsigned int ei_lba)
+{
+	int block_size = dev->dev_attrib.block_size;
+	__be16 csum;
+
+	csum = cpu_to_be16(crc_t10dif(p, block_size));
+
+	if (sdt->guard_tag != csum) {
+		pr_err("DIFv1 checksum failed on sector %llu guard tag 0x%04x"
+			" csum 0x%04x\n", (unsigned long long)sector,
+			be16_to_cpu(sdt->guard_tag), be16_to_cpu(csum));
+		return TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED;
+	}
+
+	if (dev->dev_attrib.pi_prot_type == TARGET_DIF_TYPE1_PROT &&
+	    be32_to_cpu(sdt->ref_tag) != (sector & 0xffffffff)) {
+		pr_err("DIFv1 Type 1 reference failed on sector: %llu tag: 0x%08x"
+		       " sector MSB: 0x%08x\n", (unsigned long long)sector,
+		       be32_to_cpu(sdt->ref_tag), (u32)(sector & 0xffffffff));
+		return TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;
+	}
+
+	if (dev->dev_attrib.pi_prot_type == TARGET_DIF_TYPE2_PROT &&
+	    be32_to_cpu(sdt->ref_tag) != ei_lba) {
+		pr_err("DIFv1 Type 2 reference failed on sector: %llu tag: 0x%08x"
+		       " ei_lba: 0x%08x\n", (unsigned long long)sector,
+			be32_to_cpu(sdt->ref_tag), ei_lba);
+		return TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED;
+	}
+
+	return 0;
+}
+
+static void
+sbc_dif_copy_prot(struct se_cmd *cmd, unsigned int sectors, bool read,
+		  struct scatterlist *sg, int sg_off)
+{
+	struct se_device *dev = cmd->se_dev;
+	struct scatterlist *psg;
+	void *paddr, *addr;
+	unsigned int i, len, left;
+	unsigned int offset = sg_off;
+
+	left = sectors * dev->prot_length;
+
+	for_each_sg(cmd->t_prot_sg, psg, cmd->t_prot_nents, i) {
+		unsigned int psg_len, copied = 0;
+
+		paddr = kmap_atomic(sg_page(psg)) + psg->offset;
+		psg_len = min(left, psg->length);
+		while (psg_len) {
+			len = min(psg_len, sg->length - offset);
+			addr = kmap_atomic(sg_page(sg)) + sg->offset + offset;
+
+			if (read)
+				memcpy(paddr + copied, addr, len);
+			else
+				memcpy(addr, paddr + copied, len);
+
+			left -= len;
+			offset += len;
+			copied += len;
+			psg_len -= len;
+
+			if (offset >= sg->length) {
+				sg = sg_next(sg);
+				offset = 0;
+			}
+			kunmap_atomic(addr);
+		}
+		kunmap_atomic(paddr);
+	}
+}
+
+sense_reason_t
+sbc_dif_verify_write(struct se_cmd *cmd, sector_t start, unsigned int sectors,
+		     unsigned int ei_lba, struct scatterlist *sg, int sg_off)
+{
+	struct se_device *dev = cmd->se_dev;
+	struct se_dif_v1_tuple *sdt;
+	struct scatterlist *dsg, *psg = cmd->t_prot_sg;
+	sector_t sector = start;
+	void *daddr, *paddr;
+	int i, j, offset = 0;
+	sense_reason_t rc;
+
+	for_each_sg(cmd->t_data_sg, dsg, cmd->t_data_nents, i) {
+		daddr = kmap_atomic(sg_page(dsg)) + dsg->offset;
+		paddr = kmap_atomic(sg_page(psg)) + psg->offset;
+
+		for (j = 0; j < dsg->length; j += dev->dev_attrib.block_size) {
+
+			if (offset >= psg->length) {
+				kunmap_atomic(paddr);
+				psg = sg_next(psg);
+				paddr = kmap_atomic(sg_page(psg)) + psg->offset;
+				offset = 0;
+			}
+
+			sdt = paddr + offset;
+
+			pr_debug("DIF WRITE sector: %llu guard_tag: 0x%04x"
+				 " app_tag: 0x%04x ref_tag: %u\n",
+				 (unsigned long long)sector, sdt->guard_tag,
+				 sdt->app_tag, be32_to_cpu(sdt->ref_tag));
+
+			rc = sbc_dif_v1_verify(dev, sdt, daddr + j, sector,
+					       ei_lba);
+			if (rc) {
+				kunmap_atomic(paddr);
+				kunmap_atomic(daddr);
+				cmd->bad_sector = sector;
+				return rc;
+			}
+
+			sector++;
+			ei_lba++;
+			offset += sizeof(struct se_dif_v1_tuple);
+		}
+
+		kunmap_atomic(paddr);
+		kunmap_atomic(daddr);
+	}
+	sbc_dif_copy_prot(cmd, sectors, false, sg, sg_off);
+
+	return 0;
+}
+EXPORT_SYMBOL(sbc_dif_verify_write);
+
+sense_reason_t
+sbc_dif_verify_read(struct se_cmd *cmd, sector_t start, unsigned int sectors,
+		    unsigned int ei_lba, struct scatterlist *sg, int sg_off)
+{
+	struct se_device *dev = cmd->se_dev;
+	struct se_dif_v1_tuple *sdt;
+	struct scatterlist *dsg, *psg = sg;
+	sector_t sector = start;
+	void *daddr, *paddr;
+	int i, j, offset = sg_off;
+	sense_reason_t rc;
+
+	for_each_sg(cmd->t_data_sg, dsg, cmd->t_data_nents, i) {
+		daddr = kmap_atomic(sg_page(dsg)) + dsg->offset;
+		paddr = kmap_atomic(sg_page(psg)) + sg->offset;
+
+		for (j = 0; j < dsg->length; j += dev->dev_attrib.block_size) {
+
+			if (offset >= psg->length) {
+				kunmap_atomic(paddr);
+				psg = sg_next(psg);
+				paddr = kmap_atomic(sg_page(psg)) + psg->offset;
+				offset = 0;
+			}
+
+			sdt = paddr + offset;
+
+			pr_debug("DIF READ sector: %llu guard_tag: 0x%04x"
+				 " app_tag: 0x%04x ref_tag: %u\n",
+				 (unsigned long long)sector, sdt->guard_tag,
+				 sdt->app_tag, be32_to_cpu(sdt->ref_tag));
+
+			if (sdt->app_tag == cpu_to_be16(0xffff)) {
+				sector++;
+				offset += sizeof(struct se_dif_v1_tuple);
+				continue;
+			}
+
+			rc = sbc_dif_v1_verify(dev, sdt, daddr + j, sector,
+					       ei_lba);
+			if (rc) {
+				kunmap_atomic(paddr);
+				kunmap_atomic(daddr);
+				cmd->bad_sector = sector;
+				return rc;
+			}
+
+			sector++;
+			ei_lba++;
+			offset += sizeof(struct se_dif_v1_tuple);
+		}
+
+		kunmap_atomic(paddr);
+		kunmap_atomic(daddr);
+	}
+	sbc_dif_copy_prot(cmd, sectors, true, sg, sg_off);
+
+	return 0;
+}
+EXPORT_SYMBOL(sbc_dif_verify_read);
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_spc.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_spc.c
--- linux-3.10.69/drivers/target/target_core_spc.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_spc.c	2017-05-02 03:31:56.000000000 +0200
@@ -1,7 +1,7 @@
 /*
  * SCSI Primary Commands (SPC) parsing and emulation.
  *
- * (c) Copyright 2002-2012 RisingTide Systems LLC.
+ * (c) Copyright 2002-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -35,7 +35,7 @@
 #include "target_core_alua.h"
 #include "target_core_pr.h"
 #include "target_core_ua.h"
-
+#include "target_core_xcopy.h"
 
 static void spc_fill_alua_data(struct se_port *port, unsigned char *buf)
 {
@@ -48,7 +48,7 @@
 	buf[5]	= 0x80;
 
 	/*
-	 * Set TPGS field for explict and/or implict ALUA access type
+	 * Set TPGS field for explicit and/or implicit ALUA access type
 	 * and opteration.
 	 *
 	 * See spc4r17 section 6.4.2 Table 135
@@ -95,6 +95,17 @@
 	 */
 	spc_fill_alua_data(lun->lun_sep, buf);
 
+	/*
+	 * Set Third-Party Copy (3PC) bit to indicate support for EXTENDED_COPY
+	 */
+	if (dev->dev_attrib.emulate_3pc)
+		buf[5] |= 0x8;
+	/*
+	 * Set Protection (PROTECT) bit when DIF has been enabled.
+	 */
+	if (dev->dev_attrib.pi_prot_type)
+		buf[5] |= 0x1;
+
 	buf[7] = 0x2; /* CmdQue=1 */
 
 	memcpy(&buf[8], "LIO-ORG ", 8);
@@ -129,7 +140,7 @@
 	return 0;
 }
 
-static void spc_parse_naa_6h_vendor_specific(struct se_device *dev,
+void spc_parse_naa_6h_vendor_specific(struct se_device *dev,
 		unsigned char *buf)
 {
 	unsigned char *p = &dev->t10_wwn.unit_serial[0];
@@ -261,7 +272,7 @@
 	port = lun->lun_sep;
 	if (port) {
 		struct t10_alua_lu_gp *lu_gp;
-		u32 padding, scsi_name_len;
+		u32 padding, scsi_name_len, scsi_target_len;
 		u16 lu_gp_id = 0;
 		u16 tg_pt_gp_id = 0;
 		u16 tpgt;
@@ -359,16 +370,6 @@
 		 * section 7.5.1 Table 362
 		 */
 check_scsi_name:
-		scsi_name_len = strlen(tpg->se_tpg_tfo->tpg_get_wwn(tpg));
-		/* UTF-8 ",t,0x<16-bit TPGT>" + NULL Terminator */
-		scsi_name_len += 10;
-		/* Check for 4-byte padding */
-		padding = ((-scsi_name_len) & 3);
-		if (padding != 0)
-			scsi_name_len += padding;
-		/* Header size + Designation descriptor */
-		scsi_name_len += 4;
-
 		buf[off] =
 			(tpg->se_tpg_tfo->get_fabric_proto_ident(tpg) << 4);
 		buf[off++] |= 0x3; /* CODE SET == UTF-8 */
@@ -396,13 +397,57 @@
 		 * shall be no larger than 256 and shall be a multiple
 		 * of four.
 		 */
+		padding = ((-scsi_name_len) & 3);
 		if (padding)
 			scsi_name_len += padding;
+		if (scsi_name_len > 256)
+			scsi_name_len = 256;
 
 		buf[off-1] = scsi_name_len;
 		off += scsi_name_len;
 		/* Header size + Designation descriptor */
 		len += (scsi_name_len + 4);
+
+		/*
+		 * Target device designator
+		 */
+		buf[off] =
+			(tpg->se_tpg_tfo->get_fabric_proto_ident(tpg) << 4);
+		buf[off++] |= 0x3; /* CODE SET == UTF-8 */
+		buf[off] = 0x80; /* Set PIV=1 */
+		/* Set ASSOCIATION == target device: 10b */
+		buf[off] |= 0x20;
+		/* DESIGNATOR TYPE == SCSI name string */
+		buf[off++] |= 0x8;
+		off += 2; /* Skip over Reserved and length */
+		/*
+		 * SCSI name string identifer containing, $FABRIC_MOD
+		 * dependent information.  For LIO-Target and iSCSI
+		 * Target Port, this means "<iSCSI name>" in
+		 * UTF-8 encoding.
+		 */
+		scsi_target_len = sprintf(&buf[off], "%s",
+					  tpg->se_tpg_tfo->tpg_get_wwn(tpg));
+		scsi_target_len += 1 /* Include  NULL terminator */;
+		/*
+		 * The null-terminated, null-padded (see 4.4.2) SCSI
+		 * NAME STRING field contains a UTF-8 format string.
+		 * The number of bytes in the SCSI NAME STRING field
+		 * (i.e., the value in the DESIGNATOR LENGTH field)
+		 * shall be no larger than 256 and shall be a multiple
+		 * of four.
+		 */
+		padding = ((-scsi_target_len) & 3);
+		if (padding)
+			scsi_target_len += padding;
+		if (scsi_target_len > 256)
+			scsi_target_len = 256;
+
+		buf[off-1] = scsi_target_len;
+		off += scsi_target_len;
+
+		/* Header size + Designation descriptor */
+		len += (scsi_target_len + 4);
 	}
 	buf[2] = ((len >> 8) & 0xff);
 	buf[3] = (len & 0xff); /* Page Length for VPD 0x83 */
@@ -430,12 +475,26 @@
 	struct se_device *dev = cmd->se_dev;
 
 	buf[3] = 0x3c;
+	/*
+	 * Set GRD_CHK + REF_CHK for TYPE1 protection, or GRD_CHK
+	 * only for TYPE3 protection.
+	 */
+	if (dev->dev_attrib.pi_prot_type == TARGET_DIF_TYPE1_PROT)
+		buf[4] = 0x5;
+	else if (dev->dev_attrib.pi_prot_type == TARGET_DIF_TYPE3_PROT)
+		buf[4] = 0x4;
+
 	/* Set HEADSUP, ORDSUP, SIMPSUP */
 	buf[5] = 0x07;
 
 	/* If WriteCache emulation is enabled, set V_SUP */
 	if (spc_check_dev_wce(dev))
 		buf[6] = 0x01;
+	/* If an LBA map is present set R_SUP */
+	spin_lock(&cmd->se_dev->t10_alua.lba_map_lock);
+	if (!list_empty(&dev->t10_alua.lba_map_list))
+		buf[8] = 0x10;
+	spin_unlock(&cmd->se_dev->t10_alua.lba_map_lock);
 	return 0;
 }
 
@@ -445,6 +504,7 @@
 {
 	struct se_device *dev = cmd->se_dev;
 	int have_tp = 0;
+	int opt, min;
 
 	/*
 	 * Following spc3r22 section 6.5.3 Block Limits VPD page, when
@@ -459,10 +519,18 @@
 
 	/* Set WSNZ to 1 */
 	buf[4] = 0x01;
+	/*
+	 * Set MAXIMUM COMPARE AND WRITE LENGTH
+	 */
+	if (dev->dev_attrib.emulate_caw)
+		buf[5] = 0x01;
 
 	/*
 	 * Set OPTIMAL TRANSFER LENGTH GRANULARITY
 	 */
+	if (dev->transport->get_io_min && (min = dev->transport->get_io_min(dev)))
+		put_unaligned_be16(min / dev->dev_attrib.block_size, &buf[6]);
+	else
 	put_unaligned_be16(1, &buf[6]);
 
 	/*
@@ -473,6 +541,9 @@
 	/*
 	 * Set OPTIMAL TRANSFER LENGTH
 	 */
+	if (dev->transport->get_io_opt && (opt = dev->transport->get_io_opt(dev)))
+		put_unaligned_be32(opt / dev->dev_attrib.block_size, &buf[12]);
+	else
 	put_unaligned_be32(dev->dev_attrib.optimal_sectors, &buf[12]);
 
 	/*
@@ -579,6 +650,20 @@
 	return 0;
 }
 
+/* Referrals VPD page */
+static sense_reason_t
+spc_emulate_evpd_b3(struct se_cmd *cmd, unsigned char *buf)
+{
+	struct se_device *dev = cmd->se_dev;
+
+	buf[0] = dev->transport->get_device_type(dev);
+	buf[3] = 0x0c;
+	put_unaligned_be32(dev->t10_alua.lba_map_segment_size, &buf[8]);
+	put_unaligned_be32(dev->t10_alua.lba_map_segment_size, &buf[12]);
+
+	return 0;
+}
+
 static sense_reason_t
 spc_emulate_evpd_00(struct se_cmd *cmd, unsigned char *buf);
 
@@ -593,6 +678,7 @@
 	{ .page = 0xb0, .emulate = spc_emulate_evpd_b0 },
 	{ .page = 0xb1, .emulate = spc_emulate_evpd_b1 },
 	{ .page = 0xb2, .emulate = spc_emulate_evpd_b2 },
+	{ .page = 0xb3, .emulate = spc_emulate_evpd_b3 },
 };
 
 /* supported vital product data pages */
@@ -622,12 +708,16 @@
 	struct se_portal_group *tpg = cmd->se_lun->lun_sep->sep_tpg;
 	unsigned char *rbuf;
 	unsigned char *cdb = cmd->t_task_cdb;
-	unsigned char buf[SE_INQUIRY_BUF];
+	unsigned char *buf;
 	sense_reason_t ret;
 	int p;
 	int len = 0;
 
-	memset(buf, 0, SE_INQUIRY_BUF);
+	buf = kzalloc(SE_INQUIRY_BUF, GFP_KERNEL);
+	if (!buf) {
+		pr_err("Unable to allocate response buffer for INQUIRY\n");
+		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+	}
 
 	if (dev == tpg->tpg_virt_lun0.lun_se_dev)
 		buf[0] = 0x3f; /* Not connected */
@@ -662,9 +752,10 @@
 out:
 	rbuf = transport_kmap_data_sg(cmd);
 	if (rbuf) {
-		memcpy(rbuf, buf, min_t(u32, sizeof(buf), cmd->data_length));
+		memcpy(rbuf, buf, min_t(u32, SE_INQUIRY_BUF, cmd->data_length));
 		transport_kunmap_data_sg(cmd);
 	}
+	kfree(buf);
 
 	if (!ret)
 		target_complete_cmd_with_length(cmd, GOOD, len);
@@ -767,6 +858,19 @@
 	 * status (see SAM-4).
 	 */
 	p[5] = (dev->dev_attrib.emulate_tas) ? 0x40 : 0x00;
+	/*
+	 * From spc4r30, section 7.5.7 Control mode page
+	 *
+	 * Application Tag Owner (ATO) bit set to one.
+	 *
+	 * If the ATO bit is set to one the device server shall not modify the
+	 * LOGICAL BLOCK APPLICATION TAG field and, depending on the protection
+	 * type, shall not modify the contents of the LOGICAL BLOCK REFERENCE
+	 * TAG field.
+	 */
+	if (dev->dev_attrib.pi_prot_type)
+		p[5] |= 0x80;
+
 	p[8] = 0xff;
 	p[9] = 0xff;
 	p[11] = 30;
@@ -1239,7 +1343,7 @@
 		*size = (cdb[3] << 8) + cdb[4];
 
 		/*
-		 * Do implict HEAD_OF_QUEUE processing for INQUIRY.
+		 * Do implicit HEAD_OF_QUEUE processing for INQUIRY.
 		 * See spc4r17 section 5.3
 		 */
 		cmd->sam_task_attr = MSG_HEAD_TAG;
@@ -1250,8 +1354,14 @@
 		*size = (cdb[6] << 24) | (cdb[7] << 16) | (cdb[8] << 8) | cdb[9];
 		break;
 	case EXTENDED_COPY:
-	case READ_ATTRIBUTE:
+		*size = get_unaligned_be32(&cdb[10]);
+		cmd->execute_cmd = target_do_xcopy;
+		break;
 	case RECEIVE_COPY_RESULTS:
+		*size = get_unaligned_be32(&cdb[10]);
+		cmd->execute_cmd = target_do_receive_copy_results;
+		break;
+	case READ_ATTRIBUTE:
 	case WRITE_ATTRIBUTE:
 		*size = (cdb[10] << 24) | (cdb[11] << 16) |
 		       (cdb[12] << 8) | cdb[13];
@@ -1267,7 +1377,7 @@
 		cmd->execute_cmd = spc_emulate_report_luns;
 		*size = (cdb[6] << 24) | (cdb[7] << 16) | (cdb[8] << 8) | cdb[9];
 		/*
-		 * Do implict HEAD_OF_QUEUE processing for REPORT_LUNS
+		 * Do implicit HEAD_OF_QUEUE processing for REPORT_LUNS
 		 * See spc4r17 section 5.3
 		 */
 		cmd->sam_task_attr = MSG_HEAD_TAG;
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_stat.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_stat.c
--- linux-3.10.69/drivers/target/target_core_stat.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_stat.c	2017-05-02 03:31:56.000000000 +0200
@@ -4,7 +4,7 @@
  * Modern ConfigFS group context specific statistics based on original
  * target_core_mib.c code
  *
- * (c) Copyright 2006-2012 RisingTide Systems LLC.
+ * (c) Copyright 2006-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@linux-iscsi.org>
  *
@@ -32,7 +32,6 @@
 #include <linux/utsname.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
-#include <linux/blkdev.h>
 #include <linux/configfs.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_device.h>
@@ -214,7 +213,8 @@
 	struct se_device *dev =
 		container_of(sgrps, struct se_device, dev_stat_grps);
 
-	return snprintf(page, PAGE_SIZE, "%u\n", dev->num_resets);
+	return snprintf(page, PAGE_SIZE, "%lu\n",
+			atomic_long_read(&dev->num_resets));
 }
 DEV_STAT_SCSI_TGT_DEV_ATTR_RO(resets);
 
@@ -397,8 +397,8 @@
 		container_of(sgrps, struct se_device, dev_stat_grps);
 
 	/* scsiLuNumCommands */
-	return snprintf(page, PAGE_SIZE, "%llu\n",
-			(unsigned long long)dev->num_cmds);
+	return snprintf(page, PAGE_SIZE, "%lu\n",
+			atomic_long_read(&dev->num_cmds));
 }
 DEV_STAT_SCSI_LU_ATTR_RO(num_cmds);
 
@@ -409,7 +409,8 @@
 		container_of(sgrps, struct se_device, dev_stat_grps);
 
 	/* scsiLuReadMegaBytes */
-	return snprintf(page, PAGE_SIZE, "%u\n", (u32)(dev->read_bytes >> 20));
+	return snprintf(page, PAGE_SIZE, "%lu\n",
+			atomic_long_read(&dev->read_bytes) >> 20);
 }
 DEV_STAT_SCSI_LU_ATTR_RO(read_mbytes);
 
@@ -420,7 +421,8 @@
 		container_of(sgrps, struct se_device, dev_stat_grps);
 
 	/* scsiLuWrittenMegaBytes */
-	return snprintf(page, PAGE_SIZE, "%u\n", (u32)(dev->write_bytes >> 20));
+	return snprintf(page, PAGE_SIZE, "%lu\n",
+			atomic_long_read(&dev->write_bytes) >> 20);
 }
 DEV_STAT_SCSI_LU_ATTR_RO(write_mbytes);
 
@@ -431,7 +433,7 @@
 		container_of(sgrps, struct se_device, dev_stat_grps);
 
 	/* scsiLuInResets */
-	return snprintf(page, PAGE_SIZE, "%u\n", dev->num_resets);
+	return snprintf(page, PAGE_SIZE, "%lu\n", atomic_long_read(&dev->num_resets));
 }
 DEV_STAT_SCSI_LU_ATTR_RO(resets);
 
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_tmr.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_tmr.c
--- linux-3.10.69/drivers/target/target_core_tmr.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_tmr.c	2017-05-02 03:31:56.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * This file contains SPC-3 task management infrastructure
  *
- * (c) Copyright 2009-2012 RisingTide Systems LLC.
+ * (c) Copyright 2009-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -85,13 +85,8 @@
 static void core_tmr_handle_tas_abort(
 	struct se_node_acl *tmr_nacl,
 	struct se_cmd *cmd,
-	int tas,
-	int fe_count)
+	int tas)
 {
-	if (!fe_count) {
-		transport_cmd_finish_abort(cmd, 1);
-		return;
-	}
 	/*
 	 * TASK ABORTED status (TAS) bit support
 	*/
@@ -253,7 +248,6 @@
 	LIST_HEAD(drain_task_list);
 	struct se_cmd *cmd, *next;
 	unsigned long flags;
-	int fe_count;
 
 	/*
 	 * Complete outstanding commands with TASK_ABORTED SAM status.
@@ -329,12 +323,10 @@
 		spin_lock_irqsave(&cmd->t_state_lock, flags);
 		target_stop_cmd(cmd, &flags);
 
-		fe_count = atomic_read(&cmd->t_fe_count);
-
 		cmd->transport_state |= CMD_T_ABORTED;
 		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 
-		core_tmr_handle_tas_abort(tmr_nacl, cmd, tas, fe_count);
+		core_tmr_handle_tas_abort(tmr_nacl, cmd, tas);
 	}
 }
 
@@ -394,9 +386,7 @@
 		pr_debug("LUN_RESET: SCSI-2 Released reservation\n");
 	}
 
-	spin_lock_irq(&dev->stats_lock);
-	dev->num_resets++;
-	spin_unlock_irq(&dev->stats_lock);
+	atomic_long_inc(&dev->num_resets);
 
 	pr_debug("LUN_RESET: %s for [%s] Complete\n",
 			(preempt_and_abort_list) ? "Preempt" : "TMR",
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_tpg.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_tpg.c
--- linux-3.10.69/drivers/target/target_core_tpg.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_tpg.c	2017-05-02 03:31:56.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * This file contains generic Target Portal Group related functions.
  *
- * (c) Copyright 2002-2012 RisingTide Systems LLC.
+ * (c) Copyright 2002-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -117,6 +117,7 @@
 
 	return acl;
 }
+EXPORT_SYMBOL(core_tpg_get_initiator_node_acl);
 
 /*	core_tpg_add_node_to_devs():
  *
@@ -285,7 +286,6 @@
 	snprintf(acl->initiatorname, TRANSPORT_IQN_LEN, "%s", initiatorname);
 	acl->se_tpg = tpg;
 	acl->acl_index = scsi_get_new_index(SCSI_AUTH_INTR_INDEX);
-	spin_lock_init(&acl->stats_lock);
 	acl->dynamic_node_acl = 1;
 
 	tpg->se_tpg_tfo->set_default_node_attributes(acl);
@@ -413,7 +413,6 @@
 	snprintf(acl->initiatorname, TRANSPORT_IQN_LEN, "%s", initiatorname);
 	acl->se_tpg = tpg;
 	acl->acl_index = scsi_get_new_index(SCSI_AUTH_INTR_INDEX);
-	spin_lock_init(&acl->stats_lock);
 
 	tpg->se_tpg_tfo->set_default_node_attributes(acl);
 
@@ -641,6 +640,13 @@
 }
 EXPORT_SYMBOL(core_tpg_set_initiator_node_tag);
 
+static void core_tpg_lun_ref_release(struct percpu_ref *ref)
+{
+	struct se_lun *lun = container_of(ref, struct se_lun, lun_ref);
+
+	complete(&lun->lun_ref_comp);
+}
+
 static int core_tpg_setup_virtual_lun0(struct se_portal_group *se_tpg)
 {
 	/* Set in core_dev_setup_virtual_lun0() */
@@ -654,12 +660,11 @@
 	atomic_set(&lun->lun_acl_count, 0);
 	init_completion(&lun->lun_shutdown_comp);
 	INIT_LIST_HEAD(&lun->lun_acl_list);
-	INIT_LIST_HEAD(&lun->lun_cmd_list);
 	spin_lock_init(&lun->lun_acl_lock);
-	spin_lock_init(&lun->lun_cmd_lock);
 	spin_lock_init(&lun->lun_sep_lock);
+	init_completion(&lun->lun_ref_comp);
 
-	ret = core_tpg_post_addlun(se_tpg, lun, lun_access, dev);
+	ret = core_tpg_add_lun(se_tpg, lun, lun_access, dev);
 	if (ret < 0)
 		return ret;
 
@@ -699,10 +704,9 @@
 		atomic_set(&lun->lun_acl_count, 0);
 		init_completion(&lun->lun_shutdown_comp);
 		INIT_LIST_HEAD(&lun->lun_acl_list);
-		INIT_LIST_HEAD(&lun->lun_cmd_list);
 		spin_lock_init(&lun->lun_acl_lock);
-		spin_lock_init(&lun->lun_cmd_lock);
 		spin_lock_init(&lun->lun_sep_lock);
+		init_completion(&lun->lun_ref_comp);
 	}
 
 	se_tpg->se_tpg_type = se_tpg_type;
@@ -785,7 +789,7 @@
 }
 EXPORT_SYMBOL(core_tpg_deregister);
 
-struct se_lun *core_tpg_pre_addlun(
+struct se_lun *core_tpg_alloc_lun(
 	struct se_portal_group *tpg,
 	u32 unpacked_lun)
 {
@@ -815,18 +819,24 @@
 	return lun;
 }
 
-int core_tpg_post_addlun(
+int core_tpg_add_lun(
 	struct se_portal_group *tpg,
 	struct se_lun *lun,
 	u32 lun_access,
-	void *lun_ptr)
+	struct se_device *dev)
 {
 	int ret;
 
-	ret = core_dev_export(lun_ptr, tpg, lun);
+	ret = percpu_ref_init(&lun->lun_ref, core_tpg_lun_ref_release);
 	if (ret < 0)
 		return ret;
 
+	ret = core_dev_export(dev, tpg, lun);
+	if (ret < 0) {
+		percpu_ref_cancel_init(&lun->lun_ref);
+		return ret;
+	}
+
 	spin_lock(&tpg->tpg_lun_lock);
 	lun->lun_access = lun_access;
 	lun->lun_status = TRANSPORT_LUN_STATUS_ACTIVE;
@@ -835,14 +845,6 @@
 	return 0;
 }
 
-static void core_tpg_shutdown_lun(
-	struct se_portal_group *tpg,
-	struct se_lun *lun)
-{
-	core_clear_lun_from_tpg(lun, tpg);
-	transport_clear_lun_from_sessions(lun);
-}
-
 struct se_lun *core_tpg_pre_dellun(
 	struct se_portal_group *tpg,
 	u32 unpacked_lun)
@@ -877,7 +879,8 @@
 	struct se_portal_group *tpg,
 	struct se_lun *lun)
 {
-	core_tpg_shutdown_lun(tpg, lun);
+	core_clear_lun_from_tpg(lun, tpg);
+	transport_clear_lun_ref(lun);
 
 	core_dev_unexport(lun->lun_se_dev, tpg, lun);
 
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_transport.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_transport.c
--- linux-3.10.69/drivers/target/target_core_transport.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_transport.c	2017-05-02 03:31:56.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * This file contains the Generic Target Engine Core.
  *
- * (c) Copyright 2002-2012 RisingTide Systems LLC.
+ * (c) Copyright 2002-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -28,7 +28,6 @@
 #include <linux/string.h>
 #include <linux/timer.h>
 #include <linux/slab.h>
-#include <linux/blkdev.h>
 #include <linux/spinlock.h>
 #include <linux/kthread.h>
 #include <linux/in.h>
@@ -52,6 +51,9 @@
 #include "target_core_pr.h"
 #include "target_core_ua.h"
 
+#define CREATE_TRACE_POINTS
+#include <trace/events/target.h>
+
 static struct workqueue_struct *target_completion_wq;
 static struct kmem_cache *se_sess_cache;
 struct kmem_cache *se_ua_cache;
@@ -60,11 +62,12 @@
 struct kmem_cache *t10_alua_lu_gp_mem_cache;
 struct kmem_cache *t10_alua_tg_pt_gp_cache;
 struct kmem_cache *t10_alua_tg_pt_gp_mem_cache;
+struct kmem_cache *t10_alua_lba_map_cache;
+struct kmem_cache *t10_alua_lba_map_mem_cache;
 
 static void transport_complete_task_attr(struct se_cmd *cmd);
 static void transport_handle_queue_full(struct se_cmd *cmd,
 		struct se_device *dev);
-static int transport_generic_get_mem(struct se_cmd *cmd);
 static int transport_put_cmd(struct se_cmd *cmd);
 static void target_complete_ok_work(struct work_struct *work);
 
@@ -127,14 +130,36 @@
 				"mem_t failed\n");
 		goto out_free_tg_pt_gp_cache;
 	}
+	t10_alua_lba_map_cache = kmem_cache_create(
+			"t10_alua_lba_map_cache",
+			sizeof(struct t10_alua_lba_map),
+			__alignof__(struct t10_alua_lba_map), 0, NULL);
+	if (!t10_alua_lba_map_cache) {
+		pr_err("kmem_cache_create() for t10_alua_lba_map_"
+				"cache failed\n");
+		goto out_free_tg_pt_gp_mem_cache;
+	}
+	t10_alua_lba_map_mem_cache = kmem_cache_create(
+			"t10_alua_lba_map_mem_cache",
+			sizeof(struct t10_alua_lba_map_member),
+			__alignof__(struct t10_alua_lba_map_member), 0, NULL);
+	if (!t10_alua_lba_map_mem_cache) {
+		pr_err("kmem_cache_create() for t10_alua_lba_map_mem_"
+				"cache failed\n");
+		goto out_free_lba_map_cache;
+	}
 
 	target_completion_wq = alloc_workqueue("target_completion",
 					       WQ_MEM_RECLAIM, 0);
 	if (!target_completion_wq)
-		goto out_free_tg_pt_gp_mem_cache;
+		goto out_free_lba_map_mem_cache;
 
 	return 0;
 
+out_free_lba_map_mem_cache:
+	kmem_cache_destroy(t10_alua_lba_map_mem_cache);
+out_free_lba_map_cache:
+	kmem_cache_destroy(t10_alua_lba_map_cache);
 out_free_tg_pt_gp_mem_cache:
 	kmem_cache_destroy(t10_alua_tg_pt_gp_mem_cache);
 out_free_tg_pt_gp_cache:
@@ -163,6 +188,8 @@
 	kmem_cache_destroy(t10_alua_lu_gp_mem_cache);
 	kmem_cache_destroy(t10_alua_tg_pt_gp_cache);
 	kmem_cache_destroy(t10_alua_tg_pt_gp_mem_cache);
+	kmem_cache_destroy(t10_alua_lba_map_cache);
+	kmem_cache_destroy(t10_alua_lba_map_mem_cache);
 }
 
 /* This code ensures unique mib indexes are handed out. */
@@ -229,6 +256,57 @@
 }
 EXPORT_SYMBOL(transport_init_session);
 
+int transport_alloc_session_tags(struct se_session *se_sess,
+			         unsigned int tag_num, unsigned int tag_size)
+{
+	int rc;
+
+	se_sess->sess_cmd_map = kzalloc(tag_num * tag_size,
+					GFP_KERNEL | __GFP_NOWARN | __GFP_REPEAT);
+	if (!se_sess->sess_cmd_map) {
+		se_sess->sess_cmd_map = vzalloc(tag_num * tag_size);
+		if (!se_sess->sess_cmd_map) {
+			pr_err("Unable to allocate se_sess->sess_cmd_map\n");
+			return -ENOMEM;
+		}
+	}
+
+	rc = percpu_ida_init(&se_sess->sess_tag_pool, tag_num);
+	if (rc < 0) {
+		pr_err("Unable to init se_sess->sess_tag_pool,"
+			" tag_num: %u\n", tag_num);
+		if (is_vmalloc_addr(se_sess->sess_cmd_map))
+			vfree(se_sess->sess_cmd_map);
+		else
+			kfree(se_sess->sess_cmd_map);
+		se_sess->sess_cmd_map = NULL;
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(transport_alloc_session_tags);
+
+struct se_session *transport_init_session_tags(unsigned int tag_num,
+					       unsigned int tag_size)
+{
+	struct se_session *se_sess;
+	int rc;
+
+	se_sess = transport_init_session();
+	if (IS_ERR(se_sess))
+		return se_sess;
+
+	rc = transport_alloc_session_tags(se_sess, tag_num, tag_size);
+	if (rc < 0) {
+		transport_free_session(se_sess);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	return se_sess;
+}
+EXPORT_SYMBOL(transport_init_session_tags);
+
 /*
  * Called with spin_lock_irqsave(&struct se_portal_group->session_lock called.
  */
@@ -364,6 +442,13 @@
 
 void transport_free_session(struct se_session *se_sess)
 {
+	if (se_sess->sess_cmd_map) {
+		percpu_ida_destroy(&se_sess->sess_tag_pool);
+		if (is_vmalloc_addr(se_sess->sess_cmd_map))
+			vfree(se_sess->sess_cmd_map);
+		else
+			kfree(se_sess->sess_cmd_map);
+	}
 	kmem_cache_free(se_sess_cache, se_sess);
 }
 EXPORT_SYMBOL(transport_free_session);
@@ -413,7 +498,7 @@
 	pr_debug("TARGET_CORE[%s]: Deregistered fabric_sess\n",
 		se_tpg->se_tpg_tfo->get_fabric_name());
 	/*
-	 * If last kref is dropping now for an explict NodeACL, awake sleeping
+	 * If last kref is dropping now for an explicit NodeACL, awake sleeping
 	 * ->acl_free_comp caller to wakeup configfs se_node_acl->acl_group
 	 * removal context.
 	 */
@@ -446,27 +531,14 @@
 	spin_unlock_irqrestore(&dev->execute_task_lock, flags);
 }
 
-static int transport_cmd_check_stop(struct se_cmd *cmd, bool remove_from_lists)
+static int transport_cmd_check_stop(struct se_cmd *cmd, bool remove_from_lists,
+				    bool write_pending)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&cmd->t_state_lock, flags);
-	/*
-	 * Determine if IOCTL context caller in requesting the stopping of this
-	 * command for LUN shutdown purposes.
-	 */
-	if (cmd->transport_state & CMD_T_LUN_STOP) {
-		pr_debug("%s:%d CMD_T_LUN_STOP for ITT: 0x%08x\n",
-			__func__, __LINE__, cmd->se_tfo->get_task_tag(cmd));
-
-		cmd->transport_state &= ~CMD_T_ACTIVE;
-		if (remove_from_lists)
-			target_remove_from_state_list(cmd);
-		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
-
-		complete(&cmd->transport_lun_stop_comp);
-		return 1;
-	}
+	if (write_pending)
+		cmd->t_state = TRANSPORT_WRITE_PENDING;
 
 	if (remove_from_lists) {
 		target_remove_from_state_list(cmd);
@@ -515,28 +587,18 @@
 
 static int transport_cmd_check_stop_to_fabric(struct se_cmd *cmd)
 {
-	return transport_cmd_check_stop(cmd, true);
+	return transport_cmd_check_stop(cmd, true, false);
 }
 
 static void transport_lun_remove_cmd(struct se_cmd *cmd)
 {
 	struct se_lun *lun = cmd->se_lun;
-	unsigned long flags;
 
 	if (!lun)
 		return;
 
-	spin_lock_irqsave(&cmd->t_state_lock, flags);
-	if (cmd->transport_state & CMD_T_DEV_ACTIVE) {
-		cmd->transport_state &= ~CMD_T_DEV_ACTIVE;
-		target_remove_from_state_list(cmd);
-	}
-	spin_unlock_irqrestore(&cmd->t_state_lock, flags);
-
-	spin_lock_irqsave(&lun->lun_cmd_lock, flags);
-	if (!list_empty(&cmd->se_lun_node))
-		list_del_init(&cmd->se_lun_node);
-	spin_unlock_irqrestore(&lun->lun_cmd_lock, flags);
+	if (cmpxchg(&cmd->lun_ref_active, true, false))
+		percpu_ref_put(&lun->lun_ref);
 }
 
 void transport_cmd_finish_abort(struct se_cmd *cmd, int remove)
@@ -607,11 +669,8 @@
 		return;
 	}
 
-	if (!success)
-		cmd->transport_state |= CMD_T_FAILED;
-
 	/*
-	 * Check for case where an explict ABORT_TASK has been received
+	 * Check for case where an explicit ABORT_TASK has been received
 	 * and transport_wait_for_tasks() will be waiting for completion..
 	 */
 	if (cmd->transport_state & CMD_T_ABORTED &&
@@ -619,7 +678,7 @@
 		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 		complete_all(&cmd->t_transport_stop_comp);
 		return;
-	} else if (cmd->transport_state & CMD_T_FAILED) {
+	} else if (!success) {
 		INIT_WORK(&cmd->work, target_complete_failure_work);
 	} else {
 		INIT_WORK(&cmd->work, target_complete_ok_work);
@@ -1052,17 +1111,15 @@
 	int task_attr,
 	unsigned char *sense_buffer)
 {
-	INIT_LIST_HEAD(&cmd->se_lun_node);
 	INIT_LIST_HEAD(&cmd->se_delayed_node);
 	INIT_LIST_HEAD(&cmd->se_qf_node);
 	INIT_LIST_HEAD(&cmd->se_cmd_list);
 	INIT_LIST_HEAD(&cmd->state_list);
-	init_completion(&cmd->transport_lun_fe_stop_comp);
-	init_completion(&cmd->transport_lun_stop_comp);
 	init_completion(&cmd->t_transport_stop_comp);
 	init_completion(&cmd->cmd_wait_comp);
 	init_completion(&cmd->task_stop_comp);
 	spin_lock_init(&cmd->t_state_lock);
+	kref_init(&cmd->cmd_kref);
 	cmd->transport_state = CMD_T_DEV_ACTIVE;
 
 	cmd->se_tfo = tfo;
@@ -1109,7 +1166,6 @@
 target_setup_cmd_from_cdb(struct se_cmd *cmd, unsigned char *cdb)
 {
 	struct se_device *dev = cmd->se_dev;
-	unsigned long flags;
 	sense_reason_t ret;
 
 	/*
@@ -1144,6 +1200,8 @@
 	 */
 	memcpy(cmd->t_task_cdb, cdb, scsi_command_size(cdb));
 
+	trace_target_sequencer_start(cmd);
+
 	/*
 	 * Check for an existing UNIT ATTENTION condition
 	 */
@@ -1169,9 +1227,7 @@
 	if (ret)
 		return ret;
 
-	spin_lock_irqsave(&cmd->t_state_lock, flags);
 	cmd->se_cmd_flags |= SCF_SUPPORTED_SAM_OPCODE;
-	spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 
 	spin_lock(&cmd->se_lun->lun_sep_lock);
 	if (cmd->se_lun->lun_sep)
@@ -1224,7 +1280,7 @@
 }
 EXPORT_SYMBOL(transport_handle_cdb_direct);
 
-static sense_reason_t
+sense_reason_t
 transport_generic_map_mem_to_cmd(struct se_cmd *cmd, struct scatterlist *sgl,
 		u32 sgl_count, struct scatterlist *sgl_bidi, u32 sgl_bidi_count)
 {
@@ -1270,6 +1326,8 @@
  * @sgl_count: scatterlist count for unidirectional mapping
  * @sgl_bidi: struct scatterlist memory for bidirectional READ mapping
  * @sgl_bidi_count: scatterlist count for bidirectional READ mapping
+ * @sgl_prot: struct scatterlist memory protection information
+ * @sgl_prot_count: scatterlist count for protection information
  *
  * Returns non zero to signal active I/O shutdown failure.  All other
  * setup exceptions will be returned as a SCSI CHECK_CONDITION response,
@@ -1282,7 +1340,8 @@
 		unsigned char *cdb, unsigned char *sense, u32 unpacked_lun,
 		u32 data_length, int task_attr, int data_dir, int flags,
 		struct scatterlist *sgl, u32 sgl_count,
-		struct scatterlist *sgl_bidi, u32 sgl_bidi_count)
+		struct scatterlist *sgl_bidi, u32 sgl_bidi_count,
+		struct scatterlist *sgl_prot, u32 sgl_prot_count)
 {
 	struct se_portal_group *se_tpg;
 	sense_reason_t rc;
@@ -1324,6 +1383,14 @@
 		target_put_sess_cmd(se_sess, se_cmd);
 		return 0;
 	}
+	/*
+	 * Save pointers for SGLs containing protection information,
+	 * if present.
+	 */
+	if (sgl_prot_count) {
+		se_cmd->t_prot_sg = sgl_prot;
+		se_cmd->t_prot_nents = sgl_prot_count;
+	}
 
 	rc = target_setup_cmd_from_cdb(se_cmd, cdb);
 	if (rc != 0) {
@@ -1405,7 +1473,7 @@
 {
 	return target_submit_cmd_map_sgls(se_cmd, se_sess, cdb, sense,
 			unpacked_lun, data_length, task_attr, data_dir,
-			flags, NULL, 0, NULL, 0);
+			flags, NULL, 0, NULL, 0, NULL, 0);
 }
 EXPORT_SYMBOL(target_submit_cmd);
 
@@ -1530,6 +1598,13 @@
 	 * For SAM Task Attribute emulation for failed struct se_cmd
 	 */
 	transport_complete_task_attr(cmd);
+	/*
+	 * Handle special case for COMPARE_AND_WRITE failure, where the
+	 * callback is expected to drop the per device ->caw_sem.
+	 */
+	if ((cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) &&
+	     cmd->transport_complete_callback)
+		cmd->transport_complete_callback(cmd, false);
 
 	switch (sense_reason) {
 	case TCM_NON_EXISTENT_LUN:
@@ -1544,6 +1619,9 @@
 	case TCM_CHECK_CONDITION_ABORT_CMD:
 	case TCM_CHECK_CONDITION_UNIT_ATTENTION:
 	case TCM_CHECK_CONDITION_NOT_READY:
+	case TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED:
+	case TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED:
+	case TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED:
 		break;
 	case TCM_OUT_OF_RESOURCES:
 		sense_reason = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
@@ -1569,7 +1647,8 @@
 				cmd->orig_fe_lun, 0x2C,
 				ASCQ_2CH_PREVIOUS_RESERVATION_CONFLICT_STATUS);
 
-		ret = cmd->se_tfo->queue_status(cmd);
+		trace_target_cmd_complete(cmd);
+		ret = cmd->se_tfo-> queue_status(cmd);
 		if (ret == -EAGAIN || ret == -ENOMEM)
 			goto queue_full;
 		goto check_stop;
@@ -1596,14 +1675,10 @@
 }
 EXPORT_SYMBOL(transport_generic_request_failure);
 
-static void __target_execute_cmd(struct se_cmd *cmd)
+void __target_execute_cmd(struct se_cmd *cmd)
 {
 	sense_reason_t ret;
 
-	spin_lock_irq(&cmd->t_state_lock);
-	cmd->transport_state |= (CMD_T_BUSY|CMD_T_SENT);
-	spin_unlock_irq(&cmd->t_state_lock);
-
 	if (cmd->execute_cmd) {
 		ret = cmd->execute_cmd(cmd);
 		if (ret) {
@@ -1676,29 +1751,14 @@
 	/*
 	 * If the received CDB has aleady been aborted stop processing it here.
 	 */
-	if (transport_check_aborted_status(cmd, 1)) {
-		complete(&cmd->transport_lun_stop_comp);
+	if (transport_check_aborted_status(cmd, 1))
 		return;
-	}
-
-	/*
-	 * Determine if IOCTL context caller in requesting the stopping of this
-	 * command for LUN shutdown purposes.
-	 */
-	spin_lock_irq(&cmd->t_state_lock);
-	if (cmd->transport_state & CMD_T_LUN_STOP) {
-		pr_debug("%s:%d CMD_T_LUN_STOP for ITT: 0x%08x\n",
-			__func__, __LINE__, cmd->se_tfo->get_task_tag(cmd));
 
-		cmd->transport_state &= ~CMD_T_ACTIVE;
-		spin_unlock_irq(&cmd->t_state_lock);
-		complete(&cmd->transport_lun_stop_comp);
-		return;
-	}
 	/*
 	 * Determine if frontend context caller is requesting the stopping of
 	 * this command for frontend exceptions.
 	 */
+	spin_lock_irq(&cmd->t_state_lock);
 	if (cmd->transport_state & CMD_T_STOP) {
 		pr_debug("%s:%d CMD_T_STOP for ITT: 0x%08x\n",
 			__func__, __LINE__,
@@ -1710,10 +1770,16 @@
 	}
 
 	cmd->t_state = TRANSPORT_PROCESSING;
-	cmd->transport_state |= CMD_T_ACTIVE;
+	cmd->transport_state |= CMD_T_ACTIVE|CMD_T_BUSY|CMD_T_SENT;
+	spin_unlock_irq(&cmd->t_state_lock);
+
+	if (target_handle_task_attr(cmd)) {
+		spin_lock_irq(&cmd->t_state_lock);
+		cmd->transport_state &= ~CMD_T_BUSY|CMD_T_SENT;
 	spin_unlock_irq(&cmd->t_state_lock);
+		return;
+	}
 
-	if (!target_handle_task_attr(cmd))
 		__target_execute_cmd(cmd);
 }
 EXPORT_SYMBOL(target_execute_cmd);
@@ -1787,22 +1853,25 @@
 	transport_complete_task_attr(cmd);
 
 	if (cmd->se_cmd_flags & SCF_TRANSPORT_TASK_SENSE) {
+		trace_target_cmd_complete(cmd);
 		ret = cmd->se_tfo->queue_status(cmd);
 		goto out;
 	}
 
 	switch (cmd->data_direction) {
 	case DMA_FROM_DEVICE:
+		trace_target_cmd_complete(cmd);
 		ret = cmd->se_tfo->queue_data_in(cmd);
 		break;
 	case DMA_TO_DEVICE:
-		if (cmd->t_bidi_data_sg) {
+		if (cmd->se_cmd_flags & SCF_BIDI) {
 			ret = cmd->se_tfo->queue_data_in(cmd);
 			if (ret < 0)
 				break;
 		}
 		/* Fall through for DMA_TO_DEVICE */
 	case DMA_NONE:
+		trace_target_cmd_complete(cmd);
 		ret = cmd->se_tfo->queue_status(cmd);
 		break;
 	default:
@@ -1867,11 +1936,31 @@
 	}
 	/*
 	 * Check for a callback, used by amongst other things
-	 * XDWRITE_READ_10 emulation.
+	 * XDWRITE_READ_10 and COMPARE_AND_WRITE emulation.
 	 */
-	if (cmd->transport_complete_callback)
-		cmd->transport_complete_callback(cmd);
+	if (cmd->transport_complete_callback) {
+		sense_reason_t rc;
+
+		rc = cmd->transport_complete_callback(cmd, true);
+		if (!rc && !(cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE_POST)) {
+			if ((cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) &&
+			    !cmd->data_length)
+				goto queue_rsp;
+
+			return;
+		} else if (rc) {
+			ret = transport_send_check_condition_and_sense(cmd,
+						rc, 0);
+			if (ret == -EAGAIN || ret == -ENOMEM)
+				goto queue_full;
 
+			transport_lun_remove_cmd(cmd);
+			transport_cmd_check_stop_to_fabric(cmd);
+			return;
+		}
+	}
+
+queue_rsp:
 	switch (cmd->data_direction) {
 	case DMA_FROM_DEVICE:
 		spin_lock(&cmd->se_lun->lun_sep_lock);
@@ -1881,6 +1970,7 @@
 		}
 		spin_unlock(&cmd->se_lun->lun_sep_lock);
 
+		trace_target_cmd_complete(cmd);
 		ret = cmd->se_tfo->queue_data_in(cmd);
 		if (ret == -EAGAIN || ret == -ENOMEM)
 			goto queue_full;
@@ -1895,7 +1985,7 @@
 		/*
 		 * Check if we need to send READ payload for BIDI-COMMAND
 		 */
-		if (cmd->t_bidi_data_sg) {
+		if (cmd->se_cmd_flags & SCF_BIDI) {
 			spin_lock(&cmd->se_lun->lun_sep_lock);
 			if (cmd->se_lun->lun_sep) {
 				cmd->se_lun->lun_sep->sep_stats.tx_data_octets +=
@@ -1909,6 +1999,7 @@
 		}
 		/* Fall through for DMA_TO_DEVICE */
 	case DMA_NONE:
+		trace_target_cmd_complete(cmd);
 		ret = cmd->se_tfo->queue_status(cmd);
 		if (ret == -EAGAIN || ret == -ENOMEM)
 			goto queue_full;
@@ -1939,10 +2030,39 @@
 	kfree(sgl);
 }
 
+static inline void transport_reset_sgl_orig(struct se_cmd *cmd)
+{
+	/*
+	 * Check for saved t_data_sg that may be used for COMPARE_AND_WRITE
+	 * emulation, and free + reset pointers if necessary..
+	 */
+	if (!cmd->t_data_sg_orig)
+		return;
+
+	kfree(cmd->t_data_sg);
+	cmd->t_data_sg = cmd->t_data_sg_orig;
+	cmd->t_data_sg_orig = NULL;
+	cmd->t_data_nents = cmd->t_data_nents_orig;
+	cmd->t_data_nents_orig = 0;
+}
+
 static inline void transport_free_pages(struct se_cmd *cmd)
 {
-	if (cmd->se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC)
+	if (cmd->se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) {
+		/*
+		 * Release special case READ buffer payload required for
+		 * SG_TO_MEM_NOALLOC to function with COMPARE_AND_WRITE
+		 */
+		if (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) {
+			transport_free_sgl(cmd->t_bidi_data_sg,
+					   cmd->t_bidi_data_nents);
+			cmd->t_bidi_data_sg = NULL;
+			cmd->t_bidi_data_nents = 0;
+		}
+		transport_reset_sgl_orig(cmd);
 		return;
+	}
+	transport_reset_sgl_orig(cmd);
 
 	transport_free_sgl(cmd->t_data_sg, cmd->t_data_nents);
 	cmd->t_data_sg = NULL;
@@ -1972,11 +2092,7 @@
 	 * If this cmd has been setup with target_get_sess_cmd(), drop
 	 * the kref and call ->release_cmd() in kref callback.
 	 */
-	 if (cmd->check_release != 0)
 		return target_put_sess_cmd(cmd->se_sess, cmd);
-
-	cmd->se_tfo->release_cmd(cmd);
-	return 1;
 }
 
 /**
@@ -1987,21 +2103,6 @@
  */
 static int transport_put_cmd(struct se_cmd *cmd)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&cmd->t_state_lock, flags);
-	if (atomic_read(&cmd->t_fe_count) &&
-	    !atomic_dec_and_test(&cmd->t_fe_count)) {
-		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
-		return 0;
-	}
-
-	if (cmd->transport_state & CMD_T_DEV_ACTIVE) {
-		cmd->transport_state &= ~CMD_T_DEV_ACTIVE;
-		target_remove_from_state_list(cmd);
-	}
-	spin_unlock_irqrestore(&cmd->t_state_lock, flags);
-
 	transport_free_pages(cmd);
 	return transport_release_cmd(cmd);
 }
@@ -2057,24 +2158,22 @@
 }
 EXPORT_SYMBOL(transport_kunmap_data_sg);
 
-static int
-transport_generic_get_mem(struct se_cmd *cmd)
+int
+target_alloc_sgl(struct scatterlist **sgl, unsigned int *nents, u32 length,
+		 bool zero_page)
 {
-	u32 length = cmd->data_length;
-	unsigned int nents;
+	struct scatterlist *sg;
 	struct page *page;
-	gfp_t zero_flag;
+	gfp_t zero_flag = (zero_page) ? __GFP_ZERO : 0;
+	unsigned int nent;
 	int i = 0;
 
-	nents = DIV_ROUND_UP(length, PAGE_SIZE);
-	cmd->t_data_sg = kmalloc(sizeof(struct scatterlist) * nents, GFP_KERNEL);
-	if (!cmd->t_data_sg)
+	nent = DIV_ROUND_UP(length, PAGE_SIZE);
+	sg = kmalloc(sizeof(struct scatterlist) * nent, GFP_KERNEL);
+	if (!sg)
 		return -ENOMEM;
 
-	cmd->t_data_nents = nents;
-	sg_init_table(cmd->t_data_sg, nents);
-
-	zero_flag = cmd->se_cmd_flags & SCF_SCSI_DATA_CDB ? 0 : __GFP_ZERO;
+	sg_init_table(sg, nent);
 
 	while (length) {
 		u32 page_len = min_t(u32, length, PAGE_SIZE);
@@ -2082,19 +2181,20 @@
 		if (!page)
 			goto out;
 
-		sg_set_page(&cmd->t_data_sg[i], page, page_len, 0);
+		sg_set_page(&sg[i], page, page_len, 0);
 		length -= page_len;
 		i++;
 	}
+	*sgl = sg;
+	*nents = nent;
 	return 0;
 
 out:
 	while (i > 0) {
 		i--;
-		__free_page(sg_page(&cmd->t_data_sg[i]));
+		__free_page(sg_page(&sg[i]));
 	}
-	kfree(cmd->t_data_sg);
-	cmd->t_data_sg = NULL;
+	kfree(sg);
 	return -ENOMEM;
 }
 
@@ -2107,6 +2207,7 @@
 transport_generic_new_cmd(struct se_cmd *cmd)
 {
 	int ret = 0;
+	bool zero_flag = !(cmd->se_cmd_flags & SCF_SCSI_DATA_CDB);
 
 	/*
 	 * Determine is the TCM fabric module has already allocated physical
@@ -2115,13 +2216,43 @@
 	 */
 	if (!(cmd->se_cmd_flags & SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC) &&
 	    cmd->data_length) {
-		ret = transport_generic_get_mem(cmd);
+
+		if ((cmd->se_cmd_flags & SCF_BIDI) ||
+		    (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE)) {
+			u32 bidi_length;
+
+			if (cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE)
+				bidi_length = cmd->t_task_nolb *
+					      cmd->se_dev->dev_attrib.block_size;
+			else
+				bidi_length = cmd->data_length;
+
+			ret = target_alloc_sgl(&cmd->t_bidi_data_sg,
+					       &cmd->t_bidi_data_nents,
+					       bidi_length, zero_flag);
 		if (ret < 0)
 			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 	}
 
-	atomic_inc(&cmd->t_fe_count);
+		ret = target_alloc_sgl(&cmd->t_data_sg, &cmd->t_data_nents,
+				       cmd->data_length, zero_flag);
+		if (ret < 0)
+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+	} else if ((cmd->se_cmd_flags & SCF_COMPARE_AND_WRITE) &&
+		    cmd->data_length) {
+		/*
+		 * Special case for COMPARE_AND_WRITE with fabrics
+		 * using SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC.
+		 */
+		u32 caw_length = cmd->t_task_nolb *
+				 cmd->se_dev->dev_attrib.block_size;
 
+		ret = target_alloc_sgl(&cmd->t_bidi_data_sg,
+				       &cmd->t_bidi_data_nents,
+				       caw_length, zero_flag);
+		if (ret < 0)
+			return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+	}
 	/*
 	 * If this command is not a write we can execute it right here,
 	 * for write buffers we need to notify the fabric driver first
@@ -2132,12 +2263,7 @@
 		target_execute_cmd(cmd);
 		return 0;
 	}
-
-	spin_lock_irq(&cmd->t_state_lock);
-	cmd->t_state = TRANSPORT_WRITE_PENDING;
-	spin_unlock_irq(&cmd->t_state_lock);
-
-	transport_cmd_check_stop(cmd, false);
+	transport_cmd_check_stop(cmd, false, true);
 
 	ret = cmd->se_tfo->write_pending(cmd);
 	if (ret == -EAGAIN || ret == -ENOMEM)
@@ -2170,6 +2296,7 @@
 
 int transport_generic_free_cmd(struct se_cmd *cmd, int wait_for_tasks)
 {
+	unsigned long flags;
 	int ret = 0;
 
 	if (!(cmd->se_cmd_flags & SCF_SE_LUN_CMD)) {
@@ -2180,6 +2307,16 @@
 	} else {
 		if (wait_for_tasks)
 			transport_wait_for_tasks(cmd);
+		/*
+		 * Handle WRITE failure case where transport_generic_new_cmd()
+		 * has already added se_cmd to state_list, but fabric has
+		 * failed command before I/O submission.
+		 */
+		if (cmd->state_active) {
+			spin_lock_irqsave(&cmd->t_state_lock, flags);
+			target_remove_from_state_list(cmd);
+			spin_unlock_irqrestore(&cmd->t_state_lock, flags);
+		}
 
 		if (cmd->se_lun)
 			transport_lun_remove_cmd(cmd);
@@ -2201,7 +2338,6 @@
 	unsigned long flags;
 	int ret = 0;
 
-	kref_init(&se_cmd->cmd_kref);
 	/*
 	 * Add a second kref if the fabric caller is expecting to handle
 	 * fabric acknowledgement that requires two target_put_sess_cmd()
@@ -2218,10 +2354,12 @@
 		goto out;
 	}
 	list_add_tail(&se_cmd->se_cmd_list, &se_sess->sess_cmd_list);
-	se_cmd->check_release = 1;
-
 out:
 	spin_unlock_irqrestore(&se_sess->sess_cmd_lock, flags);
+
+	if (ret && ack_kref)
+		target_put_sess_cmd(se_sess, se_cmd);
+
 	return ret;
 }
 EXPORT_SYMBOL(target_get_sess_cmd);
@@ -2253,6 +2391,10 @@
  */
 int target_put_sess_cmd(struct se_session *se_sess, struct se_cmd *se_cmd)
 {
+	if (!se_sess) {
+		se_cmd->se_tfo->release_cmd(se_cmd);
+		return 1;
+	}
 	return kref_put_spinlock_irqsave(&se_cmd->cmd_kref, target_release_cmd_kref,
 			&se_sess->sess_cmd_lock);
 }
@@ -2314,164 +2456,23 @@
 }
 EXPORT_SYMBOL(target_wait_for_sess_cmds);
 
-/*	transport_lun_wait_for_tasks():
- *
- *	Called from ConfigFS context to stop the passed struct se_cmd to allow
- *	an struct se_lun to be successfully shutdown.
- */
-static int transport_lun_wait_for_tasks(struct se_cmd *cmd, struct se_lun *lun)
-{
-	unsigned long flags;
-	int ret = 0;
-
-	/*
-	 * If the frontend has already requested this struct se_cmd to
-	 * be stopped, we can safely ignore this struct se_cmd.
-	 */
-	spin_lock_irqsave(&cmd->t_state_lock, flags);
-	if (cmd->transport_state & CMD_T_STOP) {
-		cmd->transport_state &= ~CMD_T_LUN_STOP;
-
-		pr_debug("ConfigFS ITT[0x%08x] - CMD_T_STOP, skipping\n",
-			 cmd->se_tfo->get_task_tag(cmd));
-		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
-		transport_cmd_check_stop(cmd, false);
-		return -EPERM;
-	}
-	cmd->transport_state |= CMD_T_LUN_FE_STOP;
-	spin_unlock_irqrestore(&cmd->t_state_lock, flags);
-
-	// XXX: audit task_flags checks.
-	spin_lock_irqsave(&cmd->t_state_lock, flags);
-	if ((cmd->transport_state & CMD_T_BUSY) &&
-	    (cmd->transport_state & CMD_T_SENT)) {
-		if (!target_stop_cmd(cmd, &flags))
-			ret++;
-	}
-	spin_unlock_irqrestore(&cmd->t_state_lock, flags);
-
-	pr_debug("ConfigFS: cmd: %p stop tasks ret:"
-			" %d\n", cmd, ret);
-	if (!ret) {
-		pr_debug("ConfigFS: ITT[0x%08x] - stopping cmd....\n",
-				cmd->se_tfo->get_task_tag(cmd));
-		wait_for_completion(&cmd->transport_lun_stop_comp);
-		pr_debug("ConfigFS: ITT[0x%08x] - stopped cmd....\n",
-				cmd->se_tfo->get_task_tag(cmd));
-	}
-
-	return 0;
-}
-
-static void __transport_clear_lun_from_sessions(struct se_lun *lun)
-{
-	struct se_cmd *cmd = NULL;
-	unsigned long lun_flags, cmd_flags;
-	/*
-	 * Do exception processing and return CHECK_CONDITION status to the
-	 * Initiator Port.
-	 */
-	spin_lock_irqsave(&lun->lun_cmd_lock, lun_flags);
-	while (!list_empty(&lun->lun_cmd_list)) {
-		cmd = list_first_entry(&lun->lun_cmd_list,
-		       struct se_cmd, se_lun_node);
-		list_del_init(&cmd->se_lun_node);
-
-		spin_lock(&cmd->t_state_lock);
-		pr_debug("SE_LUN[%d] - Setting cmd->transport"
-			"_lun_stop for  ITT: 0x%08x\n",
-			cmd->se_lun->unpacked_lun,
-			cmd->se_tfo->get_task_tag(cmd));
-		cmd->transport_state |= CMD_T_LUN_STOP;
-		spin_unlock(&cmd->t_state_lock);
-
-		spin_unlock_irqrestore(&lun->lun_cmd_lock, lun_flags);
-
-		if (!cmd->se_lun) {
-			pr_err("ITT: 0x%08x, [i,t]_state: %u/%u\n",
-				cmd->se_tfo->get_task_tag(cmd),
-				cmd->se_tfo->get_cmd_state(cmd), cmd->t_state);
-			BUG();
-		}
-		/*
-		 * If the Storage engine still owns the iscsi_cmd_t, determine
-		 * and/or stop its context.
-		 */
-		pr_debug("SE_LUN[%d] - ITT: 0x%08x before transport"
-			"_lun_wait_for_tasks()\n", cmd->se_lun->unpacked_lun,
-			cmd->se_tfo->get_task_tag(cmd));
-
-		if (transport_lun_wait_for_tasks(cmd, cmd->se_lun) < 0) {
-			spin_lock_irqsave(&lun->lun_cmd_lock, lun_flags);
-			continue;
-		}
-
-		pr_debug("SE_LUN[%d] - ITT: 0x%08x after transport_lun"
-			"_wait_for_tasks(): SUCCESS\n",
-			cmd->se_lun->unpacked_lun,
-			cmd->se_tfo->get_task_tag(cmd));
-
-		spin_lock_irqsave(&cmd->t_state_lock, cmd_flags);
-		if (!(cmd->transport_state & CMD_T_DEV_ACTIVE)) {
-			spin_unlock_irqrestore(&cmd->t_state_lock, cmd_flags);
-			goto check_cond;
-		}
-		cmd->transport_state &= ~CMD_T_DEV_ACTIVE;
-		target_remove_from_state_list(cmd);
-		spin_unlock_irqrestore(&cmd->t_state_lock, cmd_flags);
-
-		/*
-		 * The Storage engine stopped this struct se_cmd before it was
-		 * send to the fabric frontend for delivery back to the
-		 * Initiator Node.  Return this SCSI CDB back with an
-		 * CHECK_CONDITION status.
-		 */
-check_cond:
-		transport_send_check_condition_and_sense(cmd,
-				TCM_NON_EXISTENT_LUN, 0);
-		/*
-		 *  If the fabric frontend is waiting for this iscsi_cmd_t to
-		 * be released, notify the waiting thread now that LU has
-		 * finished accessing it.
-		 */
-		spin_lock_irqsave(&cmd->t_state_lock, cmd_flags);
-		if (cmd->transport_state & CMD_T_LUN_FE_STOP) {
-			pr_debug("SE_LUN[%d] - Detected FE stop for"
-				" struct se_cmd: %p ITT: 0x%08x\n",
-				lun->unpacked_lun,
-				cmd, cmd->se_tfo->get_task_tag(cmd));
-
-			spin_unlock_irqrestore(&cmd->t_state_lock,
-					cmd_flags);
-			transport_cmd_check_stop(cmd, false);
-			complete(&cmd->transport_lun_fe_stop_comp);
-			spin_lock_irqsave(&lun->lun_cmd_lock, lun_flags);
-			continue;
-		}
-		pr_debug("SE_LUN[%d] - ITT: 0x%08x finished processing\n",
-			lun->unpacked_lun, cmd->se_tfo->get_task_tag(cmd));
-
-		spin_unlock_irqrestore(&cmd->t_state_lock, cmd_flags);
-		spin_lock_irqsave(&lun->lun_cmd_lock, lun_flags);
-	}
-	spin_unlock_irqrestore(&lun->lun_cmd_lock, lun_flags);
-}
-
-static int transport_clear_lun_thread(void *p)
+static int transport_clear_lun_ref_thread(void *p)
 {
 	struct se_lun *lun = p;
 
-	__transport_clear_lun_from_sessions(lun);
+	percpu_ref_kill(&lun->lun_ref);
+
+	wait_for_completion(&lun->lun_ref_comp);
 	complete(&lun->lun_shutdown_comp);
 
 	return 0;
 }
 
-int transport_clear_lun_from_sessions(struct se_lun *lun)
+int transport_clear_lun_ref(struct se_lun *lun)
 {
 	struct task_struct *kt;
 
-	kt = kthread_run(transport_clear_lun_thread, lun,
+	kt = kthread_run(transport_clear_lun_ref_thread, lun,
 			"tcm_cl_%u", lun->unpacked_lun);
 	if (IS_ERR(kt)) {
 		pr_err("Unable to start clear_lun thread\n");
@@ -2505,43 +2506,6 @@
 		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
 		return false;
 	}
-	/*
-	 * If we are already stopped due to an external event (ie: LUN shutdown)
-	 * sleep until the connection can have the passed struct se_cmd back.
-	 * The cmd->transport_lun_stopped_sem will be upped by
-	 * transport_clear_lun_from_sessions() once the ConfigFS context caller
-	 * has completed its operation on the struct se_cmd.
-	 */
-	if (cmd->transport_state & CMD_T_LUN_STOP) {
-		pr_debug("wait_for_tasks: Stopping"
-			" wait_for_completion(&cmd->t_tasktransport_lun_fe"
-			"_stop_comp); for ITT: 0x%08x\n",
-			cmd->se_tfo->get_task_tag(cmd));
-		/*
-		 * There is a special case for WRITES where a FE exception +
-		 * LUN shutdown means ConfigFS context is still sleeping on
-		 * transport_lun_stop_comp in transport_lun_wait_for_tasks().
-		 * We go ahead and up transport_lun_stop_comp just to be sure
-		 * here.
-		 */
-		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
-		complete(&cmd->transport_lun_stop_comp);
-		wait_for_completion(&cmd->transport_lun_fe_stop_comp);
-		spin_lock_irqsave(&cmd->t_state_lock, flags);
-
-		target_remove_from_state_list(cmd);
-		/*
-		 * At this point, the frontend who was the originator of this
-		 * struct se_cmd, now owns the structure and can be released through
-		 * normal means below.
-		 */
-		pr_debug("wait_for_tasks: Stopped"
-			" wait_for_completion(&cmd->t_tasktransport_lun_fe_"
-			"stop_comp); for ITT: 0x%08x\n",
-			cmd->se_tfo->get_task_tag(cmd));
-
-		cmd->transport_state &= ~CMD_T_LUN_STOP;
-	}
 
 	if (!(cmd->transport_state & CMD_T_ACTIVE)) {
 		spin_unlock_irqrestore(&cmd->t_state_lock, flags);
@@ -2583,6 +2547,19 @@
 	return 0;
 }
 
+static
+void transport_err_sector_info(unsigned char *buffer, sector_t bad_sector)
+{
+	/* Place failed LBA in sense data information descriptor 0. */
+	buffer[SPC_ADD_SENSE_LEN_OFFSET] = 0xc;
+	buffer[SPC_DESC_TYPE_OFFSET] = 0; /* Information */
+	buffer[SPC_ADDITIONAL_DESC_LEN_OFFSET] = 0xa;
+	buffer[SPC_VALIDITY_OFFSET] = 0x80;
+
+	/* Descriptor Information: failing sector */
+	put_unaligned_be64(bad_sector, &buffer[12]);
+}
+
 int
 transport_send_check_condition_and_sense(struct se_cmd *cmd,
 		sense_reason_t reason, int from_transport)
@@ -2767,6 +2744,48 @@
 		buffer[SPC_ASC_KEY_OFFSET] = asc;
 		buffer[SPC_ASCQ_KEY_OFFSET] = ascq;
 		break;
+	case TCM_MISCOMPARE_VERIFY:
+		/* CURRENT ERROR */
+		buffer[0] = 0x70;
+		buffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;
+		buffer[SPC_SENSE_KEY_OFFSET] = MISCOMPARE;
+		/* MISCOMPARE DURING VERIFY OPERATION */
+		buffer[SPC_ASC_KEY_OFFSET] = 0x1d;
+		buffer[SPC_ASCQ_KEY_OFFSET] = 0x00;
+		break;
+	case TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED:
+		/* CURRENT ERROR */
+		buffer[0] = 0x70;
+		buffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;
+		/* ILLEGAL REQUEST */
+		buffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;
+		/* LOGICAL BLOCK GUARD CHECK FAILED */
+		buffer[SPC_ASC_KEY_OFFSET] = 0x10;
+		buffer[SPC_ASCQ_KEY_OFFSET] = 0x01;
+		transport_err_sector_info(buffer, cmd->bad_sector);
+		break;
+	case TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED:
+		/* CURRENT ERROR */
+		buffer[0] = 0x70;
+		buffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;
+		/* ILLEGAL REQUEST */
+		buffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;
+		/* LOGICAL BLOCK APPLICATION TAG CHECK FAILED */
+		buffer[SPC_ASC_KEY_OFFSET] = 0x10;
+		buffer[SPC_ASCQ_KEY_OFFSET] = 0x02;
+		transport_err_sector_info(buffer, cmd->bad_sector);
+		break;
+	case TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED:
+		/* CURRENT ERROR */
+		buffer[0] = 0x70;
+		buffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;
+		/* ILLEGAL REQUEST */
+		buffer[SPC_SENSE_KEY_OFFSET] = ILLEGAL_REQUEST;
+		/* LOGICAL BLOCK REFERENCE TAG CHECK FAILED */
+		buffer[SPC_ASC_KEY_OFFSET] = 0x10;
+		buffer[SPC_ASCQ_KEY_OFFSET] = 0x03;
+		transport_err_sector_info(buffer, cmd->bad_sector);
+		break;
 	case TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE:
 	default:
 		/* CURRENT ERROR */
@@ -2794,6 +2813,7 @@
 	cmd->scsi_sense_length  = TRANSPORT_SENSE_BUFFER;
 
 after_reason:
+	trace_target_cmd_complete(cmd);
 	return cmd->se_tfo->queue_status(cmd);
 }
 EXPORT_SYMBOL(transport_send_check_condition_and_sense);
@@ -2810,6 +2830,8 @@
 		 cmd->t_task_cdb[0], cmd->se_tfo->get_task_tag(cmd));
 
 	cmd->se_cmd_flags |= SCF_SENT_DELAYED_TAS;
+	cmd->scsi_status = SAM_STAT_TASK_ABORTED;
+	trace_target_cmd_complete(cmd);
 	cmd->se_tfo->queue_status(cmd);
 
 	return 1;
@@ -2837,6 +2859,7 @@
 		if (cmd->se_tfo->write_pending_status(cmd) != 0) {
 			cmd->transport_state |= CMD_T_ABORTED;
 			smp_mb__after_atomic_inc();
+			return;
 		}
 	}
 	cmd->scsi_status = SAM_STAT_TASK_ABORTED;
@@ -2847,6 +2870,7 @@
 		" ITT: 0x%08x\n", cmd->t_task_cdb[0],
 		cmd->se_tfo->get_task_tag(cmd));
 
+	trace_target_cmd_complete(cmd);
 	cmd->se_tfo->queue_status(cmd);
 }
 
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_ua.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_ua.c
--- linux-3.10.69/drivers/target/target_core_ua.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_ua.c	2017-05-02 03:31:56.000000000 +0200
@@ -3,7 +3,7 @@
  *
  * This file contains logic for SPC-3 Unit Attention emulation
  *
- * (c) Copyright 2009-2012 RisingTide Systems LLC.
+ * (c) Copyright 2009-2013 Datera, Inc.
  *
  * Nicholas A. Bellinger <nab@kernel.org>
  *
@@ -98,7 +98,6 @@
 		pr_err("Unable to allocate struct se_ua\n");
 		return -ENOMEM;
 	}
-	INIT_LIST_HEAD(&ua->ua_dev_list);
 	INIT_LIST_HEAD(&ua->ua_nacl_list);
 
 	ua->ua_nacl = nacl;
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_ua.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_ua.h
--- linux-3.10.69/drivers/target/target_core_ua.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_ua.h	2017-05-02 03:31:56.000000000 +0200
@@ -19,7 +19,7 @@
 #define ASCQ_2AH_RESERVATIONS_RELEASED				0x04
 #define ASCQ_2AH_REGISTRATIONS_PREEMPTED			0x05
 #define ASCQ_2AH_ASYMMETRIC_ACCESS_STATE_CHANGED		0x06
-#define ASCQ_2AH_IMPLICT_ASYMMETRIC_ACCESS_STATE_TRANSITION_FAILED 0x07
+#define ASCQ_2AH_IMPLICIT_ASYMMETRIC_ACCESS_STATE_TRANSITION_FAILED 0x07
 #define ASCQ_2AH_PRIORITY_CHANGED				0x08
 
 #define ASCQ_2CH_PREVIOUS_RESERVATION_CONFLICT_STATUS		0x09
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_user.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_user.c
--- linux-3.10.69/drivers/target/target_core_user.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_user.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,1151 @@
+/*
+ * Copyright (C) 2013 Shaohua Li <shli@kernel.org>
+ * Copyright (C) 2014 Red Hat, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <linux/spinlock.h>
+#include <linux/module.h>
+#include <linux/idr.h>
+#include <linux/timer.h>
+#include <linux/parser.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_host.h>
+#include <linux/uio_driver.h>
+#include <net/genetlink.h>
+#include <target/target_core_base.h>
+#include <target/target_core_fabric.h>
+#include <target/target_core_backend.h>
+#include <target/target_core_backend_configfs.h>
+
+#include <linux/target_core_user.h>
+
+/*
+ * Define a shared-memory interface for LIO to pass SCSI commands and
+ * data to userspace for processing. This is to allow backends that
+ * are too complex for in-kernel support to be possible.
+ *
+ * It uses the UIO framework to do a lot of the device-creation and
+ * introspection work for us.
+ *
+ * See the .h file for how the ring is laid out. Note that while the
+ * command ring is defined, the particulars of the data area are
+ * not. Offset values in the command entry point to other locations
+ * internal to the mmap()ed area. There is separate space outside the
+ * command ring for data buffers. This leaves maximum flexibility for
+ * moving buffer allocations, or even page flipping or other
+ * allocation techniques, without altering the command ring layout.
+ *
+ * SECURITY:
+ * The user process must be assumed to be malicious. There's no way to
+ * prevent it breaking the command ring protocol if it wants, but in
+ * order to prevent other issues we must only ever read *data* from
+ * the shared memory area, not offsets or sizes. This applies to
+ * command ring entries as well as the mailbox. Extra code needed for
+ * this may have a 'UAM' comment.
+ */
+
+
+#define TCMU_TIME_OUT (30 * MSEC_PER_SEC)
+
+#define CMDR_SIZE (16 * 4096)
+#define DATA_SIZE (257 * 4096)
+
+#define TCMU_RING_SIZE (CMDR_SIZE + DATA_SIZE)
+
+static struct device *tcmu_root_device;
+
+struct tcmu_hba {
+	u32 host_id;
+};
+
+#define TCMU_CONFIG_LEN 256
+
+struct tcmu_dev {
+	struct se_device se_dev;
+
+	char *name;
+	struct se_hba *hba;
+
+#define TCMU_DEV_BIT_OPEN 0
+#define TCMU_DEV_BIT_BROKEN 1
+	unsigned long flags;
+
+	struct uio_info uio_info;
+
+	struct tcmu_mailbox *mb_addr;
+	size_t dev_size;
+	u32 cmdr_size;
+	u32 cmdr_last_cleaned;
+	/* Offset of data ring from start of mb */
+	size_t data_off;
+	size_t data_size;
+	/* Ring head + tail values. */
+	/* Must add data_off and mb_addr to get the address */
+	size_t data_head;
+	size_t data_tail;
+
+	wait_queue_head_t wait_cmdr;
+	/* TODO should this be a mutex? */
+	spinlock_t cmdr_lock;
+
+	struct idr commands;
+	spinlock_t commands_lock;
+
+	struct timer_list timeout;
+
+	char dev_config[TCMU_CONFIG_LEN];
+};
+
+#define TCMU_DEV(_se_dev) container_of(_se_dev, struct tcmu_dev, se_dev)
+
+#define CMDR_OFF sizeof(struct tcmu_mailbox)
+
+struct tcmu_cmd {
+	struct se_cmd *se_cmd;
+	struct tcmu_dev *tcmu_dev;
+
+	uint16_t cmd_id;
+
+	/* Can't use se_cmd->data_length when cleaning up expired cmds, because if
+	   cmd has been completed then accessing se_cmd is off limits */
+	size_t data_length;
+
+	unsigned long deadline;
+
+#define TCMU_CMD_BIT_EXPIRED 0
+	unsigned long flags;
+};
+
+static struct kmem_cache *tcmu_cmd_cache;
+
+/* multicast group */
+enum tcmu_multicast_groups {
+	TCMU_MCGRP_CONFIG,
+};
+
+static const struct genl_multicast_group tcmu_mcgrps[] = {
+	[TCMU_MCGRP_CONFIG] = { .name = "config", },
+};
+
+/* Our generic netlink family */
+static struct genl_family tcmu_genl_family = {
+	.id = GENL_ID_GENERATE,
+	.hdrsize = 0,
+	.name = "TCM-USER",
+	.version = 1,
+	.maxattr = TCMU_ATTR_MAX,
+	.mcgrps = tcmu_mcgrps,
+	.n_mcgrps = ARRAY_SIZE(tcmu_mcgrps),
+};
+
+static struct tcmu_cmd *tcmu_alloc_cmd(struct se_cmd *se_cmd)
+{
+	struct se_device *se_dev = se_cmd->se_dev;
+	struct tcmu_dev *udev = TCMU_DEV(se_dev);
+	struct tcmu_cmd *tcmu_cmd;
+	int cmd_id;
+
+	tcmu_cmd = kmem_cache_zalloc(tcmu_cmd_cache, GFP_KERNEL);
+	if (!tcmu_cmd)
+		return NULL;
+
+	tcmu_cmd->se_cmd = se_cmd;
+	tcmu_cmd->tcmu_dev = udev;
+	tcmu_cmd->data_length = se_cmd->data_length;
+
+	tcmu_cmd->deadline = jiffies + msecs_to_jiffies(TCMU_TIME_OUT);
+
+	idr_preload(GFP_KERNEL);
+	spin_lock_irq(&udev->commands_lock);
+	cmd_id = idr_alloc(&udev->commands, tcmu_cmd, 0,
+		USHRT_MAX, GFP_NOWAIT);
+	spin_unlock_irq(&udev->commands_lock);
+	idr_preload_end();
+
+	if (cmd_id < 0) {
+		kmem_cache_free(tcmu_cmd_cache, tcmu_cmd);
+		return NULL;
+	}
+	tcmu_cmd->cmd_id = cmd_id;
+
+	return tcmu_cmd;
+}
+
+static inline void tcmu_flush_dcache_range(void *vaddr, size_t size)
+{
+	unsigned long offset = (unsigned long) vaddr & ~PAGE_MASK;
+
+	size = round_up(size+offset, PAGE_SIZE);
+	vaddr -= offset;
+
+	while (size) {
+		flush_dcache_page(virt_to_page(vaddr));
+		size -= PAGE_SIZE;
+	}
+}
+
+/*
+ * Some ring helper functions. We don't assume size is a power of 2 so
+ * we can't use circ_buf.h.
+ */
+static inline size_t spc_used(size_t head, size_t tail, size_t size)
+{
+	int diff = head - tail;
+
+	if (diff >= 0)
+		return diff;
+	else
+		return size + diff;
+}
+
+static inline size_t spc_free(size_t head, size_t tail, size_t size)
+{
+	/* Keep 1 byte unused or we can't tell full from empty */
+	return (size - spc_used(head, tail, size) - 1);
+}
+
+static inline size_t head_to_end(size_t head, size_t size)
+{
+	return size - head;
+}
+
+#define UPDATE_HEAD(head, used, size) smp_store_release(&head, ((head % size) + used) % size)
+
+/*
+ * We can't queue a command until we have space available on the cmd ring *and* space
+ * space avail on the data ring.
+ *
+ * Called with ring lock held.
+ */
+static bool is_ring_space_avail(struct tcmu_dev *udev, size_t cmd_size, size_t data_needed)
+{
+	struct tcmu_mailbox *mb = udev->mb_addr;
+	size_t space;
+	u32 cmd_head;
+	size_t cmd_needed;
+
+	tcmu_flush_dcache_range(mb, sizeof(*mb));
+
+	cmd_head = mb->cmd_head % udev->cmdr_size; /* UAM */
+
+	/*
+	 * If cmd end-of-ring space is too small then we need space for a NOP plus
+	 * original cmd - cmds are internally contiguous.
+	 */
+	if (head_to_end(cmd_head, udev->cmdr_size) >= cmd_size)
+		cmd_needed = cmd_size;
+	else
+		cmd_needed = cmd_size + head_to_end(cmd_head, udev->cmdr_size);
+
+	space = spc_free(cmd_head, udev->cmdr_last_cleaned, udev->cmdr_size);
+	if (space < cmd_needed) {
+		pr_debug("no cmd space: %u %u %u\n", cmd_head,
+		       udev->cmdr_last_cleaned, udev->cmdr_size);
+		return false;
+	}
+
+	space = spc_free(udev->data_head, udev->data_tail, udev->data_size);
+	if (space < data_needed) {
+		pr_debug("no data space: %zu %zu %zu\n", udev->data_head,
+		       udev->data_tail, udev->data_size);
+		return false;
+	}
+
+	return true;
+}
+
+static int tcmu_queue_cmd_ring(struct tcmu_cmd *tcmu_cmd)
+{
+	struct tcmu_dev *udev = tcmu_cmd->tcmu_dev;
+	struct se_cmd *se_cmd = tcmu_cmd->se_cmd;
+	size_t base_command_size, command_size;
+	struct tcmu_mailbox *mb;
+	struct tcmu_cmd_entry *entry;
+	int i;
+	struct scatterlist *sg;
+	struct iovec *iov;
+	int iov_cnt = 0;
+	uint32_t cmd_head;
+	uint64_t cdb_off;
+
+	if (test_bit(TCMU_DEV_BIT_BROKEN, &udev->flags))
+		return -EINVAL;
+
+	/*
+	 * Must be a certain minimum size for response sense info, but
+	 * also may be larger if the iov array is large.
+	 *
+	 * iovs = sgl_nents+1, for end-of-ring case, plus another 1
+	 * b/c size == offsetof one-past-element.
+	*/
+	base_command_size = max(offsetof(struct tcmu_cmd_entry,
+					 req.iov[se_cmd->t_data_nents + 2]),
+				sizeof(struct tcmu_cmd_entry));
+	command_size = base_command_size
+		+ round_up(scsi_command_size(se_cmd->t_task_cdb), TCMU_OP_ALIGN_SIZE);
+
+	WARN_ON(command_size & (TCMU_OP_ALIGN_SIZE-1));
+
+	spin_lock_irq(&udev->cmdr_lock);
+
+	mb = udev->mb_addr;
+	cmd_head = mb->cmd_head % udev->cmdr_size; /* UAM */
+	if ((command_size > (udev->cmdr_size / 2))
+	    || tcmu_cmd->data_length > (udev->data_size - 1))
+		pr_warn("TCMU: Request of size %zu/%zu may be too big for %u/%zu "
+			"cmd/data ring buffers\n", command_size, tcmu_cmd->data_length,
+			udev->cmdr_size, udev->data_size);
+
+	while (!is_ring_space_avail(udev, command_size, tcmu_cmd->data_length)) {
+		int ret;
+		DEFINE_WAIT(__wait);
+
+		prepare_to_wait(&udev->wait_cmdr, &__wait, TASK_INTERRUPTIBLE);
+
+		pr_debug("sleeping for ring space\n");
+		spin_unlock_irq(&udev->cmdr_lock);
+		ret = schedule_timeout(msecs_to_jiffies(TCMU_TIME_OUT));
+		finish_wait(&udev->wait_cmdr, &__wait);
+		if (!ret) {
+			pr_warn("tcmu: command timed out\n");
+			return -ETIMEDOUT;
+		}
+
+		spin_lock_irq(&udev->cmdr_lock);
+
+		/* We dropped cmdr_lock, cmd_head is stale */
+		cmd_head = mb->cmd_head % udev->cmdr_size; /* UAM */
+	}
+
+	/* Insert a PAD if end-of-ring space is too small */
+	if (head_to_end(cmd_head, udev->cmdr_size) < command_size) {
+		size_t pad_size = head_to_end(cmd_head, udev->cmdr_size);
+
+		entry = (void *) mb + CMDR_OFF + cmd_head;
+		tcmu_flush_dcache_range(entry, sizeof(*entry));
+		tcmu_hdr_set_op(&entry->hdr.len_op, TCMU_OP_PAD);
+		tcmu_hdr_set_len(&entry->hdr.len_op, pad_size);
+		entry->hdr.cmd_id = 0; /* not used for PAD */
+		entry->hdr.kflags = 0;
+		entry->hdr.uflags = 0;
+
+		UPDATE_HEAD(mb->cmd_head, pad_size, udev->cmdr_size);
+
+		cmd_head = mb->cmd_head % udev->cmdr_size; /* UAM */
+		WARN_ON(cmd_head != 0);
+	}
+
+	entry = (void *) mb + CMDR_OFF + cmd_head;
+	tcmu_flush_dcache_range(entry, sizeof(*entry));
+	tcmu_hdr_set_op(&entry->hdr.len_op, TCMU_OP_CMD);
+	tcmu_hdr_set_len(&entry->hdr.len_op, command_size);
+	entry->hdr.cmd_id = tcmu_cmd->cmd_id;
+	entry->hdr.kflags = 0;
+	entry->hdr.uflags = 0;
+
+	/*
+	 * Fix up iovecs, and handle if allocation in data ring wrapped.
+	 */
+	iov = &entry->req.iov[0];
+	for_each_sg(se_cmd->t_data_sg, sg, se_cmd->t_data_nents, i) {
+		size_t copy_bytes = min((size_t)sg->length,
+				     head_to_end(udev->data_head, udev->data_size));
+		void *from = kmap_atomic(sg_page(sg)) + sg->offset;
+		void *to = (void *) mb + udev->data_off + udev->data_head;
+
+		if (tcmu_cmd->se_cmd->data_direction == DMA_TO_DEVICE) {
+			memcpy(to, from, copy_bytes);
+			tcmu_flush_dcache_range(to, copy_bytes);
+		}
+
+		/* Even iov_base is relative to mb_addr */
+		iov->iov_len = copy_bytes;
+		iov->iov_base = (void __user *) udev->data_off +
+						udev->data_head;
+		iov_cnt++;
+		iov++;
+
+		UPDATE_HEAD(udev->data_head, copy_bytes, udev->data_size);
+
+		/* Uh oh, we wrapped the buffer. Must split sg across 2 iovs. */
+		if (sg->length != copy_bytes) {
+			from += copy_bytes;
+			copy_bytes = sg->length - copy_bytes;
+
+			iov->iov_len = copy_bytes;
+			iov->iov_base = (void __user *) udev->data_off +
+							udev->data_head;
+
+			if (se_cmd->data_direction == DMA_TO_DEVICE) {
+				to = (void *) mb + udev->data_off + udev->data_head;
+				memcpy(to, from, copy_bytes);
+				tcmu_flush_dcache_range(to, copy_bytes);
+			}
+
+			iov_cnt++;
+			iov++;
+
+			UPDATE_HEAD(udev->data_head, copy_bytes, udev->data_size);
+		}
+
+		kunmap_atomic(from);
+	}
+	entry->req.iov_cnt = iov_cnt;
+	entry->req.iov_bidi_cnt = 0;
+	entry->req.iov_dif_cnt = 0;
+
+	/* All offsets relative to mb_addr, not start of entry! */
+	cdb_off = CMDR_OFF + cmd_head + base_command_size;
+	memcpy((void *) mb + cdb_off, se_cmd->t_task_cdb, scsi_command_size(se_cmd->t_task_cdb));
+	entry->req.cdb_off = cdb_off;
+	tcmu_flush_dcache_range(entry, sizeof(*entry));
+
+	UPDATE_HEAD(mb->cmd_head, command_size, udev->cmdr_size);
+	tcmu_flush_dcache_range(mb, sizeof(*mb));
+
+	spin_unlock_irq(&udev->cmdr_lock);
+
+	/* TODO: only if FLUSH and FUA? */
+	uio_event_notify(&udev->uio_info);
+
+	mod_timer(&udev->timeout,
+		round_jiffies_up(jiffies + msecs_to_jiffies(TCMU_TIME_OUT)));
+
+	return 0;
+}
+
+static int tcmu_queue_cmd(struct se_cmd *se_cmd)
+{
+	struct se_device *se_dev = se_cmd->se_dev;
+	struct tcmu_dev *udev = TCMU_DEV(se_dev);
+	struct tcmu_cmd *tcmu_cmd;
+	int ret;
+
+	tcmu_cmd = tcmu_alloc_cmd(se_cmd);
+	if (!tcmu_cmd)
+		return -ENOMEM;
+
+	ret = tcmu_queue_cmd_ring(tcmu_cmd);
+	if (ret < 0) {
+		pr_err("TCMU: Could not queue command\n");
+		spin_lock_irq(&udev->commands_lock);
+		idr_remove(&udev->commands, tcmu_cmd->cmd_id);
+		spin_unlock_irq(&udev->commands_lock);
+
+		kmem_cache_free(tcmu_cmd_cache, tcmu_cmd);
+	}
+
+	return ret;
+}
+
+static void tcmu_handle_completion(struct tcmu_cmd *cmd, struct tcmu_cmd_entry *entry)
+{
+	struct se_cmd *se_cmd = cmd->se_cmd;
+	struct tcmu_dev *udev = cmd->tcmu_dev;
+
+	if (test_bit(TCMU_CMD_BIT_EXPIRED, &cmd->flags)) {
+		/* cmd has been completed already from timeout, just reclaim data
+		   ring space */
+		UPDATE_HEAD(udev->data_tail, cmd->data_length, udev->data_size);
+		return;
+	}
+
+	if (entry->hdr.uflags & TCMU_UFLAG_UNKNOWN_OP) {
+		UPDATE_HEAD(udev->data_tail, cmd->data_length, udev->data_size);
+		pr_warn("TCMU: Userspace set UNKNOWN_OP flag on se_cmd %p\n",
+			cmd->se_cmd);
+		transport_generic_request_failure(cmd->se_cmd,
+			TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE);
+		cmd->se_cmd = NULL;
+		kmem_cache_free(tcmu_cmd_cache, cmd);
+		return;
+	}
+
+	if (entry->rsp.scsi_status == SAM_STAT_CHECK_CONDITION) {
+		memcpy(se_cmd->sense_buffer, entry->rsp.sense_buffer,
+			       se_cmd->scsi_sense_length);
+
+		UPDATE_HEAD(udev->data_tail, cmd->data_length, udev->data_size);
+	}
+	else if (se_cmd->data_direction == DMA_FROM_DEVICE) {
+		struct scatterlist *sg;
+		int i;
+
+		/* It'd be easier to look at entry's iovec again, but UAM */
+		for_each_sg(se_cmd->t_data_sg, sg, se_cmd->t_data_nents, i) {
+			size_t copy_bytes;
+			void *to;
+			void *from;
+
+			copy_bytes = min((size_t)sg->length,
+					 head_to_end(udev->data_tail, udev->data_size));
+
+			to = kmap_atomic(sg_page(sg)) + sg->offset;
+			WARN_ON(sg->length + sg->offset > PAGE_SIZE);
+			from = (void *) udev->mb_addr + udev->data_off + udev->data_tail;
+			tcmu_flush_dcache_range(from, copy_bytes);
+			memcpy(to, from, copy_bytes);
+
+			UPDATE_HEAD(udev->data_tail, copy_bytes, udev->data_size);
+
+			/* Uh oh, wrapped the data buffer for this sg's data */
+			if (sg->length != copy_bytes) {
+				from = (void *) udev->mb_addr + udev->data_off + udev->data_tail;
+				WARN_ON(udev->data_tail);
+				to += copy_bytes;
+				copy_bytes = sg->length - copy_bytes;
+				tcmu_flush_dcache_range(from, copy_bytes);
+				memcpy(to, from, copy_bytes);
+
+				UPDATE_HEAD(udev->data_tail, copy_bytes, udev->data_size);
+			}
+
+			kunmap_atomic(to);
+		}
+
+	} else if (se_cmd->data_direction == DMA_TO_DEVICE) {
+		UPDATE_HEAD(udev->data_tail, cmd->data_length, udev->data_size);
+	} else {
+		pr_warn("TCMU: data direction was %d!\n", se_cmd->data_direction);
+	}
+
+	target_complete_cmd(cmd->se_cmd, entry->rsp.scsi_status);
+	cmd->se_cmd = NULL;
+
+	kmem_cache_free(tcmu_cmd_cache, cmd);
+}
+
+static unsigned int tcmu_handle_completions(struct tcmu_dev *udev)
+{
+	struct tcmu_mailbox *mb;
+	LIST_HEAD(cpl_cmds);
+	unsigned long flags;
+	int handled = 0;
+
+	if (test_bit(TCMU_DEV_BIT_BROKEN, &udev->flags)) {
+		pr_err("ring broken, not handling completions\n");
+		return 0;
+	}
+
+	spin_lock_irqsave(&udev->cmdr_lock, flags);
+
+	mb = udev->mb_addr;
+	tcmu_flush_dcache_range(mb, sizeof(*mb));
+
+	while (udev->cmdr_last_cleaned != ACCESS_ONCE(mb->cmd_tail)) {
+
+		struct tcmu_cmd_entry *entry = (void *) mb + CMDR_OFF + udev->cmdr_last_cleaned;
+		struct tcmu_cmd *cmd;
+
+		tcmu_flush_dcache_range(entry, sizeof(*entry));
+
+		if (tcmu_hdr_get_op(entry->hdr.len_op) == TCMU_OP_PAD) {
+			UPDATE_HEAD(udev->cmdr_last_cleaned,
+				    tcmu_hdr_get_len(entry->hdr.len_op),
+				    udev->cmdr_size);
+			continue;
+		}
+		WARN_ON(tcmu_hdr_get_op(entry->hdr.len_op) != TCMU_OP_CMD);
+
+		spin_lock(&udev->commands_lock);
+		cmd = idr_find(&udev->commands, entry->hdr.cmd_id);
+		if (cmd)
+			idr_remove(&udev->commands, cmd->cmd_id);
+		spin_unlock(&udev->commands_lock);
+
+		if (!cmd) {
+			pr_err("cmd_id not found, ring is broken\n");
+			set_bit(TCMU_DEV_BIT_BROKEN, &udev->flags);
+			break;
+		}
+
+		tcmu_handle_completion(cmd, entry);
+
+		UPDATE_HEAD(udev->cmdr_last_cleaned,
+			    tcmu_hdr_get_len(entry->hdr.len_op),
+			    udev->cmdr_size);
+
+		handled++;
+	}
+
+	if (mb->cmd_tail == mb->cmd_head)
+		del_timer(&udev->timeout); /* no more pending cmds */
+
+	spin_unlock_irqrestore(&udev->cmdr_lock, flags);
+
+	wake_up(&udev->wait_cmdr);
+
+	return handled;
+}
+
+static int tcmu_check_expired_cmd(int id, void *p, void *data)
+{
+	struct tcmu_cmd *cmd = p;
+
+	if (test_bit(TCMU_CMD_BIT_EXPIRED, &cmd->flags))
+		return 0;
+
+	if (!time_after(cmd->deadline, jiffies))
+		return 0;
+
+	set_bit(TCMU_CMD_BIT_EXPIRED, &cmd->flags);
+	target_complete_cmd(cmd->se_cmd, SAM_STAT_CHECK_CONDITION);
+	cmd->se_cmd = NULL;
+
+	kmem_cache_free(tcmu_cmd_cache, cmd);
+
+	return 0;
+}
+
+static void tcmu_device_timedout(unsigned long data)
+{
+	struct tcmu_dev *udev = (struct tcmu_dev *)data;
+	unsigned long flags;
+	int handled;
+
+	handled = tcmu_handle_completions(udev);
+
+	pr_warn("%d completions handled from timeout\n", handled);
+
+	spin_lock_irqsave(&udev->commands_lock, flags);
+	idr_for_each(&udev->commands, tcmu_check_expired_cmd, NULL);
+	spin_unlock_irqrestore(&udev->commands_lock, flags);
+
+	/*
+	 * We don't need to wakeup threads on wait_cmdr since they have their
+	 * own timeout.
+	 */
+}
+
+static int tcmu_attach_hba(struct se_hba *hba, u32 host_id)
+{
+	struct tcmu_hba *tcmu_hba;
+
+	tcmu_hba = kzalloc(sizeof(struct tcmu_hba), GFP_KERNEL);
+	if (!tcmu_hba)
+		return -ENOMEM;
+
+	tcmu_hba->host_id = host_id;
+	hba->hba_ptr = tcmu_hba;
+
+	return 0;
+}
+
+static void tcmu_detach_hba(struct se_hba *hba)
+{
+	kfree(hba->hba_ptr);
+	hba->hba_ptr = NULL;
+}
+
+static struct se_device *tcmu_alloc_device(struct se_hba *hba, const char *name)
+{
+	struct tcmu_dev *udev;
+
+	udev = kzalloc(sizeof(struct tcmu_dev), GFP_KERNEL);
+	if (!udev)
+		return NULL;
+
+	udev->name = kstrdup(name, GFP_KERNEL);
+	if (!udev->name) {
+		kfree(udev);
+		return NULL;
+	}
+
+	udev->hba = hba;
+
+	init_waitqueue_head(&udev->wait_cmdr);
+	spin_lock_init(&udev->cmdr_lock);
+
+	idr_init(&udev->commands);
+	spin_lock_init(&udev->commands_lock);
+
+	setup_timer(&udev->timeout, tcmu_device_timedout,
+		(unsigned long)udev);
+
+	return &udev->se_dev;
+}
+
+static int tcmu_irqcontrol(struct uio_info *info, s32 irq_on)
+{
+	struct tcmu_dev *tcmu_dev = container_of(info, struct tcmu_dev, uio_info);
+
+	tcmu_handle_completions(tcmu_dev);
+
+	return 0;
+}
+
+/*
+ * mmap code from uio.c. Copied here because we want to hook mmap()
+ * and this stuff must come along.
+ */
+static int tcmu_find_mem_index(struct vm_area_struct *vma)
+{
+	struct tcmu_dev *udev = vma->vm_private_data;
+	struct uio_info *info = &udev->uio_info;
+
+	if (vma->vm_pgoff < MAX_UIO_MAPS) {
+		if (info->mem[vma->vm_pgoff].size == 0)
+			return -1;
+		return (int)vma->vm_pgoff;
+	}
+	return -1;
+}
+
+static int tcmu_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
+{
+	struct tcmu_dev *udev = vma->vm_private_data;
+	struct uio_info *info = &udev->uio_info;
+	struct page *page;
+	unsigned long offset;
+	void *addr;
+
+	int mi = tcmu_find_mem_index(vma);
+	if (mi < 0)
+		return VM_FAULT_SIGBUS;
+
+	/*
+	 * We need to subtract mi because userspace uses offset = N*PAGE_SIZE
+	 * to use mem[N].
+	 */
+	offset = (vmf->pgoff - mi) << PAGE_SHIFT;
+
+	addr = (void *)(unsigned long)info->mem[mi].addr + offset;
+	if (info->mem[mi].memtype == UIO_MEM_LOGICAL)
+		page = virt_to_page(addr);
+	else
+		page = vmalloc_to_page(addr);
+	get_page(page);
+	vmf->page = page;
+	return 0;
+}
+
+static const struct vm_operations_struct tcmu_vm_ops = {
+	.fault = tcmu_vma_fault,
+};
+
+static int tcmu_mmap(struct uio_info *info, struct vm_area_struct *vma)
+{
+	struct tcmu_dev *udev = container_of(info, struct tcmu_dev, uio_info);
+
+	vma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;
+	vma->vm_ops = &tcmu_vm_ops;
+
+	vma->vm_private_data = udev;
+
+	/* Ensure the mmap is exactly the right size */
+	if (vma_pages(vma) != (TCMU_RING_SIZE >> PAGE_SHIFT))
+		return -EINVAL;
+
+	return 0;
+}
+
+static int tcmu_open(struct uio_info *info, struct inode *inode)
+{
+	struct tcmu_dev *udev = container_of(info, struct tcmu_dev, uio_info);
+
+	/* O_EXCL not supported for char devs, so fake it? */
+	if (test_and_set_bit(TCMU_DEV_BIT_OPEN, &udev->flags))
+		return -EBUSY;
+
+	pr_debug("open\n");
+
+	return 0;
+}
+
+static int tcmu_release(struct uio_info *info, struct inode *inode)
+{
+	struct tcmu_dev *udev = container_of(info, struct tcmu_dev, uio_info);
+
+	clear_bit(TCMU_DEV_BIT_OPEN, &udev->flags);
+
+	pr_debug("close\n");
+
+	return 0;
+}
+
+static int tcmu_netlink_event(enum tcmu_genl_cmd cmd, const char *name, int minor)
+{
+	struct sk_buff *skb;
+	void *msg_header;
+	int ret = -ENOMEM;
+
+	skb = genlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
+	if (!skb)
+		return ret;
+
+	msg_header = genlmsg_put(skb, 0, 0, &tcmu_genl_family, 0, cmd);
+	if (!msg_header)
+		goto free_skb;
+
+	ret = nla_put_string(skb, TCMU_ATTR_DEVICE, name);
+	if (ret < 0)
+		goto free_skb;
+
+	ret = nla_put_u32(skb, TCMU_ATTR_MINOR, minor);
+	if (ret < 0)
+		goto free_skb;
+
+	genlmsg_end(skb, msg_header);
+
+	ret = genlmsg_multicast(&tcmu_genl_family, skb, 0,
+				TCMU_MCGRP_CONFIG, GFP_KERNEL);
+
+	/* We don't care if no one is listening */
+	if (ret == -ESRCH)
+		ret = 0;
+
+	return ret;
+free_skb:
+	nlmsg_free(skb);
+	return ret;
+}
+
+static int tcmu_configure_device(struct se_device *dev)
+{
+	struct tcmu_dev *udev = TCMU_DEV(dev);
+	struct tcmu_hba *hba = udev->hba->hba_ptr;
+	struct uio_info *info;
+	struct tcmu_mailbox *mb;
+	size_t size;
+	size_t used;
+	int ret = 0;
+	char *str;
+
+	info = &udev->uio_info;
+
+	size = snprintf(NULL, 0, "tcm-user/%u/%s/%s", hba->host_id, udev->name,
+			udev->dev_config);
+	size += 1; /* for \0 */
+	str = kmalloc(size, GFP_KERNEL);
+	if (!str)
+		return -ENOMEM;
+
+	used = snprintf(str, size, "tcm-user/%u/%s", hba->host_id, udev->name);
+
+	if (udev->dev_config[0])
+		snprintf(str + used, size - used, "/%s", udev->dev_config);
+
+	info->name = str;
+
+	udev->mb_addr = vzalloc(TCMU_RING_SIZE);
+	if (!udev->mb_addr) {
+		ret = -ENOMEM;
+		goto err_vzalloc;
+	}
+
+	/* mailbox fits in first part of CMDR space */
+	udev->cmdr_size = CMDR_SIZE - CMDR_OFF;
+	udev->data_off = CMDR_SIZE;
+	udev->data_size = TCMU_RING_SIZE - CMDR_SIZE;
+
+	mb = udev->mb_addr;
+	mb->version = TCMU_MAILBOX_VERSION;
+	mb->cmdr_off = CMDR_OFF;
+	mb->cmdr_size = udev->cmdr_size;
+
+	WARN_ON(!PAGE_ALIGNED(udev->data_off));
+	WARN_ON(udev->data_size % PAGE_SIZE);
+
+	info->version = xstr(TCMU_MAILBOX_VERSION);
+
+	info->mem[0].name = "tcm-user command & data buffer";
+	info->mem[0].addr = (phys_addr_t) udev->mb_addr;
+	info->mem[0].size = TCMU_RING_SIZE;
+	info->mem[0].memtype = UIO_MEM_VIRTUAL;
+
+	info->irqcontrol = tcmu_irqcontrol;
+	info->irq = UIO_IRQ_CUSTOM;
+
+	info->mmap = tcmu_mmap;
+	info->open = tcmu_open;
+	info->release = tcmu_release;
+
+	ret = uio_register_device(tcmu_root_device, info);
+	if (ret)
+		goto err_register;
+
+	/* Other attributes can be configured in userspace */
+	dev->dev_attrib.hw_block_size = 512;
+	dev->dev_attrib.hw_max_sectors = 128;
+	dev->dev_attrib.hw_queue_depth = 128;
+
+	ret = tcmu_netlink_event(TCMU_CMD_ADDED_DEVICE, udev->uio_info.name,
+				 udev->uio_info.uio_dev->minor);
+	if (ret)
+		goto err_netlink;
+
+	return 0;
+
+err_netlink:
+	uio_unregister_device(&udev->uio_info);
+err_register:
+	vfree(udev->mb_addr);
+err_vzalloc:
+	kfree(info->name);
+
+	return ret;
+}
+
+static int tcmu_check_pending_cmd(int id, void *p, void *data)
+{
+	struct tcmu_cmd *cmd = p;
+
+	if (test_bit(TCMU_CMD_BIT_EXPIRED, &cmd->flags))
+		return 0;
+	return -EINVAL;
+}
+
+static void tcmu_free_device(struct se_device *dev)
+{
+	struct tcmu_dev *udev = TCMU_DEV(dev);
+	int i;
+
+	del_timer_sync(&udev->timeout);
+
+	vfree(udev->mb_addr);
+
+	/* Upper layer should drain all requests before calling this */
+	spin_lock_irq(&udev->commands_lock);
+	i = idr_for_each(&udev->commands, tcmu_check_pending_cmd, NULL);
+	idr_destroy(&udev->commands);
+	spin_unlock_irq(&udev->commands_lock);
+	WARN_ON(i);
+
+	/* Device was configured */
+	if (udev->uio_info.uio_dev) {
+		tcmu_netlink_event(TCMU_CMD_REMOVED_DEVICE, udev->uio_info.name,
+				   udev->uio_info.uio_dev->minor);
+
+		uio_unregister_device(&udev->uio_info);
+		kfree(udev->uio_info.name);
+		kfree(udev->name);
+	}
+
+	kfree(udev);
+}
+
+enum {
+	Opt_dev_config, Opt_dev_size, Opt_hw_block_size, Opt_err,
+};
+
+static match_table_t tokens = {
+	{Opt_dev_config, "dev_config=%s"},
+	{Opt_dev_size, "dev_size=%u"},
+	{Opt_hw_block_size, "hw_block_size=%u"},
+	{Opt_err, NULL}
+};
+
+static ssize_t tcmu_set_configfs_dev_params(struct se_device *dev,
+		const char *page, ssize_t count)
+{
+	struct tcmu_dev *udev = TCMU_DEV(dev);
+	char *orig, *ptr, *opts, *arg_p;
+	substring_t args[MAX_OPT_ARGS];
+	int ret = 0, token;
+	unsigned long tmp_ul;
+
+	opts = kstrdup(page, GFP_KERNEL);
+	if (!opts)
+		return -ENOMEM;
+
+	orig = opts;
+
+	while ((ptr = strsep(&opts, ",\n")) != NULL) {
+		if (!*ptr)
+			continue;
+
+		token = match_token(ptr, tokens, args);
+		switch (token) {
+		case Opt_dev_config:
+			if (match_strlcpy(udev->dev_config, &args[0],
+					  TCMU_CONFIG_LEN) == 0) {
+				ret = -EINVAL;
+				break;
+			}
+			pr_debug("TCMU: Referencing Path: %s\n", udev->dev_config);
+			break;
+		case Opt_dev_size:
+			arg_p = match_strdup(&args[0]);
+			if (!arg_p) {
+				ret = -ENOMEM;
+				break;
+			}
+			ret = kstrtoul(arg_p, 0, (unsigned long *) &udev->dev_size);
+			kfree(arg_p);
+			if (ret < 0)
+				pr_err("kstrtoul() failed for dev_size=\n");
+			break;
+		case Opt_hw_block_size:
+			arg_p = match_strdup(&args[0]);
+			if (!arg_p) {
+				ret = -ENOMEM;
+				break;
+			}
+			ret = kstrtoul(arg_p, 0, &tmp_ul);
+			kfree(arg_p);
+			if (ret < 0) {
+				pr_err("kstrtoul() failed for hw_block_size=\n");
+				break;
+			}
+			if (!tmp_ul) {
+				pr_err("hw_block_size must be nonzero\n");
+				break;
+			}
+			dev->dev_attrib.hw_block_size = tmp_ul;
+			break;
+		default:
+			break;
+		}
+	}
+
+	kfree(orig);
+	return (!ret) ? count : ret;
+}
+
+static ssize_t tcmu_show_configfs_dev_params(struct se_device *dev, char *b)
+{
+	struct tcmu_dev *udev = TCMU_DEV(dev);
+	ssize_t bl = 0;
+
+	bl = sprintf(b + bl, "Config: %s ",
+		     udev->dev_config[0] ? udev->dev_config : "NULL");
+	bl += sprintf(b + bl, "Size: %zu\n", udev->dev_size);
+
+	return bl;
+}
+
+static sector_t tcmu_get_blocks(struct se_device *dev)
+{
+	struct tcmu_dev *udev = TCMU_DEV(dev);
+
+	return div_u64(udev->dev_size - dev->dev_attrib.block_size,
+		       dev->dev_attrib.block_size);
+}
+
+static sense_reason_t
+tcmu_pass_op(struct se_cmd *se_cmd)
+{
+	int ret = tcmu_queue_cmd(se_cmd);
+
+	if (ret != 0)
+		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+	else
+		return TCM_NO_SENSE;
+}
+
+static sense_reason_t
+tcmu_parse_cdb(struct se_cmd *cmd)
+{
+	return passthrough_parse_cdb(cmd, tcmu_pass_op);
+}
+
+DEF_TB_DEV_ATTRIB_RO(tcmu, hw_pi_prot_type);
+TB_DEV_ATTR_RO(tcmu, hw_pi_prot_type);
+
+DEF_TB_DEV_ATTRIB_RO(tcmu, hw_block_size);
+TB_DEV_ATTR_RO(tcmu, hw_block_size);
+
+DEF_TB_DEV_ATTRIB_RO(tcmu, hw_max_sectors);
+TB_DEV_ATTR_RO(tcmu, hw_max_sectors);
+
+DEF_TB_DEV_ATTRIB_RO(tcmu, hw_queue_depth);
+TB_DEV_ATTR_RO(tcmu, hw_queue_depth);
+
+static struct configfs_attribute *tcmu_backend_dev_attrs[] = {
+	&tcmu_dev_attrib_hw_pi_prot_type.attr,
+	&tcmu_dev_attrib_hw_block_size.attr,
+	&tcmu_dev_attrib_hw_max_sectors.attr,
+	&tcmu_dev_attrib_hw_queue_depth.attr,
+	NULL,
+};
+
+static struct se_subsystem_api tcmu_template = {
+	.name			= "user",
+	.inquiry_prod		= "USER",
+	.inquiry_rev		= TCMU_VERSION,
+	.owner			= THIS_MODULE,
+	.transport_flags	= TRANSPORT_FLAG_PASSTHROUGH,
+	.attach_hba		= tcmu_attach_hba,
+	.detach_hba		= tcmu_detach_hba,
+	.alloc_device		= tcmu_alloc_device,
+	.configure_device	= tcmu_configure_device,
+	.free_device		= tcmu_free_device,
+	.parse_cdb		= tcmu_parse_cdb,
+	.set_configfs_dev_params = tcmu_set_configfs_dev_params,
+	.show_configfs_dev_params = tcmu_show_configfs_dev_params,
+	.get_device_type	= sbc_get_device_type,
+	.get_blocks		= tcmu_get_blocks,
+};
+
+static int __init tcmu_module_init(void)
+{
+	struct target_backend_cits *tbc = &tcmu_template.tb_cits;
+	int ret;
+
+	BUILD_BUG_ON((sizeof(struct tcmu_cmd_entry) % TCMU_OP_ALIGN_SIZE) != 0);
+
+	tcmu_cmd_cache = kmem_cache_create("tcmu_cmd_cache",
+				sizeof(struct tcmu_cmd),
+				__alignof__(struct tcmu_cmd),
+				0, NULL);
+	if (!tcmu_cmd_cache)
+		return -ENOMEM;
+
+	tcmu_root_device = root_device_register("tcm_user");
+	if (IS_ERR(tcmu_root_device)) {
+		ret = PTR_ERR(tcmu_root_device);
+		goto out_free_cache;
+	}
+
+	ret = genl_register_family(&tcmu_genl_family);
+	if (ret < 0) {
+		goto out_unreg_device;
+	}
+
+	target_core_setup_sub_cits(&tcmu_template);
+	tbc->tb_dev_attrib_cit.ct_attrs = tcmu_backend_dev_attrs;
+
+	ret = transport_subsystem_register(&tcmu_template);
+	if (ret)
+		goto out_unreg_genl;
+
+	return 0;
+
+out_unreg_genl:
+	genl_unregister_family(&tcmu_genl_family);
+out_unreg_device:
+	root_device_unregister(tcmu_root_device);
+out_free_cache:
+	kmem_cache_destroy(tcmu_cmd_cache);
+
+	return ret;
+}
+
+static void __exit tcmu_module_exit(void)
+{
+	transport_subsystem_release(&tcmu_template);
+	genl_unregister_family(&tcmu_genl_family);
+	root_device_unregister(tcmu_root_device);
+	kmem_cache_destroy(tcmu_cmd_cache);
+}
+
+MODULE_DESCRIPTION("TCM USER subsystem plugin");
+MODULE_AUTHOR("Shaohua Li <shli@kernel.org>");
+MODULE_AUTHOR("Andy Grover <agrover@redhat.com>");
+MODULE_LICENSE("GPL");
+
+module_init(tcmu_module_init);
+module_exit(tcmu_module_exit);
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_xcopy.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_xcopy.c
--- linux-3.10.69/drivers/target/target_core_xcopy.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_xcopy.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,1081 @@
+/*******************************************************************************
+ * Filename: target_core_xcopy.c
+ *
+ * This file contains support for SPC-4 Extended-Copy offload with generic
+ * TCM backends.
+ *
+ * Copyright (c) 2011-2013 Datera, Inc. All rights reserved.
+ *
+ * Author:
+ * Nicholas A. Bellinger <nab@daterainc.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ ******************************************************************************/
+
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/list.h>
+#include <linux/configfs.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <asm/unaligned.h>
+
+#include <target/target_core_base.h>
+#include <target/target_core_backend.h>
+#include <target/target_core_fabric.h>
+#include <target/target_core_configfs.h>
+
+#include "target_core_pr.h"
+#include "target_core_ua.h"
+#include "target_core_xcopy.h"
+
+static struct workqueue_struct *xcopy_wq = NULL;
+/*
+ * From target_core_device.c
+ */
+extern struct mutex g_device_mutex;
+extern struct list_head g_device_list;
+/*
+ * From target_core_configfs.c
+ */
+extern struct configfs_subsystem *target_core_subsystem[];
+
+static int target_xcopy_gen_naa_ieee(struct se_device *dev, unsigned char *buf)
+{
+	int off = 0;
+
+	buf[off++] = (0x6 << 4);
+	buf[off++] = 0x01;
+	buf[off++] = 0x40;
+	buf[off] = (0x5 << 4);
+
+	spc_parse_naa_6h_vendor_specific(dev, &buf[off]);
+	return 0;
+}
+
+static int target_xcopy_locate_se_dev_e4(struct se_cmd *se_cmd, struct xcopy_op *xop,
+					bool src)
+{
+	struct se_device *se_dev;
+	struct configfs_subsystem *subsys = target_core_subsystem[0];
+	unsigned char tmp_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN], *dev_wwn;
+	int rc;
+
+	if (src == true)
+		dev_wwn = &xop->dst_tid_wwn[0];
+	else
+		dev_wwn = &xop->src_tid_wwn[0];
+
+	mutex_lock(&g_device_mutex);
+	list_for_each_entry(se_dev, &g_device_list, g_dev_node) {
+
+		if (!se_dev->dev_attrib.emulate_3pc)
+			continue;
+
+		memset(&tmp_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);
+		target_xcopy_gen_naa_ieee(se_dev, &tmp_dev_wwn[0]);
+
+		rc = memcmp(&tmp_dev_wwn[0], dev_wwn, XCOPY_NAA_IEEE_REGEX_LEN);
+		if (rc != 0)
+			continue;
+
+		if (src == true) {
+			xop->dst_dev = se_dev;
+			pr_debug("XCOPY 0xe4: Setting xop->dst_dev: %p from located"
+				" se_dev\n", xop->dst_dev);
+		} else {
+			xop->src_dev = se_dev;
+			pr_debug("XCOPY 0xe4: Setting xop->src_dev: %p from located"
+				" se_dev\n", xop->src_dev);
+		}
+
+		rc = configfs_depend_item(subsys,
+				&se_dev->dev_group.cg_item);
+		if (rc != 0) {
+			pr_err("configfs_depend_item attempt failed:"
+				" %d for se_dev: %p\n", rc, se_dev);
+			mutex_unlock(&g_device_mutex);
+			return rc;
+		}
+
+		pr_debug("Called configfs_depend_item for subsys: %p se_dev: %p"
+			" se_dev->se_dev_group: %p\n", subsys, se_dev,
+			&se_dev->dev_group);
+
+		mutex_unlock(&g_device_mutex);
+		return 0;
+	}
+	mutex_unlock(&g_device_mutex);
+
+	pr_err("Unable to locate 0xe4 descriptor for EXTENDED_COPY\n");
+	return -EINVAL;
+}
+
+static int target_xcopy_parse_tiddesc_e4(struct se_cmd *se_cmd, struct xcopy_op *xop,
+				unsigned char *p, bool src)
+{
+	unsigned char *desc = p;
+	unsigned short ript;
+	u8 desig_len;
+	/*
+	 * Extract RELATIVE INITIATOR PORT IDENTIFIER
+	 */
+	ript = get_unaligned_be16(&desc[2]);
+	pr_debug("XCOPY 0xe4: RELATIVE INITIATOR PORT IDENTIFIER: %hu\n", ript);
+	/*
+	 * Check for supported code set, association, and designator type
+	 */
+	if ((desc[4] & 0x0f) != 0x1) {
+		pr_err("XCOPY 0xe4: code set of non binary type not supported\n");
+		return -EINVAL;
+	}
+	if ((desc[5] & 0x30) != 0x00) {
+		pr_err("XCOPY 0xe4: association other than LUN not supported\n");
+		return -EINVAL;
+	}
+	if ((desc[5] & 0x0f) != 0x3) {
+		pr_err("XCOPY 0xe4: designator type unsupported: 0x%02x\n",
+				(desc[5] & 0x0f));
+		return -EINVAL;
+	}
+	/*
+	 * Check for matching 16 byte length for NAA IEEE Registered Extended
+	 * Assigned designator
+	 */
+	desig_len = desc[7];
+	if (desig_len != 16) {
+		pr_err("XCOPY 0xe4: invalid desig_len: %d\n", (int)desig_len);
+		return -EINVAL;
+	}
+	pr_debug("XCOPY 0xe4: desig_len: %d\n", (int)desig_len);
+	/*
+	 * Check for NAA IEEE Registered Extended Assigned header..
+	 */
+	if ((desc[8] & 0xf0) != 0x60) {
+		pr_err("XCOPY 0xe4: Unsupported DESIGNATOR TYPE: 0x%02x\n",
+					(desc[8] & 0xf0));
+		return -EINVAL;
+	}
+
+	if (src == true) {
+		memcpy(&xop->src_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);
+		/*
+		 * Determine if the source designator matches the local device
+		 */
+		if (!memcmp(&xop->local_dev_wwn[0], &xop->src_tid_wwn[0],
+				XCOPY_NAA_IEEE_REGEX_LEN)) {
+			xop->op_origin = XCOL_SOURCE_RECV_OP;
+			xop->src_dev = se_cmd->se_dev;
+			pr_debug("XCOPY 0xe4: Set xop->src_dev %p from source"
+					" received xop\n", xop->src_dev);
+		}
+	} else {
+		memcpy(&xop->dst_tid_wwn[0], &desc[8], XCOPY_NAA_IEEE_REGEX_LEN);
+		/*
+		 * Determine if the destination designator matches the local device
+		 */
+		if (!memcmp(&xop->local_dev_wwn[0], &xop->dst_tid_wwn[0],
+				XCOPY_NAA_IEEE_REGEX_LEN)) {
+			xop->op_origin = XCOL_DEST_RECV_OP;
+			xop->dst_dev = se_cmd->se_dev;
+			pr_debug("XCOPY 0xe4: Set xop->dst_dev: %p from destination"
+				" received xop\n", xop->dst_dev);
+		}
+	}
+
+	return 0;
+}
+
+static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,
+				struct xcopy_op *xop, unsigned char *p,
+				unsigned short tdll)
+{
+	struct se_device *local_dev = se_cmd->se_dev;
+	unsigned char *desc = p;
+	int offset = tdll % XCOPY_TARGET_DESC_LEN, rc, ret = 0;
+	unsigned short start = 0;
+	bool src = true;
+
+	if (offset != 0) {
+		pr_err("XCOPY target descriptor list length is not"
+			" multiple of %d\n", XCOPY_TARGET_DESC_LEN);
+		return -EINVAL;
+	}
+	if (tdll > 64) {
+		pr_err("XCOPY target descriptor supports a maximum"
+			" two src/dest descriptors, tdll: %hu too large..\n", tdll);
+		return -EINVAL;
+	}
+	/*
+	 * Generate an IEEE Registered Extended designator based upon the
+	 * se_device the XCOPY was received upon..
+	 */
+	memset(&xop->local_dev_wwn[0], 0, XCOPY_NAA_IEEE_REGEX_LEN);
+	target_xcopy_gen_naa_ieee(local_dev, &xop->local_dev_wwn[0]);
+
+	while (start < tdll) {
+		/*
+		 * Check target descriptor identification with 0xE4 type with
+		 * use VPD 0x83 WWPN matching ..
+		 */
+		switch (desc[0]) {
+		case 0xe4:
+			rc = target_xcopy_parse_tiddesc_e4(se_cmd, xop,
+							&desc[0], src);
+			if (rc != 0)
+				goto out;
+			/*
+			 * Assume target descriptors are in source -> destination order..
+			 */
+			if (src == true)
+				src = false;
+			else
+				src = true;
+			start += XCOPY_TARGET_DESC_LEN;
+			desc += XCOPY_TARGET_DESC_LEN;
+			ret++;
+			break;
+		default:
+			pr_err("XCOPY unsupported descriptor type code:"
+					" 0x%02x\n", desc[0]);
+			goto out;
+		}
+	}
+
+	if (xop->op_origin == XCOL_SOURCE_RECV_OP)
+		rc = target_xcopy_locate_se_dev_e4(se_cmd, xop, true);
+	else
+		rc = target_xcopy_locate_se_dev_e4(se_cmd, xop, false);
+
+	if (rc < 0)
+		goto out;
+
+	pr_debug("XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\n",
+		 xop->src_dev, &xop->src_tid_wwn[0]);
+	pr_debug("XCOPY TGT desc: Dest dev: %p NAA IEEE WWN: 0x%16phN\n",
+		 xop->dst_dev, &xop->dst_tid_wwn[0]);
+
+	return ret;
+
+out:
+	return -EINVAL;
+}
+
+static int target_xcopy_parse_segdesc_02(struct se_cmd *se_cmd, struct xcopy_op *xop,
+					unsigned char *p)
+{
+	unsigned char *desc = p;
+	int dc = (desc[1] & 0x02);
+	unsigned short desc_len;
+
+	desc_len = get_unaligned_be16(&desc[2]);
+	if (desc_len != 0x18) {
+		pr_err("XCOPY segment desc 0x02: Illegal desc_len:"
+				" %hu\n", desc_len);
+		return -EINVAL;
+	}
+
+	xop->stdi = get_unaligned_be16(&desc[4]);
+	xop->dtdi = get_unaligned_be16(&desc[6]);
+	pr_debug("XCOPY seg desc 0x02: desc_len: %hu stdi: %hu dtdi: %hu, DC: %d\n",
+		desc_len, xop->stdi, xop->dtdi, dc);
+
+	xop->nolb = get_unaligned_be16(&desc[10]);
+	xop->src_lba = get_unaligned_be64(&desc[12]);
+	xop->dst_lba = get_unaligned_be64(&desc[20]);
+	pr_debug("XCOPY seg desc 0x02: nolb: %hu src_lba: %llu dst_lba: %llu\n",
+		xop->nolb, (unsigned long long)xop->src_lba,
+		(unsigned long long)xop->dst_lba);
+
+	if (dc != 0) {
+		xop->dbl = (desc[29] & 0xff) << 16;
+		xop->dbl |= (desc[30] & 0xff) << 8;
+		xop->dbl |= desc[31] & 0xff;
+
+		pr_debug("XCOPY seg desc 0x02: DC=1 w/ dbl: %u\n", xop->dbl);
+	}
+	return 0;
+}
+
+static int target_xcopy_parse_segment_descriptors(struct se_cmd *se_cmd,
+				struct xcopy_op *xop, unsigned char *p,
+				unsigned int sdll)
+{
+	unsigned char *desc = p;
+	unsigned int start = 0;
+	int offset = sdll % XCOPY_SEGMENT_DESC_LEN, rc, ret = 0;
+
+	if (offset != 0) {
+		pr_err("XCOPY segment descriptor list length is not"
+			" multiple of %d\n", XCOPY_SEGMENT_DESC_LEN);
+		return -EINVAL;
+	}
+
+	while (start < sdll) {
+		/*
+		 * Check segment descriptor type code for block -> block
+		 */
+		switch (desc[0]) {
+		case 0x02:
+			rc = target_xcopy_parse_segdesc_02(se_cmd, xop, desc);
+			if (rc < 0)
+				goto out;
+
+			ret++;
+			start += XCOPY_SEGMENT_DESC_LEN;
+			desc += XCOPY_SEGMENT_DESC_LEN;
+			break;
+		default:
+			pr_err("XCOPY unspported segment descriptor"
+				"type: 0x%02x\n", desc[0]);
+			goto out;
+		}
+	}
+
+	return ret;
+
+out:
+	return -EINVAL;
+}
+
+/*
+ * Start xcopy_pt ops
+ */
+
+struct xcopy_pt_cmd {
+	bool remote_port;
+	struct se_cmd se_cmd;
+	struct xcopy_op *xcopy_op;
+	struct completion xpt_passthrough_sem;
+	unsigned char sense_buffer[TRANSPORT_SENSE_BUFFER];
+};
+
+static struct se_port xcopy_pt_port;
+static struct se_portal_group xcopy_pt_tpg;
+static struct se_session xcopy_pt_sess;
+static struct se_node_acl xcopy_pt_nacl;
+
+static char *xcopy_pt_get_fabric_name(void)
+{
+        return "xcopy-pt";
+}
+
+static u32 xcopy_pt_get_tag(struct se_cmd *se_cmd)
+{
+        return 0;
+}
+
+static int xcopy_pt_get_cmd_state(struct se_cmd *se_cmd)
+{
+        return 0;
+}
+
+static void xcopy_pt_undepend_remotedev(struct xcopy_op *xop)
+{
+	struct configfs_subsystem *subsys = target_core_subsystem[0];
+	struct se_device *remote_dev;
+
+	if (xop->op_origin == XCOL_SOURCE_RECV_OP)
+		remote_dev = xop->dst_dev;
+	else
+		remote_dev = xop->src_dev;
+
+	pr_debug("Calling configfs_undepend_item for subsys: %p"
+		  " remote_dev: %p remote_dev->dev_group: %p\n",
+		  subsys, remote_dev, &remote_dev->dev_group.cg_item);
+
+	configfs_undepend_item(subsys, &remote_dev->dev_group.cg_item);
+}
+
+static void xcopy_pt_release_cmd(struct se_cmd *se_cmd)
+{
+	struct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,
+				struct xcopy_pt_cmd, se_cmd);
+
+	kfree(xpt_cmd);
+}
+
+static int xcopy_pt_check_stop_free(struct se_cmd *se_cmd)
+{
+	struct xcopy_pt_cmd *xpt_cmd = container_of(se_cmd,
+				struct xcopy_pt_cmd, se_cmd);
+
+	complete(&xpt_cmd->xpt_passthrough_sem);
+	return 0;
+}
+
+static int xcopy_pt_write_pending(struct se_cmd *se_cmd)
+{
+	return 0;
+}
+
+static int xcopy_pt_write_pending_status(struct se_cmd *se_cmd)
+{
+	return 0;
+}
+
+static int xcopy_pt_queue_data_in(struct se_cmd *se_cmd)
+{
+	return 0;
+}
+
+static int xcopy_pt_queue_status(struct se_cmd *se_cmd)
+{
+	return 0;
+}
+
+static struct target_core_fabric_ops xcopy_pt_tfo = {
+	.get_fabric_name	= xcopy_pt_get_fabric_name,
+	.get_task_tag		= xcopy_pt_get_tag,
+	.get_cmd_state		= xcopy_pt_get_cmd_state,
+	.release_cmd		= xcopy_pt_release_cmd,
+	.check_stop_free	= xcopy_pt_check_stop_free,
+	.write_pending		= xcopy_pt_write_pending,
+	.write_pending_status	= xcopy_pt_write_pending_status,
+	.queue_data_in		= xcopy_pt_queue_data_in,
+	.queue_status		= xcopy_pt_queue_status,
+};
+
+/*
+ * End xcopy_pt_ops
+ */
+
+int target_xcopy_setup_pt(void)
+{
+	xcopy_wq = alloc_workqueue("xcopy_wq", WQ_MEM_RECLAIM, 0);
+	if (!xcopy_wq) {
+		pr_err("Unable to allocate xcopy_wq\n");
+		return -ENOMEM;
+	}
+
+	memset(&xcopy_pt_port, 0, sizeof(struct se_port));
+	INIT_LIST_HEAD(&xcopy_pt_port.sep_alua_list);
+	INIT_LIST_HEAD(&xcopy_pt_port.sep_list);
+	mutex_init(&xcopy_pt_port.sep_tg_pt_md_mutex);
+
+	memset(&xcopy_pt_tpg, 0, sizeof(struct se_portal_group));
+	INIT_LIST_HEAD(&xcopy_pt_tpg.se_tpg_node);
+	INIT_LIST_HEAD(&xcopy_pt_tpg.acl_node_list);
+	INIT_LIST_HEAD(&xcopy_pt_tpg.tpg_sess_list);
+
+	xcopy_pt_port.sep_tpg = &xcopy_pt_tpg;
+	xcopy_pt_tpg.se_tpg_tfo = &xcopy_pt_tfo;
+
+	memset(&xcopy_pt_nacl, 0, sizeof(struct se_node_acl));
+	INIT_LIST_HEAD(&xcopy_pt_nacl.acl_list);
+	INIT_LIST_HEAD(&xcopy_pt_nacl.acl_sess_list);
+	memset(&xcopy_pt_sess, 0, sizeof(struct se_session));
+	INIT_LIST_HEAD(&xcopy_pt_sess.sess_list);
+	INIT_LIST_HEAD(&xcopy_pt_sess.sess_acl_list);
+
+	xcopy_pt_nacl.se_tpg = &xcopy_pt_tpg;
+	xcopy_pt_nacl.nacl_sess = &xcopy_pt_sess;
+
+	xcopy_pt_sess.se_tpg = &xcopy_pt_tpg;
+	xcopy_pt_sess.se_node_acl = &xcopy_pt_nacl;
+
+	return 0;
+}
+
+void target_xcopy_release_pt(void)
+{
+	if (xcopy_wq)
+		destroy_workqueue(xcopy_wq);
+}
+
+static void target_xcopy_setup_pt_port(
+	struct xcopy_pt_cmd *xpt_cmd,
+	struct xcopy_op *xop,
+	bool remote_port)
+{
+	struct se_cmd *ec_cmd = xop->xop_se_cmd;
+	struct se_cmd *pt_cmd = &xpt_cmd->se_cmd;
+
+	if (xop->op_origin == XCOL_SOURCE_RECV_OP) {
+		/*
+		 * Honor destination port reservations for X-COPY PUSH emulation
+		 * when CDB is received on local source port, and READs blocks to
+		 * WRITE on remote destination port.
+		 */
+		if (remote_port) {
+			xpt_cmd->remote_port = remote_port;
+			pt_cmd->se_lun->lun_sep = &xcopy_pt_port;
+			pr_debug("Setup emulated remote DEST xcopy_pt_port: %p to"
+				" cmd->se_lun->lun_sep for X-COPY data PUSH\n",
+				pt_cmd->se_lun->lun_sep);
+		} else {
+			pt_cmd->se_lun = ec_cmd->se_lun;
+			pt_cmd->se_dev = ec_cmd->se_dev;
+
+			pr_debug("Honoring local SRC port from ec_cmd->se_dev:"
+				" %p\n", pt_cmd->se_dev);
+			pt_cmd->se_lun = ec_cmd->se_lun;
+			pr_debug("Honoring local SRC port from ec_cmd->se_lun: %p\n",
+				pt_cmd->se_lun);
+		}
+	} else {
+		/*
+		 * Honor source port reservation for X-COPY PULL emulation
+		 * when CDB is received on local desintation port, and READs
+		 * blocks from the remote source port to WRITE on local
+		 * destination port.
+		 */
+		if (remote_port) {
+			xpt_cmd->remote_port = remote_port;
+			pt_cmd->se_lun->lun_sep = &xcopy_pt_port;
+			pr_debug("Setup emulated remote SRC xcopy_pt_port: %p to"
+				" cmd->se_lun->lun_sep for X-COPY data PULL\n",
+				pt_cmd->se_lun->lun_sep);
+		} else {
+			pt_cmd->se_lun = ec_cmd->se_lun;
+			pt_cmd->se_dev = ec_cmd->se_dev;
+
+			pr_debug("Honoring local DST port from ec_cmd->se_dev:"
+				" %p\n", pt_cmd->se_dev);
+			pt_cmd->se_lun = ec_cmd->se_lun;
+			pr_debug("Honoring local DST port from ec_cmd->se_lun: %p\n",
+				pt_cmd->se_lun);
+		}
+	}
+}
+
+static int target_xcopy_init_pt_lun(
+	struct xcopy_pt_cmd *xpt_cmd,
+	struct xcopy_op *xop,
+	struct se_device *se_dev,
+	struct se_cmd *pt_cmd,
+	bool remote_port)
+{
+	/*
+	 * Don't allocate + init an pt_cmd->se_lun if honoring local port for
+	 * reservations.  The pt_cmd->se_lun pointer will be setup from within
+	 * target_xcopy_setup_pt_port()
+	 */
+	if (remote_port == false) {
+		pt_cmd->se_cmd_flags |= SCF_SE_LUN_CMD | SCF_CMD_XCOPY_PASSTHROUGH;
+		return 0;
+	}
+
+	pt_cmd->se_lun = &se_dev->xcopy_lun;
+	pt_cmd->se_dev = se_dev;
+
+	pr_debug("Setup emulated se_dev: %p from se_dev\n", pt_cmd->se_dev);
+	pt_cmd->se_cmd_flags |= SCF_SE_LUN_CMD | SCF_CMD_XCOPY_PASSTHROUGH;
+
+	pr_debug("Setup emulated se_dev: %p to pt_cmd->se_lun->lun_se_dev\n",
+		pt_cmd->se_lun->lun_se_dev);
+
+	return 0;
+}
+
+static int target_xcopy_setup_pt_cmd(
+	struct xcopy_pt_cmd *xpt_cmd,
+	struct xcopy_op *xop,
+	struct se_device *se_dev,
+	unsigned char *cdb,
+	bool remote_port,
+	bool alloc_mem)
+{
+	struct se_cmd *cmd = &xpt_cmd->se_cmd;
+	sense_reason_t sense_rc;
+	int ret = 0, rc;
+	/*
+	 * Setup LUN+port to honor reservations based upon xop->op_origin for
+	 * X-COPY PUSH or X-COPY PULL based upon where the CDB was received.
+	 */
+	rc = target_xcopy_init_pt_lun(xpt_cmd, xop, se_dev, cmd, remote_port);
+	if (rc < 0) {
+		ret = rc;
+		goto out;
+	}
+	xpt_cmd->xcopy_op = xop;
+	target_xcopy_setup_pt_port(xpt_cmd, xop, remote_port);
+
+	sense_rc = target_setup_cmd_from_cdb(cmd, cdb);
+	if (sense_rc) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	if (alloc_mem) {
+		rc = target_alloc_sgl(&cmd->t_data_sg, &cmd->t_data_nents,
+				      cmd->data_length, false);
+		if (rc < 0) {
+			ret = rc;
+			goto out;
+		}
+		/*
+		 * Set this bit so that transport_free_pages() allows the
+		 * caller to release SGLs + physical memory allocated by
+		 * transport_generic_get_mem()..
+		 */
+		cmd->se_cmd_flags |= SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;
+	} else {
+		/*
+		 * Here the previously allocated SGLs for the internal READ
+		 * are mapped zero-copy to the internal WRITE.
+		 */
+		sense_rc = transport_generic_map_mem_to_cmd(cmd,
+					xop->xop_data_sg, xop->xop_data_nents,
+					NULL, 0);
+		if (sense_rc) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		pr_debug("Setup PASSTHROUGH_NOALLOC t_data_sg: %p t_data_nents:"
+			 " %u\n", cmd->t_data_sg, cmd->t_data_nents);
+	}
+
+	return 0;
+
+out:
+	return ret;
+}
+
+static int target_xcopy_issue_pt_cmd(struct xcopy_pt_cmd *xpt_cmd)
+{
+	struct se_cmd *se_cmd = &xpt_cmd->se_cmd;
+	sense_reason_t sense_rc;
+
+	sense_rc = transport_generic_new_cmd(se_cmd);
+	if (sense_rc)
+		return -EINVAL;
+
+	if (se_cmd->data_direction == DMA_TO_DEVICE)
+		target_execute_cmd(se_cmd);
+
+	wait_for_completion_interruptible(&xpt_cmd->xpt_passthrough_sem);
+
+	pr_debug("target_xcopy_issue_pt_cmd(): SCSI status: 0x%02x\n",
+			se_cmd->scsi_status);
+
+	return (se_cmd->scsi_status) ? -EINVAL : 0;
+}
+
+static int target_xcopy_read_source(
+	struct se_cmd *ec_cmd,
+	struct xcopy_op *xop,
+	struct se_device *src_dev,
+	sector_t src_lba,
+	u32 src_sectors)
+{
+	struct xcopy_pt_cmd *xpt_cmd;
+	struct se_cmd *se_cmd;
+	u32 length = (src_sectors * src_dev->dev_attrib.block_size);
+	int rc;
+	unsigned char cdb[16];
+	bool remote_port = (xop->op_origin == XCOL_DEST_RECV_OP);
+
+	xpt_cmd = kzalloc(sizeof(struct xcopy_pt_cmd), GFP_KERNEL);
+	if (!xpt_cmd) {
+		pr_err("Unable to allocate xcopy_pt_cmd\n");
+		return -ENOMEM;
+	}
+	init_completion(&xpt_cmd->xpt_passthrough_sem);
+	se_cmd = &xpt_cmd->se_cmd;
+
+	memset(&cdb[0], 0, 16);
+	cdb[0] = READ_16;
+	put_unaligned_be64(src_lba, &cdb[2]);
+	put_unaligned_be32(src_sectors, &cdb[10]);
+	pr_debug("XCOPY: Built READ_16: LBA: %llu Sectors: %u Length: %u\n",
+		(unsigned long long)src_lba, src_sectors, length);
+
+	transport_init_se_cmd(se_cmd, &xcopy_pt_tfo, NULL, length,
+			      DMA_FROM_DEVICE, 0, &xpt_cmd->sense_buffer[0]);
+	xop->src_pt_cmd = xpt_cmd;
+
+	rc = target_xcopy_setup_pt_cmd(xpt_cmd, xop, src_dev, &cdb[0],
+				remote_port, true);
+	if (rc < 0) {
+		transport_generic_free_cmd(se_cmd, 0);
+		return rc;
+	}
+
+	xop->xop_data_sg = se_cmd->t_data_sg;
+	xop->xop_data_nents = se_cmd->t_data_nents;
+	pr_debug("XCOPY-READ: Saved xop->xop_data_sg: %p, num: %u for READ"
+		" memory\n", xop->xop_data_sg, xop->xop_data_nents);
+
+	rc = target_xcopy_issue_pt_cmd(xpt_cmd);
+	if (rc < 0) {
+		transport_generic_free_cmd(se_cmd, 0);
+		return rc;
+	}
+	/*
+	 * Clear off the allocated t_data_sg, that has been saved for
+	 * zero-copy WRITE submission reuse in struct xcopy_op..
+	 */
+	se_cmd->t_data_sg = NULL;
+	se_cmd->t_data_nents = 0;
+
+	return 0;
+}
+
+static int target_xcopy_write_destination(
+	struct se_cmd *ec_cmd,
+	struct xcopy_op *xop,
+	struct se_device *dst_dev,
+	sector_t dst_lba,
+	u32 dst_sectors)
+{
+	struct xcopy_pt_cmd *xpt_cmd;
+	struct se_cmd *se_cmd;
+	u32 length = (dst_sectors * dst_dev->dev_attrib.block_size);
+	int rc;
+	unsigned char cdb[16];
+	bool remote_port = (xop->op_origin == XCOL_SOURCE_RECV_OP);
+
+	xpt_cmd = kzalloc(sizeof(struct xcopy_pt_cmd), GFP_KERNEL);
+	if (!xpt_cmd) {
+		pr_err("Unable to allocate xcopy_pt_cmd\n");
+		return -ENOMEM;
+	}
+	init_completion(&xpt_cmd->xpt_passthrough_sem);
+	se_cmd = &xpt_cmd->se_cmd;
+
+	memset(&cdb[0], 0, 16);
+	cdb[0] = WRITE_16;
+	put_unaligned_be64(dst_lba, &cdb[2]);
+	put_unaligned_be32(dst_sectors, &cdb[10]);
+	pr_debug("XCOPY: Built WRITE_16: LBA: %llu Sectors: %u Length: %u\n",
+		(unsigned long long)dst_lba, dst_sectors, length);
+
+	transport_init_se_cmd(se_cmd, &xcopy_pt_tfo, NULL, length,
+			      DMA_TO_DEVICE, 0, &xpt_cmd->sense_buffer[0]);
+	xop->dst_pt_cmd = xpt_cmd;
+
+	rc = target_xcopy_setup_pt_cmd(xpt_cmd, xop, dst_dev, &cdb[0],
+				remote_port, false);
+	if (rc < 0) {
+		struct se_cmd *src_cmd = &xop->src_pt_cmd->se_cmd;
+		/*
+		 * If the failure happened before the t_mem_list hand-off in
+		 * target_xcopy_setup_pt_cmd(), Reset memory + clear flag so that
+		 * core releases this memory on error during X-COPY WRITE I/O.
+		 */
+		src_cmd->se_cmd_flags &= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;
+		src_cmd->t_data_sg = xop->xop_data_sg;
+		src_cmd->t_data_nents = xop->xop_data_nents;
+
+		transport_generic_free_cmd(se_cmd, 0);
+		return rc;
+	}
+
+	rc = target_xcopy_issue_pt_cmd(xpt_cmd);
+	if (rc < 0) {
+		se_cmd->se_cmd_flags &= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;
+		transport_generic_free_cmd(se_cmd, 0);
+		return rc;
+	}
+
+	return 0;
+}
+
+static void target_xcopy_do_work(struct work_struct *work)
+{
+	struct xcopy_op *xop = container_of(work, struct xcopy_op, xop_work);
+	struct se_device *src_dev = xop->src_dev, *dst_dev = xop->dst_dev;
+	struct se_cmd *ec_cmd = xop->xop_se_cmd;
+	sector_t src_lba = xop->src_lba, dst_lba = xop->dst_lba, end_lba;
+	unsigned int max_sectors;
+	int rc;
+	unsigned short nolb = xop->nolb, cur_nolb, max_nolb, copied_nolb = 0;
+
+	end_lba = src_lba + nolb;
+	/*
+	 * Break up XCOPY I/O into hw_max_sectors sized I/O based on the
+	 * smallest max_sectors between src_dev + dev_dev, or
+	 */
+	max_sectors = min(src_dev->dev_attrib.hw_max_sectors,
+			  dst_dev->dev_attrib.hw_max_sectors);
+	max_sectors = min_t(u32, max_sectors, XCOPY_MAX_SECTORS);
+
+	max_nolb = min_t(u16, max_sectors, ((u16)(~0U)));
+
+	pr_debug("target_xcopy_do_work: nolb: %hu, max_nolb: %hu end_lba: %llu\n",
+			nolb, max_nolb, (unsigned long long)end_lba);
+	pr_debug("target_xcopy_do_work: Starting src_lba: %llu, dst_lba: %llu\n",
+			(unsigned long long)src_lba, (unsigned long long)dst_lba);
+
+	while (src_lba < end_lba) {
+		cur_nolb = min(nolb, max_nolb);
+
+		pr_debug("target_xcopy_do_work: Calling read src_dev: %p src_lba: %llu,"
+			" cur_nolb: %hu\n", src_dev, (unsigned long long)src_lba, cur_nolb);
+
+		rc = target_xcopy_read_source(ec_cmd, xop, src_dev, src_lba, cur_nolb);
+		if (rc < 0)
+			goto out;
+
+		src_lba += cur_nolb;
+		pr_debug("target_xcopy_do_work: Incremented READ src_lba to %llu\n",
+				(unsigned long long)src_lba);
+
+		pr_debug("target_xcopy_do_work: Calling write dst_dev: %p dst_lba: %llu,"
+			" cur_nolb: %hu\n", dst_dev, (unsigned long long)dst_lba, cur_nolb);
+
+		rc = target_xcopy_write_destination(ec_cmd, xop, dst_dev,
+						dst_lba, cur_nolb);
+		if (rc < 0) {
+			transport_generic_free_cmd(&xop->src_pt_cmd->se_cmd, 0);
+			goto out;
+		}
+
+		dst_lba += cur_nolb;
+		pr_debug("target_xcopy_do_work: Incremented WRITE dst_lba to %llu\n",
+				(unsigned long long)dst_lba);
+
+		copied_nolb += cur_nolb;
+		nolb -= cur_nolb;
+
+		transport_generic_free_cmd(&xop->src_pt_cmd->se_cmd, 0);
+		xop->dst_pt_cmd->se_cmd.se_cmd_flags &= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;
+
+		transport_generic_free_cmd(&xop->dst_pt_cmd->se_cmd, 0);
+	}
+
+	xcopy_pt_undepend_remotedev(xop);
+	kfree(xop);
+
+	pr_debug("target_xcopy_do_work: Final src_lba: %llu, dst_lba: %llu\n",
+		(unsigned long long)src_lba, (unsigned long long)dst_lba);
+	pr_debug("target_xcopy_do_work: Blocks copied: %hu, Bytes Copied: %u\n",
+		copied_nolb, copied_nolb * dst_dev->dev_attrib.block_size);
+
+	pr_debug("target_xcopy_do_work: Setting X-COPY GOOD status -> sending response\n");
+	target_complete_cmd(ec_cmd, SAM_STAT_GOOD);
+	return;
+
+out:
+	xcopy_pt_undepend_remotedev(xop);
+	kfree(xop);
+
+	pr_warn("target_xcopy_do_work: Setting X-COPY CHECK_CONDITION -> sending response\n");
+	ec_cmd->scsi_status = SAM_STAT_CHECK_CONDITION;
+	target_complete_cmd(ec_cmd, SAM_STAT_CHECK_CONDITION);
+}
+
+sense_reason_t target_do_xcopy(struct se_cmd *se_cmd)
+{
+	struct se_device *dev = se_cmd->se_dev;
+	struct xcopy_op *xop = NULL;
+	unsigned char *p = NULL, *seg_desc;
+	unsigned int list_id, list_id_usage, sdll, inline_dl, sa;
+	sense_reason_t ret = TCM_INVALID_PARAMETER_LIST;
+	int rc;
+	unsigned short tdll;
+
+	if (!dev->dev_attrib.emulate_3pc) {
+		pr_err("EXTENDED_COPY operation explicitly disabled\n");
+		return TCM_UNSUPPORTED_SCSI_OPCODE;
+	}
+
+	sa = se_cmd->t_task_cdb[1] & 0x1f;
+	if (sa != 0x00) {
+		pr_err("EXTENDED_COPY(LID4) not supported\n");
+		return TCM_UNSUPPORTED_SCSI_OPCODE;
+	}
+
+	xop = kzalloc(sizeof(struct xcopy_op), GFP_KERNEL);
+	if (!xop) {
+		pr_err("Unable to allocate xcopy_op\n");
+		return TCM_OUT_OF_RESOURCES;
+	}
+	xop->xop_se_cmd = se_cmd;
+
+	p = transport_kmap_data_sg(se_cmd);
+	if (!p) {
+		pr_err("transport_kmap_data_sg() failed in target_do_xcopy\n");
+		kfree(xop);
+		return TCM_OUT_OF_RESOURCES;
+	}
+
+	list_id = p[0];
+	list_id_usage = (p[1] & 0x18) >> 3;
+
+	/*
+	 * Determine TARGET DESCRIPTOR LIST LENGTH + SEGMENT DESCRIPTOR LIST LENGTH
+	 */
+	tdll = get_unaligned_be16(&p[2]);
+	sdll = get_unaligned_be32(&p[8]);
+
+	inline_dl = get_unaligned_be32(&p[12]);
+	if (inline_dl != 0) {
+		pr_err("XCOPY with non zero inline data length\n");
+		goto out;
+	}
+
+	pr_debug("Processing XCOPY with list_id: 0x%02x list_id_usage: 0x%02x"
+		" tdll: %hu sdll: %u inline_dl: %u\n", list_id, list_id_usage,
+		tdll, sdll, inline_dl);
+
+	rc = target_xcopy_parse_target_descriptors(se_cmd, xop, &p[16], tdll);
+	if (rc <= 0)
+		goto out;
+
+	if (xop->src_dev->dev_attrib.block_size !=
+	    xop->dst_dev->dev_attrib.block_size) {
+		pr_err("XCOPY: Non matching src_dev block_size: %u + dst_dev"
+		       " block_size: %u currently unsupported\n",
+			xop->src_dev->dev_attrib.block_size,
+			xop->dst_dev->dev_attrib.block_size);
+		xcopy_pt_undepend_remotedev(xop);
+		ret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
+		goto out;
+	}
+
+	pr_debug("XCOPY: Processed %d target descriptors, length: %u\n", rc,
+				rc * XCOPY_TARGET_DESC_LEN);
+	seg_desc = &p[16];
+	seg_desc += (rc * XCOPY_TARGET_DESC_LEN);
+
+	rc = target_xcopy_parse_segment_descriptors(se_cmd, xop, seg_desc, sdll);
+	if (rc <= 0) {
+		xcopy_pt_undepend_remotedev(xop);
+		goto out;
+	}
+	transport_kunmap_data_sg(se_cmd);
+
+	pr_debug("XCOPY: Processed %d segment descriptors, length: %u\n", rc,
+				rc * XCOPY_SEGMENT_DESC_LEN);
+	INIT_WORK(&xop->xop_work, target_xcopy_do_work);
+	queue_work(xcopy_wq, &xop->xop_work);
+	return TCM_NO_SENSE;
+
+out:
+	if (p)
+		transport_kunmap_data_sg(se_cmd);
+	kfree(xop);
+	return ret;
+}
+
+static sense_reason_t target_rcr_operating_parameters(struct se_cmd *se_cmd)
+{
+	unsigned char *p;
+
+	p = transport_kmap_data_sg(se_cmd);
+	if (!p) {
+		pr_err("transport_kmap_data_sg failed in"
+		       " target_rcr_operating_parameters\n");
+		return TCM_OUT_OF_RESOURCES;
+	}
+
+	if (se_cmd->data_length < 54) {
+		pr_err("Receive Copy Results Op Parameters length"
+		       " too small: %u\n", se_cmd->data_length);
+		transport_kunmap_data_sg(se_cmd);
+		return TCM_INVALID_CDB_FIELD;
+	}
+	/*
+	 * Set SNLID=1 (Supports no List ID)
+	 */
+	p[4] = 0x1;
+	/*
+	 * MAXIMUM TARGET DESCRIPTOR COUNT
+	 */
+	put_unaligned_be16(RCR_OP_MAX_TARGET_DESC_COUNT, &p[8]);
+	/*
+	 * MAXIMUM SEGMENT DESCRIPTOR COUNT
+	 */
+	put_unaligned_be16(RCR_OP_MAX_SG_DESC_COUNT, &p[10]);
+	/*
+	 * MAXIMUM DESCRIPTOR LIST LENGTH
+	 */
+	put_unaligned_be32(RCR_OP_MAX_DESC_LIST_LEN, &p[12]);
+	/*
+	 * MAXIMUM SEGMENT LENGTH
+	 */
+	put_unaligned_be32(RCR_OP_MAX_SEGMENT_LEN, &p[16]);
+	/*
+	 * MAXIMUM INLINE DATA LENGTH for SA 0x04 (NOT SUPPORTED)
+	 */
+	put_unaligned_be32(0x0, &p[20]);
+	/*
+	 * HELD DATA LIMIT
+	 */
+	put_unaligned_be32(0x0, &p[24]);
+	/*
+	 * MAXIMUM STREAM DEVICE TRANSFER SIZE
+	 */
+	put_unaligned_be32(0x0, &p[28]);
+	/*
+	 * TOTAL CONCURRENT COPIES
+	 */
+	put_unaligned_be16(RCR_OP_TOTAL_CONCURR_COPIES, &p[34]);
+	/*
+	 * MAXIMUM CONCURRENT COPIES
+	 */
+	p[36] = RCR_OP_MAX_CONCURR_COPIES;
+	/*
+	 * DATA SEGMENT GRANULARITY (log 2)
+	 */
+	p[37] = RCR_OP_DATA_SEG_GRAN_LOG2;
+	/*
+	 * INLINE DATA GRANULARITY log 2)
+	 */
+	p[38] = RCR_OP_INLINE_DATA_GRAN_LOG2;
+	/*
+	 * HELD DATA GRANULARITY
+	 */
+	p[39] = RCR_OP_HELD_DATA_GRAN_LOG2;
+	/*
+	 * IMPLEMENTED DESCRIPTOR LIST LENGTH
+	 */
+	p[43] = 0x2;
+	/*
+	 * List of implemented descriptor type codes (ordered)
+	 */
+	p[44] = 0x02; /* Copy Block to Block device */
+	p[45] = 0xe4; /* Identification descriptor target descriptor */
+
+	/*
+	 * AVAILABLE DATA (n-3)
+	 */
+	put_unaligned_be32(42, &p[0]);
+
+	transport_kunmap_data_sg(se_cmd);
+	target_complete_cmd(se_cmd, GOOD);
+
+	return TCM_NO_SENSE;
+}
+
+sense_reason_t target_do_receive_copy_results(struct se_cmd *se_cmd)
+{
+	unsigned char *cdb = &se_cmd->t_task_cdb[0];
+	int sa = (cdb[1] & 0x1f), list_id = cdb[2];
+	sense_reason_t rc = TCM_NO_SENSE;
+
+	pr_debug("Entering target_do_receive_copy_results: SA: 0x%02x, List ID:"
+		" 0x%02x, AL: %u\n", sa, list_id, se_cmd->data_length);
+
+	if (list_id != 0) {
+		pr_err("Receive Copy Results with non zero list identifier"
+		       " not supported\n");
+		return TCM_INVALID_CDB_FIELD;
+	}
+
+	switch (sa) {
+	case RCR_SA_OPERATING_PARAMETERS:
+		rc = target_rcr_operating_parameters(se_cmd);
+		break;
+	case RCR_SA_COPY_STATUS:
+	case RCR_SA_RECEIVE_DATA:
+	case RCR_SA_FAILED_SEGMENT_DETAILS:
+	default:
+		pr_err("Unsupported SA for receive copy results: 0x%02x\n", sa);
+		return TCM_INVALID_CDB_FIELD;
+	}
+
+	return rc;
+}
diff -rubB --new-file linux-3.10.69/drivers/target/target_core_xcopy.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_xcopy.h
--- linux-3.10.69/drivers/target/target_core_xcopy.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/target_core_xcopy.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,62 @@
+#define XCOPY_TARGET_DESC_LEN		32
+#define XCOPY_SEGMENT_DESC_LEN		28
+#define XCOPY_NAA_IEEE_REGEX_LEN	16
+#define XCOPY_MAX_SECTORS		1024
+
+enum xcopy_origin_list {
+	XCOL_SOURCE_RECV_OP = 0x01,
+	XCOL_DEST_RECV_OP = 0x02,
+};
+
+struct xcopy_pt_cmd;
+
+struct xcopy_op {
+	int op_origin;
+
+	struct se_cmd *xop_se_cmd;
+	struct se_device *src_dev;
+	unsigned char src_tid_wwn[XCOPY_NAA_IEEE_REGEX_LEN];
+	struct se_device *dst_dev;
+	unsigned char dst_tid_wwn[XCOPY_NAA_IEEE_REGEX_LEN];
+	unsigned char local_dev_wwn[XCOPY_NAA_IEEE_REGEX_LEN];
+
+	sector_t src_lba;
+	sector_t dst_lba;
+	unsigned short stdi;
+	unsigned short dtdi;
+	unsigned short nolb;
+	unsigned int dbl;
+
+	struct xcopy_pt_cmd *src_pt_cmd;
+	struct xcopy_pt_cmd *dst_pt_cmd;
+
+	u32 xop_data_nents;
+	struct scatterlist *xop_data_sg;
+	struct work_struct xop_work;
+};
+
+/*
+ * Receive Copy Results Sevice Actions
+ */
+#define RCR_SA_COPY_STATUS		0x00
+#define RCR_SA_RECEIVE_DATA		0x01
+#define RCR_SA_OPERATING_PARAMETERS	0x03
+#define RCR_SA_FAILED_SEGMENT_DETAILS	0x04
+
+/*
+ * Receive Copy Results defs for Operating Parameters
+ */
+#define RCR_OP_MAX_TARGET_DESC_COUNT	0x2
+#define RCR_OP_MAX_SG_DESC_COUNT	0x1
+#define RCR_OP_MAX_DESC_LIST_LEN	1024
+#define RCR_OP_MAX_SEGMENT_LEN		268435456 /* 256 MB */
+#define RCR_OP_TOTAL_CONCURR_COPIES	0x1 /* Must be <= 16384 */
+#define RCR_OP_MAX_CONCURR_COPIES	0x1 /* Must be <= 255 */
+#define RCR_OP_DATA_SEG_GRAN_LOG2	9 /* 512 bytes in log 2 */
+#define RCR_OP_INLINE_DATA_GRAN_LOG2	9 /* 512 bytes in log 2 */
+#define RCR_OP_HELD_DATA_GRAN_LOG2	9 /* 512 bytes in log 2 */
+
+extern int target_xcopy_setup_pt(void);
+extern void target_xcopy_release_pt(void);
+extern sense_reason_t target_do_xcopy(struct se_cmd *);
+extern sense_reason_t target_do_receive_copy_results(struct se_cmd *);
diff -rubB --new-file linux-3.10.69/drivers/target/tcm_fc/tcm_fc.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/tcm_fc/tcm_fc.h
--- linux-3.10.69/drivers/target/tcm_fc/tcm_fc.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/tcm_fc/tcm_fc.h	2017-05-02 03:31:56.000000000 +0200
@@ -22,6 +22,7 @@
 #define FT_NAMELEN 32		/* length of ASCII WWPNs including pad */
 #define FT_TPG_NAMELEN 32	/* max length of TPG name */
 #define FT_LUN_NAMELEN 32	/* max length of LUN name */
+#define TCM_FC_DEFAULT_TAGS 512	/* tags used for per-session preallocation */
 
 struct ft_transport_id {
 	__u8	format;
@@ -161,7 +162,7 @@
 int ft_write_pending_status(struct se_cmd *);
 u32 ft_get_task_tag(struct se_cmd *);
 int ft_get_cmd_state(struct se_cmd *);
-int ft_queue_tm_resp(struct se_cmd *);
+void ft_queue_tm_resp(struct se_cmd *);
 
 /*
  * other internal functions.
diff -rubB --new-file linux-3.10.69/drivers/target/tcm_fc/tfc_cmd.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/tcm_fc/tfc_cmd.c
--- linux-3.10.69/drivers/target/tcm_fc/tfc_cmd.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/tcm_fc/tfc_cmd.c	2017-05-02 03:31:56.000000000 +0200
@@ -28,6 +28,7 @@
 #include <linux/configfs.h>
 #include <linux/ctype.h>
 #include <linux/hash.h>
+#include <linux/percpu_ida.h>
 #include <asm/unaligned.h>
 #include <scsi/scsi.h>
 #include <scsi/scsi_host.h>
@@ -89,16 +90,18 @@
 {
 	struct fc_frame *fp;
 	struct fc_lport *lport;
+	struct ft_sess *sess;
 
 	if (!cmd)
 		return;
+	sess = cmd->sess;
 	fp = cmd->req_frame;
 	lport = fr_dev(fp);
 	if (fr_seq(fp))
 		lport->tt.seq_release(fr_seq(fp));
 	fc_frame_free(fp);
-	ft_sess_put(cmd->sess);	/* undo get from lookup at recv */
-	kfree(cmd);
+	percpu_ida_free(&sess->se_sess->sess_tag_pool, cmd->se_cmd.map_tag);
+	ft_sess_put(sess);	/* undo get from lookup at recv */
 }
 
 void ft_release_cmd(struct se_cmd *se_cmd)
@@ -394,14 +397,14 @@
 /*
  * Send status from completed task management request.
  */
-int ft_queue_tm_resp(struct se_cmd *se_cmd)
+void ft_queue_tm_resp(struct se_cmd *se_cmd)
 {
 	struct ft_cmd *cmd = container_of(se_cmd, struct ft_cmd, se_cmd);
 	struct se_tmr_req *tmr = se_cmd->se_tmr_req;
 	enum fcp_resp_rsp_codes code;
 
 	if (cmd->aborted)
-		return 0;
+		return;
 	switch (tmr->response) {
 	case TMR_FUNCTION_COMPLETE:
 		code = FCP_TMF_CMPL;
@@ -413,10 +416,7 @@
 		code = FCP_TMF_REJECTED;
 		break;
 	case TMR_TASK_DOES_NOT_EXIST:
-	case TMR_TASK_STILL_ALLEGIANT:
-	case TMR_TASK_FAILOVER_NOT_SUPPORTED:
 	case TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED:
-	case TMR_FUNCTION_AUTHORIZATION_FAILED:
 	default:
 		code = FCP_TMF_FAILED;
 		break;
@@ -424,7 +424,6 @@
 	pr_debug("tmr fn %d resp %d fcp code %d\n",
 		  tmr->function, tmr->response, code);
 	ft_send_resp_code(cmd, code);
-	return 0;
 }
 
 static void ft_send_work(struct work_struct *work);
@@ -436,14 +435,21 @@
 {
 	struct ft_cmd *cmd;
 	struct fc_lport *lport = sess->tport->lport;
+	struct se_session *se_sess = sess->se_sess;
+	int tag;
 
-	cmd = kzalloc(sizeof(*cmd), GFP_ATOMIC);
-	if (!cmd)
+	tag = percpu_ida_alloc(&se_sess->sess_tag_pool, TASK_RUNNING);
+	if (tag < 0)
 		goto busy;
+
+	cmd = &((struct ft_cmd *)se_sess->sess_cmd_map)[tag];
+	memset(cmd, 0, sizeof(struct ft_cmd));
+
+	cmd->se_cmd.map_tag = tag;
 	cmd->sess = sess;
 	cmd->seq = lport->tt.seq_assign(lport, fp);
 	if (!cmd->seq) {
-		kfree(cmd);
+		percpu_ida_free(&se_sess->sess_tag_pool, tag);
 		goto busy;
 	}
 	cmd->req_frame = fp;		/* hold frame during cmd */
diff -rubB --new-file linux-3.10.69/drivers/target/tcm_fc/tfc_conf.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/tcm_fc/tfc_conf.c
--- linux-3.10.69/drivers/target/tcm_fc/tfc_conf.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/tcm_fc/tfc_conf.c	2017-05-02 03:31:56.000000000 +0200
@@ -267,7 +267,7 @@
 	return found;
 }
 
-struct se_node_acl *ft_tpg_alloc_fabric_acl(struct se_portal_group *se_tpg)
+static struct se_node_acl *ft_tpg_alloc_fabric_acl(struct se_portal_group *se_tpg)
 {
 	struct ft_node_acl *acl;
 
@@ -311,7 +311,11 @@
 	 */
 	if (strstr(name, "tpgt_") != name)
 		return NULL;
-	if (strict_strtoul(name + 5, 10, &index) || index > UINT_MAX)
+
+	ret = kstrtoul(name + 5, 10, &index);
+	if (ret)
+		return NULL;
+	if (index > UINT_MAX)
 		return NULL;
 
 	lacl = container_of(wwn, struct ft_lport_acl, fc_lport_wwn);
@@ -548,7 +552,7 @@
 	.fabric_drop_nodeacl =		&ft_del_acl,
 };
 
-int ft_register_configfs(void)
+static int ft_register_configfs(void)
 {
 	struct target_fabric_configfs *fabric;
 	int ret;
@@ -567,16 +571,16 @@
 	/*
 	 * Setup default attribute lists for various fabric->tf_cit_tmpl
 	 */
-	TF_CIT_TMPL(fabric)->tfc_wwn_cit.ct_attrs = ft_wwn_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_base_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_attrib_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_param_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_np_base_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_base_cit.ct_attrs =
+	fabric->tf_cit_tmpl.tfc_wwn_cit.ct_attrs = ft_wwn_attrs;
+	fabric->tf_cit_tmpl.tfc_tpg_base_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_attrib_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_param_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_np_base_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_base_cit.ct_attrs =
 						    ft_nacl_base_attrs;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_auth_cit.ct_attrs = NULL;
-	TF_CIT_TMPL(fabric)->tfc_tpg_nacl_param_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_attrib_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_auth_cit.ct_attrs = NULL;
+	fabric->tf_cit_tmpl.tfc_tpg_nacl_param_cit.ct_attrs = NULL;
 	/*
 	 * register the fabric for use within TCM
 	 */
@@ -595,7 +599,7 @@
 	return 0;
 }
 
-void ft_deregister_configfs(void)
+static void ft_deregister_configfs(void)
 {
 	if (!ft_configfs)
 		return;
diff -rubB --new-file linux-3.10.69/drivers/target/tcm_fc/tfc_io.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/tcm_fc/tfc_io.c
--- linux-3.10.69/drivers/target/tcm_fc/tfc_io.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/tcm_fc/tfc_io.c	2017-05-02 03:31:56.000000000 +0200
@@ -346,7 +346,7 @@
 		ep = fc_seq_exch(seq);
 		if (ep) {
 			lport = ep->lp;
-			if (lport && (ep->xid <= lport->lro_xid))
+			if (lport && (ep->xid <= lport->lro_xid)) {
 				/*
 				 * "ddp_done" trigger invalidation of HW
 				 * specific DDP context
@@ -363,4 +363,5 @@
 				cmd->was_ddp_setup = 0;
 		}
 	}
+	}
 }
diff -rubB --new-file linux-3.10.69/drivers/target/tcm_fc/tfc_sess.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/tcm_fc/tfc_sess.c
--- linux-3.10.69/drivers/target/tcm_fc/tfc_sess.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/target/tcm_fc/tfc_sess.c	2017-05-02 03:31:56.000000000 +0200
@@ -211,7 +211,8 @@
 	if (!sess)
 		return NULL;
 
-	sess->se_sess = transport_init_session();
+	sess->se_sess = transport_init_session_tags(TCM_FC_DEFAULT_TAGS,
+						    sizeof(struct ft_cmd));
 	if (IS_ERR(sess->se_sess)) {
 		kfree(sess);
 		return NULL;
diff -rubB --new-file linux-3.10.69/drivers/tty/serial/8250/8250_core.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/tty/serial/8250/8250_core.c
--- linux-3.10.69/drivers/tty/serial/8250/8250_core.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/tty/serial/8250/8250_core.c	2017-05-02 03:31:56.000000000 +0200
@@ -2824,6 +2824,13 @@
 	for (i = 0; i < nr_uarts; i++) {
 		struct uart_8250_port *up = &serial8250_ports[i];
 
+#ifdef CONFIG_BUFFALO_USE_UPS
+                {
+                        extern struct uart_port *uart_ports[];
+                        uart_ports[i] = &up->port;
+                }
+#endif  /* CONFIG_BUFFALO_USE_UPS */
+
 		if (up->port.dev)
 			continue;
 
diff -rubB --new-file linux-3.10.69/drivers/tty/serial/serial_core.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/tty/serial/serial_core.c
--- linux-3.10.69/drivers/tty/serial/serial_core.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/tty/serial/serial_core.c	2017-05-02 03:31:56.000000000 +0200
@@ -241,9 +241,6 @@
 		/*
 		 * Turn off DTR and RTS early.
 		 */
-		if (uart_console(uport) && tty)
-			uport->cons->cflag = tty->termios.c_cflag;
-
 		if (!tty || (tty->termios.c_cflag & HUPCL))
 			uart_clear_mctrl(uport, TIOCM_DTR | TIOCM_RTS);
 
@@ -359,7 +356,7 @@
 		 * The spd_hi, spd_vhi, spd_shi, spd_warp kludge...
 		 * Die! Die! Die!
 		 */
-		if (try == 0 && baud == 38400)
+		if (baud == 38400)
 			baud = altbaud;
 
 		/*
diff -rubB --new-file linux-3.10.69/drivers/usb/host/ehci-exynos.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/usb/host/ehci-exynos.c
--- linux-3.10.69/drivers/usb/host/ehci-exynos.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/usb/host/ehci-exynos.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,390 @@
+/*
+ * SAMSUNG EXYNOS USB HOST EHCI Controller
+ *
+ * Copyright (C) 2011 Samsung Electronics Co.Ltd
+ * Author: Jingoo Han <jg1.han@samsung.com>
+ * Author: Joonyoung Shim <jy0922.shim@samsung.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/phy/phy.h>
+#include <linux/platform_device.h>
+#include <linux/usb/phy.h>
+#include <linux/usb/samsung_usb_phy.h>
+#include <linux/usb.h>
+#include <linux/usb/hcd.h>
+#include <linux/usb/otg.h>
+
+#include "ehci.h"
+
+#define DRIVER_DESC "EHCI EXYNOS driver"
+
+#define EHCI_INSNREG00(base)			(base + 0x90)
+#define EHCI_INSNREG00_ENA_INCR16		(0x1 << 25)
+#define EHCI_INSNREG00_ENA_INCR8		(0x1 << 24)
+#define EHCI_INSNREG00_ENA_INCR4		(0x1 << 23)
+#define EHCI_INSNREG00_ENA_INCRX_ALIGN		(0x1 << 22)
+#define EHCI_INSNREG00_ENABLE_DMA_BURST	\
+	(EHCI_INSNREG00_ENA_INCR16 | EHCI_INSNREG00_ENA_INCR8 |	\
+	 EHCI_INSNREG00_ENA_INCR4 | EHCI_INSNREG00_ENA_INCRX_ALIGN)
+
+static const char hcd_name[] = "ehci-exynos";
+static struct hc_driver __read_mostly exynos_ehci_hc_driver;
+
+#define PHY_NUMBER 3
+
+struct exynos_ehci_hcd {
+	struct clk *clk;
+	struct usb_phy *phy;
+	struct usb_otg *otg;
+	struct phy *phy_g[PHY_NUMBER];
+};
+
+#define to_exynos_ehci(hcd) (struct exynos_ehci_hcd *)(hcd_to_ehci(hcd)->priv)
+
+static int exynos_ehci_get_phy(struct device *dev,
+				struct exynos_ehci_hcd *exynos_ehci)
+{
+	struct device_node *child;
+	struct phy *phy;
+	int phy_number;
+	int ret = 0;
+
+	exynos_ehci->phy = devm_usb_get_phy(dev, USB_PHY_TYPE_USB2);
+	if (IS_ERR(exynos_ehci->phy)) {
+		ret = PTR_ERR(exynos_ehci->phy);
+		if (ret != -ENXIO && ret != -ENODEV) {
+			dev_err(dev, "no usb2 phy configured\n");
+			return ret;
+		}
+		dev_dbg(dev, "Failed to get usb2 phy\n");
+	} else {
+		exynos_ehci->otg = exynos_ehci->phy->otg;
+	}
+
+	for_each_available_child_of_node(dev->of_node, child) {
+		ret = of_property_read_u32(child, "reg", &phy_number);
+		if (ret) {
+			dev_err(dev, "Failed to parse device tree\n");
+			of_node_put(child);
+			return ret;
+		}
+
+		if (phy_number >= PHY_NUMBER) {
+			dev_err(dev, "Invalid number of PHYs\n");
+			of_node_put(child);
+			return -EINVAL;
+		}
+
+		phy = devm_of_phy_get(dev, child, 0);
+		of_node_put(child);
+		if (IS_ERR(phy)) {
+			ret = PTR_ERR(phy);
+			if (ret != -ENOSYS && ret != -ENODEV) {
+				dev_err(dev, "no usb2 phy configured\n");
+				return ret;
+			}
+			dev_dbg(dev, "Failed to get usb2 phy\n");
+		}
+		exynos_ehci->phy_g[phy_number] = phy;
+	}
+
+	return ret;
+}
+
+static int exynos_ehci_phy_enable(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);
+	int i;
+	int ret = 0;
+
+	if (!IS_ERR(exynos_ehci->phy))
+		return usb_phy_init(exynos_ehci->phy);
+
+	for (i = 0; ret == 0 && i < PHY_NUMBER; i++)
+		if (!IS_ERR(exynos_ehci->phy_g[i]))
+			ret = phy_power_on(exynos_ehci->phy_g[i]);
+	if (ret)
+		for (i--; i >= 0; i--)
+			if (!IS_ERR(exynos_ehci->phy_g[i]))
+				phy_power_off(exynos_ehci->phy_g[i]);
+
+	return ret;
+}
+
+static void exynos_ehci_phy_disable(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);
+	int i;
+
+	if (!IS_ERR(exynos_ehci->phy)) {
+		usb_phy_shutdown(exynos_ehci->phy);
+		return;
+	}
+
+	for (i = 0; i < PHY_NUMBER; i++)
+		if (!IS_ERR(exynos_ehci->phy_g[i]))
+			phy_power_off(exynos_ehci->phy_g[i]);
+}
+
+static void exynos_setup_vbus_gpio(struct device *dev)
+{
+	int err;
+	int gpio;
+
+	if (!dev->of_node)
+		return;
+
+	gpio = of_get_named_gpio(dev->of_node, "samsung,vbus-gpio", 0);
+	if (!gpio_is_valid(gpio))
+		return;
+
+	err = devm_gpio_request_one(dev, gpio, GPIOF_OUT_INIT_HIGH,
+				    "ehci_vbus_gpio");
+	if (err)
+		dev_err(dev, "can't request ehci vbus gpio %d", gpio);
+}
+
+static int exynos_ehci_probe(struct platform_device *pdev)
+{
+	struct exynos_ehci_hcd *exynos_ehci;
+	struct usb_hcd *hcd;
+	struct ehci_hcd *ehci;
+	struct resource *res;
+	int irq;
+	int err;
+
+	/*
+	 * Right now device-tree probed devices don't get dma_mask set.
+	 * Since shared usb code relies on it, set it here for now.
+	 * Once we move to full device tree support this will vanish off.
+	 */
+	err = dma_coerce_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
+	if (err)
+		return err;
+
+	exynos_setup_vbus_gpio(&pdev->dev);
+
+	hcd = usb_create_hcd(&exynos_ehci_hc_driver,
+			     &pdev->dev, dev_name(&pdev->dev));
+	if (!hcd) {
+		dev_err(&pdev->dev, "Unable to create HCD\n");
+		return -ENOMEM;
+	}
+	exynos_ehci = to_exynos_ehci(hcd);
+
+	if (of_device_is_compatible(pdev->dev.of_node,
+					"samsung,exynos5440-ehci"))
+		goto skip_phy;
+
+	err = exynos_ehci_get_phy(&pdev->dev, exynos_ehci);
+	if (err)
+		goto fail_clk;
+
+skip_phy:
+
+	exynos_ehci->clk = devm_clk_get(&pdev->dev, "usbhost");
+
+	if (IS_ERR(exynos_ehci->clk)) {
+		dev_err(&pdev->dev, "Failed to get usbhost clock\n");
+		err = PTR_ERR(exynos_ehci->clk);
+		goto fail_clk;
+	}
+
+	err = clk_prepare_enable(exynos_ehci->clk);
+	if (err)
+		goto fail_clk;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "Failed to get I/O memory\n");
+		err = -ENXIO;
+		goto fail_io;
+	}
+
+	hcd->rsrc_start = res->start;
+	hcd->rsrc_len = resource_size(res);
+	hcd->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(hcd->regs)) {
+		err = PTR_ERR(hcd->regs);
+		goto fail_io;
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (!irq) {
+		dev_err(&pdev->dev, "Failed to get IRQ\n");
+		err = -ENODEV;
+		goto fail_io;
+	}
+
+	if (exynos_ehci->otg)
+		exynos_ehci->otg->set_host(exynos_ehci->otg, &hcd->self);
+
+	err = exynos_ehci_phy_enable(&pdev->dev);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to enable USB phy\n");
+		goto fail_io;
+	}
+
+	ehci = hcd_to_ehci(hcd);
+	ehci->caps = hcd->regs;
+
+	/* DMA burst Enable */
+	writel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd->regs));
+
+	err = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (err) {
+		dev_err(&pdev->dev, "Failed to add USB HCD\n");
+		goto fail_add_hcd;
+	}
+	device_wakeup_enable(hcd->self.controller);
+
+	platform_set_drvdata(pdev, hcd);
+
+	return 0;
+
+fail_add_hcd:
+	exynos_ehci_phy_disable(&pdev->dev);
+fail_io:
+	clk_disable_unprepare(exynos_ehci->clk);
+fail_clk:
+	usb_put_hcd(hcd);
+	return err;
+}
+
+static int exynos_ehci_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	struct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);
+
+	usb_remove_hcd(hcd);
+
+	if (exynos_ehci->otg)
+		exynos_ehci->otg->set_host(exynos_ehci->otg, &hcd->self);
+
+	exynos_ehci_phy_disable(&pdev->dev);
+
+	clk_disable_unprepare(exynos_ehci->clk);
+
+	usb_put_hcd(hcd);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int exynos_ehci_suspend(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);
+
+	bool do_wakeup = device_may_wakeup(dev);
+	int rc;
+
+	rc = ehci_suspend(hcd, do_wakeup);
+	if (rc)
+		return rc;
+
+	if (exynos_ehci->otg)
+		exynos_ehci->otg->set_host(exynos_ehci->otg, &hcd->self);
+
+	exynos_ehci_phy_disable(dev);
+
+	clk_disable_unprepare(exynos_ehci->clk);
+
+	return rc;
+}
+
+static int exynos_ehci_resume(struct device *dev)
+{
+	struct usb_hcd *hcd = dev_get_drvdata(dev);
+	struct exynos_ehci_hcd *exynos_ehci = to_exynos_ehci(hcd);
+	int ret;
+
+	clk_prepare_enable(exynos_ehci->clk);
+
+	if (exynos_ehci->otg)
+		exynos_ehci->otg->set_host(exynos_ehci->otg, &hcd->self);
+
+	ret = exynos_ehci_phy_enable(dev);
+	if (ret) {
+		dev_err(dev, "Failed to enable USB phy\n");
+		clk_disable_unprepare(exynos_ehci->clk);
+		return ret;
+	}
+
+	/* DMA burst Enable */
+	writel(EHCI_INSNREG00_ENABLE_DMA_BURST, EHCI_INSNREG00(hcd->regs));
+
+	ehci_resume(hcd, false);
+	return 0;
+}
+#else
+#define exynos_ehci_suspend	NULL
+#define exynos_ehci_resume	NULL
+#endif
+
+static const struct dev_pm_ops exynos_ehci_pm_ops = {
+	.suspend	= exynos_ehci_suspend,
+	.resume		= exynos_ehci_resume,
+};
+
+#ifdef CONFIG_OF
+static const struct of_device_id exynos_ehci_match[] = {
+	{ .compatible = "samsung,exynos4210-ehci" },
+	{ .compatible = "samsung,exynos5440-ehci" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, exynos_ehci_match);
+#endif
+
+static struct platform_driver exynos_ehci_driver = {
+	.probe		= exynos_ehci_probe,
+	.remove		= exynos_ehci_remove,
+	.shutdown	= usb_hcd_platform_shutdown,
+	.driver = {
+		.name	= "exynos-ehci",
+		.owner	= THIS_MODULE,
+		.pm	= &exynos_ehci_pm_ops,
+		.of_match_table = of_match_ptr(exynos_ehci_match),
+	}
+};
+static const struct ehci_driver_overrides exynos_overrides __initdata = {
+	.extra_priv_size = sizeof(struct exynos_ehci_hcd),
+};
+
+static int __init ehci_exynos_init(void)
+{
+	if (usb_disabled())
+		return -ENODEV;
+
+	pr_info("%s: " DRIVER_DESC "\n", hcd_name);
+	ehci_init_driver(&exynos_ehci_hc_driver, &exynos_overrides);
+	return platform_driver_register(&exynos_ehci_driver);
+}
+module_init(ehci_exynos_init);
+
+static void __exit ehci_exynos_cleanup(void)
+{
+	platform_driver_unregister(&exynos_ehci_driver);
+}
+module_exit(ehci_exynos_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_ALIAS("platform:exynos-ehci");
+MODULE_AUTHOR("Jingoo Han");
+MODULE_AUTHOR("Joonyoung Shim");
+MODULE_LICENSE("GPL v2");
diff -rubB --new-file linux-3.10.69/drivers/usb/host/ehci-pci.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/usb/host/ehci-pci.c
--- linux-3.10.69/drivers/usb/host/ehci-pci.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/usb/host/ehci-pci.c	2017-05-02 03:31:56.000000000 +0200
@@ -90,6 +90,9 @@
 
 	ehci->caps = hcd->regs;
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+	if (hcd->self.controller->bus == &pci_bus_type) {
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	/*
 	 * ehci_init() causes memory for DMA transfers to be
 	 * allocated.  Thus, any vendor-specific workarounds based on
@@ -224,6 +227,9 @@
 		ehci->frame_index_bug = 1;
 		break;
 	}
+#ifdef CONFIG_BUFFALO_PLATFORM
+	}
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 
 	/* optional debug port, normally in the first BAR */
 	temp = pci_find_capability(pdev, PCI_CAP_ID_DBG);
@@ -249,6 +255,9 @@
 	if (retval)
 		return retval;
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+	if (hcd->self.controller->bus == &pci_bus_type) {
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	/* These workarounds need to be applied after ehci_setup() */
 	switch (pdev->vendor) {
 	case PCI_VENDOR_ID_NEC:
@@ -272,6 +281,9 @@
 		}
 		break;
 	}
+#ifdef CONFIG_BUFFALO_PLATFORM
+	}
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 
 	/* at least the Genesys GL880S needs fixup here */
 	temp = HCS_N_CC(ehci->hcs_params) * HCS_N_PCC(ehci->hcs_params);
@@ -283,6 +295,9 @@
 			HCS_N_PCC(ehci->hcs_params),
 			HCS_N_PORTS(ehci->hcs_params));
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+		if (hcd->self.controller->bus == &pci_bus_type) {
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 		switch (pdev->vendor) {
 		case 0x17a0:		/* GENESYS */
 			/* GL880S: should be PORTS=2 */
@@ -293,8 +308,14 @@
 			/* NF4: should be PCC=10 */
 			break;
 		}
+#ifdef CONFIG_BUFFALO_PLATFORM
+		}
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	}
 
+#ifdef CONFIG_BUFFALO_PLATFORM
+	if (hcd->self.controller->bus == &pci_bus_type) {
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	/* Serial Bus Release Number is at PCI 0x60 offset */
 	if (pdev->vendor == PCI_VENDOR_ID_STMICRO
 	    && pdev->device == PCI_DEVICE_ID_STMICRO_USB_HOST)
@@ -323,6 +344,9 @@
 #endif
 
 	retval = ehci_pci_reinit(ehci, pdev);
+#ifdef CONFIG_BUFFALO_PLATFORM
+	}
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 done:
 	return retval;
 }
diff -rubB --new-file linux-3.10.69/drivers/usb/storage/scsiglue.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/usb/storage/scsiglue.c
--- linux-3.10.69/drivers/usb/storage/scsiglue.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/drivers/usb/storage/scsiglue.c	2017-05-02 03:31:56.000000000 +0200
@@ -445,6 +445,29 @@
 /***********************************************************************
  * /proc/scsi/ functions
  ***********************************************************************/
+#ifdef CONFIG_BUFFALO_SCSI_GUID
+#define GUID(x)			__u32 x[3]
+#define GUID_EQUAL(x, y)	(x[0] == y[0] && x[1] == y[1] && x[2] == y[2])
+#define GUID_CLEAR(x)		x[0] = x[1] = x[2] = 0;
+#define GUID_NONE(x)		(!x[0] && !x[1] && !x[2])
+#define GUID_FORMAT		"%08x%08x%08x"
+#define GUID_ARGS(x)		x[0], x[1], x[2]
+static inline void
+make_guid( __u32 *pg, __u16 vendor, __u16 product, char *serial)
+{
+	pg[0] = (vendor << 16) | product;
+	pg[1] = pg[2] = 0;
+	while (*serial) {
+		pg[1] <<= 4;
+		pg[1] |= pg[2] >> 28;
+		pg[2] <<= 4;
+		if (*serial >= 'a')
+			*serial -= 'a' - 'A';
+		pg[2] |= (*serial <= '9' && *serial >= '0') ? *serial - '0' : *serial - 'A' + 10;
+		serial++;
+	}
+}
+#endif	/* CONFIG_BUFFALO_SCSI_GUID */
 
 static int write_info(struct Scsi_Host *host, char *buffer, int length)
 {
@@ -489,6 +512,34 @@
 	SPRINTF("     Protocol: %s\n", us->protocol_name);
 	SPRINTF("    Transport: %s\n", us->transport_name);
 
+#ifdef CONFIG_BUFFALO_SCSI_GUID
+	{
+		char serial[USB_STOR_STRING_LEN];       /* serial number */
+
+		GUID(guid);                     /* Global Unique Identifier */
+		GUID_CLEAR(guid);
+		memset(serial,0,sizeof(serial));
+
+		if (us->pusb_dev->descriptor.iSerialNumber /* && !(flags & US_FL_IGNORE_SER)*/)
+			usb_string(us->pusb_dev,
+				   us->pusb_dev->descriptor.iSerialNumber,
+				   serial, sizeof(serial));
+
+		/* Create a GUID for this device */
+		if (us->pusb_dev->descriptor.iSerialNumber && serial[0]) {
+			/* If we have a serial number, and it's a non-NULL string */
+			make_guid(guid, us->pusb_dev->descriptor.idVendor,
+				  us->pusb_dev->descriptor.idProduct, serial);
+		} else {
+			/* We don't have a serial number, so we use 0 */
+			make_guid(guid, us->pusb_dev->descriptor.idVendor,
+				  us->pusb_dev->descriptor.idProduct, "0");
+		}
+		/* show the GUID of the device */
+		SPRINTF("         GUID: " GUID_FORMAT "\n", GUID_ARGS(guid));
+	}
+#endif	/* CONFIG_BUFFALO_SCSI_GUID */
+
 	/* show the device flags */
 	SPRINTF("       Quirks:");
 
diff -rubB --new-file linux-3.10.69/fs/ext2/super.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/ext2/super.c
--- linux-3.10.69/fs/ext2/super.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/ext2/super.c	2017-05-02 03:31:56.000000000 +0200
@@ -829,7 +829,12 @@
 	sbi->s_es = es;
 	sb->s_magic = le16_to_cpu(es->s_magic);
 
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+	if ((sb->s_magic != EXT2_SUPER_MAGIC) &&
+	    (sb->s_magic != MEL_EXT2_SUPER_MAGIC))
+#else	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 	if (sb->s_magic != EXT2_SUPER_MAGIC)
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 		goto cantfind_ext2;
 
 	/* Set defaults before we parse the mount options */
@@ -927,7 +932,12 @@
 		}
 		es = (struct ext2_super_block *) (((char *)bh->b_data) + offset);
 		sbi->s_es = es;
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+		if ((sb->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) &&
+		    (sb->s_magic != cpu_to_le16(MEL_EXT2_SUPER_MAGIC))) {
+#else	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 		if (es->s_magic != cpu_to_le16(EXT2_SUPER_MAGIC)) {
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 			ext2_msg(sb, KERN_ERR, "error: magic mismatch");
 			goto failed_mount;
 		}
@@ -978,7 +988,12 @@
 	sbi->s_desc_per_block_bits =
 		ilog2 (EXT2_DESC_PER_BLOCK(sb));
 
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+	if ((sb->s_magic != EXT2_SUPER_MAGIC) &&
+	    (sb->s_magic != MEL_EXT2_SUPER_MAGIC))
+#else	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 	if (sb->s_magic != EXT2_SUPER_MAGIC)
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 		goto cantfind_ext2;
 
 	if (sb->s_blocksize != bh->b_size) {
diff -rubB --new-file linux-3.10.69/fs/ext3/super.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/ext3/super.c
--- linux-3.10.69/fs/ext3/super.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/ext3/super.c	2017-05-02 03:31:56.000000000 +0200
@@ -1683,7 +1683,12 @@
 	es = (struct ext3_super_block *) (bh->b_data + offset);
 	sbi->s_es = es;
 	sb->s_magic = le16_to_cpu(es->s_magic);
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+	if ((sb->s_magic != EXT3_SUPER_MAGIC) &&
+	    (sb->s_magic != MEL_EXT3_SUPER_MAGIC))
+#else	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 	if (sb->s_magic != EXT3_SUPER_MAGIC)
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 		goto cantfind_ext3;
 
 	/* Set defaults before we parse the mount options */
@@ -1795,7 +1800,12 @@
 		}
 		es = (struct ext3_super_block *)(bh->b_data + offset);
 		sbi->s_es = es;
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+		if ((es->s_magic != le16_to_cpu(EXT3_SUPER_MAGIC)) &&
+		    (es->s_magic != le16_to_cpu(MEL_EXT3_SUPER_MAGIC))) {
+#else	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 		if (es->s_magic != cpu_to_le16(EXT3_SUPER_MAGIC)) {
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 			ext3_msg(sb, KERN_ERR,
 				"error: magic mismatch");
 			goto failed_mount;
@@ -2193,7 +2203,12 @@
 	}
 
 	es = (struct ext3_super_block *) (bh->b_data + offset);
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+	if (((le16_to_cpu(es->s_magic) != EXT3_SUPER_MAGIC) &&
+	     (le16_to_cpu(es->s_magic) != MEL_EXT3_SUPER_MAGIC)) ||
+#else	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 	if ((le16_to_cpu(es->s_magic) != EXT3_SUPER_MAGIC) ||
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 	    !(le32_to_cpu(es->s_feature_incompat) &
 	      EXT3_FEATURE_INCOMPAT_JOURNAL_DEV)) {
 		ext3_msg(sb, KERN_ERR, "error: external journal has "
diff -rubB --new-file linux-3.10.69/fs/ntfs/super.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/ntfs/super.c
--- linux-3.10.69/fs/ntfs/super.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/ntfs/super.c	2017-05-02 03:31:56.000000000 +0200
@@ -881,6 +881,7 @@
 	}
 	vol->nr_clusters = ll;
 	ntfs_debug("vol->nr_clusters = 0x%llx", (long long)vol->nr_clusters);
+#ifndef CONFIG_BUFFALO_NTFS_CPU32_FIX
 	/*
 	 * On an architecture where unsigned long is 32-bits, we restrict the
 	 * volume size to 2TiB (2^41). On a 64-bit architecture, the compiler
@@ -896,6 +897,25 @@
 			return false;
 		}
 	}
+#else /* CONFIG_BUFFALO_NTFS_CPU32_FIX */
+	/*
+	 * On an architecture where unsigned long is 32-bits, we restrict the
+	 * volume size to 2TiB (2^41). On a 64-bit architecture, the compiler
+	 * will hopefully optimize the whole check away.
+	 */
+	if (sizeof(unsigned long) < 8) {
+		int shift = 41 + (vol->cluster_size_bits - 9); /* 512byte is (2^9)*/
+		if ((ll << vol->cluster_size_bits) >= (1ULL << shift)) {
+			ntfs_error(vol->sb, "Volume size (%lluTiB) is too "
+					"large for this architecture.  "
+					"Maximum supported is %dTiB.  Sorry.",
+					(unsigned long long)ll >> (40 -
+					vol->cluster_size_bits),
+					16 >> (44 - shift));
+			return false;
+		}
+	}
+#endif /* CONFIG_BUFFALO_NTFS_CPU32_FIX */
 	ll = sle64_to_cpu(b->mft_lcn);
 	if (ll >= vol->nr_clusters) {
 		ntfs_error(vol->sb, "MFT LCN (%lli, 0x%llx) is beyond end of "
diff -rubB --new-file linux-3.10.69/fs/xfs/xfs_inode.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/xfs/xfs_inode.c
--- linux-3.10.69/fs/xfs/xfs_inode.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/xfs/xfs_inode.c	2017-05-02 03:31:56.000000000 +0200
@@ -1372,6 +1372,8 @@
 					di_flags |= XFS_DIFLAG_EXTSZINHERIT;
 					ip->i_d.di_extsize = pip->i_d.di_extsize;
 				}
+				if (pip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)
+					di_flags |= XFS_DIFLAG_PROJINHERIT;
 			} else if (S_ISREG(mode)) {
 				if (pip->i_d.di_flags & XFS_DIFLAG_RTINHERIT)
 					di_flags |= XFS_DIFLAG_REALTIME;
@@ -1392,8 +1394,6 @@
 			if ((pip->i_d.di_flags & XFS_DIFLAG_NOSYMLINKS) &&
 			    xfs_inherit_nosymlinks)
 				di_flags |= XFS_DIFLAG_NOSYMLINKS;
-			if (pip->i_d.di_flags & XFS_DIFLAG_PROJINHERIT)
-				di_flags |= XFS_DIFLAG_PROJINHERIT;
 			if ((pip->i_d.di_flags & XFS_DIFLAG_NODEFRAG) &&
 			    xfs_inherit_nodefrag)
 				di_flags |= XFS_DIFLAG_NODEFRAG;
diff -rubB --new-file linux-3.10.69/fs/xfs/xfs_ioctl.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/xfs/xfs_ioctl.c
--- linux-3.10.69/fs/xfs/xfs_ioctl.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/xfs/xfs_ioctl.c	2017-05-02 03:31:56.000000000 +0200
@@ -866,8 +866,6 @@
 		di_flags |= XFS_DIFLAG_NOATIME;
 	if (xflags & XFS_XFLAG_NODUMP)
 		di_flags |= XFS_DIFLAG_NODUMP;
-	if (xflags & XFS_XFLAG_PROJINHERIT)
-		di_flags |= XFS_DIFLAG_PROJINHERIT;
 	if (xflags & XFS_XFLAG_NODEFRAG)
 		di_flags |= XFS_DIFLAG_NODEFRAG;
 	if (xflags & XFS_XFLAG_FILESTREAM)
@@ -879,6 +877,8 @@
 			di_flags |= XFS_DIFLAG_NOSYMLINKS;
 		if (xflags & XFS_XFLAG_EXTSZINHERIT)
 			di_flags |= XFS_DIFLAG_EXTSZINHERIT;
+		if (xflags & XFS_XFLAG_PROJINHERIT)
+			di_flags |= XFS_DIFLAG_PROJINHERIT;
 	} else if (S_ISREG(ip->i_d.di_mode)) {
 		if (xflags & XFS_XFLAG_REALTIME)
 			di_flags |= XFS_DIFLAG_REALTIME;
diff -rubB --new-file linux-3.10.69/fs/xfs/xfs_log.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/xfs/xfs_log.c
--- linux-3.10.69/fs/xfs/xfs_log.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/fs/xfs/xfs_log.c	2017-05-02 03:31:56.000000000 +0200
@@ -1127,10 +1127,13 @@
 	ASSERT(XFS_BUF_ISASYNC(bp));
 	xlog_state_done_syncing(iclog, aborted);
 	/*
-	 * do not reference the buffer (bp) here as we could race
-	 * with it being freed after writing the unmount record to the
-	 * log.
+	 * drop the buffer lock now that we are done. Nothing references
+	 * the buffer after this, so an unmount waiting on this lock can now
+	 * tear it down safely. As such, it is unsafe to reference the buffer
+	 * (bp) after the unlock as we could race with it being freed.
 	 */
+	xfs_buf_unlock(bp);
+
 }
 
 /*
@@ -1313,8 +1316,16 @@
 	bp = xfs_buf_alloc(mp->m_logdev_targp, 0, BTOBB(log->l_iclog_size), 0);
 	if (!bp)
 		goto out_free_log;
-	bp->b_iodone = xlog_iodone;
+
+	/*
+	 * The iclogbuf buffer locks are held over IO but we are not going to do
+	 * IO yet.  Hence unlock the buffer so that the log IO path can grab it
+	 * when appropriately.
+	 */
 	ASSERT(xfs_buf_islocked(bp));
+	xfs_buf_unlock(bp);
+
+	bp->b_iodone = xlog_iodone;
 	log->l_xbuf = bp;
 
 	spin_lock_init(&log->l_icloglock);
@@ -1342,6 +1353,8 @@
 						BTOBB(log->l_iclog_size), 0);
 		if (!bp)
 			goto out_free_iclog;
+		ASSERT(xfs_buf_islocked(bp));
+		xfs_buf_unlock(bp);
 
 		bp->b_iodone = xlog_iodone;
 		iclog->ic_bp = bp;
@@ -1367,7 +1380,6 @@
 		iclog->ic_callback_tail = &(iclog->ic_callback);
 		iclog->ic_datap = (char *)iclog->ic_data + log->l_iclog_hsize;
 
-		ASSERT(xfs_buf_islocked(iclog->ic_bp));
 		init_waitqueue_head(&iclog->ic_force_wait);
 		init_waitqueue_head(&iclog->ic_write_wait);
 
@@ -1576,6 +1588,11 @@
  * we transition the iclogs to IOERROR state *after* flushing all existing
  * iclogs to disk. This is because we don't want anymore new transactions to be
  * started or completed afterwards.
+ * We lock the iclogbufs here so that we can serialise against IO completion
+ * during unmount. We might be processing a shutdown triggered during unmount,
+ * and that can occur asynchronously to the unmount thread, and hence we need to
+ * ensure that completes before tearing down the iclogbufs. Hence we need to
+ * hold the buffer lock across the log IO to acheive that.
  */
 STATIC int
 xlog_bdstrat(
@@ -1583,6 +1600,7 @@
 {
 	struct xlog_in_core	*iclog = bp->b_fspriv;
 
+	xfs_buf_lock(bp);
 	if (iclog->ic_state & XLOG_STATE_IOERROR) {
 		xfs_buf_ioerror(bp, EIO);
 		xfs_buf_stale(bp);
@@ -1591,6 +1609,8 @@
 		 * It would seem logical to return EIO here, but we rely on
 		 * the log state machine to propagate I/O errors instead of
 		 * doing it here.
+		 * doing it here. Similarly, IO completion will unlock the
+		 * buffer, so we don't do it here.
 		 */
 		return 0;
 	}
@@ -1792,14 +1812,28 @@
 	xlog_cil_destroy(log);
 
 	/*
-	 * always need to ensure that the extra buffer does not point to memory
-	 * owned by another log buffer before we free it.
+	 * Cycle all the iclogbuf locks to make sure all log IO completion
+	 * is done before we tear down these buffers.
+	 */
+	iclog = log->l_iclog;
+   	for (i = 0; i < log->l_iclog_bufs; i++) {
+   		xfs_buf_lock(iclog->ic_bp);
+       	xfs_buf_unlock(iclog->ic_bp);
+       	iclog = iclog->ic_next;
+ 	}
+
+   	/*
+   	 * Always need to ensure that the extra buffer does not point to memory
+     	 * owned by another log buffer before we free it. Also, cycle the lock
+     	* first to ensure we've completed IO on it.
 	 */
+    	xfs_buf_lock(log->l_xbuf);
+    	xfs_buf_unlock(log->l_xbuf);
 	xfs_buf_set_empty(log->l_xbuf, BTOBB(log->l_iclog_size));
 	xfs_buf_free(log->l_xbuf);
 
 	iclog = log->l_iclog;
-	for (i=0; i<log->l_iclog_bufs; i++) {
+	for(i = 0; i < log->l_iclog_bufs; i++) {
 		xfs_buf_free(iclog->ic_bp);
 		next_iclog = iclog->ic_next;
 		kmem_free(iclog);
diff -rubB --new-file linux-3.10.69/include/buffalo/kernevnt.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/buffalo/kernevnt.h
--- linux-3.10.69/include/buffalo/kernevnt.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/buffalo/kernevnt.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,68 @@
+#ifndef _KERNEVNT_H_
+#define _KERNEVNT_H_
+
+// variable definition.
+#define POWER_STATUS_REBOOTING                  1
+#define POWER_STATUS_REBOOTING_UBOOT_PASSED     2
+#define POWER_STATUS_NORMAL_STATE               3
+#define POWER_STATUS_HW_POWER_OFF               4
+#define POWER_STATUS_SW_POWER_OFF               5
+#define POWER_STATUS_SW_POFF_UBOOT_PASSED       6
+#define POWER_STATUS_FWUPDATING                 7
+#define POWER_STATUS_REBOOT_REACHED_HALT        8
+#define	POWER_STATUS_SW_POFF_REACHED_HALT       9
+#define POWER_STATUS_UPS_SHUTDOWN		10
+#define POWER_STATUS_UPS_SHUTDOWN_REACHED_HALT	11
+#define POWER_STATUS_WOL_READY_STATE		12
+#define POWER_STATUS_WOL_READY_UBOOT_PASSED	13
+
+// difinition for MagicKey.
+// DEF4CPU = (CONFIG_ARCH_FEROCEON_MV78XX0, CONFIG_ARCH_ARMADA_XP, other)
+
+#if defined(CONFIG_ARCH_FEROCEON_MV78XX0)
+#define DEF4CPU(x,y,z)  x
+#elif defined(CONFIG_ARCH_ARMADA_XP)
+#define DEF4CPU(x,y,z)  y
+#else
+#define DEF4CPU(x,y,z)  z
+#endif
+
+#define MagicKeyReboot                  0x18
+#define MagicKeyRebootUbootPassed       0x3a
+#define MagicKeyNormalState             0x71
+#define MagicKeyHwPoff                  0x43
+#define MagicKeySwPoff                  DEF4CPU(0x02,	0x41,	0x02)
+#define MagicKeySWPoffUbootPassed       0x5c
+#define MagicKeyFWUpdating              0x6f
+#define MagicKeyRebootReachedHalt       0x2b
+#define MagicKeySWPoffReachedHalt       0x7a
+#define MagicKeyUpsShutdown             DEF4CPU(0x45,   0x21,   0x21)
+#define MagicKeyUpsShutdownReachedHalt  DEF4CPU(0x16,   0x32,   0x32)
+#define MagicKeyWOLReadyState           DEF4CPU(0x75,   0x02,   0x75)
+#define MagicKeyWOLReadyUbootPasswd	0x70
+
+/* routines are in kernel/arch/ppc/platforms/buffalo/kernevnt.c */
+
+void kernevnt_LanAct(void *data);
+void kernevnt_SwitchHubAct(const char *msg);
+#ifdef CONFIG_MD
+void kernevnt_RaidRecovery(int devno,int on, int isRecovery, int major, int minor);
+void kernevnt_RaidScan(int devno, int on);
+void kernevnt_RaidDegraded(int devno, int major, int minor);
+void kernevnt_RaidReshape(int devno, int on);
+#endif
+
+// drivers/block/ll_rw_blk.c
+#ifdef CONFIG_X86
+void kernevnt_IOErr(const char *kdevname, const char *dir, unsigned long sector, unsigned int errcnt);
+#else // CONFIG_X86
+void kernevnt_IOErr(const char *kdevname, const char *dir, sector_t sector, unsigned int errcnt);  /* 2006.9.5 :add errcnt */
+#endif // CONFIG_X86
+void kernevnt_FlashUpdate(int on);
+void kernevnt_DriveDead(const char *drvname);
+void kernevnt_I2cErr(void);
+void kernevnt_MiconInt(void);
+void kernevnt_EnetOverload(const char *name);
+void buffalo_kernevnt_queuein(const char *cmd);
+
+#endif
diff -rubB --new-file linux-3.10.69/include/linux/blkdev.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/linux/blkdev.h
--- linux-3.10.69/include/linux/blkdev.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/linux/blkdev.h	2017-05-02 03:31:56.000000000 +0200
@@ -1092,9 +1092,17 @@
 extern int blk_verify_command(unsigned char *cmd, fmode_t has_write_perm);
 
 enum blk_default_limits {
+#ifdef CONFIG_BUFFALO_PLATFORM
 	BLK_MAX_SEGMENTS	= 128,
+#else	/* CONFIG_BUFFALO_PLATFORM */
+	BLK_MAX_SEGMENTS	= 256,
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	BLK_SAFE_MAX_SECTORS	= 255,
+#ifdef CONFIG_BUFFALO_PLATFORM
 	BLK_DEF_MAX_SECTORS	= 1024,
+#else	/* CONFIG_BUFFALO_PLATFORM */
+	BLK_DEF_MAX_SECTORS	= 2048,
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 	BLK_MAX_SEGMENT_SIZE	= 65536,
 	BLK_SEG_BOUNDARY_MASK	= 0xFFFFFFFFUL,
 };
diff -rubB --new-file linux-3.10.69/include/linux/genhd.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/linux/genhd.h
--- linux-3.10.69/include/linux/genhd.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/linux/genhd.h	2017-05-02 03:31:56.000000000 +0200
@@ -200,6 +200,16 @@
 	struct blk_integrity *integrity;
 #endif
 	int node_id;
+
+#ifdef CONFIG_BUFFALO_PLATFORM
+	unsigned io_errors;		/* I/O error counter */
+	unsigned limit_io_errors;	/* I/O error limit */
+#ifdef CONFIG_BUFFALO_ERRCNT
+	atomic_t nr_errs;		/* number of errors occur during
+					 * Block I/O execution. */
+#endif	/* CONFIG_BUFFALO_ERRCNT */
+#endif	/* CONFIG_BUFFALO_PLATFORM */
+	
 };
 
 static inline struct gendisk *part_to_disk(struct hd_struct *part)
diff -rubB --new-file linux-3.10.69/include/linux/hid.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/linux/hid.h
--- linux-3.10.69/include/linux/hid.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/linux/hid.h	2017-05-02 03:31:56.000000000 +0200
@@ -532,7 +532,7 @@
 }
 
 #define HID_GLOBAL_STACK_SIZE 4
-#define HID_COLLECTION_STACK_SIZE 4
+#define HID_COLLECTION_STACK_SIZE 8
 
 struct hid_parser {
 	struct hid_global     global;
diff -rubB --new-file linux-3.10.69/include/linux/percpu_ida.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/linux/percpu_ida.h
--- linux-3.10.69/include/linux/percpu_ida.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/linux/percpu_ida.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,82 @@
+#ifndef __PERCPU_IDA_H__
+#define __PERCPU_IDA_H__
+
+#include <linux/types.h>
+#include <linux/bitops.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/spinlock_types.h>
+#include <linux/wait.h>
+#include <linux/cpumask.h>
+
+struct percpu_ida_cpu;
+
+struct percpu_ida {
+	/*
+	 * number of tags available to be allocated, as passed to
+	 * percpu_ida_init()
+	 */
+	unsigned			nr_tags;
+	unsigned			percpu_max_size;
+	unsigned			percpu_batch_size;
+
+	struct percpu_ida_cpu __percpu	*tag_cpu;
+
+	/*
+	 * Bitmap of cpus that (may) have tags on their percpu freelists:
+	 * steal_tags() uses this to decide when to steal tags, and which cpus
+	 * to try stealing from.
+	 *
+	 * It's ok for a freelist to be empty when its bit is set - steal_tags()
+	 * will just keep looking - but the bitmap _must_ be set whenever a
+	 * percpu freelist does have tags.
+	 */
+	cpumask_t			cpus_have_tags;
+
+	struct {
+		spinlock_t		lock;
+		/*
+		 * When we go to steal tags from another cpu (see steal_tags()),
+		 * we want to pick a cpu at random. Cycling through them every
+		 * time we steal is a bit easier and more or less equivalent:
+		 */
+		unsigned		cpu_last_stolen;
+
+		/* For sleeping on allocation failure */
+		wait_queue_head_t	wait;
+
+		/*
+		 * Global freelist - it's a stack where nr_free points to the
+		 * top
+		 */
+		unsigned		nr_free;
+		unsigned		*freelist;
+	} ____cacheline_aligned_in_smp;
+};
+
+/*
+ * Number of tags we move between the percpu freelist and the global freelist at
+ * a time
+ */
+#define IDA_DEFAULT_PCPU_BATCH_MOVE	32U
+/* Max size of percpu freelist, */
+#define IDA_DEFAULT_PCPU_SIZE	((IDA_DEFAULT_PCPU_BATCH_MOVE * 3) / 2)
+
+int percpu_ida_alloc(struct percpu_ida *pool, int state);
+void percpu_ida_free(struct percpu_ida *pool, unsigned tag);
+
+void percpu_ida_destroy(struct percpu_ida *pool);
+int __percpu_ida_init(struct percpu_ida *pool, unsigned long nr_tags,
+	unsigned long max_size, unsigned long batch_size);
+static inline int percpu_ida_init(struct percpu_ida *pool, unsigned long nr_tags)
+{
+	return __percpu_ida_init(pool, nr_tags, IDA_DEFAULT_PCPU_SIZE,
+		IDA_DEFAULT_PCPU_BATCH_MOVE);
+}
+
+typedef int (*percpu_ida_cb)(unsigned, void *);
+int percpu_ida_for_each_free(struct percpu_ida *pool, percpu_ida_cb fn,
+	void *data);
+
+unsigned percpu_ida_free_tags(struct percpu_ida *pool, int cpu);
+#endif /* __PERCPU_IDA_H__ */
diff -rubB --new-file linux-3.10.69/include/linux/percpu-refcount.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/linux/percpu-refcount.h
--- linux-3.10.69/include/linux/percpu-refcount.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/linux/percpu-refcount.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,174 @@
+/*
+ * Percpu refcounts:
+ * (C) 2012 Google, Inc.
+ * Author: Kent Overstreet <koverstreet@google.com>
+ *
+ * This implements a refcount with similar semantics to atomic_t - atomic_inc(),
+ * atomic_dec_and_test() - but percpu.
+ *
+ * There's one important difference between percpu refs and normal atomic_t
+ * refcounts; you have to keep track of your initial refcount, and then when you
+ * start shutting down you call percpu_ref_kill() _before_ dropping the initial
+ * refcount.
+ *
+ * The refcount will have a range of 0 to ((1U << 31) - 1), i.e. one bit less
+ * than an atomic_t - this is because of the way shutdown works, see
+ * percpu_ref_kill()/PCPU_COUNT_BIAS.
+ *
+ * Before you call percpu_ref_kill(), percpu_ref_put() does not check for the
+ * refcount hitting 0 - it can't, if it was in percpu mode. percpu_ref_kill()
+ * puts the ref back in single atomic_t mode, collecting the per cpu refs and
+ * issuing the appropriate barriers, and then marks the ref as shutting down so
+ * that percpu_ref_put() will check for the ref hitting 0.  After it returns,
+ * it's safe to drop the initial ref.
+ *
+ * USAGE:
+ *
+ * See fs/aio.c for some example usage; it's used there for struct kioctx, which
+ * is created when userspaces calls io_setup(), and destroyed when userspace
+ * calls io_destroy() or the process exits.
+ *
+ * In the aio code, kill_ioctx() is called when we wish to destroy a kioctx; it
+ * calls percpu_ref_kill(), then hlist_del_rcu() and sychronize_rcu() to remove
+ * the kioctx from the proccess's list of kioctxs - after that, there can't be
+ * any new users of the kioctx (from lookup_ioctx()) and it's then safe to drop
+ * the initial ref with percpu_ref_put().
+ *
+ * Code that does a two stage shutdown like this often needs some kind of
+ * explicit synchronization to ensure the initial refcount can only be dropped
+ * once - percpu_ref_kill() does this for you, it returns true once and false if
+ * someone else already called it. The aio code uses it this way, but it's not
+ * necessary if the code has some other mechanism to synchronize teardown.
+ * around.
+ */
+
+#ifndef _LINUX_PERCPU_REFCOUNT_H
+#define _LINUX_PERCPU_REFCOUNT_H
+
+#include <linux/atomic.h>
+#include <linux/kernel.h>
+#include <linux/percpu.h>
+#include <linux/rcupdate.h>
+
+struct percpu_ref;
+typedef void (percpu_ref_func_t)(struct percpu_ref *);
+
+struct percpu_ref {
+	atomic_t		count;
+	/*
+	 * The low bit of the pointer indicates whether the ref is in percpu
+	 * mode; if set, then get/put will manipulate the atomic_t (this is a
+	 * hack because we need to keep the pointer around for
+	 * percpu_ref_kill_rcu())
+	 */
+	unsigned __percpu	*pcpu_count;
+	percpu_ref_func_t	*release;
+	percpu_ref_func_t	*confirm_kill;
+	struct rcu_head		rcu;
+};
+
+int __must_check percpu_ref_init(struct percpu_ref *ref,
+				 percpu_ref_func_t *release);
+void percpu_ref_cancel_init(struct percpu_ref *ref);
+void percpu_ref_kill_and_confirm(struct percpu_ref *ref,
+				 percpu_ref_func_t *confirm_kill);
+
+/**
+ * percpu_ref_kill - drop the initial ref
+ * @ref: percpu_ref to kill
+ *
+ * Must be used to drop the initial ref on a percpu refcount; must be called
+ * precisely once before shutdown.
+ *
+ * Puts @ref in non percpu mode, then does a call_rcu() before gathering up the
+ * percpu counters and dropping the initial ref.
+ */
+static inline void percpu_ref_kill(struct percpu_ref *ref)
+{
+	return percpu_ref_kill_and_confirm(ref, NULL);
+}
+
+#define PCPU_STATUS_BITS	2
+#define PCPU_STATUS_MASK	((1 << PCPU_STATUS_BITS) - 1)
+#define PCPU_REF_PTR		0
+#define PCPU_REF_DEAD		1
+
+#define REF_STATUS(count)	(((unsigned long) count) & PCPU_STATUS_MASK)
+
+/**
+ * percpu_ref_get - increment a percpu refcount
+ * @ref: percpu_ref to get
+ *
+ * Analagous to atomic_inc().
+  */
+static inline void percpu_ref_get(struct percpu_ref *ref)
+{
+	unsigned __percpu *pcpu_count;
+
+	rcu_read_lock_sched();
+
+	pcpu_count = ACCESS_ONCE(ref->pcpu_count);
+
+	if (likely(REF_STATUS(pcpu_count) == PCPU_REF_PTR))
+		__this_cpu_inc(*pcpu_count);
+	else
+		atomic_inc(&ref->count);
+
+	rcu_read_unlock_sched();
+}
+
+/**
+ * percpu_ref_tryget - try to increment a percpu refcount
+ * @ref: percpu_ref to try-get
+ *
+ * Increment a percpu refcount unless it has already been killed.  Returns
+ * %true on success; %false on failure.
+ *
+ * Completion of percpu_ref_kill() in itself doesn't guarantee that tryget
+ * will fail.  For such guarantee, percpu_ref_kill_and_confirm() should be
+ * used.  After the confirm_kill callback is invoked, it's guaranteed that
+ * no new reference will be given out by percpu_ref_tryget().
+ */
+static inline bool percpu_ref_tryget(struct percpu_ref *ref)
+{
+	unsigned __percpu *pcpu_count;
+	int ret = false;
+
+	rcu_read_lock_sched();
+
+	pcpu_count = ACCESS_ONCE(ref->pcpu_count);
+
+	if (likely(REF_STATUS(pcpu_count) == PCPU_REF_PTR)) {
+		__this_cpu_inc(*pcpu_count);
+		ret = true;
+	}
+
+	rcu_read_unlock_sched();
+
+	return ret;
+}
+
+/**
+ * percpu_ref_put - decrement a percpu refcount
+ * @ref: percpu_ref to put
+ *
+ * Decrement the refcount, and if 0, call the release function (which was passed
+ * to percpu_ref_init())
+ */
+static inline void percpu_ref_put(struct percpu_ref *ref)
+{
+	unsigned __percpu *pcpu_count;
+
+	rcu_read_lock_sched();
+
+	pcpu_count = ACCESS_ONCE(ref->pcpu_count);
+
+	if (likely(REF_STATUS(pcpu_count) == PCPU_REF_PTR))
+		__this_cpu_dec(*pcpu_count);
+	else if (unlikely(atomic_dec_and_test(&ref->count)))
+		ref->release(ref);
+
+	rcu_read_unlock_sched();
+}
+
+#endif
diff -rubB --new-file linux-3.10.69/include/scsi/scsi_device.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/scsi/scsi_device.h
--- linux-3.10.69/include/scsi/scsi_device.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/scsi/scsi_device.h	2017-05-02 03:31:56.000000000 +0200
@@ -183,6 +183,10 @@
 
 	struct scsi_dh_data	*scsi_dh_data;
 	enum scsi_device_state sdev_state;
+#if defined(CONFIG_BUFFALO_IGNORE_LUN) // BUFFALO_PLATFFORM
+	int ignore_lun;
+#endif // BUFFALO_PLATFFORM
+
 	unsigned long		sdev_data[0];
 } __attribute__((aligned(sizeof(unsigned long))));
 
diff -rubB --new-file linux-3.10.69/include/scsi/scsi.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/scsi/scsi.h
--- linux-3.10.69/include/scsi/scsi.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/scsi/scsi.h	2017-05-02 03:31:56.000000000 +0200
@@ -139,6 +139,7 @@
 #define ACCESS_CONTROL_IN     0x86
 #define ACCESS_CONTROL_OUT    0x87
 #define READ_16               0x88
+#define COMPARE_AND_WRITE     0x89
 #define WRITE_16              0x8a
 #define READ_ATTRIBUTE        0x8c
 #define WRITE_ATTRIBUTE	      0x8d
@@ -149,6 +150,7 @@
 /* values for service action in */
 #define	SAI_READ_CAPACITY_16  0x10
 #define SAI_GET_LBA_STATUS    0x12
+#define SAI_REPORT_REFERRALS  0x13
 /* values for VARIABLE_LENGTH_CMD service action codes
  * see spc4r17 Section D.3.5, table D.7 and D.8 */
 #define VLC_SA_RECEIVE_CREDENTIAL 0x1800
@@ -452,6 +454,8 @@
 				 * other paths */
 #define DID_NEXUS_FAILURE 0x11  /* Permanent nexus failure, retry on other
 				 * paths might yield different results */
+#define DID_ALLOC_FAILURE 0x12  /* Space allocation on the device failed */
+#define DID_MEDIUM_ERROR  0x13  /* Medium error */
 #define DRIVER_OK       0x00	/* Driver status                           */
 
 /*
diff -rubB --new-file linux-3.10.69/include/target/iscsi/iscsi_target_core.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/iscsi/iscsi_target_core.h
--- linux-3.10.69/include/target/iscsi/iscsi_target_core.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/iscsi/iscsi_target_core.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,910 @@
+#ifndef ISCSI_TARGET_CORE_H
+#define ISCSI_TARGET_CORE_H
+
+#include <linux/in.h>
+#include <linux/configfs.h>
+#include <net/sock.h>
+#include <net/tcp.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/iscsi_proto.h>
+#include <target/target_core_base.h>
+
+#define ISCSIT_VERSION			"v4.1.0"
+#define ISCSI_MAX_DATASN_MISSING_COUNT	16
+#define ISCSI_TX_THREAD_TCP_TIMEOUT	2
+#define ISCSI_RX_THREAD_TCP_TIMEOUT	2
+#define SECONDS_FOR_ASYNC_LOGOUT	10
+#define SECONDS_FOR_ASYNC_TEXT		10
+#define SECONDS_FOR_LOGOUT_COMP		15
+#define WHITE_SPACE			" \t\v\f\n\r"
+#define ISCSIT_MIN_TAGS			16
+#define ISCSIT_EXTRA_TAGS		8
+#define ISCSIT_TCP_BACKLOG		256
+#define ISCSI_RX_THREAD_NAME		"iscsi_trx"
+#define ISCSI_TX_THREAD_NAME		"iscsi_ttx"
+
+/* struct iscsi_node_attrib sanity values */
+#define NA_DATAOUT_TIMEOUT		3
+#define NA_DATAOUT_TIMEOUT_MAX		60
+#define NA_DATAOUT_TIMEOUT_MIX		2
+#define NA_DATAOUT_TIMEOUT_RETRIES	5
+#define NA_DATAOUT_TIMEOUT_RETRIES_MAX	15
+#define NA_DATAOUT_TIMEOUT_RETRIES_MIN	1
+#define NA_NOPIN_TIMEOUT		15
+#define NA_NOPIN_TIMEOUT_MAX		60
+#define NA_NOPIN_TIMEOUT_MIN		3
+#define NA_NOPIN_RESPONSE_TIMEOUT	30
+#define NA_NOPIN_RESPONSE_TIMEOUT_MAX	60
+#define NA_NOPIN_RESPONSE_TIMEOUT_MIN	3
+#define NA_RANDOM_DATAIN_PDU_OFFSETS	0
+#define NA_RANDOM_DATAIN_SEQ_OFFSETS	0
+#define NA_RANDOM_R2T_OFFSETS		0
+
+/* struct iscsi_tpg_attrib sanity values */
+#define TA_AUTHENTICATION		1
+#define TA_LOGIN_TIMEOUT		15
+#define TA_LOGIN_TIMEOUT_MAX		30
+#define TA_LOGIN_TIMEOUT_MIN		5
+#define TA_NETIF_TIMEOUT		2
+#define TA_NETIF_TIMEOUT_MAX		15
+#define TA_NETIF_TIMEOUT_MIN		2
+#define TA_GENERATE_NODE_ACLS		0
+#define TA_DEFAULT_CMDSN_DEPTH		64
+#define TA_DEFAULT_CMDSN_DEPTH_MAX	512
+#define TA_DEFAULT_CMDSN_DEPTH_MIN	1
+#define TA_CACHE_DYNAMIC_ACLS		0
+/* Enabled by default in demo mode (generic_node_acls=1) */
+#define TA_DEMO_MODE_WRITE_PROTECT	1
+/* Disabled by default in production mode w/ explict ACLs */
+#define TA_PROD_MODE_WRITE_PROTECT	0
+#define TA_DEMO_MODE_DISCOVERY		1
+#define TA_DEFAULT_ERL			0
+#define TA_CACHE_CORE_NPS		0
+/* T10 protection information disabled by default */
+#define TA_DEFAULT_T10_PI		0
+#define TA_DEFAULT_FABRIC_PROT_TYPE	0
+
+#define ISCSI_IOV_DATA_BUFFER		5
+
+enum iscsit_transport_type {
+	ISCSI_TCP				= 0,
+	ISCSI_SCTP_TCP				= 1,
+	ISCSI_SCTP_UDP				= 2,
+	ISCSI_IWARP_TCP				= 3,
+	ISCSI_IWARP_SCTP			= 4,
+	ISCSI_INFINIBAND			= 5,
+};
+
+/* RFC-3720 7.1.4  Standard Connection State Diagram for a Target */
+enum target_conn_state_table {
+	TARG_CONN_STATE_FREE			= 0x1,
+	TARG_CONN_STATE_XPT_UP			= 0x3,
+	TARG_CONN_STATE_IN_LOGIN		= 0x4,
+	TARG_CONN_STATE_LOGGED_IN		= 0x5,
+	TARG_CONN_STATE_IN_LOGOUT		= 0x6,
+	TARG_CONN_STATE_LOGOUT_REQUESTED	= 0x7,
+	TARG_CONN_STATE_CLEANUP_WAIT		= 0x8,
+};
+
+/* RFC-3720 7.3.2  Session State Diagram for a Target */
+enum target_sess_state_table {
+	TARG_SESS_STATE_FREE			= 0x1,
+	TARG_SESS_STATE_ACTIVE			= 0x2,
+	TARG_SESS_STATE_LOGGED_IN		= 0x3,
+	TARG_SESS_STATE_FAILED			= 0x4,
+	TARG_SESS_STATE_IN_CONTINUE		= 0x5,
+};
+
+/* struct iscsi_data_count->type */
+enum data_count_type {
+	ISCSI_RX_DATA	= 1,
+	ISCSI_TX_DATA	= 2,
+};
+
+/* struct iscsi_datain_req->dr_complete */
+enum datain_req_comp_table {
+	DATAIN_COMPLETE_NORMAL			= 1,
+	DATAIN_COMPLETE_WITHIN_COMMAND_RECOVERY = 2,
+	DATAIN_COMPLETE_CONNECTION_RECOVERY	= 3,
+};
+
+/* struct iscsi_datain_req->recovery */
+enum datain_req_rec_table {
+	DATAIN_WITHIN_COMMAND_RECOVERY		= 1,
+	DATAIN_CONNECTION_RECOVERY		= 2,
+};
+
+/* struct iscsi_portal_group->state */
+enum tpg_state_table {
+	TPG_STATE_FREE				= 0,
+	TPG_STATE_ACTIVE			= 1,
+	TPG_STATE_INACTIVE			= 2,
+	TPG_STATE_COLD_RESET			= 3,
+};
+
+/* struct iscsi_tiqn->tiqn_state */
+enum tiqn_state_table {
+	TIQN_STATE_ACTIVE			= 1,
+	TIQN_STATE_SHUTDOWN			= 2,
+};
+
+/* struct iscsi_cmd->cmd_flags */
+enum cmd_flags_table {
+	ICF_GOT_LAST_DATAOUT			= 0x00000001,
+	ICF_GOT_DATACK_SNACK			= 0x00000002,
+	ICF_NON_IMMEDIATE_UNSOLICITED_DATA	= 0x00000004,
+	ICF_SENT_LAST_R2T			= 0x00000008,
+	ICF_WITHIN_COMMAND_RECOVERY		= 0x00000010,
+	ICF_CONTIG_MEMORY			= 0x00000020,
+	ICF_ATTACHED_TO_RQUEUE			= 0x00000040,
+	ICF_OOO_CMDSN				= 0x00000080,
+	ICF_SENDTARGETS_ALL			= 0x00000100,
+	ICF_SENDTARGETS_SINGLE			= 0x00000200,
+};
+
+/* struct iscsi_cmd->i_state */
+enum cmd_i_state_table {
+	ISTATE_NO_STATE			= 0,
+	ISTATE_NEW_CMD			= 1,
+	ISTATE_DEFERRED_CMD		= 2,
+	ISTATE_UNSOLICITED_DATA		= 3,
+	ISTATE_RECEIVE_DATAOUT		= 4,
+	ISTATE_RECEIVE_DATAOUT_RECOVERY	= 5,
+	ISTATE_RECEIVED_LAST_DATAOUT	= 6,
+	ISTATE_WITHIN_DATAOUT_RECOVERY	= 7,
+	ISTATE_IN_CONNECTION_RECOVERY	= 8,
+	ISTATE_RECEIVED_TASKMGT		= 9,
+	ISTATE_SEND_ASYNCMSG		= 10,
+	ISTATE_SENT_ASYNCMSG		= 11,
+	ISTATE_SEND_DATAIN		= 12,
+	ISTATE_SEND_LAST_DATAIN		= 13,
+	ISTATE_SENT_LAST_DATAIN		= 14,
+	ISTATE_SEND_LOGOUTRSP		= 15,
+	ISTATE_SENT_LOGOUTRSP		= 16,
+	ISTATE_SEND_NOPIN		= 17,
+	ISTATE_SENT_NOPIN		= 18,
+	ISTATE_SEND_REJECT		= 19,
+	ISTATE_SENT_REJECT		= 20,
+	ISTATE_SEND_R2T			= 21,
+	ISTATE_SENT_R2T			= 22,
+	ISTATE_SEND_R2T_RECOVERY	= 23,
+	ISTATE_SENT_R2T_RECOVERY	= 24,
+	ISTATE_SEND_LAST_R2T		= 25,
+	ISTATE_SENT_LAST_R2T		= 26,
+	ISTATE_SEND_LAST_R2T_RECOVERY	= 27,
+	ISTATE_SENT_LAST_R2T_RECOVERY	= 28,
+	ISTATE_SEND_STATUS		= 29,
+	ISTATE_SEND_STATUS_BROKEN_PC	= 30,
+	ISTATE_SENT_STATUS		= 31,
+	ISTATE_SEND_STATUS_RECOVERY	= 32,
+	ISTATE_SENT_STATUS_RECOVERY	= 33,
+	ISTATE_SEND_TASKMGTRSP		= 34,
+	ISTATE_SENT_TASKMGTRSP		= 35,
+	ISTATE_SEND_TEXTRSP		= 36,
+	ISTATE_SENT_TEXTRSP		= 37,
+	ISTATE_SEND_NOPIN_WANT_RESPONSE	= 38,
+	ISTATE_SENT_NOPIN_WANT_RESPONSE	= 39,
+	ISTATE_SEND_NOPIN_NO_RESPONSE	= 40,
+	ISTATE_REMOVE			= 41,
+	ISTATE_FREE			= 42,
+};
+
+/* Used for iscsi_recover_cmdsn() return values */
+enum recover_cmdsn_ret_table {
+	CMDSN_ERROR_CANNOT_RECOVER	= -1,
+	CMDSN_NORMAL_OPERATION		= 0,
+	CMDSN_LOWER_THAN_EXP		= 1,
+	CMDSN_HIGHER_THAN_EXP		= 2,
+	CMDSN_MAXCMDSN_OVERRUN		= 3,
+};
+
+/* Used for iscsi_handle_immediate_data() return values */
+enum immedate_data_ret_table {
+	IMMEDIATE_DATA_CANNOT_RECOVER	= -1,
+	IMMEDIATE_DATA_NORMAL_OPERATION = 0,
+	IMMEDIATE_DATA_ERL1_CRC_FAILURE = 1,
+};
+
+/* Used for iscsi_decide_dataout_action() return values */
+enum dataout_action_ret_table {
+	DATAOUT_CANNOT_RECOVER		= -1,
+	DATAOUT_NORMAL			= 0,
+	DATAOUT_SEND_R2T		= 1,
+	DATAOUT_SEND_TO_TRANSPORT	= 2,
+	DATAOUT_WITHIN_COMMAND_RECOVERY = 3,
+};
+
+/* Used for struct iscsi_node_auth->naf_flags */
+enum naf_flags_table {
+	NAF_USERID_SET			= 0x01,
+	NAF_PASSWORD_SET		= 0x02,
+	NAF_USERID_IN_SET		= 0x04,
+	NAF_PASSWORD_IN_SET		= 0x08,
+};
+
+/* Used by various struct timer_list to manage iSCSI specific state */
+enum iscsi_timer_flags_table {
+	ISCSI_TF_RUNNING		= 0x01,
+	ISCSI_TF_STOP			= 0x02,
+	ISCSI_TF_EXPIRED		= 0x04,
+};
+
+/* Used for struct iscsi_np->np_flags */
+enum np_flags_table {
+	NPF_IP_NETWORK		= 0x00,
+};
+
+/* Used for struct iscsi_np->np_thread_state */
+enum np_thread_state_table {
+	ISCSI_NP_THREAD_ACTIVE		= 1,
+	ISCSI_NP_THREAD_INACTIVE	= 2,
+	ISCSI_NP_THREAD_RESET		= 3,
+	ISCSI_NP_THREAD_SHUTDOWN	= 4,
+	ISCSI_NP_THREAD_EXIT		= 5,
+};
+
+struct iscsi_conn_ops {
+	u8	HeaderDigest;			/* [0,1] == [None,CRC32C] */
+	u8	DataDigest;			/* [0,1] == [None,CRC32C] */
+	u32	MaxRecvDataSegmentLength;	/* [512..2**24-1] */
+	u32	MaxXmitDataSegmentLength;	/* [512..2**24-1] */
+	u8	OFMarker;			/* [0,1] == [No,Yes] */
+	u8	IFMarker;			/* [0,1] == [No,Yes] */
+	u32	OFMarkInt;			/* [1..65535] */
+	u32	IFMarkInt;			/* [1..65535] */
+	/*
+	 * iSER specific connection parameters
+	 */
+	u32	InitiatorRecvDataSegmentLength;	/* [512..2**24-1] */
+	u32	TargetRecvDataSegmentLength;	/* [512..2**24-1] */
+};
+
+struct iscsi_sess_ops {
+	char	InitiatorName[224];
+	char	InitiatorAlias[256];
+	char	TargetName[224];
+	char	TargetAlias[256];
+	char	TargetAddress[256];
+	u16	TargetPortalGroupTag;		/* [0..65535] */
+	u16	MaxConnections;			/* [1..65535] */
+	u8	InitialR2T;			/* [0,1] == [No,Yes] */
+	u8	ImmediateData;			/* [0,1] == [No,Yes] */
+	u32	MaxBurstLength;			/* [512..2**24-1] */
+	u32	FirstBurstLength;		/* [512..2**24-1] */
+	u16	DefaultTime2Wait;		/* [0..3600] */
+	u16	DefaultTime2Retain;		/* [0..3600] */
+	u16	MaxOutstandingR2T;		/* [1..65535] */
+	u8	DataPDUInOrder;			/* [0,1] == [No,Yes] */
+	u8	DataSequenceInOrder;		/* [0,1] == [No,Yes] */
+	u8	ErrorRecoveryLevel;		/* [0..2] */
+	u8	SessionType;			/* [0,1] == [Normal,Discovery]*/
+	/*
+	 * iSER specific session parameters
+	 */
+	u8	RDMAExtensions;			/* [0,1] == [No,Yes] */
+};
+
+struct iscsi_queue_req {
+	int			state;
+	struct iscsi_cmd	*cmd;
+	struct list_head	qr_list;
+};
+
+struct iscsi_data_count {
+	int			data_length;
+	int			sync_and_steering;
+	enum data_count_type	type;
+	u32			iov_count;
+	u32			ss_iov_count;
+	u32			ss_marker_count;
+	struct kvec		*iov;
+};
+
+struct iscsi_param_list {
+	bool			iser;
+	struct list_head	param_list;
+	struct list_head	extra_response_list;
+};
+
+struct iscsi_datain_req {
+	enum datain_req_comp_table dr_complete;
+	int			generate_recovery_values;
+	enum datain_req_rec_table recovery;
+	u32			begrun;
+	u32			runlength;
+	u32			data_length;
+	u32			data_offset;
+	u32			data_sn;
+	u32			next_burst_len;
+	u32			read_data_done;
+	u32			seq_send_order;
+	struct list_head	cmd_datain_node;
+} ____cacheline_aligned;
+
+struct iscsi_ooo_cmdsn {
+	u16			cid;
+	u32			batch_count;
+	u32			cmdsn;
+	u32			exp_cmdsn;
+	struct iscsi_cmd	*cmd;
+	struct list_head	ooo_list;
+} ____cacheline_aligned;
+
+struct iscsi_datain {
+	u8			flags;
+	u32			data_sn;
+	u32			length;
+	u32			offset;
+} ____cacheline_aligned;
+
+struct iscsi_r2t {
+	int			seq_complete;
+	int			recovery_r2t;
+	int			sent_r2t;
+	u32			r2t_sn;
+	u32			offset;
+	u32			targ_xfer_tag;
+	u32			xfer_len;
+	struct list_head	r2t_list;
+} ____cacheline_aligned;
+
+struct iscsi_cmd {
+	enum iscsi_timer_flags_table dataout_timer_flags;
+	/* DataOUT timeout retries */
+	u8			dataout_timeout_retries;
+	/* Within command recovery count */
+	u8			error_recovery_count;
+	/* iSCSI dependent state for out or order CmdSNs */
+	enum cmd_i_state_table	deferred_i_state;
+	/* iSCSI dependent state */
+	enum cmd_i_state_table	i_state;
+	/* Command is an immediate command (ISCSI_OP_IMMEDIATE set) */
+	u8			immediate_cmd;
+	/* Immediate data present */
+	u8			immediate_data;
+	/* iSCSI Opcode */
+	u8			iscsi_opcode;
+	/* iSCSI Response Code */
+	u8			iscsi_response;
+	/* Logout reason when iscsi_opcode == ISCSI_INIT_LOGOUT_CMND */
+	u8			logout_reason;
+	/* Logout response code when iscsi_opcode == ISCSI_INIT_LOGOUT_CMND */
+	u8			logout_response;
+	/* MaxCmdSN has been incremented */
+	u8			maxcmdsn_inc;
+	/* Immediate Unsolicited Dataout */
+	u8			unsolicited_data;
+	/* Reject reason code */
+	u8			reject_reason;
+	/* CID contained in logout PDU when opcode == ISCSI_INIT_LOGOUT_CMND */
+	u16			logout_cid;
+	/* Command flags */
+	enum cmd_flags_table	cmd_flags;
+	/* Initiator Task Tag assigned from Initiator */
+	itt_t			init_task_tag;
+	/* Target Transfer Tag assigned from Target */
+	u32			targ_xfer_tag;
+	/* CmdSN assigned from Initiator */
+	u32			cmd_sn;
+	/* ExpStatSN assigned from Initiator */
+	u32			exp_stat_sn;
+	/* StatSN assigned to this ITT */
+	u32			stat_sn;
+	/* DataSN Counter */
+	u32			data_sn;
+	/* R2TSN Counter */
+	u32			r2t_sn;
+	/* Last DataSN acknowledged via DataAck SNACK */
+	u32			acked_data_sn;
+	/* Used for echoing NOPOUT ping data */
+	u32			buf_ptr_size;
+	/* Used to store DataDigest */
+	u32			data_crc;
+	/* Counter for MaxOutstandingR2T */
+	u32			outstanding_r2ts;
+	/* Next R2T Offset when DataSequenceInOrder=Yes */
+	u32			r2t_offset;
+	/* Iovec current and orig count for iscsi_cmd->iov_data */
+	u32			iov_data_count;
+	u32			orig_iov_data_count;
+	/* Number of miscellaneous iovecs used for IP stack calls */
+	u32			iov_misc_count;
+	/* Number of struct iscsi_pdu in struct iscsi_cmd->pdu_list */
+	u32			pdu_count;
+	/* Next struct iscsi_pdu to send in struct iscsi_cmd->pdu_list */
+	u32			pdu_send_order;
+	/* Current struct iscsi_pdu in struct iscsi_cmd->pdu_list */
+	u32			pdu_start;
+	/* Next struct iscsi_seq to send in struct iscsi_cmd->seq_list */
+	u32			seq_send_order;
+	/* Number of struct iscsi_seq in struct iscsi_cmd->seq_list */
+	u32			seq_count;
+	/* Current struct iscsi_seq in struct iscsi_cmd->seq_list */
+	u32			seq_no;
+	/* Lowest offset in current DataOUT sequence */
+	u32			seq_start_offset;
+	/* Highest offset in current DataOUT sequence */
+	u32			seq_end_offset;
+	/* Total size in bytes received so far of READ data */
+	u32			read_data_done;
+	/* Total size in bytes received so far of WRITE data */
+	u32			write_data_done;
+	/* Counter for FirstBurstLength key */
+	u32			first_burst_len;
+	/* Counter for MaxBurstLength key */
+	u32			next_burst_len;
+	/* Transfer size used for IP stack calls */
+	u32			tx_size;
+	/* Buffer used for various purposes */
+	void			*buf_ptr;
+	/* Used by SendTargets=[iqn.,eui.] discovery */
+	void			*text_in_ptr;
+	/* See include/linux/dma-mapping.h */
+	enum dma_data_direction	data_direction;
+	/* iSCSI PDU Header + CRC */
+	unsigned char		pdu[ISCSI_HDR_LEN + ISCSI_CRC_LEN];
+	/* Number of times struct iscsi_cmd is present in immediate queue */
+	atomic_t		immed_queue_count;
+	atomic_t		response_queue_count;
+	spinlock_t		datain_lock;
+	spinlock_t		dataout_timeout_lock;
+	/* spinlock for protecting struct iscsi_cmd->i_state */
+	spinlock_t		istate_lock;
+	/* spinlock for adding within command recovery entries */
+	spinlock_t		error_lock;
+	/* spinlock for adding R2Ts */
+	spinlock_t		r2t_lock;
+	/* DataIN List */
+	struct list_head	datain_list;
+	/* R2T List */
+	struct list_head	cmd_r2t_list;
+	/* Timer for DataOUT */
+	struct timer_list	dataout_timer;
+	/* Iovecs for SCSI data payload RX/TX w/ kernel level sockets */
+	struct kvec		*iov_data;
+	/* Iovecs for miscellaneous purposes */
+#define ISCSI_MISC_IOVECS			5
+	struct kvec		iov_misc[ISCSI_MISC_IOVECS];
+	/* Array of struct iscsi_pdu used for DataPDUInOrder=No */
+	struct iscsi_pdu	*pdu_list;
+	/* Current struct iscsi_pdu used for DataPDUInOrder=No */
+	struct iscsi_pdu	*pdu_ptr;
+	/* Array of struct iscsi_seq used for DataSequenceInOrder=No */
+	struct iscsi_seq	*seq_list;
+	/* Current struct iscsi_seq used for DataSequenceInOrder=No */
+	struct iscsi_seq	*seq_ptr;
+	/* TMR Request when iscsi_opcode == ISCSI_OP_SCSI_TMFUNC */
+	struct iscsi_tmr_req	*tmr_req;
+	/* Connection this command is alligient to */
+	struct iscsi_conn	*conn;
+	/* Pointer to connection recovery entry */
+	struct iscsi_conn_recovery *cr;
+	/* Session the command is part of,  used for connection recovery */
+	struct iscsi_session	*sess;
+	/* list_head for connection list */
+	struct list_head	i_conn_node;
+	/* The TCM I/O descriptor that is accessed via container_of() */
+	struct se_cmd		se_cmd;
+	/* Sense buffer that will be mapped into outgoing status */
+#define ISCSI_SENSE_BUFFER_LEN          (TRANSPORT_SENSE_BUFFER + 2)
+	unsigned char		sense_buffer[ISCSI_SENSE_BUFFER_LEN];
+
+	u32			padding;
+	u8			pad_bytes[4];
+
+	struct scatterlist	*first_data_sg;
+	u32			first_data_sg_off;
+	u32			kmapped_nents;
+	sense_reason_t		sense_reason;
+}  ____cacheline_aligned;
+
+struct iscsi_tmr_req {
+	bool			task_reassign:1;
+	u32			exp_data_sn;
+	struct iscsi_cmd	*ref_cmd;
+	struct iscsi_conn_recovery *conn_recovery;
+	struct se_tmr_req	*se_tmr_req;
+};
+
+struct iscsi_conn {
+	wait_queue_head_t	queues_wq;
+	/* Authentication Successful for this connection */
+	u8			auth_complete;
+	/* State connection is currently in */
+	u8			conn_state;
+	u8			conn_logout_reason;
+	u8			network_transport;
+	enum iscsi_timer_flags_table nopin_timer_flags;
+	enum iscsi_timer_flags_table nopin_response_timer_flags;
+	/* Used to know what thread encountered a transport failure */
+	u8			which_thread;
+	/* connection id assigned by the Initiator */
+	u16			cid;
+	/* Remote TCP Port */
+	u16			login_port;
+	u16			local_port;
+	int			net_size;
+	int			login_family;
+	u32			auth_id;
+	u32			conn_flags;
+	/* Used for iscsi_tx_login_rsp() */
+	itt_t			login_itt;
+	u32			exp_statsn;
+	/* Per connection status sequence number */
+	u32			stat_sn;
+	/* IFMarkInt's Current Value */
+	u32			if_marker;
+	/* OFMarkInt's Current Value */
+	u32			of_marker;
+	/* Used for calculating OFMarker offset to next PDU */
+	u32			of_marker_offset;
+#define IPV6_ADDRESS_SPACE				48
+	unsigned char		login_ip[IPV6_ADDRESS_SPACE];
+	unsigned char		local_ip[IPV6_ADDRESS_SPACE];
+	int			conn_usage_count;
+	int			conn_waiting_on_uc;
+	atomic_t		check_immediate_queue;
+	atomic_t		conn_logout_remove;
+	atomic_t		connection_exit;
+	atomic_t		connection_recovery;
+	atomic_t		connection_reinstatement;
+	atomic_t		connection_wait_rcfr;
+	atomic_t		sleep_on_conn_wait_comp;
+	atomic_t		transport_failed;
+	struct completion	conn_post_wait_comp;
+	struct completion	conn_wait_comp;
+	struct completion	conn_wait_rcfr_comp;
+	struct completion	conn_waiting_on_uc_comp;
+	struct completion	conn_logout_comp;
+	struct completion	tx_half_close_comp;
+	struct completion	rx_half_close_comp;
+	/* socket used by this connection */
+	struct socket		*sock;
+	void			(*orig_data_ready)(struct sock *);
+	void			(*orig_state_change)(struct sock *);
+#define LOGIN_FLAGS_READ_ACTIVE		1
+#define LOGIN_FLAGS_CLOSED		2
+#define LOGIN_FLAGS_READY		4
+	unsigned long		login_flags;
+	struct delayed_work	login_work;
+	struct delayed_work	login_cleanup_work;
+	struct iscsi_login	*login;
+	struct timer_list	nopin_timer;
+	struct timer_list	nopin_response_timer;
+	struct timer_list	transport_timer;
+	struct task_struct	*login_kworker;
+	/* Spinlock used for add/deleting cmd's from conn_cmd_list */
+	spinlock_t		cmd_lock;
+	spinlock_t		conn_usage_lock;
+	spinlock_t		immed_queue_lock;
+	spinlock_t		nopin_timer_lock;
+	spinlock_t		response_queue_lock;
+	spinlock_t		state_lock;
+	/* libcrypto RX and TX contexts for crc32c */
+	struct hash_desc	conn_rx_hash;
+	struct hash_desc	conn_tx_hash;
+	/* Used for scheduling TX and RX connection kthreads */
+	cpumask_var_t		conn_cpumask;
+	unsigned int		conn_rx_reset_cpumask:1;
+	unsigned int		conn_tx_reset_cpumask:1;
+	/* list_head of struct iscsi_cmd for this connection */
+	struct list_head	conn_cmd_list;
+	struct list_head	immed_queue_list;
+	struct list_head	response_queue_list;
+	struct iscsi_conn_ops	*conn_ops;
+	struct iscsi_login	*conn_login;
+	struct iscsit_transport *conn_transport;
+	struct iscsi_param_list	*param_list;
+	/* Used for per connection auth state machine */
+	void			*auth_protocol;
+	void			*context;
+	struct iscsi_login_thread_s *login_thread;
+	struct iscsi_portal_group *tpg;
+	struct iscsi_tpg_np	*tpg_np;
+	/* Pointer to parent session */
+	struct iscsi_session	*sess;
+	int			bitmap_id;
+	int			rx_thread_active;
+	struct task_struct	*rx_thread;
+	struct completion	rx_login_comp;
+	int			tx_thread_active;
+	struct task_struct	*tx_thread;
+	/* list_head for session connection list */
+	struct list_head	conn_list;
+} ____cacheline_aligned;
+
+struct iscsi_conn_recovery {
+	u16			cid;
+	u32			cmd_count;
+	u32			maxrecvdatasegmentlength;
+	u32			maxxmitdatasegmentlength;
+	int			ready_for_reallegiance;
+	struct list_head	conn_recovery_cmd_list;
+	spinlock_t		conn_recovery_cmd_lock;
+	struct timer_list	time2retain_timer;
+	struct iscsi_session	*sess;
+	struct list_head	cr_list;
+}  ____cacheline_aligned;
+
+struct iscsi_session {
+	u8			initiator_vendor;
+	u8			isid[6];
+	enum iscsi_timer_flags_table time2retain_timer_flags;
+	u8			version_active;
+	u16			cid_called;
+	u16			conn_recovery_count;
+	u16			tsih;
+	/* state session is currently in */
+	u32			session_state;
+	/* session wide counter: initiator assigned task tag */
+	itt_t			init_task_tag;
+	/* session wide counter: target assigned task tag */
+	u32			targ_xfer_tag;
+	u32			cmdsn_window;
+
+	/* protects cmdsn values */
+	struct mutex		cmdsn_mutex;
+	/* session wide counter: expected command sequence number */
+	u32			exp_cmd_sn;
+	/* session wide counter: maximum allowed command sequence number */
+	u32			max_cmd_sn;
+	struct list_head	sess_ooo_cmdsn_list;
+
+	/* LIO specific session ID */
+	u32			sid;
+	char			auth_type[8];
+	/* unique within the target */
+	int			session_index;
+	/* Used for session reference counting */
+	int			session_usage_count;
+	int			session_waiting_on_uc;
+	atomic_long_t		cmd_pdus;
+	atomic_long_t		rsp_pdus;
+	atomic_long_t		tx_data_octets;
+	atomic_long_t		rx_data_octets;
+	atomic_long_t		conn_digest_errors;
+	atomic_long_t		conn_timeout_errors;
+	u64			creation_time;
+	/* Number of active connections */
+	atomic_t		nconn;
+	atomic_t		session_continuation;
+	atomic_t		session_fall_back_to_erl0;
+	atomic_t		session_logout;
+	atomic_t		session_reinstatement;
+	atomic_t		session_stop_active;
+	atomic_t		sleep_on_sess_wait_comp;
+	/* connection list */
+	struct list_head	sess_conn_list;
+	struct list_head	cr_active_list;
+	struct list_head	cr_inactive_list;
+	spinlock_t		conn_lock;
+	spinlock_t		cr_a_lock;
+	spinlock_t		cr_i_lock;
+	spinlock_t		session_usage_lock;
+	spinlock_t		ttt_lock;
+	struct completion	async_msg_comp;
+	struct completion	reinstatement_comp;
+	struct completion	session_wait_comp;
+	struct completion	session_waiting_on_uc_comp;
+	struct timer_list	time2retain_timer;
+	struct iscsi_sess_ops	*sess_ops;
+	struct se_session	*se_sess;
+	struct iscsi_portal_group *tpg;
+} ____cacheline_aligned;
+
+struct iscsi_login {
+	u8 auth_complete;
+	u8 checked_for_existing;
+	u8 current_stage;
+	u8 leading_connection;
+	u8 first_request;
+	u8 version_min;
+	u8 version_max;
+	u8 login_complete;
+	u8 login_failed;
+	bool zero_tsih;
+	char isid[6];
+	u32 cmd_sn;
+	itt_t init_task_tag;
+	u32 initial_exp_statsn;
+	u32 rsp_length;
+	u16 cid;
+	u16 tsih;
+	char req[ISCSI_HDR_LEN];
+	char rsp[ISCSI_HDR_LEN];
+	char *req_buf;
+	char *rsp_buf;
+	struct iscsi_conn *conn;
+	struct iscsi_np *np;
+} ____cacheline_aligned;
+
+struct iscsi_node_attrib {
+	u32			dataout_timeout;
+	u32			dataout_timeout_retries;
+	u32			default_erl;
+	u32			nopin_timeout;
+	u32			nopin_response_timeout;
+	u32			random_datain_pdu_offsets;
+	u32			random_datain_seq_offsets;
+	u32			random_r2t_offsets;
+	u32			tmr_cold_reset;
+	u32			tmr_warm_reset;
+	struct iscsi_node_acl *nacl;
+};
+
+struct se_dev_entry_s;
+
+struct iscsi_node_auth {
+	enum naf_flags_table	naf_flags;
+	int			authenticate_target;
+	/* Used for iscsit_global->discovery_auth,
+	 * set to zero (auth disabled) by default */
+	int			enforce_discovery_auth;
+#define MAX_USER_LEN				256
+#define MAX_PASS_LEN				256
+	char			userid[MAX_USER_LEN];
+	char			password[MAX_PASS_LEN];
+	char			userid_mutual[MAX_USER_LEN];
+	char			password_mutual[MAX_PASS_LEN];
+};
+
+#include "iscsi_target_stat.h"
+
+struct iscsi_node_stat_grps {
+	struct config_group	iscsi_sess_stats_group;
+	struct config_group	iscsi_conn_stats_group;
+};
+
+struct iscsi_node_acl {
+	struct iscsi_node_attrib node_attrib;
+	struct iscsi_node_auth	node_auth;
+	struct iscsi_node_stat_grps node_stat_grps;
+	struct se_node_acl	se_node_acl;
+};
+
+struct iscsi_tpg_attrib {
+	u32			authentication;
+	u32			login_timeout;
+	u32			netif_timeout;
+	u32			generate_node_acls;
+	u32			cache_dynamic_acls;
+	u32			default_cmdsn_depth;
+	u32			demo_mode_write_protect;
+	u32			prod_mode_write_protect;
+	u32			demo_mode_discovery;
+	u32			default_erl;
+	u8			t10_pi;
+	u32			fabric_prot_type;
+	struct iscsi_portal_group *tpg;
+};
+
+struct iscsi_np {
+	int			np_network_transport;
+	int			np_ip_proto;
+	int			np_sock_type;
+	enum np_thread_state_table np_thread_state;
+	bool                    enabled;
+	enum iscsi_timer_flags_table np_login_timer_flags;
+	u32			np_exports;
+	enum np_flags_table	np_flags;
+	u16			np_port;
+	spinlock_t		np_thread_lock;
+	struct completion	np_restart_comp;
+	struct socket		*np_socket;
+	struct __kernel_sockaddr_storage np_sockaddr;
+	struct task_struct	*np_thread;
+	struct timer_list	np_login_timer;
+	void			*np_context;
+	struct iscsit_transport *np_transport;
+	struct list_head	np_list;
+} ____cacheline_aligned;
+
+struct iscsi_tpg_np {
+	struct iscsi_np		*tpg_np;
+	struct iscsi_portal_group *tpg;
+	struct iscsi_tpg_np	*tpg_np_parent;
+	struct list_head	tpg_np_list;
+	struct list_head	tpg_np_child_list;
+	struct list_head	tpg_np_parent_list;
+	struct se_tpg_np	se_tpg_np;
+	spinlock_t		tpg_np_parent_lock;
+	struct completion	tpg_np_comp;
+	struct kref		tpg_np_kref;
+};
+
+struct iscsi_portal_group {
+	unsigned char		tpg_chap_id;
+	/* TPG State */
+	enum tpg_state_table	tpg_state;
+	/* Target Portal Group Tag */
+	u16			tpgt;
+	/* Id assigned to target sessions */
+	u16			ntsih;
+	/* Number of active sessions */
+	u32			nsessions;
+	/* Number of Network Portals available for this TPG */
+	u32			num_tpg_nps;
+	/* Per TPG LIO specific session ID. */
+	u32			sid;
+	/* Spinlock for adding/removing Network Portals */
+	spinlock_t		tpg_np_lock;
+	spinlock_t		tpg_state_lock;
+	struct se_portal_group tpg_se_tpg;
+	struct mutex		tpg_access_lock;
+	struct semaphore	np_login_sem;
+	struct iscsi_tpg_attrib	tpg_attrib;
+	struct iscsi_node_auth	tpg_demo_auth;
+	/* Pointer to default list of iSCSI parameters for TPG */
+	struct iscsi_param_list	*param_list;
+	struct iscsi_tiqn	*tpg_tiqn;
+	struct list_head	tpg_gnp_list;
+	struct list_head	tpg_list;
+} ____cacheline_aligned;
+
+struct iscsi_wwn_stat_grps {
+	struct config_group	iscsi_stat_group;
+	struct config_group	iscsi_instance_group;
+	struct config_group	iscsi_sess_err_group;
+	struct config_group	iscsi_tgt_attr_group;
+	struct config_group	iscsi_login_stats_group;
+	struct config_group	iscsi_logout_stats_group;
+};
+
+struct iscsi_tiqn {
+#define ISCSI_IQN_LEN				224
+	unsigned char		tiqn[ISCSI_IQN_LEN];
+	enum tiqn_state_table	tiqn_state;
+	int			tiqn_access_count;
+	u32			tiqn_active_tpgs;
+	u32			tiqn_ntpgs;
+	u32			tiqn_num_tpg_nps;
+	u32			tiqn_nsessions;
+	struct list_head	tiqn_list;
+	struct list_head	tiqn_tpg_list;
+	spinlock_t		tiqn_state_lock;
+	spinlock_t		tiqn_tpg_lock;
+	struct se_wwn		tiqn_wwn;
+	struct iscsi_wwn_stat_grps tiqn_stat_grps;
+	int			tiqn_index;
+	struct iscsi_sess_err_stats  sess_err_stats;
+	struct iscsi_login_stats     login_stats;
+	struct iscsi_logout_stats    logout_stats;
+} ____cacheline_aligned;
+
+struct iscsit_global {
+	/* In core shutdown */
+	u32			in_shutdown;
+	u32			active_ts;
+	/* Unique identifier used for the authentication daemon */
+	u32			auth_id;
+	u32			inactive_ts;
+#define ISCSIT_BITMAP_BITS	262144
+	/* Thread Set bitmap pointer */
+	unsigned long		*ts_bitmap;
+	spinlock_t		ts_bitmap_lock;
+	/* Used for iSCSI discovery session authentication */
+	struct iscsi_node_acl	discovery_acl;
+	struct iscsi_portal_group	*discovery_tpg;
+	
+	struct list_head        *tiqn_list;
+	struct list_head        *np_list;
+	spinlock_t              *tiqn_lock;
+	spinlock_t              *np_lock;
+
+};
+
+static inline u32 session_get_next_ttt(struct iscsi_session *session)
+{
+	u32 ttt;
+
+	spin_lock_bh(&session->ttt_lock);
+	ttt = session->targ_xfer_tag++;
+	if (ttt == 0xFFFFFFFF)
+		ttt = session->targ_xfer_tag++;
+	spin_unlock_bh(&session->ttt_lock);
+
+	return ttt;
+}
+
+extern struct iscsi_cmd *iscsit_find_cmd_from_itt(struct iscsi_conn *, itt_t);
+#endif /* ISCSI_TARGET_CORE_H */
diff -rubB --new-file linux-3.10.69/include/target/iscsi/iscsi_target_stat.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/iscsi/iscsi_target_stat.h
--- linux-3.10.69/include/target/iscsi/iscsi_target_stat.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/iscsi/iscsi_target_stat.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,64 @@
+#ifndef ISCSI_TARGET_STAT_H
+#define ISCSI_TARGET_STAT_H
+
+/*
+ * For struct iscsi_tiqn->tiqn_wwn default groups
+ */
+extern struct config_item_type iscsi_stat_instance_cit;
+extern struct config_item_type iscsi_stat_sess_err_cit;
+extern struct config_item_type iscsi_stat_tgt_attr_cit;
+extern struct config_item_type iscsi_stat_login_cit;
+extern struct config_item_type iscsi_stat_logout_cit;
+
+/*
+ * For struct iscsi_session->se_sess default groups
+ */
+extern struct config_item_type iscsi_stat_sess_cit;
+
+/* iSCSI session error types */
+#define ISCSI_SESS_ERR_UNKNOWN		0
+#define ISCSI_SESS_ERR_DIGEST		1
+#define ISCSI_SESS_ERR_CXN_TIMEOUT	2
+#define ISCSI_SESS_ERR_PDU_FORMAT	3
+
+/* iSCSI session error stats */
+struct iscsi_sess_err_stats {
+	spinlock_t	lock;
+	u32		digest_errors;
+	u32		cxn_timeout_errors;
+	u32		pdu_format_errors;
+	u32		last_sess_failure_type;
+	char		last_sess_fail_rem_name[224];
+} ____cacheline_aligned;
+
+/* iSCSI login failure types (sub oids) */
+#define ISCSI_LOGIN_FAIL_OTHER		2
+#define ISCSI_LOGIN_FAIL_REDIRECT	3
+#define ISCSI_LOGIN_FAIL_AUTHORIZE	4
+#define ISCSI_LOGIN_FAIL_AUTHENTICATE	5
+#define ISCSI_LOGIN_FAIL_NEGOTIATE	6
+
+/* iSCSI login stats */
+struct iscsi_login_stats {
+	spinlock_t	lock;
+	u32		accepts;
+	u32		other_fails;
+	u32		redirects;
+	u32		authorize_fails;
+	u32		authenticate_fails;
+	u32		negotiate_fails;	/* used for notifications */
+	u64		last_fail_time;		/* time stamp (jiffies) */
+	u32		last_fail_type;
+	int		last_intr_fail_ip_family;
+	unsigned char	last_intr_fail_ip_addr[IPV6_ADDRESS_SPACE];
+	char		last_intr_fail_name[224];
+} ____cacheline_aligned;
+
+/* iSCSI logout stats */
+struct iscsi_logout_stats {
+	spinlock_t	lock;
+	u32		normal_logouts;
+	u32		abnormal_logouts;
+} ____cacheline_aligned;
+
+#endif   /*** ISCSI_TARGET_STAT_H ***/
diff -rubB --new-file linux-3.10.69/include/target/iscsi/iscsi_transport.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/iscsi/iscsi_transport.h
--- linux-3.10.69/include/target/iscsi/iscsi_transport.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/iscsi/iscsi_transport.h	2017-05-02 03:31:56.000000000 +0200
@@ -6,6 +6,7 @@
 #define ISCSIT_TRANSPORT_NAME	16
 	char name[ISCSIT_TRANSPORT_NAME];
 	int transport_type;
+	int priv_size;
 	struct module *owner;
 	struct list_head t_node;
 	int (*iscsit_setup_np)(struct iscsi_np *, struct __kernel_sockaddr_storage *);
@@ -13,7 +14,6 @@
 	void (*iscsit_free_np)(struct iscsi_np *);
 	void (*iscsit_wait_conn)(struct iscsi_conn *);
 	void (*iscsit_free_conn)(struct iscsi_conn *);
-	struct iscsi_cmd *(*iscsit_alloc_cmd)(struct iscsi_conn *, gfp_t);
 	int (*iscsit_get_login_rx)(struct iscsi_conn *, struct iscsi_login *);
 	int (*iscsit_put_login_tx)(struct iscsi_conn *, struct iscsi_login *, u32);
 	int (*iscsit_immediate_queue)(struct iscsi_conn *, struct iscsi_cmd *, int);
@@ -23,6 +23,11 @@
 	int (*iscsit_queue_status)(struct iscsi_conn *, struct iscsi_cmd *);
 };
 
+static inline void *iscsit_priv_cmd(struct iscsi_cmd *cmd)
+{
+	return (void *)(cmd + 1);
+}
+
 /*
  * From iscsi_target_transport.c
  */
@@ -44,18 +49,27 @@
 				struct iscsi_cmd **);
 extern int iscsit_check_dataout_payload(struct iscsi_cmd *, struct iscsi_data *,
 				bool);
-extern int iscsit_handle_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
-				unsigned char *);
+extern int iscsit_setup_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
+				struct iscsi_nopout *);
+extern int iscsit_process_nop_out(struct iscsi_conn *, struct iscsi_cmd *,
+				struct iscsi_nopout *);
 extern int iscsit_handle_logout_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				unsigned char *);
 extern int iscsit_handle_task_mgt_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 				unsigned char *);
+extern int iscsit_setup_text_cmd(struct iscsi_conn *, struct iscsi_cmd *,
+				 struct iscsi_text *);
+extern int iscsit_process_text_cmd(struct iscsi_conn *, struct iscsi_cmd *,
+				   struct iscsi_text *);
 extern void iscsit_build_rsp_pdu(struct iscsi_cmd *, struct iscsi_conn *,
 				bool, struct iscsi_scsi_rsp *);
 extern void iscsit_build_nopin_rsp(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_nopin *, bool);
 extern void iscsit_build_task_mgt_rsp(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_tm_rsp *);
+extern int iscsit_build_text_rsp(struct iscsi_cmd *, struct iscsi_conn *,
+				struct iscsi_text_rsp *,
+				enum iscsit_transport_type);
 extern void iscsit_build_reject(struct iscsi_cmd *, struct iscsi_conn *,
 				struct iscsi_reject *);
 extern int iscsit_build_logout_rsp(struct iscsi_cmd *, struct iscsi_conn *,
@@ -82,6 +96,7 @@
 /*
  * From iscsi_target_util.c
  */
-extern struct iscsi_cmd *iscsit_allocate_cmd(struct iscsi_conn *, gfp_t);
+extern struct iscsi_cmd *iscsit_allocate_cmd(struct iscsi_conn *, int);
 extern int iscsit_sequence_cmd(struct iscsi_conn *, struct iscsi_cmd *,
 			       unsigned char *, __be32);
+extern void iscsit_release_cmd(struct iscsi_cmd *);
diff -rubB --new-file linux-3.10.69/include/target/target_core_backend_configfs.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_backend_configfs.h
--- linux-3.10.69/include/target/target_core_backend_configfs.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_backend_configfs.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,118 @@
+#ifndef TARGET_CORE_BACKEND_CONFIGFS_H
+#define TARGET_CORE_BACKEND_CONFIGFS_H
+
+#include <target/configfs_macros.h>
+
+#define DEF_TB_DEV_ATTRIB_SHOW(_backend, _name)				\
+static ssize_t _backend##_dev_show_attr_##_name(			\
+	struct se_dev_attrib *da,					\
+	char *page)							\
+{									\
+	return snprintf(page, PAGE_SIZE, "%u\n",			\
+			(u32)da->da_dev->dev_attrib._name);		\
+}
+
+#define DEF_TB_DEV_ATTRIB_STORE(_backend, _name)			\
+static ssize_t _backend##_dev_store_attr_##_name(			\
+	struct se_dev_attrib *da,					\
+	const char *page,						\
+	size_t count)							\
+{									\
+	unsigned long val;						\
+	int ret;							\
+									\
+	ret = kstrtoul(page, 0, &val);					\
+	if (ret < 0) {							\
+		pr_err("kstrtoul() failed with ret: %d\n", ret);	\
+		return -EINVAL;						\
+	}								\
+	ret = se_dev_set_##_name(da->da_dev, (u32)val);			\
+									\
+	return (!ret) ? count : -EINVAL;				\
+}
+
+#define DEF_TB_DEV_ATTRIB(_backend, _name)				\
+DEF_TB_DEV_ATTRIB_SHOW(_backend, _name);				\
+DEF_TB_DEV_ATTRIB_STORE(_backend, _name);
+
+#define DEF_TB_DEV_ATTRIB_RO(_backend, name)				\
+DEF_TB_DEV_ATTRIB_SHOW(_backend, name);
+
+CONFIGFS_EATTR_STRUCT(target_backend_dev_attrib, se_dev_attrib);
+#define TB_DEV_ATTR(_backend, _name, _mode)				\
+static struct target_backend_dev_attrib_attribute _backend##_dev_attrib_##_name = \
+		__CONFIGFS_EATTR(_name, _mode,				\
+		_backend##_dev_show_attr_##_name,			\
+		_backend##_dev_store_attr_##_name);
+
+#define TB_DEV_ATTR_RO(_backend, _name)						\
+static struct target_backend_dev_attrib_attribute _backend##_dev_attrib_##_name = \
+	__CONFIGFS_EATTR_RO(_name,					\
+	_backend##_dev_show_attr_##_name);
+
+/*
+ * Default list of target backend device attributes as defined by
+ * struct se_dev_attrib
+ */
+
+#define DEF_TB_DEFAULT_ATTRIBS(_backend)				\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_model_alias);		\
+	TB_DEV_ATTR(_backend, emulate_model_alias, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_dpo);			\
+	TB_DEV_ATTR(_backend, emulate_dpo, S_IRUGO | S_IWUSR);		\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_fua_write);			\
+	TB_DEV_ATTR(_backend, emulate_fua_write, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_fua_read);			\
+	TB_DEV_ATTR(_backend, emulate_fua_read, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_write_cache);		\
+	TB_DEV_ATTR(_backend, emulate_write_cache, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_ua_intlck_ctrl);		\
+	TB_DEV_ATTR(_backend, emulate_ua_intlck_ctrl, S_IRUGO | S_IWUSR); \
+	DEF_TB_DEV_ATTRIB(_backend, emulate_tas);			\
+	TB_DEV_ATTR(_backend, emulate_tas, S_IRUGO | S_IWUSR);		\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_tpu);			\
+	TB_DEV_ATTR(_backend, emulate_tpu, S_IRUGO | S_IWUSR);		\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_tpws);			\
+	TB_DEV_ATTR(_backend, emulate_tpws, S_IRUGO | S_IWUSR);		\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_caw);			\
+	TB_DEV_ATTR(_backend, emulate_caw, S_IRUGO | S_IWUSR);		\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_3pc);			\
+	TB_DEV_ATTR(_backend, emulate_3pc, S_IRUGO | S_IWUSR);		\
+	DEF_TB_DEV_ATTRIB(_backend, pi_prot_type);			\
+	TB_DEV_ATTR(_backend, pi_prot_type, S_IRUGO | S_IWUSR);		\
+	DEF_TB_DEV_ATTRIB_RO(_backend, hw_pi_prot_type);		\
+	TB_DEV_ATTR_RO(_backend, hw_pi_prot_type);			\
+	DEF_TB_DEV_ATTRIB(_backend, pi_prot_format);			\
+	TB_DEV_ATTR(_backend, pi_prot_format, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB(_backend, enforce_pr_isids);			\
+	TB_DEV_ATTR(_backend, enforce_pr_isids, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB(_backend, is_nonrot);				\
+	TB_DEV_ATTR(_backend, is_nonrot, S_IRUGO | S_IWUSR);		\
+	DEF_TB_DEV_ATTRIB(_backend, emulate_rest_reord);		\
+	TB_DEV_ATTR(_backend, emulate_rest_reord, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB(_backend, force_pr_aptpl);			\
+	TB_DEV_ATTR(_backend, force_pr_aptpl, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB_RO(_backend, hw_block_size);			\
+	TB_DEV_ATTR_RO(_backend, hw_block_size);			\
+	DEF_TB_DEV_ATTRIB(_backend, block_size);			\
+	TB_DEV_ATTR(_backend, block_size, S_IRUGO | S_IWUSR);		\
+	DEF_TB_DEV_ATTRIB_RO(_backend, hw_max_sectors);			\
+	TB_DEV_ATTR_RO(_backend, hw_max_sectors);			\
+	DEF_TB_DEV_ATTRIB(_backend, optimal_sectors);			\
+	TB_DEV_ATTR(_backend, optimal_sectors, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB_RO(_backend, hw_queue_depth);			\
+	TB_DEV_ATTR_RO(_backend, hw_queue_depth);			\
+	DEF_TB_DEV_ATTRIB(_backend, queue_depth);			\
+	TB_DEV_ATTR(_backend, queue_depth, S_IRUGO | S_IWUSR);		\
+	DEF_TB_DEV_ATTRIB(_backend, max_unmap_lba_count);		\
+	TB_DEV_ATTR(_backend, max_unmap_lba_count, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB(_backend, max_unmap_block_desc_count);	\
+	TB_DEV_ATTR(_backend, max_unmap_block_desc_count, S_IRUGO | S_IWUSR); \
+	DEF_TB_DEV_ATTRIB(_backend, unmap_granularity);			\
+	TB_DEV_ATTR(_backend, unmap_granularity, S_IRUGO | S_IWUSR);	\
+	DEF_TB_DEV_ATTRIB(_backend, unmap_granularity_alignment);	\
+	TB_DEV_ATTR(_backend, unmap_granularity_alignment, S_IRUGO | S_IWUSR); \
+	DEF_TB_DEV_ATTRIB(_backend, max_write_same_len);		\
+	TB_DEV_ATTR(_backend, max_write_same_len, S_IRUGO | S_IWUSR);
+
+#endif /* TARGET_CORE_BACKEND_CONFIGFS_H */
diff -rubB --new-file linux-3.10.69/include/target/target_core_backend.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_backend.h
--- linux-3.10.69/include/target/target_core_backend.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_backend.h	2017-05-02 03:31:56.000000000 +0200
@@ -34,12 +34,21 @@
 	sense_reason_t (*parse_cdb)(struct se_cmd *cmd);
 	u32 (*get_device_type)(struct se_device *);
 	sector_t (*get_blocks)(struct se_device *);
+	sector_t (*get_alignment_offset_lbas)(struct se_device *);
+	/* lbppbe = logical blocks per physical block exponent. see SBC-3 */
+	unsigned int (*get_lbppbe)(struct se_device *);
+	unsigned int (*get_io_min)(struct se_device *);
+	unsigned int (*get_io_opt)(struct se_device *);
 	unsigned char *(*get_sense_buffer)(struct se_cmd *);
 	bool (*get_write_cache)(struct se_device *);
+	int (*init_prot)(struct se_device *);
+	int (*format_prot)(struct se_device *);
+	void (*free_prot)(struct se_device *);
 };
 
 struct sbc_ops {
-	sense_reason_t (*execute_rw)(struct se_cmd *cmd);
+	sense_reason_t (*execute_rw)(struct se_cmd *cmd, struct scatterlist *,
+				     u32, enum dma_data_direction);
 	sense_reason_t (*execute_sync_cache)(struct se_cmd *cmd);
 	sense_reason_t (*execute_write_same)(struct se_cmd *cmd);
 	sense_reason_t (*execute_write_same_unmap)(struct se_cmd *cmd);
@@ -65,6 +74,10 @@
 	sense_reason_t (*do_unmap_fn)(struct se_cmd *cmd, void *priv,
 				      sector_t lba, sector_t nolb),
 	void *priv);
+sense_reason_t	sbc_dif_verify_write(struct se_cmd *, sector_t, unsigned int,
+				     unsigned int, struct scatterlist *, int);
+sense_reason_t	sbc_dif_verify_read(struct se_cmd *, sector_t, unsigned int,
+				    unsigned int, struct scatterlist *, int);
 
 void	transport_set_vpd_proto_id(struct t10_vpd *, unsigned char *);
 int	transport_set_vpd_assoc(struct t10_vpd *, unsigned char *);
@@ -74,6 +87,10 @@
 /* core helpers also used by command snooping in pscsi */
 void	*transport_kmap_data_sg(struct se_cmd *);
 void	transport_kunmap_data_sg(struct se_cmd *);
+/* core helpers also used by xcopy during internal command setup */
+int	target_alloc_sgl(struct scatterlist **, unsigned int *, u32, bool);
+sense_reason_t	transport_generic_map_mem_to_cmd(struct se_cmd *,
+		struct scatterlist *, u32, struct scatterlist *, u32);
 
 void	array_free(void *array, int n);
 
diff -rubB --new-file linux-3.10.69/include/target/target_core_base.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_base.h
--- linux-3.10.69/include/target/target_core_base.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_base.h	2017-05-02 03:31:56.000000000 +0200
@@ -5,11 +5,13 @@
 #include <linux/configfs.h>
 #include <linux/dma-mapping.h>
 #include <linux/blkdev.h>
+#include <linux/percpu_ida.h>
+#include <linux/percpu-refcount.h>
 #include <scsi/scsi_cmnd.h>
 #include <net/sock.h>
 #include <net/tcp.h>
 
-#define TARGET_CORE_MOD_VERSION		"v4.1.0-rc2-ml"
+#define TARGET_CORE_MOD_VERSION		"v4.1.0"
 #define TARGET_CORE_VERSION		TARGET_CORE_MOD_VERSION
 
 /* Maximum Number of LUNs per Target Portal Group */
@@ -36,6 +38,9 @@
 /* Used by transport_send_check_condition_and_sense() */
 #define SPC_SENSE_KEY_OFFSET			2
 #define SPC_ADD_SENSE_LEN_OFFSET		7
+#define SPC_DESC_TYPE_OFFSET			8
+#define SPC_ADDITIONAL_DESC_LEN_OFFSET		9
+#define SPC_VALIDITY_OFFSET			10
 #define SPC_ASC_KEY_OFFSET			12
 #define SPC_ASCQ_KEY_OFFSET			13
 #define TRANSPORT_IQN_LEN			224
@@ -96,6 +101,10 @@
  * block/blk-lib.c:blkdev_issue_discard()
  */
 #define DA_EMULATE_TPWS				0
+/* Emulation for CompareAndWrite (AtomicTestandSet) by default */
+#define DA_EMULATE_CAW				1
+/* Emulation for 3rd Party Copy (ExtendedCopy) by default */
+#define DA_EMULATE_3PC				1
 /* No Emulation for PSCSI by default */
 #define DA_EMULATE_ALUA				0
 /* Enforce SCSI Initiator Port TransportID with 'ISID' for PR */
@@ -107,7 +116,7 @@
 /* Queue Algorithm Modifier default for restricted reordering in control mode page */
 #define DA_EMULATE_REST_REORD			0
 
-#define SE_INQUIRY_BUF				512
+#define SE_INQUIRY_BUF				1024
 #define SE_MODE_PAGE_BUF			512
 #define SE_SENSE_BUF				96
 
@@ -158,6 +167,9 @@
 	SCF_ALUA_NON_OPTIMIZED		= 0x00008000,
 	SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC = 0x00020000,
 	SCF_ACK_KREF			= 0x00040000,
+	SCF_COMPARE_AND_WRITE		= 0x00080000,
+	SCF_COMPARE_AND_WRITE_POST	= 0x00100000,
+	SCF_CMD_XCOPY_PASSTHROUGH	= 0x00200000,
 };
 
 /* struct se_dev_entry->lun_flags and struct se_lun->lun_access */
@@ -196,6 +208,10 @@
 	TCM_ADDRESS_OUT_OF_RANGE		= R(0x11),
 	TCM_OUT_OF_RESOURCES			= R(0x12),
 	TCM_PARAMETER_LIST_LENGTH_ERROR		= R(0x13),
+	TCM_MISCOMPARE_VERIFY			= R(0x14),
+	TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED	= R(0x15),
+	TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED	= R(0x16),
+	TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED	= R(0x17),
 #undef R
 };
 
@@ -218,14 +234,12 @@
 
 /* fabric independent task management response values */
 enum tcm_tmrsp_table {
-	TMR_FUNCTION_COMPLETE		= 0,
-	TMR_TASK_DOES_NOT_EXIST		= 1,
-	TMR_LUN_DOES_NOT_EXIST		= 2,
-	TMR_TASK_STILL_ALLEGIANT	= 3,
-	TMR_TASK_FAILOVER_NOT_SUPPORTED	= 4,
-	TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED	= 5,
-	TMR_FUNCTION_AUTHORIZATION_FAILED = 6,
-	TMR_FUNCTION_REJECTED		= 255,
+	TMR_FUNCTION_FAILED		= 0,
+	TMR_FUNCTION_COMPLETE		= 1,
+	TMR_TASK_DOES_NOT_EXIST		= 2,
+	TMR_LUN_DOES_NOT_EXIST		= 3,
+	TMR_TASK_MGMT_FUNCTION_NOT_SUPPORTED	= 4,
+	TMR_FUNCTION_REJECTED		= 5,
 };
 
 /*
@@ -240,10 +254,28 @@
 
 struct se_cmd;
 
+struct t10_alua_lba_map_member {
+	struct list_head lba_map_mem_list;
+	int lba_map_mem_alua_state;
+	int lba_map_mem_alua_pg_id;
+};
+
+struct t10_alua_lba_map {
+	u64 lba_map_first_lba;
+	u64 lba_map_last_lba;
+	struct list_head lba_map_list;
+	struct list_head lba_map_mem_list;
+};
+
 struct t10_alua {
 	/* ALUA Target Port Group ID */
 	u16	alua_tg_pt_gps_counter;
 	u32	alua_tg_pt_gps_count;
+	/* Referrals support */
+	spinlock_t lba_map_lock;
+	u32     lba_map_segment_size;
+	u32     lba_map_segment_multiplier;
+	struct list_head lba_map_list;
 	spinlock_t tg_pt_gps_lock;
 	struct se_device *t10_dev;
 	/* Used for default ALUA Target Port Group */
@@ -276,16 +308,16 @@
 struct t10_alua_tg_pt_gp {
 	u16	tg_pt_gp_id;
 	int	tg_pt_gp_valid_id;
+	int	tg_pt_gp_alua_supported_states;
+	int	tg_pt_gp_alua_pending_state;
+	int	tg_pt_gp_alua_previous_state;
 	int	tg_pt_gp_alua_access_status;
 	int	tg_pt_gp_alua_access_type;
 	int	tg_pt_gp_nonop_delay_msecs;
 	int	tg_pt_gp_trans_delay_msecs;
-	int	tg_pt_gp_implict_trans_secs;
+	int	tg_pt_gp_implicit_trans_secs;
 	int	tg_pt_gp_pref;
 	int	tg_pt_gp_write_metadata;
-	/* Used by struct t10_alua_tg_pt_gp->tg_pt_gp_md_buf_len */
-#define ALUA_MD_BUF_LEN				1024
-	u32	tg_pt_gp_md_buf_len;
 	u32	tg_pt_gp_members;
 	atomic_t tg_pt_gp_alua_access_state;
 	atomic_t tg_pt_gp_ref_cnt;
@@ -295,6 +327,10 @@
 	struct config_group tg_pt_gp_group;
 	struct list_head tg_pt_gp_list;
 	struct list_head tg_pt_gp_mem_list;
+	struct se_port *tg_pt_gp_alua_port;
+	struct se_node_acl *tg_pt_gp_alua_nacl;
+	struct delayed_work tg_pt_gp_transition_work;
+	struct completion *tg_pt_gp_transition_complete;
 };
 
 struct t10_alua_tg_pt_gp_member {
@@ -339,8 +375,6 @@
 	/* Used during APTPL metadata reading */
 #define PR_APTPL_MAX_TPORT_LEN			256
 	unsigned char pr_tport[PR_APTPL_MAX_TPORT_LEN];
-	/* For writing out live meta data */
-	unsigned char *pr_aptpl_buf;
 	u16 pr_aptpl_rpti;
 	u16 pr_reg_tpgt;
 	/* Reservation effects all target ports */
@@ -374,9 +408,7 @@
 	/* Activate Persistence across Target Power Loss enabled
 	 * for SCSI device */
 	int pr_aptpl_active;
-	/* Used by struct t10_reservation->pr_aptpl_buf_len */
-#define PR_APTPL_BUF_LEN			8192
-	u32 pr_aptpl_buf_len;
+#define PR_APTPL_BUF_LEN			262144
 	u32 pr_generation;
 	spinlock_t registration_lock;
 	spinlock_t aptpl_reg_lock;
@@ -410,6 +442,34 @@
 	struct list_head	tmr_list;
 };
 
+enum target_prot_op {
+	TARGET_PROT_NORMAL = 0,
+	TARGET_PROT_DIN_INSERT,
+	TARGET_PROT_DOUT_INSERT,
+	TARGET_PROT_DIN_STRIP,
+	TARGET_PROT_DOUT_STRIP,
+	TARGET_PROT_DIN_PASS,
+	TARGET_PROT_DOUT_PASS,
+};
+
+enum target_prot_ho {
+	PROT_SEPERATED,
+	PROT_INTERLEAVED,
+};
+
+enum target_prot_type {
+	TARGET_DIF_TYPE0_PROT,
+	TARGET_DIF_TYPE1_PROT,
+	TARGET_DIF_TYPE2_PROT,
+	TARGET_DIF_TYPE3_PROT,
+};
+
+struct se_dif_v1_tuple {
+	__be16			guard_tag;
+	__be16			app_tag;
+	__be32			ref_tag;
+};
+
 struct se_cmd {
 	/* SAM response code being sent to initiator */
 	u8			scsi_status;
@@ -422,10 +482,10 @@
 	enum dma_data_direction	data_direction;
 	/* For SAM Task Attribute */
 	int			sam_task_attr;
+	/* Used for se_sess->sess_tag_pool */
+	unsigned int		map_tag;
 	/* Transport protocol dependent state, see transport_state_table */
 	enum transport_state_table t_state;
-	/* Used to signal cmd->se_tfo->check_release_cmd() usage per cmd */
-	unsigned		check_release:1;
 	unsigned		cmd_wait_set:1;
 	unsigned		unknown_data_length:1;
 	/* See se_cmd_flags_table */
@@ -440,7 +500,6 @@
 	/* Used for sense data */
 	void			*sense_buffer;
 	struct list_head	se_delayed_node;
-	struct list_head	se_lun_node;
 	struct list_head	se_qf_node;
 	struct se_device      *se_dev;
 	struct se_dev_entry   *se_deve;
@@ -453,33 +512,32 @@
 	struct kref		cmd_kref;
 	struct target_core_fabric_ops *se_tfo;
 	sense_reason_t		(*execute_cmd)(struct se_cmd *);
-	void (*transport_complete_callback)(struct se_cmd *);
+	sense_reason_t		(*execute_rw)(struct se_cmd *, struct scatterlist *,
+					      u32, enum dma_data_direction);
+	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool);
 
 	unsigned char		*t_task_cdb;
 	unsigned char		__t_task_cdb[TCM_MAX_COMMAND_SIZE];
 	unsigned long long	t_task_lba;
-	atomic_t		t_fe_count;
+	unsigned int		t_task_nolb;
 	unsigned int		transport_state;
 #define CMD_T_ABORTED		(1 << 0)
 #define CMD_T_ACTIVE		(1 << 1)
 #define CMD_T_COMPLETE		(1 << 2)
 #define CMD_T_SENT		(1 << 4)
 #define CMD_T_STOP		(1 << 5)
-#define CMD_T_FAILED		(1 << 6)
-#define CMD_T_LUN_STOP		(1 << 7)
-#define CMD_T_LUN_FE_STOP	(1 << 8)
-#define CMD_T_DEV_ACTIVE	(1 << 9)
-#define CMD_T_REQUEST_STOP	(1 << 10)
-#define CMD_T_BUSY		(1 << 11)
+#define CMD_T_DEV_ACTIVE	(1 << 7)
+#define CMD_T_REQUEST_STOP	(1 << 8)
+#define CMD_T_BUSY		(1 << 9)
 	spinlock_t		t_state_lock;
 	struct completion	t_transport_stop_comp;
-	struct completion	transport_lun_fe_stop_comp;
-	struct completion	transport_lun_stop_comp;
 
 	struct work_struct	work;
 
 	struct scatterlist	*t_data_sg;
+	struct scatterlist	*t_data_sg_orig;
 	unsigned int		t_data_nents;
+	unsigned int		t_data_nents_orig;
 	void			*t_data_vmap;
 	struct scatterlist	*t_bidi_data_sg;
 	unsigned int		t_bidi_data_nents;
@@ -492,13 +550,26 @@
 
 	/* backend private data */
 	void			*priv;
+
+	/* Used for lun->lun_ref counting */
+	int			lun_ref_active;
+
+	/* DIF related members */
+	enum target_prot_op	prot_op;
+	enum target_prot_type	prot_type;
+	u32			prot_length;
+	u32			reftag_seed;
+	struct scatterlist	*t_prot_sg;
+	unsigned int		t_prot_nents;
+	enum target_prot_ho	prot_handover;
+	sense_reason_t		pi_err;
+	sector_t		bad_sector;
 };
 
 struct se_ua {
 	u8			ua_asc;
 	u8			ua_ascq;
 	struct se_node_acl	*ua_nacl;
-	struct list_head	ua_dev_list;
 	struct list_head	ua_nacl_list;
 };
 
@@ -511,10 +582,6 @@
 	u32			acl_index;
 #define MAX_ACL_TAG_SIZE 64
 	char			acl_tag[MAX_ACL_TAG_SIZE];
-	u64			num_cmds;
-	u64			read_bytes;
-	u64			write_bytes;
-	spinlock_t		stats_lock;
 	/* Used for PR SPEC_I_PT=1 and REGISTER_AND_MOVE */
 	atomic_t		acl_pr_ref_count;
 	struct se_dev_entry	**device_list;
@@ -546,6 +613,8 @@
 	struct list_head	sess_wait_list;
 	spinlock_t		sess_cmd_lock;
 	struct kref		sess_kref;
+	void			*sess_cmd_map;
+	struct percpu_ida	sess_tag_pool;
 };
 
 struct se_device;
@@ -599,6 +668,11 @@
 	int		emulate_tas;
 	int		emulate_tpu;
 	int		emulate_tpws;
+	int		emulate_caw;
+	int		emulate_3pc;
+	int		pi_prot_format;
+	enum target_prot_type pi_prot_type;
+	enum target_prot_type hw_pi_prot_type;
 	int		enforce_pr_isids;
 	int		is_nonrot;
 	int		emulate_rest_reord;
@@ -619,6 +693,34 @@
 	struct config_group da_group;
 };
 
+struct se_port_stat_grps {
+	struct config_group stat_group;
+	struct config_group scsi_port_group;
+	struct config_group scsi_tgt_port_group;
+	struct config_group scsi_transport_group;
+};
+
+struct se_lun {
+#define SE_LUN_LINK_MAGIC			0xffff7771
+	u32			lun_link_magic;
+	/* See transport_lun_status_table */
+	enum transport_lun_status_table lun_status;
+	u32			lun_access;
+	u32			lun_flags;
+	u32			unpacked_lun;
+	atomic_t		lun_acl_count;
+	spinlock_t		lun_acl_lock;
+	spinlock_t		lun_sep_lock;
+	struct completion	lun_shutdown_comp;
+	struct list_head	lun_acl_list;
+	struct se_device	*lun_se_dev;
+	struct se_port		*lun_sep;
+	struct config_group	lun_group;
+	struct se_port_stat_grps port_stat_grps;
+	struct completion	lun_ref_comp;
+	struct percpu_ref	lun_ref;
+};
+
 struct se_dev_stat_grps {
 	struct config_group stat_group;
 	struct config_group scsi_dev_group;
@@ -647,11 +749,10 @@
 	/* Pointer to transport specific device structure */
 	u32			dev_index;
 	u64			creation_time;
-	u32			num_resets;
-	u64			num_cmds;
-	u64			read_bytes;
-	u64			write_bytes;
-	spinlock_t		stats_lock;
+	atomic_long_t		num_resets;
+	atomic_long_t		num_cmds;
+	atomic_long_t		read_bytes;
+	atomic_long_t		write_bytes;
 	/* Active commands on this virtual SE device */
 	atomic_t		simple_cmds;
 	atomic_t		dev_ordered_id;
@@ -667,6 +768,7 @@
 	spinlock_t		se_port_lock;
 	spinlock_t		se_tmr_lock;
 	spinlock_t		qf_cmd_lock;
+	struct semaphore	caw_sem;
 	/* Used for legacy SPC-2 reservationsa */
 	struct se_node_acl	*dev_reserved_node_acl;
 	/* Used for ALUA Logical Unit Group membership */
@@ -680,6 +782,7 @@
 	struct list_head	delayed_cmd_list;
 	struct list_head	state_list;
 	struct list_head	qf_cmd_list;
+	struct list_head	g_dev_node;
 	/* Pointer to associated SE HBA */
 	struct se_hba		*se_hba;
 	/* T10 Inquiry and VPD WWN Information */
@@ -700,6 +803,9 @@
 	struct se_subsystem_api *transport;
 	/* Linked list for struct se_hba struct se_device list */
 	struct list_head	dev_list;
+	struct se_lun		xcopy_lun;
+	/* Protection Information */
+	int			prot_length;
 };
 
 struct se_hba {
@@ -719,34 +825,6 @@
 	struct se_subsystem_api *transport;
 };
 
-struct se_port_stat_grps {
-	struct config_group stat_group;
-	struct config_group scsi_port_group;
-	struct config_group scsi_tgt_port_group;
-	struct config_group scsi_transport_group;
-};
-
-struct se_lun {
-#define SE_LUN_LINK_MAGIC			0xffff7771
-	u32			lun_link_magic;
-	/* See transport_lun_status_table */
-	enum transport_lun_status_table lun_status;
-	u32			lun_access;
-	u32			lun_flags;
-	u32			unpacked_lun;
-	atomic_t		lun_acl_count;
-	spinlock_t		lun_acl_lock;
-	spinlock_t		lun_cmd_lock;
-	spinlock_t		lun_sep_lock;
-	struct completion	lun_shutdown_comp;
-	struct list_head	lun_cmd_list;
-	struct list_head	lun_acl_list;
-	struct se_device	*lun_se_dev;
-	struct se_port		*lun_sep;
-	struct config_group	lun_group;
-	struct se_port_stat_grps port_stat_grps;
-};
-
 struct scsi_port_stats {
        u64     cmd_pdus;
        u64     tx_data_octets;
@@ -803,11 +881,12 @@
 	struct target_core_fabric_ops *se_tpg_tfo;
 	struct se_wwn		*se_tpg_wwn;
 	struct config_group	tpg_group;
-	struct config_group	*tpg_default_groups[6];
+	struct config_group	*tpg_default_groups[7];
 	struct config_group	tpg_lun_group;
 	struct config_group	tpg_np_group;
 	struct config_group	tpg_acl_group;
 	struct config_group	tpg_attrib_group;
+	struct config_group	tpg_auth_group;
 	struct config_group	tpg_param_group;
 };
 
diff -rubB --new-file linux-3.10.69/include/target/target_core_configfs.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_configfs.h
--- linux-3.10.69/include/target/target_core_configfs.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_configfs.h	2017-05-02 03:31:56.000000000 +0200
@@ -23,6 +23,7 @@
 	struct config_item_type tfc_tpg_np_cit;
 	struct config_item_type tfc_tpg_np_base_cit;
 	struct config_item_type tfc_tpg_attrib_cit;
+	struct config_item_type tfc_tpg_auth_cit;
 	struct config_item_type tfc_tpg_param_cit;
 	struct config_item_type tfc_tpg_nacl_cit;
 	struct config_item_type tfc_tpg_nacl_base_cit;
@@ -53,4 +54,3 @@
 	struct target_fabric_configfs_template tf_cit_tmpl;
 };
 
-#define TF_CIT_TMPL(tf) (&(tf)->tf_cit_tmpl)
diff -rubB --new-file linux-3.10.69/include/target/target_core_fabric_configfs.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_fabric_configfs.h
--- linux-3.10.69/include/target/target_core_fabric_configfs.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_fabric_configfs.h	2017-05-02 03:31:56.000000000 +0200
@@ -62,6 +62,17 @@
 	_fabric##_tpg_attrib_show_##_name,				\
 	_fabric##_tpg_attrib_store_##_name);
 
+CONFIGFS_EATTR_STRUCT(target_fabric_tpg_auth, se_portal_group);
+#define TF_TPG_AUTH_ATTR(_fabric, _name, _mode) 			\
+static struct target_fabric_tpg_auth_attribute _fabric##_tpg_auth_##_name = \
+	__CONFIGFS_EATTR(_name, _mode,					\
+	_fabric##_tpg_auth_show_##_name,				\
+	_fabric##_tpg_auth_store_##_name);
+
+#define TF_TPG_AUTH_ATTR_RO(_fabric, _name)				\
+static struct target_fabric_tpg_auth_attribute _fabric##_tpg_auth_##_name = \
+	__CONFIGFS_EATTR_RO(_name,					\
+	_fabric##_tpg_auth_show_##_name);
 
 CONFIGFS_EATTR_STRUCT(target_fabric_tpg_param, se_portal_group);
 #define TF_TPG_PARAM_ATTR(_fabric, _name, _mode)			\
diff -rubB --new-file linux-3.10.69/include/target/target_core_fabric.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_fabric.h
--- linux-3.10.69/include/target/target_core_fabric.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/target/target_core_fabric.h	2017-05-02 03:31:56.000000000 +0200
@@ -61,7 +61,7 @@
 	int (*get_cmd_state)(struct se_cmd *);
 	int (*queue_data_in)(struct se_cmd *);
 	int (*queue_status)(struct se_cmd *);
-	int (*queue_tm_rsp)(struct se_cmd *);
+	void (*queue_tm_rsp)(struct se_cmd *);
 	/*
 	 * fabric module calls for target_core_fabric_configfs.c
 	 */
@@ -84,6 +84,9 @@
 };
 
 struct se_session *transport_init_session(void);
+int transport_alloc_session_tags(struct se_session *, unsigned int,
+		unsigned int);
+struct se_session *transport_init_session_tags(unsigned int, unsigned int);
 void	__transport_register_session(struct se_portal_group *,
 		struct se_node_acl *, struct se_session *, void *);
 void	transport_register_session(struct se_portal_group *,
@@ -102,7 +105,8 @@
 sense_reason_t target_setup_cmd_from_cdb(struct se_cmd *, unsigned char *);
 int	target_submit_cmd_map_sgls(struct se_cmd *, struct se_session *,
 		unsigned char *, unsigned char *, u32, u32, int, int, int,
-		struct scatterlist *, u32, struct scatterlist *, u32);
+		struct scatterlist *, u32, struct scatterlist *, u32,
+		struct scatterlist *, u32);
 int	target_submit_cmd(struct se_cmd *, struct se_session *, unsigned char *,
 		unsigned char *, u32, u32, int, int, int);
 int	target_submit_tmr(struct se_cmd *se_cmd, struct se_session *se_sess,
@@ -131,8 +135,11 @@
 void	core_tmr_release_req(struct se_tmr_req *);
 int	transport_generic_handle_tmr(struct se_cmd *);
 void	transport_generic_request_failure(struct se_cmd *, sense_reason_t);
+void	__target_execute_cmd(struct se_cmd *);
 int	transport_lookup_tmr_lun(struct se_cmd *, u32);
 
+struct se_node_acl *core_tpg_get_initiator_node_acl(struct se_portal_group *tpg,
+		unsigned char *);
 struct se_node_acl *core_tpg_check_initiator_node_acl(struct se_portal_group *,
 		unsigned char *);
 void	core_tpg_clear_object_luns(struct se_portal_group *);
@@ -175,4 +182,30 @@
 char	*iscsi_parse_pr_out_transport_id(struct se_portal_group *, const char *,
 		u32 *, char **);
 
+/*
+ * The LIO target core uses DMA_TO_DEVICE to mean that data is going
+ * to the target (eg handling a WRITE) and DMA_FROM_DEVICE to mean
+ * that data is coming from the target (eg handling a READ).  However,
+ * this is just the opposite of what we have to tell the DMA mapping
+ * layer -- eg when handling a READ, the HBA will have to DMA the data
+ * out of memory so it can send it to the initiator, which means we
+ * need to use DMA_TO_DEVICE when we map the data.
+ */
+static inline enum dma_data_direction
+target_reverse_dma_direction(struct se_cmd *se_cmd)
+{
+	if (se_cmd->se_cmd_flags & SCF_BIDI)
+		return DMA_BIDIRECTIONAL;
+
+	switch (se_cmd->data_direction) {
+	case DMA_TO_DEVICE:
+		return DMA_FROM_DEVICE;
+	case DMA_FROM_DEVICE:
+		return DMA_TO_DEVICE;
+	case DMA_NONE:
+	default:
+		return DMA_NONE;
+	}
+}
+
 #endif /* TARGET_CORE_FABRICH */
diff -rubB --new-file linux-3.10.69/include/trace/events/target.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/trace/events/target.h
--- linux-3.10.69/include/trace/events/target.h	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/trace/events/target.h	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,214 @@
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM target
+
+#if !defined(_TRACE_TARGET_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_TARGET_H
+
+#include <linux/tracepoint.h>
+#include <linux/trace_seq.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_tcq.h>
+#include <target/target_core_base.h>
+
+/* cribbed verbatim from <trace/event/scsi.h> */
+#define scsi_opcode_name(opcode)	{ opcode, #opcode }
+#define show_opcode_name(val)					\
+	__print_symbolic(val,					\
+		scsi_opcode_name(TEST_UNIT_READY),		\
+		scsi_opcode_name(REZERO_UNIT),			\
+		scsi_opcode_name(REQUEST_SENSE),		\
+		scsi_opcode_name(FORMAT_UNIT),			\
+		scsi_opcode_name(READ_BLOCK_LIMITS),		\
+		scsi_opcode_name(REASSIGN_BLOCKS),		\
+		scsi_opcode_name(INITIALIZE_ELEMENT_STATUS),	\
+		scsi_opcode_name(READ_6),			\
+		scsi_opcode_name(WRITE_6),			\
+		scsi_opcode_name(SEEK_6),			\
+		scsi_opcode_name(READ_REVERSE),			\
+		scsi_opcode_name(WRITE_FILEMARKS),		\
+		scsi_opcode_name(SPACE),			\
+		scsi_opcode_name(INQUIRY),			\
+		scsi_opcode_name(RECOVER_BUFFERED_DATA),	\
+		scsi_opcode_name(MODE_SELECT),			\
+		scsi_opcode_name(RESERVE),			\
+		scsi_opcode_name(RELEASE),			\
+		scsi_opcode_name(COPY),				\
+		scsi_opcode_name(ERASE),			\
+		scsi_opcode_name(MODE_SENSE),			\
+		scsi_opcode_name(START_STOP),			\
+		scsi_opcode_name(RECEIVE_DIAGNOSTIC),		\
+		scsi_opcode_name(SEND_DIAGNOSTIC),		\
+		scsi_opcode_name(ALLOW_MEDIUM_REMOVAL),		\
+		scsi_opcode_name(SET_WINDOW),			\
+		scsi_opcode_name(READ_CAPACITY),		\
+		scsi_opcode_name(READ_10),			\
+		scsi_opcode_name(WRITE_10),			\
+		scsi_opcode_name(SEEK_10),			\
+		scsi_opcode_name(POSITION_TO_ELEMENT),		\
+		scsi_opcode_name(WRITE_VERIFY),			\
+		scsi_opcode_name(VERIFY),			\
+		scsi_opcode_name(SEARCH_HIGH),			\
+		scsi_opcode_name(SEARCH_EQUAL),			\
+		scsi_opcode_name(SEARCH_LOW),			\
+		scsi_opcode_name(SET_LIMITS),			\
+		scsi_opcode_name(PRE_FETCH),			\
+		scsi_opcode_name(READ_POSITION),		\
+		scsi_opcode_name(SYNCHRONIZE_CACHE),		\
+		scsi_opcode_name(LOCK_UNLOCK_CACHE),		\
+		scsi_opcode_name(READ_DEFECT_DATA),		\
+		scsi_opcode_name(MEDIUM_SCAN),			\
+		scsi_opcode_name(COMPARE),			\
+		scsi_opcode_name(COPY_VERIFY),			\
+		scsi_opcode_name(WRITE_BUFFER),			\
+		scsi_opcode_name(READ_BUFFER),			\
+		scsi_opcode_name(UPDATE_BLOCK),			\
+		scsi_opcode_name(READ_LONG),			\
+		scsi_opcode_name(WRITE_LONG),			\
+		scsi_opcode_name(CHANGE_DEFINITION),		\
+		scsi_opcode_name(WRITE_SAME),			\
+		scsi_opcode_name(UNMAP),			\
+		scsi_opcode_name(READ_TOC),			\
+		scsi_opcode_name(LOG_SELECT),			\
+		scsi_opcode_name(LOG_SENSE),			\
+		scsi_opcode_name(XDWRITEREAD_10),		\
+		scsi_opcode_name(MODE_SELECT_10),		\
+		scsi_opcode_name(RESERVE_10),			\
+		scsi_opcode_name(RELEASE_10),			\
+		scsi_opcode_name(MODE_SENSE_10),		\
+		scsi_opcode_name(PERSISTENT_RESERVE_IN),	\
+		scsi_opcode_name(PERSISTENT_RESERVE_OUT),	\
+		scsi_opcode_name(VARIABLE_LENGTH_CMD),		\
+		scsi_opcode_name(REPORT_LUNS),			\
+		scsi_opcode_name(MAINTENANCE_IN),		\
+		scsi_opcode_name(MAINTENANCE_OUT),		\
+		scsi_opcode_name(MOVE_MEDIUM),			\
+		scsi_opcode_name(EXCHANGE_MEDIUM),		\
+		scsi_opcode_name(READ_12),			\
+		scsi_opcode_name(WRITE_12),			\
+		scsi_opcode_name(WRITE_VERIFY_12),		\
+		scsi_opcode_name(SEARCH_HIGH_12),		\
+		scsi_opcode_name(SEARCH_EQUAL_12),		\
+		scsi_opcode_name(SEARCH_LOW_12),		\
+		scsi_opcode_name(READ_ELEMENT_STATUS),		\
+		scsi_opcode_name(SEND_VOLUME_TAG),		\
+		scsi_opcode_name(WRITE_LONG_2),			\
+		scsi_opcode_name(READ_16),			\
+		scsi_opcode_name(WRITE_16),			\
+		scsi_opcode_name(VERIFY_16),			\
+		scsi_opcode_name(WRITE_SAME_16),		\
+		scsi_opcode_name(SERVICE_ACTION_IN),		\
+		scsi_opcode_name(SAI_READ_CAPACITY_16),		\
+		scsi_opcode_name(SAI_GET_LBA_STATUS),		\
+		scsi_opcode_name(MI_REPORT_TARGET_PGS),		\
+		scsi_opcode_name(MO_SET_TARGET_PGS),		\
+		scsi_opcode_name(READ_32),			\
+		scsi_opcode_name(WRITE_32),			\
+		scsi_opcode_name(WRITE_SAME_32),		\
+		scsi_opcode_name(ATA_16),			\
+		scsi_opcode_name(ATA_12))
+
+#define show_task_attribute_name(val)				\
+	__print_symbolic(val,					\
+		{ MSG_SIMPLE_TAG,	"SIMPLE"	},	\
+		{ MSG_HEAD_TAG,		"HEAD"		},	\
+		{ MSG_ORDERED_TAG,	"ORDERED"	},	\
+		{ MSG_ACA_TAG,		"ACA"		} )
+
+#define show_scsi_status_name(val)				\
+	__print_symbolic(val,					\
+		{ SAM_STAT_GOOD,	"GOOD" },		\
+		{ SAM_STAT_CHECK_CONDITION, "CHECK CONDITION" }, \
+		{ SAM_STAT_CONDITION_MET, "CONDITION MET" },	\
+		{ SAM_STAT_BUSY,	"BUSY" },		\
+		{ SAM_STAT_INTERMEDIATE, "INTERMEDIATE" },	\
+		{ SAM_STAT_INTERMEDIATE_CONDITION_MET, "INTERMEDIATE CONDITION MET" }, \
+		{ SAM_STAT_RESERVATION_CONFLICT, "RESERVATION CONFLICT" }, \
+		{ SAM_STAT_COMMAND_TERMINATED, "COMMAND TERMINATED" }, \
+		{ SAM_STAT_TASK_SET_FULL, "TASK SET FULL" },	\
+		{ SAM_STAT_ACA_ACTIVE, "ACA ACTIVE" },		\
+		{ SAM_STAT_TASK_ABORTED, "TASK ABORTED" } )
+
+TRACE_EVENT(target_sequencer_start,
+
+	TP_PROTO(struct se_cmd *cmd),
+
+	TP_ARGS(cmd),
+
+	TP_STRUCT__entry(
+		__field( unsigned int,	unpacked_lun	)
+		__field( unsigned int,	opcode		)
+		__field( unsigned int,	data_length	)
+		__field( unsigned int,	task_attribute  )
+		__array( unsigned char,	cdb, TCM_MAX_COMMAND_SIZE	)
+		__string( initiator,	cmd->se_sess->se_node_acl->initiatorname	)
+	),
+
+	TP_fast_assign(
+		__entry->unpacked_lun	= cmd->orig_fe_lun;
+		__entry->opcode		= cmd->t_task_cdb[0];
+		__entry->data_length	= cmd->data_length;
+		__entry->task_attribute	= cmd->sam_task_attr;
+		memcpy(__entry->cdb, cmd->t_task_cdb, TCM_MAX_COMMAND_SIZE);
+		__assign_str(initiator, cmd->se_sess->se_node_acl->initiatorname);
+	),
+
+	TP_printk("%s -> LUN %03u %s data_length %6u  CDB %s  (TA:%s C:%02x)",
+		  __get_str(initiator), __entry->unpacked_lun,
+		  show_opcode_name(__entry->opcode),
+		  __entry->data_length, __print_hex(__entry->cdb, 16),
+		  show_task_attribute_name(__entry->task_attribute),
+		  scsi_command_size(__entry->cdb) <= 16 ?
+			__entry->cdb[scsi_command_size(__entry->cdb) - 1] :
+			__entry->cdb[1]
+	)
+);
+
+TRACE_EVENT(target_cmd_complete,
+
+	TP_PROTO(struct se_cmd *cmd),
+
+	TP_ARGS(cmd),
+
+	TP_STRUCT__entry(
+		__field( unsigned int,	unpacked_lun	)
+		__field( unsigned int,	opcode		)
+		__field( unsigned int,	data_length	)
+		__field( unsigned int,	task_attribute  )
+		__field( unsigned char,	scsi_status	)
+		__field( unsigned char,	sense_length	)
+		__array( unsigned char,	cdb, TCM_MAX_COMMAND_SIZE	)
+		__array( unsigned char,	sense_data, 18	)
+		__string(initiator,	cmd->se_sess->se_node_acl->initiatorname)
+	),
+
+	TP_fast_assign(
+		__entry->unpacked_lun	= cmd->orig_fe_lun;
+		__entry->opcode		= cmd->t_task_cdb[0];
+		__entry->data_length	= cmd->data_length;
+		__entry->task_attribute	= cmd->sam_task_attr;
+		__entry->scsi_status	= cmd->scsi_status;
+		__entry->sense_length	= cmd->scsi_status == SAM_STAT_CHECK_CONDITION ?
+			min(18, ((u8 *) cmd->sense_buffer)[SPC_ADD_SENSE_LEN_OFFSET] + 8) : 0;
+		memcpy(__entry->cdb, cmd->t_task_cdb, TCM_MAX_COMMAND_SIZE);
+		memcpy(__entry->sense_data, cmd->sense_buffer, __entry->sense_length);
+		__assign_str(initiator, cmd->se_sess->se_node_acl->initiatorname);
+	),
+
+	TP_printk("%s <- LUN %03u status %s (sense len %d%s%s)  %s data_length %6u  CDB %s  (TA:%s C:%02x)",
+		  __get_str(initiator), __entry->unpacked_lun,
+		  show_scsi_status_name(__entry->scsi_status),
+		  __entry->sense_length, __entry->sense_length ? " / " : "",
+		  __print_hex(__entry->sense_data, __entry->sense_length),
+		  show_opcode_name(__entry->opcode),
+		  __entry->data_length, __print_hex(__entry->cdb, 16),
+		  show_task_attribute_name(__entry->task_attribute),
+		  scsi_command_size(__entry->cdb) <= 16 ?
+			__entry->cdb[scsi_command_size(__entry->cdb) - 1] :
+			__entry->cdb[1]
+	)
+);
+
+#endif /*  _TRACE_TARGET_H */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
diff -rubB --new-file linux-3.10.69/include/uapi/linux/magic.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/uapi/linux/magic.h
--- linux-3.10.69/include/uapi/linux/magic.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/uapi/linux/magic.h	2017-05-02 03:31:56.000000000 +0200
@@ -20,6 +20,10 @@
 #define EFS_SUPER_MAGIC		0x414A53
 #define EXT2_SUPER_MAGIC	0xEF53
 #define EXT3_SUPER_MAGIC	0xEF53
+#ifdef CONFIG_BUFFALO_EXT23_EXTENSION
+#define MEL_EXT2_SUPER_MAGIC	0xEF54
+#define MEL_EXT3_SUPER_MAGIC	0xEF54
+#endif	/* CONFIG_BUFFALO_EXT23_EXTENSION */
 #define XENFS_SUPER_MAGIC	0xabba1974
 #define EXT4_SUPER_MAGIC	0xEF53
 #define BTRFS_SUPER_MAGIC	0x9123683E
diff -rubB --new-file linux-3.10.69/include/uapi/linux/sysctl.h F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/uapi/linux/sysctl.h
--- linux-3.10.69/include/uapi/linux/sysctl.h	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/include/uapi/linux/sysctl.h	2017-05-02 03:31:56.000000000 +0200
@@ -867,7 +867,17 @@
 /* /proc/sys/dev/raid */
 enum {
 	DEV_RAID_SPEED_LIMIT_MIN=1,
+#ifdef CONFIG_BUFFALO_PLATFORM
+	DEV_RAID_SPEED_LIMIT_MAX=2,
+#ifdef CONFIG_BUFFALO_SKIP_RESYNC
+	DEV_RAID_SKIP_RESYNC=3,
+#endif	/* CONFIG_BUFFALO_SKIP_RESYNC */
+#ifdef CONFIG_BUFFALO_USE_MD_KERNEVNT
+	DEV_RAID_USE_KERNELEVENT=4,
+#endif	/* CONFIG_BUFFALO_USE_MD_KERNEVNT */
+#else	/* CONFIG_BUFFALO_PLATFORM */
 	DEV_RAID_SPEED_LIMIT_MAX=2
+#endif	/* CONFIG_BUFFALO_PLATFORM */
 };
 
 /* /proc/sys/dev/parport/default */
diff -rubB --new-file linux-3.10.69/kernel/cgroup.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/kernel/cgroup.c
--- linux-3.10.69/kernel/cgroup.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/kernel/cgroup.c	2017-05-02 03:31:56.000000000 +0200
@@ -5078,7 +5078,8 @@
 		i = 0;
 		/* minimal command environment */
 		envp[i++] = "HOME=/";
-		envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+//		envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+		envp[i++] = "PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin";
 		envp[i] = NULL;
 
 		/* Drop the lock while we invoke the usermode helper,
diff -rubB --new-file linux-3.10.69/kernel/sys.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/kernel/sys.c
--- linux-3.10.69/kernel/sys.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/kernel/sys.c	2017-05-02 03:31:56.000000000 +0200
@@ -442,6 +442,13 @@
 	kernel_shutdown_prepare(SYSTEM_POWER_OFF);
 	if (pm_power_off_prepare)
 		pm_power_off_prepare();
+#ifdef CONFIG_BUFFALO_USE_UPS
+	{
+		extern void BuffaloUps_ShutdownUps(void);
+
+		BuffaloUps_ShutdownUps();
+	}
+#endif	/* CONFIG_BUFFALO_USE_UPS */
 	migrate_to_reboot_cpu();
 	syscore_shutdown();
 	printk(KERN_EMERG "Power down.\n");
@@ -2288,7 +2295,8 @@
 	char **argv;
 	static char *envp[] = {
 		"HOME=/",
-		"PATH=/sbin:/bin:/usr/sbin:/usr/bin",
+//		"PATH=/sbin:/bin:/usr/sbin:/usr/bin",
+		"PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin",
 		NULL
 	};
 	int ret;
diff -rubB --new-file linux-3.10.69/lib/kobject_uevent.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/lib/kobject_uevent.c
--- linux-3.10.69/lib/kobject_uevent.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/lib/kobject_uevent.c	2017-05-02 03:31:56.000000000 +0200
@@ -304,7 +304,8 @@
 		if (retval)
 			goto exit;
 		retval = add_uevent_var(env,
-					"PATH=/sbin:/bin:/usr/sbin:/usr/bin");
+//					"PATH=/sbin:/bin:/usr/sbin:/usr/bin");
+					"PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin");
 		if (retval)
 			goto exit;
 
diff -rubB --new-file linux-3.10.69/lib/Makefile F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/lib/Makefile
--- linux-3.10.69/lib/Makefile	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/lib/Makefile	2017-05-02 03:31:56.000000000 +0200
@@ -90,6 +90,8 @@
 obj-$(CONFIG_TEXTSEARCH_BM) += ts_bm.o
 obj-$(CONFIG_TEXTSEARCH_FSM) += ts_fsm.o
 obj-$(CONFIG_SMP) += percpu_counter.o
+obj-$(CONFIG_SMP) += percpu_ida.o
+obj-$(CONFIG_SMP) += percpu-refcount.o
 obj-$(CONFIG_AUDIT_GENERIC) += audit.o
 
 obj-$(CONFIG_SWIOTLB) += swiotlb.o
diff -rubB --new-file linux-3.10.69/lib/percpu_ida.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/lib/percpu_ida.c
--- linux-3.10.69/lib/percpu_ida.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/lib/percpu_ida.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,396 @@
+/*
+ * Percpu IDA library
+ *
+ * Copyright (C) 2013 Datera, Inc. Kent Overstreet
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ */
+
+#include <linux/bitmap.h>
+#include <linux/bitops.h>
+#include <linux/bug.h>
+#include <linux/err.h>
+#include <linux/export.h>
+#include <linux/hardirq.h>
+#include <linux/idr.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/percpu.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/spinlock.h>
+#include <linux/percpu_ida.h>
+
+struct percpu_ida_cpu {
+	/*
+	 * Even though this is percpu, we need a lock for tag stealing by remote
+	 * CPUs:
+	 */
+	spinlock_t			lock;
+
+	/* nr_free/freelist form a stack of free IDs */
+	unsigned			nr_free;
+	unsigned			freelist[];
+};
+
+static inline void move_tags(unsigned *dst, unsigned *dst_nr,
+			     unsigned *src, unsigned *src_nr,
+			     unsigned nr)
+{
+	*src_nr -= nr;
+	memcpy(dst + *dst_nr, src + *src_nr, sizeof(unsigned) * nr);
+	*dst_nr += nr;
+}
+
+/*
+ * Try to steal tags from a remote cpu's percpu freelist.
+ *
+ * We first check how many percpu freelists have tags - we don't steal tags
+ * unless enough percpu freelists have tags on them that it's possible more than
+ * half the total tags could be stuck on remote percpu freelists.
+ *
+ * Then we iterate through the cpus until we find some tags - we don't attempt
+ * to find the "best" cpu to steal from, to keep cacheline bouncing to a
+ * minimum.
+ */
+static inline void steal_tags(struct percpu_ida *pool,
+			      struct percpu_ida_cpu *tags)
+{
+	unsigned cpus_have_tags, cpu = pool->cpu_last_stolen;
+	struct percpu_ida_cpu *remote;
+
+	for (cpus_have_tags = cpumask_weight(&pool->cpus_have_tags);
+	     cpus_have_tags * pool->percpu_max_size > pool->nr_tags / 2;
+	     cpus_have_tags--) {
+		cpu = cpumask_next(cpu, &pool->cpus_have_tags);
+
+		if (cpu >= nr_cpu_ids) {
+			cpu = cpumask_first(&pool->cpus_have_tags);
+			if (cpu >= nr_cpu_ids)
+				BUG();
+		}
+
+		pool->cpu_last_stolen = cpu;
+		remote = per_cpu_ptr(pool->tag_cpu, cpu);
+
+		cpumask_clear_cpu(cpu, &pool->cpus_have_tags);
+
+		if (remote == tags)
+			continue;
+
+		spin_lock(&remote->lock);
+
+		if (remote->nr_free) {
+			memcpy(tags->freelist,
+			       remote->freelist,
+			       sizeof(unsigned) * remote->nr_free);
+
+			tags->nr_free = remote->nr_free;
+			remote->nr_free = 0;
+		}
+
+		spin_unlock(&remote->lock);
+
+		if (tags->nr_free)
+			break;
+	}
+}
+
+/*
+ * Pop up to IDA_PCPU_BATCH_MOVE IDs off the global freelist, and push them onto
+ * our percpu freelist:
+ */
+static inline void alloc_global_tags(struct percpu_ida *pool,
+				     struct percpu_ida_cpu *tags)
+{
+	move_tags(tags->freelist, &tags->nr_free,
+		  pool->freelist, &pool->nr_free,
+		  min(pool->nr_free, pool->percpu_batch_size));
+}
+
+static inline unsigned alloc_local_tag(struct percpu_ida_cpu *tags)
+{
+	int tag = -ENOSPC;
+
+	spin_lock(&tags->lock);
+	if (tags->nr_free)
+		tag = tags->freelist[--tags->nr_free];
+	spin_unlock(&tags->lock);
+
+	return tag;
+}
+
+/**
+ * percpu_ida_alloc - allocate a tag
+ * @pool: pool to allocate from
+ * @state: task state for prepare_to_wait
+ *
+ * Returns a tag - an integer in the range [0..nr_tags) (passed to
+ * tag_pool_init()), or otherwise -ENOSPC on allocation failure.
+ *
+ * Safe to be called from interrupt context (assuming it isn't passed
+ * TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, of course).
+ *
+ * @gfp indicates whether or not to wait until a free id is available (it's not
+ * used for internal memory allocations); thus if passed __GFP_WAIT we may sleep
+ * however long it takes until another thread frees an id (same semantics as a
+ * mempool).
+ *
+ * Will not fail if passed TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE.
+ */
+int percpu_ida_alloc(struct percpu_ida *pool, int state)
+{
+	DEFINE_WAIT(wait);
+	struct percpu_ida_cpu *tags;
+	unsigned long flags;
+	int tag;
+
+	local_irq_save(flags);
+	tags = this_cpu_ptr(pool->tag_cpu);
+
+	/* Fastpath */
+	tag = alloc_local_tag(tags);
+	if (likely(tag >= 0)) {
+		local_irq_restore(flags);
+		return tag;
+	}
+
+	while (1) {
+		spin_lock(&pool->lock);
+
+		/*
+		 * prepare_to_wait() must come before steal_tags(), in case
+		 * percpu_ida_free() on another cpu flips a bit in
+		 * cpus_have_tags
+		 *
+		 * global lock held and irqs disabled, don't need percpu lock
+		 */
+		if (state != TASK_RUNNING)
+			prepare_to_wait(&pool->wait, &wait, state);
+
+		if (!tags->nr_free)
+			alloc_global_tags(pool, tags);
+		if (!tags->nr_free)
+			steal_tags(pool, tags);
+
+		if (tags->nr_free) {
+			tag = tags->freelist[--tags->nr_free];
+			if (tags->nr_free)
+				cpumask_set_cpu(smp_processor_id(),
+						&pool->cpus_have_tags);
+		}
+
+		spin_unlock(&pool->lock);
+		local_irq_restore(flags);
+
+		if (tag >= 0 || state == TASK_RUNNING)
+			break;
+
+		if (signal_pending_state(state, current)) {
+			tag = -ERESTARTSYS;
+			break;
+		}
+
+		schedule();
+
+		local_irq_save(flags);
+		tags = this_cpu_ptr(pool->tag_cpu);
+	}
+	if (state != TASK_RUNNING)
+		finish_wait(&pool->wait, &wait);
+
+	return tag;
+}
+EXPORT_SYMBOL_GPL(percpu_ida_alloc);
+
+/**
+ * percpu_ida_free - free a tag
+ * @pool: pool @tag was allocated from
+ * @tag: a tag previously allocated with percpu_ida_alloc()
+ *
+ * Safe to be called from interrupt context.
+ */
+void percpu_ida_free(struct percpu_ida *pool, unsigned tag)
+{
+	struct percpu_ida_cpu *tags;
+	unsigned long flags;
+	unsigned nr_free;
+
+	BUG_ON(tag >= pool->nr_tags);
+
+	local_irq_save(flags);
+	tags = this_cpu_ptr(pool->tag_cpu);
+
+	spin_lock(&tags->lock);
+	tags->freelist[tags->nr_free++] = tag;
+
+	nr_free = tags->nr_free;
+	spin_unlock(&tags->lock);
+
+	if (nr_free == 1) {
+		cpumask_set_cpu(smp_processor_id(),
+				&pool->cpus_have_tags);
+		wake_up(&pool->wait);
+	}
+
+	if (nr_free == pool->percpu_max_size) {
+		spin_lock(&pool->lock);
+
+		/*
+		 * Global lock held and irqs disabled, don't need percpu
+		 * lock
+		 */
+		if (tags->nr_free == pool->percpu_max_size) {
+			move_tags(pool->freelist, &pool->nr_free,
+				  tags->freelist, &tags->nr_free,
+				  pool->percpu_batch_size);
+
+			wake_up(&pool->wait);
+		}
+		spin_unlock(&pool->lock);
+	}
+
+	local_irq_restore(flags);
+}
+EXPORT_SYMBOL_GPL(percpu_ida_free);
+
+/**
+ * percpu_ida_destroy - release a tag pool's resources
+ * @pool: pool to free
+ *
+ * Frees the resources allocated by percpu_ida_init().
+ */
+void percpu_ida_destroy(struct percpu_ida *pool)
+{
+	free_percpu(pool->tag_cpu);
+	free_pages((unsigned long) pool->freelist,
+		   get_order(pool->nr_tags * sizeof(unsigned)));
+}
+EXPORT_SYMBOL_GPL(percpu_ida_destroy);
+
+/**
+ * percpu_ida_init - initialize a percpu tag pool
+ * @pool: pool to initialize
+ * @nr_tags: number of tags that will be available for allocation
+ *
+ * Initializes @pool so that it can be used to allocate tags - integers in the
+ * range [0, nr_tags). Typically, they'll be used by driver code to refer to a
+ * preallocated array of tag structures.
+ *
+ * Allocation is percpu, but sharding is limited by nr_tags - for best
+ * performance, the workload should not span more cpus than nr_tags / 128.
+ */
+int __percpu_ida_init(struct percpu_ida *pool, unsigned long nr_tags,
+	unsigned long max_size, unsigned long batch_size)
+{
+	unsigned i, cpu, order;
+
+	memset(pool, 0, sizeof(*pool));
+
+	init_waitqueue_head(&pool->wait);
+	spin_lock_init(&pool->lock);
+	pool->nr_tags = nr_tags;
+	pool->percpu_max_size = max_size;
+	pool->percpu_batch_size = batch_size;
+
+	/* Guard against overflow */
+	if (nr_tags > (unsigned) INT_MAX + 1) {
+		pr_err("percpu_ida_init(): nr_tags too large\n");
+		return -EINVAL;
+	}
+
+	order = get_order(nr_tags * sizeof(unsigned));
+	pool->freelist = (void *) __get_free_pages(GFP_KERNEL, order);
+	if (!pool->freelist)
+		return -ENOMEM;
+
+	for (i = 0; i < nr_tags; i++)
+		pool->freelist[i] = i;
+
+	pool->nr_free = nr_tags;
+
+	pool->tag_cpu = __alloc_percpu(sizeof(struct percpu_ida_cpu) +
+				       pool->percpu_max_size * sizeof(unsigned),
+				       sizeof(unsigned));
+	if (!pool->tag_cpu)
+		goto err;
+
+	for_each_possible_cpu(cpu)
+		spin_lock_init(&per_cpu_ptr(pool->tag_cpu, cpu)->lock);
+
+	return 0;
+err:
+	percpu_ida_destroy(pool);
+	return -ENOMEM;
+}
+EXPORT_SYMBOL_GPL(__percpu_ida_init);
+
+/**
+ * percpu_ida_for_each_free - iterate free ids of a pool
+ * @pool: pool to iterate
+ * @fn: interate callback function
+ * @data: parameter for @fn
+ *
+ * Note, this doesn't guarantee to iterate all free ids restrictly. Some free
+ * ids might be missed, some might be iterated duplicated, and some might
+ * be iterated and not free soon.
+ */
+int percpu_ida_for_each_free(struct percpu_ida *pool, percpu_ida_cb fn,
+	void *data)
+{
+	unsigned long flags;
+	struct percpu_ida_cpu *remote;
+	unsigned cpu, i, err = 0;
+
+	local_irq_save(flags);
+	for_each_possible_cpu(cpu) {
+		remote = per_cpu_ptr(pool->tag_cpu, cpu);
+		spin_lock(&remote->lock);
+		for (i = 0; i < remote->nr_free; i++) {
+			err = fn(remote->freelist[i], data);
+			if (err)
+				break;
+		}
+		spin_unlock(&remote->lock);
+		if (err)
+			goto out;
+	}
+
+	spin_lock(&pool->lock);
+	for (i = 0; i < pool->nr_free; i++) {
+		err = fn(pool->freelist[i], data);
+		if (err)
+			break;
+	}
+	spin_unlock(&pool->lock);
+out:
+	local_irq_restore(flags);
+	return err;
+}
+EXPORT_SYMBOL_GPL(percpu_ida_for_each_free);
+
+/**
+ * percpu_ida_free_tags - return free tags number of a specific cpu or global pool
+ * @pool: pool related
+ * @cpu: specific cpu or global pool if @cpu == nr_cpu_ids
+ *
+ * Note: this just returns a snapshot of free tags number.
+ */
+unsigned percpu_ida_free_tags(struct percpu_ida *pool, int cpu)
+{
+	struct percpu_ida_cpu *remote;
+	if (cpu == nr_cpu_ids)
+		return pool->nr_free;
+	remote = per_cpu_ptr(pool->tag_cpu, cpu);
+	return remote->nr_free;
+}
+EXPORT_SYMBOL_GPL(percpu_ida_free_tags);
diff -rubB --new-file linux-3.10.69/lib/percpu-refcount.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/lib/percpu-refcount.c
--- linux-3.10.69/lib/percpu-refcount.c	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/lib/percpu-refcount.c	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,161 @@
+#define pr_fmt(fmt) "%s: " fmt "\n", __func__
+
+#include <linux/kernel.h>
+#include <linux/percpu-refcount.h>
+
+/*
+ * Initially, a percpu refcount is just a set of percpu counters. Initially, we
+ * don't try to detect the ref hitting 0 - which means that get/put can just
+ * increment or decrement the local counter. Note that the counter on a
+ * particular cpu can (and will) wrap - this is fine, when we go to shutdown the
+ * percpu counters will all sum to the correct value
+ *
+ * (More precisely: because moduler arithmatic is commutative the sum of all the
+ * pcpu_count vars will be equal to what it would have been if all the gets and
+ * puts were done to a single integer, even if some of the percpu integers
+ * overflow or underflow).
+ *
+ * The real trick to implementing percpu refcounts is shutdown. We can't detect
+ * the ref hitting 0 on every put - this would require global synchronization
+ * and defeat the whole purpose of using percpu refs.
+ *
+ * What we do is require the user to keep track of the initial refcount; we know
+ * the ref can't hit 0 before the user drops the initial ref, so as long as we
+ * convert to non percpu mode before the initial ref is dropped everything
+ * works.
+ *
+ * Converting to non percpu mode is done with some RCUish stuff in
+ * percpu_ref_kill. Additionally, we need a bias value so that the atomic_t
+ * can't hit 0 before we've added up all the percpu refs.
+ */
+
+#define PCPU_COUNT_BIAS		(1U << 31)
+
+/**
+ * percpu_ref_init - initialize a percpu refcount
+ * @ref: percpu_ref to initialize
+ * @release: function which will be called when refcount hits 0
+ *
+ * Initializes the refcount in single atomic counter mode with a refcount of 1;
+ * analagous to atomic_set(ref, 1).
+ *
+ * Note that @release must not sleep - it may potentially be called from RCU
+ * callback context by percpu_ref_kill().
+ */
+int percpu_ref_init(struct percpu_ref *ref, percpu_ref_func_t *release)
+{
+	atomic_set(&ref->count, 1 + PCPU_COUNT_BIAS);
+
+	ref->pcpu_count = alloc_percpu(unsigned);
+	if (!ref->pcpu_count)
+		return -ENOMEM;
+
+	ref->release = release;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(percpu_ref_init);
+
+/**
+ * percpu_ref_cancel_init - cancel percpu_ref_init()
+ * @ref: percpu_ref to cancel init for
+ *
+ * Once a percpu_ref is initialized, its destruction is initiated by
+ * percpu_ref_kill() and completes asynchronously, which can be painful to
+ * do when destroying a half-constructed object in init failure path.
+ *
+ * This function destroys @ref without invoking @ref->release and the
+ * memory area containing it can be freed immediately on return.  To
+ * prevent accidental misuse, it's required that @ref has finished
+ * percpu_ref_init(), whether successful or not, but never used.
+ *
+ * The weird name and usage restriction are to prevent people from using
+ * this function by mistake for normal shutdown instead of
+ * percpu_ref_kill().
+ */
+void percpu_ref_cancel_init(struct percpu_ref *ref)
+{
+	unsigned __percpu *pcpu_count = ref->pcpu_count;
+	int cpu;
+
+	WARN_ON_ONCE(atomic_read(&ref->count) != 1 + PCPU_COUNT_BIAS);
+
+	if (pcpu_count) {
+		for_each_possible_cpu(cpu)
+			WARN_ON_ONCE(*per_cpu_ptr(pcpu_count, cpu));
+		free_percpu(ref->pcpu_count);
+	}
+}
+EXPORT_SYMBOL_GPL(percpu_ref_cancel_init);
+
+static void percpu_ref_kill_rcu(struct rcu_head *rcu)
+{
+	struct percpu_ref *ref = container_of(rcu, struct percpu_ref, rcu);
+	unsigned __percpu *pcpu_count = ref->pcpu_count;
+	unsigned count = 0;
+	int cpu;
+
+	/* Mask out PCPU_REF_DEAD */
+	pcpu_count = (unsigned __percpu *)
+		(((unsigned long) pcpu_count) & ~PCPU_STATUS_MASK);
+
+	for_each_possible_cpu(cpu)
+		count += *per_cpu_ptr(pcpu_count, cpu);
+
+	free_percpu(pcpu_count);
+
+	pr_debug("global %i pcpu %i", atomic_read(&ref->count), (int) count);
+
+	/*
+	 * It's crucial that we sum the percpu counters _before_ adding the sum
+	 * to &ref->count; since gets could be happening on one cpu while puts
+	 * happen on another, adding a single cpu's count could cause
+	 * @ref->count to hit 0 before we've got a consistent value - but the
+	 * sum of all the counts will be consistent and correct.
+	 *
+	 * Subtracting the bias value then has to happen _after_ adding count to
+	 * &ref->count; we need the bias value to prevent &ref->count from
+	 * reaching 0 before we add the percpu counts. But doing it at the same
+	 * time is equivalent and saves us atomic operations:
+	 */
+
+	atomic_add((int) count - PCPU_COUNT_BIAS, &ref->count);
+
+	/* @ref is viewed as dead on all CPUs, send out kill confirmation */
+	if (ref->confirm_kill)
+		ref->confirm_kill(ref);
+
+	/*
+	 * Now we're in single atomic_t mode with a consistent refcount, so it's
+	 * safe to drop our initial ref:
+	 */
+	percpu_ref_put(ref);
+}
+
+/**
+ * percpu_ref_kill_and_confirm - drop the initial ref and schedule confirmation
+ * @ref: percpu_ref to kill
+ * @confirm_kill: optional confirmation callback
+ *
+ * Equivalent to percpu_ref_kill() but also schedules kill confirmation if
+ * @confirm_kill is not NULL.  @confirm_kill, which may not block, will be
+ * called after @ref is seen as dead from all CPUs - all further
+ * invocations of percpu_ref_tryget() will fail.  See percpu_ref_tryget()
+ * for more details.
+ *
+ * Due to the way percpu_ref is implemented, @confirm_kill will be called
+ * after at least one full RCU grace period has passed but this is an
+ * implementation detail and callers must not depend on it.
+ */
+void percpu_ref_kill_and_confirm(struct percpu_ref *ref,
+				 percpu_ref_func_t *confirm_kill)
+{
+	WARN_ONCE(REF_STATUS(ref->pcpu_count) == PCPU_REF_DEAD,
+		  "percpu_ref_kill() called more than once!\n");
+
+	ref->pcpu_count = (unsigned __percpu *)
+		(((unsigned long) ref->pcpu_count)|PCPU_REF_DEAD);
+	ref->confirm_kill = confirm_kill;
+
+	call_rcu_sched(&ref->rcu, percpu_ref_kill_rcu);
+}
+EXPORT_SYMBOL_GPL(percpu_ref_kill_and_confirm);
diff -rubB --new-file linux-3.10.69/Makefile F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/Makefile
--- linux-3.10.69/Makefile	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/Makefile	2017-05-02 03:31:56.000000000 +0200
@@ -1,7 +1,7 @@
 VERSION = 3
 PATCHLEVEL = 10
 SUBLEVEL = 69
-EXTRAVERSION =
+EXTRAVERSION = -bromolow
 NAME = TOSSUG Baby Fish
 
 # *DOCUMENTATION*
@@ -614,8 +614,6 @@
 endif
 endif
 
-KBUILD_CFLAGS   += $(call cc-option, -fno-var-tracking-assignments)
-
 ifdef CONFIG_DEBUG_INFO
 KBUILD_CFLAGS	+= -g
 KBUILD_AFLAGS	+= -gdwarf-2
@@ -1021,6 +1019,7 @@
 # Directories & files removed with 'make mrproper'
 MRPROPER_DIRS  += include/config usr/include include/generated          \
                   arch/*/include/generated
+MRPRPPER_DIRS  += buffalo/include/generated buffalo/arch/*/include/generated
 MRPROPER_FILES += .config .config.old .version .old_version $(version_h) \
 		  Module.symvers tags TAGS cscope* GPATH GTAGS GRTAGS GSYMS \
 		  signing_key.priv signing_key.x509 x509.genkey		\
@@ -1086,8 +1085,10 @@
 # ---------------------------------------------------------------------------
 
 boards := $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*_defconfig)
+boards += $(wildcard $(srctree)/buffalo/arch/$(SRCARCH)/configs/*_defconfig)
 boards := $(notdir $(boards))
 board-dirs := $(dir $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*/*_defconfig))
+board-dirs += $(dir $(wildcard $(srctree)/buffalo/arch/$(SRCARCH)/configs/*/*_defconfig))
 board-dirs := $(sort $(notdir $(board-dirs:/=)))
 
 help:
diff -rubB --new-file linux-3.10.69/Makefile.atom_usi F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/Makefile.atom_usi
--- linux-3.10.69/Makefile.atom_usi	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/Makefile.atom_usi	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,1436 @@
+VERSION = 3
+PATCHLEVEL = 10
+SUBLEVEL = 69
+EXTRAVERSION = -atom_usi
+NAME = TOSSUG Baby Fish
+
+# *DOCUMENTATION*
+# To see a list of typical targets execute "make help"
+# More info can be located in ./README
+# Comments in this file are targeted only to the developer, do not
+# expect to learn how to build the kernel reading this file.
+
+# Do not:
+# o  use make's built-in rules and variables
+#    (this increases performance and avoids hard-to-debug behaviour);
+# o  print "Entering directory ...";
+MAKEFLAGS += -rR --no-print-directory
+
+# Avoid funny character set dependencies
+unexport LC_ALL
+LC_COLLATE=C
+LC_NUMERIC=C
+export LC_COLLATE LC_NUMERIC
+
+# We are using a recursive build, so we need to do a little thinking
+# to get the ordering right.
+#
+# Most importantly: sub-Makefiles should only ever modify files in
+# their own directory. If in some directory we have a dependency on
+# a file in another dir (which doesn't happen often, but it's often
+# unavoidable when linking the built-in.o targets which finally
+# turn into vmlinux), we will call a sub make in that other dir, and
+# after that we are sure that everything which is in that other dir
+# is now up to date.
+#
+# The only cases where we need to modify files which have global
+# effects are thus separated out and done before the recursive
+# descending is started. They are now explicitly listed as the
+# prepare rule.
+
+# To put more focus on warnings, be less verbose as default
+# Use 'make V=1' to see the full commands
+
+ifeq ("$(origin V)", "command line")
+  KBUILD_VERBOSE = $(V)
+endif
+ifndef KBUILD_VERBOSE
+  KBUILD_VERBOSE = 0
+endif
+
+# Call a source code checker (by default, "sparse") as part of the
+# C compilation.
+#
+# Use 'make C=1' to enable checking of only re-compiled files.
+# Use 'make C=2' to enable checking of *all* source files, regardless
+# of whether they are re-compiled or not.
+#
+# See the file "Documentation/sparse.txt" for more details, including
+# where to get the "sparse" utility.
+
+ifeq ("$(origin C)", "command line")
+  KBUILD_CHECKSRC = $(C)
+endif
+ifndef KBUILD_CHECKSRC
+  KBUILD_CHECKSRC = 0
+endif
+
+# Use make M=dir to specify directory of external module to build
+# Old syntax make ... SUBDIRS=$PWD is still supported
+# Setting the environment variable KBUILD_EXTMOD take precedence
+ifdef SUBDIRS
+  KBUILD_EXTMOD ?= $(SUBDIRS)
+endif
+
+ifeq ("$(origin M)", "command line")
+  KBUILD_EXTMOD := $(M)
+endif
+
+# kbuild supports saving output files in a separate directory.
+# To locate output files in a separate directory two syntaxes are supported.
+# In both cases the working directory must be the root of the kernel src.
+# 1) O=
+# Use "make O=dir/to/store/output/files/"
+#
+# 2) Set KBUILD_OUTPUT
+# Set the environment variable KBUILD_OUTPUT to point to the directory
+# where the output files shall be placed.
+# export KBUILD_OUTPUT=dir/to/store/output/files/
+# make
+#
+# The O= assignment takes precedence over the KBUILD_OUTPUT environment
+# variable.
+
+
+# KBUILD_SRC is set on invocation of make in OBJ directory
+# KBUILD_SRC is not intended to be used by the regular user (for now)
+ifeq ($(KBUILD_SRC),)
+
+# OK, Make called in directory where kernel src resides
+# Do we want to locate output files in a separate directory?
+ifeq ("$(origin O)", "command line")
+  KBUILD_OUTPUT := $(O)
+endif
+
+ifeq ("$(origin W)", "command line")
+  export KBUILD_ENABLE_EXTRA_GCC_CHECKS := $(W)
+endif
+
+# That's our default target when none is given on the command line
+PHONY := _all
+_all:
+
+# Cancel implicit rules on top Makefile
+$(CURDIR)/Makefile Makefile: ;
+
+ifneq ($(KBUILD_OUTPUT),)
+# Invoke a second make in the output directory, passing relevant variables
+# check that the output directory actually exists
+saved-output := $(KBUILD_OUTPUT)
+KBUILD_OUTPUT := $(shell cd $(KBUILD_OUTPUT) && /bin/pwd)
+$(if $(KBUILD_OUTPUT),, \
+     $(error output directory "$(saved-output)" does not exist))
+
+PHONY += $(MAKECMDGOALS) sub-make
+
+$(filter-out _all sub-make $(CURDIR)/Makefile, $(MAKECMDGOALS)) _all: sub-make
+	@:
+
+sub-make: FORCE
+	$(if $(KBUILD_VERBOSE:1=),@)$(MAKE) -C $(KBUILD_OUTPUT) \
+	KBUILD_SRC=$(CURDIR) \
+	KBUILD_EXTMOD="$(KBUILD_EXTMOD)" -f $(CURDIR)/Makefile \
+	$(filter-out _all sub-make,$(MAKECMDGOALS))
+
+# Leave processing to above invocation of make
+skip-makefile := 1
+endif # ifneq ($(KBUILD_OUTPUT),)
+endif # ifeq ($(KBUILD_SRC),)
+
+# We process the rest of the Makefile if this is the final invocation of make
+ifeq ($(skip-makefile),)
+
+# If building an external module we do not care about the all: rule
+# but instead _all depend on modules
+PHONY += all
+ifeq ($(KBUILD_EXTMOD),)
+_all: all
+else
+_all: modules
+endif
+
+srctree		:= $(if $(KBUILD_SRC),$(KBUILD_SRC),$(CURDIR))
+objtree		:= $(CURDIR)
+src		:= $(srctree)
+obj		:= $(objtree)
+
+VPATH		:= $(srctree)$(if $(KBUILD_EXTMOD),:$(KBUILD_EXTMOD))
+
+export srctree objtree VPATH
+
+
+# SUBARCH tells the usermode build what the underlying arch is.  That is set
+# first, and if a usermode build is happening, the "ARCH=um" on the command
+# line overrides the setting of ARCH below.  If a native build is happening,
+# then ARCH is assigned, getting whatever value it gets normally, and 
+# SUBARCH is subsequently ignored.
+
+SUBARCH := $(shell uname -m | sed -e s/i.86/x86/ -e s/x86_64/x86/ \
+				  -e s/sun4u/sparc64/ \
+				  -e s/arm.*/arm/ -e s/sa110/arm/ \
+				  -e s/s390x/s390/ -e s/parisc64/parisc/ \
+				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ \
+				  -e s/sh[234].*/sh/ -e s/aarch64.*/arm64/ )
+
+# Cross compiling and selecting different set of gcc/bin-utils
+# ---------------------------------------------------------------------------
+#
+# When performing cross compilation for other architectures ARCH shall be set
+# to the target architecture. (See arch/* for the possibilities).
+# ARCH can be set during invocation of make:
+# make ARCH=ia64
+# Another way is to have ARCH set in the environment.
+# The default ARCH is the host where make is executed.
+
+# CROSS_COMPILE specify the prefix used for all executables used
+# during compilation. Only gcc and related bin-utils executables
+# are prefixed with $(CROSS_COMPILE).
+# CROSS_COMPILE can be set on the command line
+# make CROSS_COMPILE=ia64-linux-
+# Alternatively CROSS_COMPILE can be set in the environment.
+# A third alternative is to store a setting in .config so that plain
+# "make" in the configured kernel build directory always uses that.
+# Default value for CROSS_COMPILE is not to prefix executables
+# Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
+ARCH		?= $(SUBARCH)
+CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
+
+# Architecture as present in compile.h
+UTS_MACHINE 	:= $(ARCH)
+SRCARCH 	:= $(ARCH)
+
+# Additional ARCH settings for x86
+ifeq ($(ARCH),i386)
+        SRCARCH := x86
+endif
+ifeq ($(ARCH),x86_64)
+        SRCARCH := x86
+endif
+
+# Additional ARCH settings for sparc
+ifeq ($(ARCH),sparc32)
+       SRCARCH := sparc
+endif
+ifeq ($(ARCH),sparc64)
+       SRCARCH := sparc
+endif
+
+# Additional ARCH settings for sh
+ifeq ($(ARCH),sh64)
+       SRCARCH := sh
+endif
+
+# Additional ARCH settings for tile
+ifeq ($(ARCH),tilepro)
+       SRCARCH := tile
+endif
+ifeq ($(ARCH),tilegx)
+       SRCARCH := tile
+endif
+
+# Where to locate arch specific headers
+hdr-arch  := $(SRCARCH)
+
+KCONFIG_CONFIG	?= .config
+export KCONFIG_CONFIG
+
+# SHELL used by kbuild
+CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
+	  else if [ -x /bin/bash ]; then echo /bin/bash; \
+	  else echo sh; fi ; fi)
+
+HOSTCC       = gcc
+HOSTCXX      = g++
+HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCXXFLAGS = -O2
+
+# Decide whether to build built-in, modular, or both.
+# Normally, just do built-in.
+
+KBUILD_MODULES :=
+KBUILD_BUILTIN := 1
+
+#	If we have only "make modules", don't compile built-in objects.
+#	When we're building modules with modversions, we need to consider
+#	the built-in objects during the descend as well, in order to
+#	make sure the checksums are up to date before we record them.
+
+ifeq ($(MAKECMDGOALS),modules)
+  KBUILD_BUILTIN := $(if $(CONFIG_MODVERSIONS),1)
+endif
+
+#	If we have "make <whatever> modules", compile modules
+#	in addition to whatever we do anyway.
+#	Just "make" or "make all" shall build modules as well
+
+ifneq ($(filter all _all modules,$(MAKECMDGOALS)),)
+  KBUILD_MODULES := 1
+endif
+
+ifeq ($(MAKECMDGOALS),)
+  KBUILD_MODULES := 1
+endif
+
+export KBUILD_MODULES KBUILD_BUILTIN
+export KBUILD_CHECKSRC KBUILD_SRC KBUILD_EXTMOD
+
+# Beautify output
+# ---------------------------------------------------------------------------
+#
+# Normally, we echo the whole command before executing it. By making
+# that echo $($(quiet)$(cmd)), we now have the possibility to set
+# $(quiet) to choose other forms of output instead, e.g.
+#
+#         quiet_cmd_cc_o_c = Compiling $(RELDIR)/$@
+#         cmd_cc_o_c       = $(CC) $(c_flags) -c -o $@ $<
+#
+# If $(quiet) is empty, the whole command will be printed.
+# If it is set to "quiet_", only the short version will be printed. 
+# If it is set to "silent_", nothing will be printed at all, since
+# the variable $(silent_cmd_cc_o_c) doesn't exist.
+#
+# A simple variant is to prefix commands with $(Q) - that's useful
+# for commands that shall be hidden in non-verbose mode.
+#
+#	$(Q)ln $@ :<
+#
+# If KBUILD_VERBOSE equals 0 then the above command will be hidden.
+# If KBUILD_VERBOSE equals 1 then the above command is displayed.
+
+ifeq ($(KBUILD_VERBOSE),1)
+  quiet =
+  Q =
+else
+  quiet=quiet_
+  Q = @
+endif
+
+# If the user is running make -s (silent mode), suppress echoing of
+# commands
+
+ifneq ($(filter s% -s%,$(MAKEFLAGS)),)
+  quiet=silent_
+endif
+
+export quiet Q KBUILD_VERBOSE
+
+
+# Look for make include files relative to root of kernel src
+MAKEFLAGS += --include-dir=$(srctree)
+
+# We need some generic definitions (do not try to remake the file).
+$(srctree)/scripts/Kbuild.include: ;
+include $(srctree)/scripts/Kbuild.include
+
+# Make variables (CC, etc...)
+
+AS		= $(CROSS_COMPILE)as
+LD		= $(CROSS_COMPILE)ld
+CC		= $(CROSS_COMPILE)gcc
+CPP		= $(CC) -E
+AR		= $(CROSS_COMPILE)ar
+NM		= $(CROSS_COMPILE)nm
+STRIP		= $(CROSS_COMPILE)strip
+OBJCOPY		= $(CROSS_COMPILE)objcopy
+OBJDUMP		= $(CROSS_COMPILE)objdump
+AWK		= awk
+GENKSYMS	= scripts/genksyms/genksyms
+INSTALLKERNEL  := installkernel
+DEPMOD		= /sbin/depmod
+PERL		= perl
+CHECK		= sparse
+
+CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
+		  -Wbitwise -Wno-return-void $(CF)
+CFLAGS_MODULE   =
+AFLAGS_MODULE   =
+LDFLAGS_MODULE  =
+CFLAGS_KERNEL	=
+AFLAGS_KERNEL	=
+CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage
+
+
+# Use USERINCLUDE when you must reference the UAPI directories only.
+USERINCLUDE    := \
+		-I$(srctree)/arch/$(hdr-arch)/include/uapi \
+		-Iarch/$(hdr-arch)/include/generated/uapi \
+		-I$(srctree)/include/uapi \
+		-Iinclude/generated/uapi \
+                -include $(srctree)/include/linux/kconfig.h
+
+# Use LINUXINCLUDE when you must reference the include/ directory.
+# Needed to be compatible with the O= option
+LINUXINCLUDE    := \
+		-I$(srctree)/arch/$(hdr-arch)/include \
+		-Iarch/$(hdr-arch)/include/generated \
+		$(if $(KBUILD_SRC), -I$(srctree)/include) \
+		-Iinclude \
+		$(USERINCLUDE)
+
+KBUILD_CPPFLAGS := -D__KERNEL__
+
+KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
+		   -fno-strict-aliasing -fno-common \
+		   -Werror-implicit-function-declaration \
+		   -Wno-format-security \
+		   -fno-delete-null-pointer-checks
+KBUILD_AFLAGS_KERNEL :=
+KBUILD_CFLAGS_KERNEL :=
+KBUILD_AFLAGS   := -D__ASSEMBLY__
+KBUILD_AFLAGS_MODULE  := -DMODULE
+KBUILD_CFLAGS_MODULE  := -DMODULE
+KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
+
+# Read KERNELRELEASE from include/config/kernel.release (if it exists)
+KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
+KERNELVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
+
+export VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION
+export ARCH SRCARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC
+export CPP AR NM STRIP OBJCOPY OBJDUMP
+export MAKE AWK GENKSYMS INSTALLKERNEL PERL UTS_MACHINE
+export HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
+
+export KBUILD_CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS LDFLAGS
+export KBUILD_CFLAGS CFLAGS_KERNEL CFLAGS_MODULE CFLAGS_GCOV
+export KBUILD_AFLAGS AFLAGS_KERNEL AFLAGS_MODULE
+export KBUILD_AFLAGS_MODULE KBUILD_CFLAGS_MODULE KBUILD_LDFLAGS_MODULE
+export KBUILD_AFLAGS_KERNEL KBUILD_CFLAGS_KERNEL
+export KBUILD_ARFLAGS
+
+# When compiling out-of-tree modules, put MODVERDIR in the module
+# tree rather than in the kernel tree. The kernel tree might
+# even be read-only.
+export MODVERDIR := $(if $(KBUILD_EXTMOD),$(firstword $(KBUILD_EXTMOD))/).tmp_versions
+
+# Files to ignore in find ... statements
+
+RCS_FIND_IGNORE := \( -name SCCS -o -name BitKeeper -o -name .svn -o -name CVS \
+		   -o -name .pc -o -name .hg -o -name .git \) -prune -o
+export RCS_TAR_IGNORE := --exclude SCCS --exclude BitKeeper --exclude .svn \
+			 --exclude CVS --exclude .pc --exclude .hg --exclude .git
+
+# ===========================================================================
+# Rules shared between *config targets and build targets
+
+# Basic helpers built in scripts/
+PHONY += scripts_basic
+scripts_basic:
+	$(Q)$(MAKE) $(build)=scripts/basic
+	$(Q)rm -f .tmp_quiet_recordmcount
+
+# To avoid any implicit rule to kick in, define an empty command.
+scripts/basic/%: scripts_basic ;
+
+PHONY += outputmakefile
+# outputmakefile generates a Makefile in the output directory, if using a
+# separate output directory. This allows convenient use of make in the
+# output directory.
+outputmakefile:
+ifneq ($(KBUILD_SRC),)
+	$(Q)ln -fsn $(srctree) source
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \
+	    $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)
+endif
+
+# Support for using generic headers in asm-generic
+PHONY += asm-generic
+asm-generic:
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.asm-generic \
+	            src=asm obj=arch/$(SRCARCH)/include/generated/asm
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.asm-generic \
+	            src=uapi/asm obj=arch/$(SRCARCH)/include/generated/uapi/asm
+
+# To make sure we do not include .config for any of the *config targets
+# catch them early, and hand them over to scripts/kconfig/Makefile
+# It is allowed to specify more targets when calling make, including
+# mixing *config targets and build targets.
+# For example 'make oldconfig all'.
+# Detect when mixed targets is specified, and make a second invocation
+# of make so .config is not included in this case either (for *config).
+
+version_h := include/generated/uapi/linux/version.h
+
+no-dot-config-targets := clean mrproper distclean \
+			 cscope gtags TAGS tags help %docs check% coccicheck \
+			 $(version_h) headers_% archheaders archscripts \
+			 kernelversion %src-pkg
+
+config-targets := 0
+mixed-targets  := 0
+dot-config     := 1
+
+ifneq ($(filter $(no-dot-config-targets), $(MAKECMDGOALS)),)
+	ifeq ($(filter-out $(no-dot-config-targets), $(MAKECMDGOALS)),)
+		dot-config := 0
+	endif
+endif
+
+ifeq ($(KBUILD_EXTMOD),)
+        ifneq ($(filter config %config,$(MAKECMDGOALS)),)
+                config-targets := 1
+                ifneq ($(filter-out config %config,$(MAKECMDGOALS)),)
+                        mixed-targets := 1
+                endif
+        endif
+endif
+
+ifeq ($(mixed-targets),1)
+# ===========================================================================
+# We're called with mixed targets (*config and build targets).
+# Handle them one by one.
+
+%:: FORCE
+	$(Q)$(MAKE) -C $(srctree) KBUILD_SRC= $@
+
+else
+ifeq ($(config-targets),1)
+# ===========================================================================
+# *config targets only - make sure prerequisites are updated, and descend
+# in scripts/kconfig to make the *config target
+
+# Read arch specific Makefile to set KBUILD_DEFCONFIG as needed.
+# KBUILD_DEFCONFIG may point out an alternative default configuration
+# used for 'make defconfig'
+include $(srctree)/arch/$(SRCARCH)/Makefile
+export KBUILD_DEFCONFIG KBUILD_KCONFIG
+
+config: scripts_basic outputmakefile FORCE
+	$(Q)mkdir -p include/linux include/config
+	$(Q)$(MAKE) $(build)=scripts/kconfig $@
+
+%config: scripts_basic outputmakefile FORCE
+	$(Q)mkdir -p include/linux include/config
+	$(Q)$(MAKE) $(build)=scripts/kconfig $@
+
+else
+# ===========================================================================
+# Build targets only - this includes vmlinux, arch specific targets, clean
+# targets and others. In general all targets except *config targets.
+
+ifeq ($(KBUILD_EXTMOD),)
+# Additional helpers built in scripts/
+# Carefully list dependencies so we do not try to build scripts twice
+# in parallel
+PHONY += scripts
+scripts: scripts_basic include/config/auto.conf include/config/tristate.conf \
+	 asm-generic
+	$(Q)$(MAKE) $(build)=$(@)
+
+# Objects we will link into vmlinux / subdirs we need to visit
+init-y		:= init/
+drivers-y	:= drivers/ sound/ firmware/
+net-y		:= net/
+libs-y		:= lib/
+core-y		:= usr/
+endif # KBUILD_EXTMOD
+
+ifeq ($(dot-config),1)
+# Read in config
+-include include/config/auto.conf
+
+ifeq ($(KBUILD_EXTMOD),)
+# Read in dependencies to all Kconfig* files, make sure to run
+# oldconfig if changes are detected.
+-include include/config/auto.conf.cmd
+
+# To avoid any implicit rule to kick in, define an empty command
+$(KCONFIG_CONFIG) include/config/auto.conf.cmd: ;
+
+# If .config is newer than include/config/auto.conf, someone tinkered
+# with it and forgot to run make oldconfig.
+# if auto.conf.cmd is missing then we are probably in a cleaned tree so
+# we execute the config step to be sure to catch updated Kconfig files
+include/config/%.conf: $(KCONFIG_CONFIG) include/config/auto.conf.cmd
+	$(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig
+else
+# external modules needs include/generated/autoconf.h and include/config/auto.conf
+# but do not care if they are up-to-date. Use auto.conf to trigger the test
+PHONY += include/config/auto.conf
+
+include/config/auto.conf:
+	$(Q)test -e include/generated/autoconf.h -a -e $@ || (		\
+	echo >&2;							\
+	echo >&2 "  ERROR: Kernel configuration is invalid.";		\
+	echo >&2 "         include/generated/autoconf.h or $@ are missing.";\
+	echo >&2 "         Run 'make oldconfig && make prepare' on kernel src to fix it.";	\
+	echo >&2 ;							\
+	/bin/false)
+
+endif # KBUILD_EXTMOD
+
+else
+# Dummy target needed, because used as prerequisite
+include/config/auto.conf: ;
+endif # $(dot-config)
+
+# The all: target is the default when no target is given on the
+# command line.
+# This allow a user to issue only 'make' to build a kernel including modules
+# Defaults to vmlinux, but the arch makefile usually adds further targets
+all: vmlinux
+
+ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
+KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)
+else
+KBUILD_CFLAGS	+= -O2
+endif
+
+include $(srctree)/arch/$(SRCARCH)/Makefile
+
+ifdef CONFIG_READABLE_ASM
+# Disable optimizations that make assembler listings hard to read.
+# reorder blocks reorders the control in the function
+# ipa clone creates specialized cloned functions
+# partial inlining inlines only parts of functions
+KBUILD_CFLAGS += $(call cc-option,-fno-reorder-blocks,) \
+                 $(call cc-option,-fno-ipa-cp-clone,) \
+                 $(call cc-option,-fno-partial-inlining)
+endif
+
+ifneq ($(CONFIG_FRAME_WARN),0)
+KBUILD_CFLAGS += $(call cc-option,-Wframe-larger-than=${CONFIG_FRAME_WARN})
+endif
+
+# Force gcc to behave correct even for buggy distributions
+ifndef CONFIG_CC_STACKPROTECTOR
+KBUILD_CFLAGS += $(call cc-option, -fno-stack-protector)
+endif
+
+# This warning generated too much noise in a regular build.
+# Use make W=1 to enable this warning (see scripts/Makefile.build)
+KBUILD_CFLAGS += $(call cc-disable-warning, unused-but-set-variable)
+
+ifdef CONFIG_FRAME_POINTER
+KBUILD_CFLAGS	+= -fno-omit-frame-pointer -fno-optimize-sibling-calls
+else
+# Some targets (ARM with Thumb2, for example), can't be built with frame
+# pointers.  For those, we don't have FUNCTION_TRACER automatically
+# select FRAME_POINTER.  However, FUNCTION_TRACER adds -pg, and this is
+# incompatible with -fomit-frame-pointer with current GCC, so we don't use
+# -fomit-frame-pointer with FUNCTION_TRACER.
+ifndef CONFIG_FUNCTION_TRACER
+KBUILD_CFLAGS	+= -fomit-frame-pointer
+endif
+endif
+
+ifdef CONFIG_DEBUG_INFO
+KBUILD_CFLAGS	+= -g
+KBUILD_AFLAGS	+= -gdwarf-2
+endif
+
+ifdef CONFIG_DEBUG_INFO_REDUCED
+KBUILD_CFLAGS 	+= $(call cc-option, -femit-struct-debug-baseonly) \
+		   $(call cc-option,-fno-var-tracking)
+endif
+
+ifdef CONFIG_FUNCTION_TRACER
+ifdef CONFIG_HAVE_FENTRY
+CC_USING_FENTRY	:= $(call cc-option, -mfentry -DCC_USING_FENTRY)
+endif
+KBUILD_CFLAGS	+= -pg $(CC_USING_FENTRY)
+KBUILD_AFLAGS	+= $(CC_USING_FENTRY)
+ifdef CONFIG_DYNAMIC_FTRACE
+	ifdef CONFIG_HAVE_C_RECORDMCOUNT
+		BUILD_C_RECORDMCOUNT := y
+		export BUILD_C_RECORDMCOUNT
+	endif
+endif
+endif
+
+# We trigger additional mismatches with less inlining
+ifdef CONFIG_DEBUG_SECTION_MISMATCH
+KBUILD_CFLAGS += $(call cc-option, -fno-inline-functions-called-once)
+endif
+
+# arch Makefile may override CC so keep this after arch Makefile is included
+NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
+CHECKFLAGS     += $(NOSTDINC_FLAGS)
+
+# warn about C99 declaration after statement
+KBUILD_CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
+
+# disable pointer signed / unsigned warnings in gcc 4.0
+KBUILD_CFLAGS += $(call cc-disable-warning, pointer-sign)
+
+# disable invalid "can't wrap" optimizations for signed / pointers
+KBUILD_CFLAGS	+= $(call cc-option,-fno-strict-overflow)
+
+# conserve stack if available
+KBUILD_CFLAGS   += $(call cc-option,-fconserve-stack)
+
+# use the deterministic mode of AR if available
+KBUILD_ARFLAGS := $(call ar-option,D)
+
+# check for 'asm goto'
+ifeq ($(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-goto.sh $(CC)), y)
+	KBUILD_CFLAGS += -DCC_HAVE_ASM_GOTO
+endif
+
+# Add user supplied CPPFLAGS, AFLAGS and CFLAGS as the last assignments
+KBUILD_CPPFLAGS += $(KCPPFLAGS)
+KBUILD_AFLAGS += $(KAFLAGS)
+KBUILD_CFLAGS += $(KCFLAGS)
+
+# Use --build-id when available.
+LDFLAGS_BUILD_ID = $(patsubst -Wl$(comma)%,%,\
+			      $(call cc-ldoption, -Wl$(comma)--build-id,))
+KBUILD_LDFLAGS_MODULE += $(LDFLAGS_BUILD_ID)
+LDFLAGS_vmlinux += $(LDFLAGS_BUILD_ID)
+
+ifeq ($(CONFIG_STRIP_ASM_SYMS),y)
+LDFLAGS_vmlinux	+= $(call ld-option, -X,)
+endif
+
+# Default kernel image to build when no specific target is given.
+# KBUILD_IMAGE may be overruled on the command line or
+# set in the environment
+# Also any assignments in arch/$(ARCH)/Makefile take precedence over
+# this default value
+export KBUILD_IMAGE ?= vmlinux
+
+#
+# INSTALL_PATH specifies where to place the updated kernel and system map
+# images. Default is /boot, but you can set it to other values
+export	INSTALL_PATH ?= /boot
+
+#
+# INSTALL_MOD_PATH specifies a prefix to MODLIB for module directory
+# relocations required by build roots.  This is not defined in the
+# makefile but the argument can be passed to make if needed.
+#
+
+MODLIB	= $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)
+export MODLIB
+
+#
+#  INSTALL_MOD_STRIP, if defined, will cause modules to be
+#  stripped after they are installed.  If INSTALL_MOD_STRIP is '1', then
+#  the default option --strip-debug will be used.  Otherwise,
+#  INSTALL_MOD_STRIP value will be used as the options to the strip command.
+
+ifdef INSTALL_MOD_STRIP
+ifeq ($(INSTALL_MOD_STRIP),1)
+mod_strip_cmd = $(STRIP) --strip-debug
+else
+mod_strip_cmd = $(STRIP) $(INSTALL_MOD_STRIP)
+endif # INSTALL_MOD_STRIP=1
+else
+mod_strip_cmd = true
+endif # INSTALL_MOD_STRIP
+export mod_strip_cmd
+
+
+ifdef CONFIG_MODULE_SIG_ALL
+MODSECKEY = ./signing_key.priv
+MODPUBKEY = ./signing_key.x509
+export MODPUBKEY
+mod_sign_cmd = perl $(srctree)/scripts/sign-file $(CONFIG_MODULE_SIG_HASH) $(MODSECKEY) $(MODPUBKEY)
+else
+mod_sign_cmd = true
+endif
+export mod_sign_cmd
+
+
+ifeq ($(KBUILD_EXTMOD),)
+core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
+
+vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
+		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
+		     $(net-y) $(net-m) $(libs-y) $(libs-m)))
+
+vmlinux-alldirs	:= $(sort $(vmlinux-dirs) $(patsubst %/,%,$(filter %/, \
+		     $(init-n) $(init-) \
+		     $(core-n) $(core-) $(drivers-n) $(drivers-) \
+		     $(net-n)  $(net-)  $(libs-n)    $(libs-))))
+
+init-y		:= $(patsubst %/, %/built-in.o, $(init-y))
+core-y		:= $(patsubst %/, %/built-in.o, $(core-y))
+drivers-y	:= $(patsubst %/, %/built-in.o, $(drivers-y))
+net-y		:= $(patsubst %/, %/built-in.o, $(net-y))
+libs-y1		:= $(patsubst %/, %/lib.a, $(libs-y))
+libs-y2		:= $(patsubst %/, %/built-in.o, $(libs-y))
+libs-y		:= $(libs-y1) $(libs-y2)
+
+# Externally visible symbols (used by link-vmlinux.sh)
+export KBUILD_VMLINUX_INIT := $(head-y) $(init-y)
+export KBUILD_VMLINUX_MAIN := $(core-y) $(libs-y) $(drivers-y) $(net-y)
+export KBUILD_LDS          := arch/$(SRCARCH)/kernel/vmlinux.lds
+export LDFLAGS_vmlinux
+# used by scripts/pacmage/Makefile
+export KBUILD_ALLDIRS := $(sort $(filter-out arch/%,$(vmlinux-alldirs)) arch Documentation include samples scripts tools virt)
+
+vmlinux-deps := $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN)
+
+# Final link of vmlinux
+      cmd_link-vmlinux = $(CONFIG_SHELL) $< $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux)
+quiet_cmd_link-vmlinux = LINK    $@
+
+# Include targets which we want to
+# execute if the rest of the kernel build went well.
+vmlinux: scripts/link-vmlinux.sh $(vmlinux-deps) FORCE
+ifdef CONFIG_HEADERS_CHECK
+	$(Q)$(MAKE) -f $(srctree)/Makefile headers_check
+endif
+ifdef CONFIG_SAMPLES
+	$(Q)$(MAKE) $(build)=samples
+endif
+ifdef CONFIG_BUILD_DOCSRC
+	$(Q)$(MAKE) $(build)=Documentation
+endif
+	+$(call if_changed,link-vmlinux)
+
+# The actual objects are generated when descending, 
+# make sure no implicit rule kicks in
+$(sort $(vmlinux-deps)): $(vmlinux-dirs) ;
+
+# Handle descending into subdirectories listed in $(vmlinux-dirs)
+# Preset locale variables to speed up the build process. Limit locale
+# tweaks to this spot to avoid wrong language settings when running
+# make menuconfig etc.
+# Error messages still appears in the original language
+
+PHONY += $(vmlinux-dirs)
+$(vmlinux-dirs): prepare scripts
+	$(Q)$(MAKE) $(build)=$@
+
+# Store (new) KERNELRELASE string in include/config/kernel.release
+include/config/kernel.release: include/config/auto.conf FORCE
+	$(Q)rm -f $@
+	$(Q)echo "$(KERNELVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))" > $@
+
+
+# Things we need to do before we recursively start building the kernel
+# or the modules are listed in "prepare".
+# A multi level approach is used. prepareN is processed before prepareN-1.
+# archprepare is used in arch Makefiles and when processed asm symlink,
+# version.h and scripts_basic is processed / created.
+
+# Listed in dependency order
+PHONY += prepare archprepare prepare0 prepare1 prepare2 prepare3
+
+# prepare3 is used to check if we are building in a separate output directory,
+# and if so do:
+# 1) Check that make has not been executed in the kernel src $(srctree)
+prepare3: include/config/kernel.release
+ifneq ($(KBUILD_SRC),)
+	@$(kecho) '  Using $(srctree) as source for kernel'
+	$(Q)if [ -f $(srctree)/.config -o -d $(srctree)/include/config ]; then \
+		echo >&2 "  $(srctree) is not clean, please run 'make mrproper'"; \
+		echo >&2 "  in the '$(srctree)' directory.";\
+		/bin/false; \
+	fi;
+endif
+
+# prepare2 creates a makefile if using a separate output directory
+prepare2: prepare3 outputmakefile asm-generic
+
+prepare1: prepare2 $(version_h) include/generated/utsrelease.h \
+                   include/config/auto.conf
+	$(cmd_crmodverdir)
+
+archprepare: archheaders archscripts prepare1 scripts_basic
+
+prepare0: archprepare FORCE
+	$(Q)$(MAKE) $(build)=.
+
+# All the preparing..
+prepare: prepare0
+
+# Generate some files
+# ---------------------------------------------------------------------------
+
+# KERNELRELEASE can change from a few different places, meaning version.h
+# needs to be updated, so this check is forced on all builds
+
+uts_len := 64
+define filechk_utsrelease.h
+	if [ `echo -n "$(KERNELRELEASE)" | wc -c ` -gt $(uts_len) ]; then \
+	  echo '"$(KERNELRELEASE)" exceeds $(uts_len) characters' >&2;    \
+	  exit 1;                                                         \
+	fi;                                                               \
+	(echo \#define UTS_RELEASE \"$(KERNELRELEASE)\";)
+endef
+
+define filechk_version.h
+	(echo \#define LINUX_VERSION_CODE $(shell                         \
+	expr $(VERSION) \* 65536 + 0$(PATCHLEVEL) \* 256 + 0$(SUBLEVEL)); \
+	echo '#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))';)
+endef
+
+$(version_h): $(srctree)/Makefile FORCE
+	$(call filechk,version.h)
+
+include/generated/utsrelease.h: include/config/kernel.release FORCE
+	$(call filechk,utsrelease.h)
+
+PHONY += headerdep
+headerdep:
+	$(Q)find $(srctree)/include/ -name '*.h' | xargs --max-args 1 \
+	$(srctree)/scripts/headerdep.pl -I$(srctree)/include
+
+# ---------------------------------------------------------------------------
+
+PHONY += depend dep
+depend dep:
+	@echo '*** Warning: make $@ is unnecessary now.'
+
+# ---------------------------------------------------------------------------
+# Firmware install
+INSTALL_FW_PATH=$(INSTALL_MOD_PATH)/lib/firmware
+export INSTALL_FW_PATH
+
+PHONY += firmware_install
+firmware_install: FORCE
+	@mkdir -p $(objtree)/firmware
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.fwinst obj=firmware __fw_install
+
+# ---------------------------------------------------------------------------
+# Kernel headers
+
+#Default location for installed headers
+export INSTALL_HDR_PATH = $(objtree)/usr
+
+hdr-inst := -rR -f $(srctree)/scripts/Makefile.headersinst obj
+
+# If we do an all arch process set dst to asm-$(hdr-arch)
+hdr-dst = $(if $(KBUILD_HEADERS), dst=include/asm-$(hdr-arch), dst=include/asm)
+
+PHONY += archheaders
+archheaders:
+
+PHONY += archscripts
+archscripts:
+
+PHONY += __headers
+__headers: $(version_h) scripts_basic asm-generic archheaders archscripts FORCE
+	$(Q)$(MAKE) $(build)=scripts build_unifdef
+
+PHONY += headers_install_all
+headers_install_all:
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/headers.sh install
+
+PHONY += headers_install
+headers_install: __headers
+	$(if $(wildcard $(srctree)/arch/$(hdr-arch)/include/uapi/asm/Kbuild),, \
+	  $(error Headers not exportable for the $(SRCARCH) architecture))
+	$(Q)$(MAKE) $(hdr-inst)=include/uapi
+	$(Q)$(MAKE) $(hdr-inst)=arch/$(hdr-arch)/include/uapi/asm $(hdr-dst)
+
+PHONY += headers_check_all
+headers_check_all: headers_install_all
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/headers.sh check
+
+PHONY += headers_check
+headers_check: headers_install
+	$(Q)$(MAKE) $(hdr-inst)=include/uapi HDRCHECK=1
+	$(Q)$(MAKE) $(hdr-inst)=arch/$(hdr-arch)/include/uapi/asm $(hdr-dst) HDRCHECK=1
+
+# ---------------------------------------------------------------------------
+# Modules
+
+ifdef CONFIG_MODULES
+
+# By default, build modules as well
+
+all: modules
+
+#	Build modules
+#
+#	A module can be listed more than once in obj-m resulting in
+#	duplicate lines in modules.order files.  Those are removed
+#	using awk while concatenating to the final file.
+
+PHONY += modules
+modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) modules.builtin
+	$(Q)$(AWK) '!x[$$0]++' $(vmlinux-dirs:%=$(objtree)/%/modules.order) > $(objtree)/modules.order
+	@$(kecho) '  Building modules, stage 2.';
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.fwinst obj=firmware __fw_modbuild
+
+modules.builtin: $(vmlinux-dirs:%=%/modules.builtin)
+	$(Q)$(AWK) '!x[$$0]++' $^ > $(objtree)/modules.builtin
+
+%/modules.builtin: include/config/auto.conf
+	$(Q)$(MAKE) $(modbuiltin)=$*
+
+
+# Target to prepare building external modules
+PHONY += modules_prepare
+modules_prepare: prepare scripts
+
+# Target to install modules
+PHONY += modules_install
+modules_install: _modinst_ _modinst_post
+
+PHONY += _modinst_
+_modinst_:
+	@rm -rf $(MODLIB)/kernel
+	@rm -f $(MODLIB)/source
+	@mkdir -p $(MODLIB)/kernel
+	@ln -s $(srctree) $(MODLIB)/source
+	@if [ ! $(objtree) -ef  $(MODLIB)/build ]; then \
+		rm -f $(MODLIB)/build ; \
+		ln -s $(objtree) $(MODLIB)/build ; \
+	fi
+	@cp -f $(objtree)/modules.order $(MODLIB)/
+	@cp -f $(objtree)/modules.builtin $(MODLIB)/
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
+
+# This depmod is only for convenience to give the initial
+# boot a modules.dep even before / is mounted read-write.  However the
+# boot script depmod is the master version.
+PHONY += _modinst_post
+_modinst_post: _modinst_
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.fwinst obj=firmware __fw_modinst
+	$(call cmd,depmod)
+
+ifeq ($(CONFIG_MODULE_SIG), y)
+PHONY += modules_sign
+modules_sign:
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modsign
+endif
+
+else # CONFIG_MODULES
+
+# Modules not configured
+# ---------------------------------------------------------------------------
+
+modules modules_install: FORCE
+	@echo >&2
+	@echo >&2 "The present kernel configuration has modules disabled."
+	@echo >&2 "Type 'make config' and enable loadable module support."
+	@echo >&2 "Then build a kernel with module support enabled."
+	@echo >&2
+	@exit 1
+
+endif # CONFIG_MODULES
+
+###
+# Cleaning is done on three levels.
+# make clean     Delete most generated files
+#                Leave enough to build external modules
+# make mrproper  Delete the current configuration, and all generated files
+# make distclean Remove editor backup files, patch leftover files and the like
+
+# Directories & files removed with 'make clean'
+CLEAN_DIRS  += $(MODVERDIR)
+
+# Directories & files removed with 'make mrproper'
+MRPROPER_DIRS  += include/config usr/include include/generated          \
+                  arch/*/include/generated
+MRPRPPER_DIRS  += buffalo/include/generated buffalo/arch/*/include/generated
+MRPROPER_FILES += .config .config.old .version .old_version $(version_h) \
+		  Module.symvers tags TAGS cscope* GPATH GTAGS GRTAGS GSYMS \
+		  signing_key.priv signing_key.x509 x509.genkey		\
+		  extra_certificates signing_key.x509.keyid		\
+		  signing_key.x509.signer
+
+# clean - Delete most, but leave enough to build external modules
+#
+clean: rm-dirs  := $(CLEAN_DIRS)
+clean: rm-files := $(CLEAN_FILES)
+clean-dirs      := $(addprefix _clean_, . $(vmlinux-alldirs) Documentation samples)
+
+PHONY += $(clean-dirs) clean archclean vmlinuxclean
+$(clean-dirs):
+	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
+
+vmlinuxclean:
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/link-vmlinux.sh clean
+
+clean: archclean vmlinuxclean
+
+# mrproper - Delete all generated files, including .config
+#
+mrproper: rm-dirs  := $(wildcard $(MRPROPER_DIRS))
+mrproper: rm-files := $(wildcard $(MRPROPER_FILES))
+mrproper-dirs      := $(addprefix _mrproper_,Documentation/DocBook scripts)
+
+PHONY += $(mrproper-dirs) mrproper archmrproper
+$(mrproper-dirs):
+	$(Q)$(MAKE) $(clean)=$(patsubst _mrproper_%,%,$@)
+
+mrproper: clean archmrproper $(mrproper-dirs)
+	$(call cmd,rmdirs)
+	$(call cmd,rmfiles)
+
+# distclean
+#
+PHONY += distclean
+
+distclean: mrproper
+	@find $(srctree) $(RCS_FIND_IGNORE) \
+		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
+		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
+		-o -name '.*.rej' \
+		-o -name '*%' -o -name '.*.cmd' -o -name 'core' \) \
+		-type f -print | xargs rm -f
+
+
+# Packaging of the kernel to various formats
+# ---------------------------------------------------------------------------
+# rpm target kept for backward compatibility
+package-dir	:= $(srctree)/scripts/package
+
+%src-pkg: FORCE
+	$(Q)$(MAKE) $(build)=$(package-dir) $@
+%pkg: include/config/kernel.release FORCE
+	$(Q)$(MAKE) $(build)=$(package-dir) $@
+rpm: include/config/kernel.release FORCE
+	$(Q)$(MAKE) $(build)=$(package-dir) $@
+
+
+# Brief documentation of the typical targets used
+# ---------------------------------------------------------------------------
+
+boards := $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*_defconfig)
+boards += $(wildcard $(srctree)/buffalo/arch/$(SRCARCH)/configs/*_defconfig)
+boards := $(notdir $(boards))
+board-dirs := $(dir $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*/*_defconfig))
+board-dirs += $(dir $(wildcard $(srctree)/buffalo/arch/$(SRCARCH)/configs/*/*_defconfig))
+board-dirs := $(sort $(notdir $(board-dirs:/=)))
+
+help:
+	@echo  'Cleaning targets:'
+	@echo  '  clean		  - Remove most generated files but keep the config and'
+	@echo  '                    enough build support to build external modules'
+	@echo  '  mrproper	  - Remove all generated files + config + various backup files'
+	@echo  '  distclean	  - mrproper + remove editor backup and patch files'
+	@echo  ''
+	@echo  'Configuration targets:'
+	@$(MAKE) -f $(srctree)/scripts/kconfig/Makefile help
+	@echo  ''
+	@echo  'Other generic targets:'
+	@echo  '  all		  - Build all targets marked with [*]'
+	@echo  '* vmlinux	  - Build the bare kernel'
+	@echo  '* modules	  - Build all modules'
+	@echo  '  modules_install - Install all modules to INSTALL_MOD_PATH (default: /)'
+	@echo  '  firmware_install- Install all firmware to INSTALL_FW_PATH'
+	@echo  '                    (default: $$(INSTALL_MOD_PATH)/lib/firmware)'
+	@echo  '  dir/            - Build all files in dir and below'
+	@echo  '  dir/file.[oisS] - Build specified target only'
+	@echo  '  dir/file.lst    - Build specified mixed source/assembly target only'
+	@echo  '                    (requires a recent binutils and recent build (System.map))'
+	@echo  '  dir/file.ko     - Build module including final link'
+	@echo  '  modules_prepare - Set up for building external modules'
+	@echo  '  tags/TAGS	  - Generate tags file for editors'
+	@echo  '  cscope	  - Generate cscope index'
+	@echo  '  gtags           - Generate GNU GLOBAL index'
+	@echo  '  kernelrelease	  - Output the release version string'
+	@echo  '  kernelversion	  - Output the version stored in Makefile'
+	@echo  '  headers_install - Install sanitised kernel headers to INSTALL_HDR_PATH'; \
+	 echo  '                    (default: $(INSTALL_HDR_PATH))'; \
+	 echo  ''
+	@echo  'Static analysers'
+	@echo  '  checkstack      - Generate a list of stack hogs'
+	@echo  '  namespacecheck  - Name space analysis on compiled kernel'
+	@echo  '  versioncheck    - Sanity check on version.h usage'
+	@echo  '  includecheck    - Check for duplicate included header files'
+	@echo  '  export_report   - List the usages of all exported symbols'
+	@echo  '  headers_check   - Sanity check on exported headers'
+	@echo  '  headerdep       - Detect inclusion cycles in headers'
+	@$(MAKE) -f $(srctree)/scripts/Makefile.help checker-help
+	@echo  ''
+	@echo  'Kernel packaging:'
+	@$(MAKE) $(build)=$(package-dir) help
+	@echo  ''
+	@echo  'Documentation targets:'
+	@$(MAKE) -f $(srctree)/Documentation/DocBook/Makefile dochelp
+	@echo  ''
+	@echo  'Architecture specific targets ($(SRCARCH)):'
+	@$(if $(archhelp),$(archhelp),\
+		echo '  No architecture specific help defined for $(SRCARCH)')
+	@echo  ''
+	@$(if $(boards), \
+		$(foreach b, $(boards), \
+		printf "  %-24s - Build for %s\\n" $(b) $(subst _defconfig,,$(b));) \
+		echo '')
+	@$(if $(board-dirs), \
+		$(foreach b, $(board-dirs), \
+		printf "  %-16s - Show %s-specific targets\\n" help-$(b) $(b);) \
+		printf "  %-16s - Show all of the above\\n" help-boards; \
+		echo '')
+
+	@echo  '  make V=0|1 [targets] 0 => quiet build (default), 1 => verbose build'
+	@echo  '  make V=2   [targets] 2 => give reason for rebuild of target'
+	@echo  '  make O=dir [targets] Locate all output files in "dir", including .config'
+	@echo  '  make C=1   [targets] Check all c source with $$CHECK (sparse by default)'
+	@echo  '  make C=2   [targets] Force check of all c source with $$CHECK'
+	@echo  '  make RECORDMCOUNT_WARN=1 [targets] Warn about ignored mcount sections'
+	@echo  '  make W=n   [targets] Enable extra gcc checks, n=1,2,3 where'
+	@echo  '		1: warnings which may be relevant and do not occur too often'
+	@echo  '		2: warnings which occur quite often but may still be relevant'
+	@echo  '		3: more obscure warnings, can most likely be ignored'
+	@echo  '		Multiple levels can be combined with W=12 or W=123'
+	@echo  ''
+	@echo  'Execute "make" or "make all" to build all targets marked with [*] '
+	@echo  'For further info see the ./README file'
+
+
+help-board-dirs := $(addprefix help-,$(board-dirs))
+
+help-boards: $(help-board-dirs)
+
+boards-per-dir = $(notdir $(wildcard $(srctree)/arch/$(SRCARCH)/configs/$*/*_defconfig))
+
+$(help-board-dirs): help-%:
+	@echo  'Architecture specific targets ($(SRCARCH) $*):'
+	@$(if $(boards-per-dir), \
+		$(foreach b, $(boards-per-dir), \
+		printf "  %-24s - Build for %s\\n" $*/$(b) $(subst _defconfig,,$(b));) \
+		echo '')
+
+
+# Documentation targets
+# ---------------------------------------------------------------------------
+%docs: scripts_basic FORCE
+	$(Q)$(MAKE) $(build)=scripts build_docproc
+	$(Q)$(MAKE) $(build)=Documentation/DocBook $@
+
+else # KBUILD_EXTMOD
+
+###
+# External module support.
+# When building external modules the kernel used as basis is considered
+# read-only, and no consistency checks are made and the make
+# system is not used on the basis kernel. If updates are required
+# in the basis kernel ordinary make commands (without M=...) must
+# be used.
+#
+# The following are the only valid targets when building external
+# modules.
+# make M=dir clean     Delete all automatically generated files
+# make M=dir modules   Make all modules in specified dir
+# make M=dir	       Same as 'make M=dir modules'
+# make M=dir modules_install
+#                      Install the modules built in the module directory
+#                      Assumes install directory is already created
+
+# We are always building modules
+KBUILD_MODULES := 1
+PHONY += crmodverdir
+crmodverdir:
+	$(cmd_crmodverdir)
+
+PHONY += $(objtree)/Module.symvers
+$(objtree)/Module.symvers:
+	@test -e $(objtree)/Module.symvers || ( \
+	echo; \
+	echo "  WARNING: Symbol version dump $(objtree)/Module.symvers"; \
+	echo "           is missing; modules will have no dependencies and modversions."; \
+	echo )
+
+module-dirs := $(addprefix _module_,$(KBUILD_EXTMOD))
+PHONY += $(module-dirs) modules
+$(module-dirs): crmodverdir $(objtree)/Module.symvers
+	$(Q)$(MAKE) $(build)=$(patsubst _module_%,%,$@)
+
+modules: $(module-dirs)
+	@$(kecho) '  Building modules, stage 2.';
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
+
+PHONY += modules_install
+modules_install: _emodinst_ _emodinst_post
+
+install-dir := $(if $(INSTALL_MOD_DIR),$(INSTALL_MOD_DIR),extra)
+PHONY += _emodinst_
+_emodinst_:
+	$(Q)mkdir -p $(MODLIB)/$(install-dir)
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
+
+PHONY += _emodinst_post
+_emodinst_post: _emodinst_
+	$(call cmd,depmod)
+
+clean-dirs := $(addprefix _clean_,$(KBUILD_EXTMOD))
+
+PHONY += $(clean-dirs) clean
+$(clean-dirs):
+	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
+
+clean:	rm-dirs := $(MODVERDIR)
+clean: rm-files := $(KBUILD_EXTMOD)/Module.symvers
+
+help:
+	@echo  '  Building external modules.'
+	@echo  '  Syntax: make -C path/to/kernel/src M=$$PWD target'
+	@echo  ''
+	@echo  '  modules         - default target, build the module(s)'
+	@echo  '  modules_install - install the module'
+	@echo  '  clean           - remove generated files in module directory only'
+	@echo  ''
+
+# Dummies...
+PHONY += prepare scripts
+prepare: ;
+scripts: ;
+endif # KBUILD_EXTMOD
+
+clean: $(clean-dirs)
+	$(call cmd,rmdirs)
+	$(call cmd,rmfiles)
+	@find $(if $(KBUILD_EXTMOD), $(KBUILD_EXTMOD), .) $(RCS_FIND_IGNORE) \
+		\( -name '*.[oas]' -o -name '*.ko' -o -name '.*.cmd' \
+		-o -name '*.ko.*' \
+		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
+		-o -name '*.symtypes' -o -name 'modules.order' \
+		-o -name modules.builtin -o -name '.tmp_*.o.*' \
+		-o -name '*.gcno' \) -type f -print | xargs rm -f
+
+# Generate tags for editors
+# ---------------------------------------------------------------------------
+quiet_cmd_tags = GEN     $@
+      cmd_tags = $(CONFIG_SHELL) $(srctree)/scripts/tags.sh $@
+
+tags TAGS cscope gtags: FORCE
+	$(call cmd,tags)
+
+# Scripts to check various things for consistency
+# ---------------------------------------------------------------------------
+
+PHONY += includecheck versioncheck coccicheck namespacecheck export_report
+
+includecheck:
+	find $(srctree)/* $(RCS_FIND_IGNORE) \
+		-name '*.[hcS]' -type f -print | sort \
+		| xargs $(PERL) -w $(srctree)/scripts/checkincludes.pl
+
+versioncheck:
+	find $(srctree)/* $(RCS_FIND_IGNORE) \
+		-name '*.[hcS]' -type f -print | sort \
+		| xargs $(PERL) -w $(srctree)/scripts/checkversion.pl
+
+coccicheck:
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/$@
+
+namespacecheck:
+	$(PERL) $(srctree)/scripts/namespace.pl
+
+export_report:
+	$(PERL) $(srctree)/scripts/export_report.pl
+
+endif #ifeq ($(config-targets),1)
+endif #ifeq ($(mixed-targets),1)
+
+PHONY += checkstack kernelrelease kernelversion
+
+# UML needs a little special treatment here.  It wants to use the host
+# toolchain, so needs $(SUBARCH) passed to checkstack.pl.  Everyone
+# else wants $(ARCH), including people doing cross-builds, which means
+# that $(SUBARCH) doesn't work here.
+ifeq ($(ARCH), um)
+CHECKSTACK_ARCH := $(SUBARCH)
+else
+CHECKSTACK_ARCH := $(ARCH)
+endif
+checkstack:
+	$(OBJDUMP) -d vmlinux $$(find . -name '*.ko') | \
+	$(PERL) $(src)/scripts/checkstack.pl $(CHECKSTACK_ARCH)
+
+kernelrelease:
+	@echo "$(KERNELVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))"
+
+kernelversion:
+	@echo $(KERNELVERSION)
+
+# Clear a bunch of variables before executing the submake
+tools/: FORCE
+	$(Q)mkdir -p $(objtree)/tools
+	$(Q)$(MAKE) LDFLAGS= MAKEFLAGS="$(filter --j% -j,$(MAKEFLAGS))" O=$(objtree) subdir=tools -C $(src)/tools/
+
+tools/%: FORCE
+	$(Q)mkdir -p $(objtree)/tools
+	$(Q)$(MAKE) LDFLAGS= MAKEFLAGS="$(filter --j% -j,$(MAKEFLAGS))" O=$(objtree) subdir=tools -C $(src)/tools/ $*
+
+# Single targets
+# ---------------------------------------------------------------------------
+# Single targets are compatible with:
+# - build with mixed source and output
+# - build with separate output dir 'make O=...'
+# - external modules
+#
+#  target-dir => where to store outputfile
+#  build-dir  => directory in kernel source tree to use
+
+ifeq ($(KBUILD_EXTMOD),)
+        build-dir  = $(patsubst %/,%,$(dir $@))
+        target-dir = $(dir $@)
+else
+        zap-slash=$(filter-out .,$(patsubst %/,%,$(dir $@)))
+        build-dir  = $(KBUILD_EXTMOD)$(if $(zap-slash),/$(zap-slash))
+        target-dir = $(if $(KBUILD_EXTMOD),$(dir $<),$(dir $@))
+endif
+
+%.s: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.i: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.o: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.lst: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.s: %.S prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.o: %.S prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.symtypes: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+
+# Modules
+/: prepare scripts FORCE
+	$(cmd_crmodverdir)
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
+	$(build)=$(build-dir)
+%/: prepare scripts FORCE
+	$(cmd_crmodverdir)
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
+	$(build)=$(build-dir)
+%.ko: prepare scripts FORCE
+	$(cmd_crmodverdir)
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1)   \
+	$(build)=$(build-dir) $(@:.ko=.o)
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
+
+# FIXME Should go into a make.lib or something 
+# ===========================================================================
+
+quiet_cmd_rmdirs = $(if $(wildcard $(rm-dirs)),CLEAN   $(wildcard $(rm-dirs)))
+      cmd_rmdirs = rm -rf $(rm-dirs)
+
+quiet_cmd_rmfiles = $(if $(wildcard $(rm-files)),CLEAN   $(wildcard $(rm-files)))
+      cmd_rmfiles = rm -f $(rm-files)
+
+# Run depmod only if we have System.map and depmod is executable
+quiet_cmd_depmod = DEPMOD  $(KERNELRELEASE)
+      cmd_depmod = $(CONFIG_SHELL) $(srctree)/scripts/depmod.sh $(DEPMOD) \
+                   $(KERNELRELEASE) "$(patsubst y,_,$(CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX))"
+
+# Create temporary dir for module support files
+# clean it up only when building all modules
+cmd_crmodverdir = $(Q)mkdir -p $(MODVERDIR) \
+                  $(if $(KBUILD_MODULES),; rm -f $(MODVERDIR)/*)
+
+# read all saved command lines
+
+targets := $(wildcard $(sort $(targets)))
+cmd_files := $(wildcard .*.cmd $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))
+
+ifneq ($(cmd_files),)
+  $(cmd_files): ;	# Do not try to update included dependency files
+  include $(cmd_files)
+endif
+
+# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.clean obj=dir
+# Usage:
+# $(Q)$(MAKE) $(clean)=dir
+clean := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.clean obj
+
+endif	# skip-makefile
+
+PHONY += FORCE
+FORCE:
+
+# Declare the contents of the .PHONY variable as phony.  We keep that
+# information in a variable so we can use it in if_changed and friends.
+.PHONY: $(PHONY)
diff -rubB --new-file linux-3.10.69/Makefile.bromolow F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/Makefile.bromolow
--- linux-3.10.69/Makefile.bromolow	1970-01-01 01:00:00.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/Makefile.bromolow	2017-05-02 03:31:56.000000000 +0200
@@ -0,0 +1,1436 @@
+VERSION = 3
+PATCHLEVEL = 10
+SUBLEVEL = 69
+EXTRAVERSION = -bromolow
+NAME = TOSSUG Baby Fish
+
+# *DOCUMENTATION*
+# To see a list of typical targets execute "make help"
+# More info can be located in ./README
+# Comments in this file are targeted only to the developer, do not
+# expect to learn how to build the kernel reading this file.
+
+# Do not:
+# o  use make's built-in rules and variables
+#    (this increases performance and avoids hard-to-debug behaviour);
+# o  print "Entering directory ...";
+MAKEFLAGS += -rR --no-print-directory
+
+# Avoid funny character set dependencies
+unexport LC_ALL
+LC_COLLATE=C
+LC_NUMERIC=C
+export LC_COLLATE LC_NUMERIC
+
+# We are using a recursive build, so we need to do a little thinking
+# to get the ordering right.
+#
+# Most importantly: sub-Makefiles should only ever modify files in
+# their own directory. If in some directory we have a dependency on
+# a file in another dir (which doesn't happen often, but it's often
+# unavoidable when linking the built-in.o targets which finally
+# turn into vmlinux), we will call a sub make in that other dir, and
+# after that we are sure that everything which is in that other dir
+# is now up to date.
+#
+# The only cases where we need to modify files which have global
+# effects are thus separated out and done before the recursive
+# descending is started. They are now explicitly listed as the
+# prepare rule.
+
+# To put more focus on warnings, be less verbose as default
+# Use 'make V=1' to see the full commands
+
+ifeq ("$(origin V)", "command line")
+  KBUILD_VERBOSE = $(V)
+endif
+ifndef KBUILD_VERBOSE
+  KBUILD_VERBOSE = 0
+endif
+
+# Call a source code checker (by default, "sparse") as part of the
+# C compilation.
+#
+# Use 'make C=1' to enable checking of only re-compiled files.
+# Use 'make C=2' to enable checking of *all* source files, regardless
+# of whether they are re-compiled or not.
+#
+# See the file "Documentation/sparse.txt" for more details, including
+# where to get the "sparse" utility.
+
+ifeq ("$(origin C)", "command line")
+  KBUILD_CHECKSRC = $(C)
+endif
+ifndef KBUILD_CHECKSRC
+  KBUILD_CHECKSRC = 0
+endif
+
+# Use make M=dir to specify directory of external module to build
+# Old syntax make ... SUBDIRS=$PWD is still supported
+# Setting the environment variable KBUILD_EXTMOD take precedence
+ifdef SUBDIRS
+  KBUILD_EXTMOD ?= $(SUBDIRS)
+endif
+
+ifeq ("$(origin M)", "command line")
+  KBUILD_EXTMOD := $(M)
+endif
+
+# kbuild supports saving output files in a separate directory.
+# To locate output files in a separate directory two syntaxes are supported.
+# In both cases the working directory must be the root of the kernel src.
+# 1) O=
+# Use "make O=dir/to/store/output/files/"
+#
+# 2) Set KBUILD_OUTPUT
+# Set the environment variable KBUILD_OUTPUT to point to the directory
+# where the output files shall be placed.
+# export KBUILD_OUTPUT=dir/to/store/output/files/
+# make
+#
+# The O= assignment takes precedence over the KBUILD_OUTPUT environment
+# variable.
+
+
+# KBUILD_SRC is set on invocation of make in OBJ directory
+# KBUILD_SRC is not intended to be used by the regular user (for now)
+ifeq ($(KBUILD_SRC),)
+
+# OK, Make called in directory where kernel src resides
+# Do we want to locate output files in a separate directory?
+ifeq ("$(origin O)", "command line")
+  KBUILD_OUTPUT := $(O)
+endif
+
+ifeq ("$(origin W)", "command line")
+  export KBUILD_ENABLE_EXTRA_GCC_CHECKS := $(W)
+endif
+
+# That's our default target when none is given on the command line
+PHONY := _all
+_all:
+
+# Cancel implicit rules on top Makefile
+$(CURDIR)/Makefile Makefile: ;
+
+ifneq ($(KBUILD_OUTPUT),)
+# Invoke a second make in the output directory, passing relevant variables
+# check that the output directory actually exists
+saved-output := $(KBUILD_OUTPUT)
+KBUILD_OUTPUT := $(shell cd $(KBUILD_OUTPUT) && /bin/pwd)
+$(if $(KBUILD_OUTPUT),, \
+     $(error output directory "$(saved-output)" does not exist))
+
+PHONY += $(MAKECMDGOALS) sub-make
+
+$(filter-out _all sub-make $(CURDIR)/Makefile, $(MAKECMDGOALS)) _all: sub-make
+	@:
+
+sub-make: FORCE
+	$(if $(KBUILD_VERBOSE:1=),@)$(MAKE) -C $(KBUILD_OUTPUT) \
+	KBUILD_SRC=$(CURDIR) \
+	KBUILD_EXTMOD="$(KBUILD_EXTMOD)" -f $(CURDIR)/Makefile \
+	$(filter-out _all sub-make,$(MAKECMDGOALS))
+
+# Leave processing to above invocation of make
+skip-makefile := 1
+endif # ifneq ($(KBUILD_OUTPUT),)
+endif # ifeq ($(KBUILD_SRC),)
+
+# We process the rest of the Makefile if this is the final invocation of make
+ifeq ($(skip-makefile),)
+
+# If building an external module we do not care about the all: rule
+# but instead _all depend on modules
+PHONY += all
+ifeq ($(KBUILD_EXTMOD),)
+_all: all
+else
+_all: modules
+endif
+
+srctree		:= $(if $(KBUILD_SRC),$(KBUILD_SRC),$(CURDIR))
+objtree		:= $(CURDIR)
+src		:= $(srctree)
+obj		:= $(objtree)
+
+VPATH		:= $(srctree)$(if $(KBUILD_EXTMOD),:$(KBUILD_EXTMOD))
+
+export srctree objtree VPATH
+
+
+# SUBARCH tells the usermode build what the underlying arch is.  That is set
+# first, and if a usermode build is happening, the "ARCH=um" on the command
+# line overrides the setting of ARCH below.  If a native build is happening,
+# then ARCH is assigned, getting whatever value it gets normally, and 
+# SUBARCH is subsequently ignored.
+
+SUBARCH := $(shell uname -m | sed -e s/i.86/x86/ -e s/x86_64/x86/ \
+				  -e s/sun4u/sparc64/ \
+				  -e s/arm.*/arm/ -e s/sa110/arm/ \
+				  -e s/s390x/s390/ -e s/parisc64/parisc/ \
+				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ \
+				  -e s/sh[234].*/sh/ -e s/aarch64.*/arm64/ )
+
+# Cross compiling and selecting different set of gcc/bin-utils
+# ---------------------------------------------------------------------------
+#
+# When performing cross compilation for other architectures ARCH shall be set
+# to the target architecture. (See arch/* for the possibilities).
+# ARCH can be set during invocation of make:
+# make ARCH=ia64
+# Another way is to have ARCH set in the environment.
+# The default ARCH is the host where make is executed.
+
+# CROSS_COMPILE specify the prefix used for all executables used
+# during compilation. Only gcc and related bin-utils executables
+# are prefixed with $(CROSS_COMPILE).
+# CROSS_COMPILE can be set on the command line
+# make CROSS_COMPILE=ia64-linux-
+# Alternatively CROSS_COMPILE can be set in the environment.
+# A third alternative is to store a setting in .config so that plain
+# "make" in the configured kernel build directory always uses that.
+# Default value for CROSS_COMPILE is not to prefix executables
+# Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
+ARCH		?= $(SUBARCH)
+CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
+
+# Architecture as present in compile.h
+UTS_MACHINE 	:= $(ARCH)
+SRCARCH 	:= $(ARCH)
+
+# Additional ARCH settings for x86
+ifeq ($(ARCH),i386)
+        SRCARCH := x86
+endif
+ifeq ($(ARCH),x86_64)
+        SRCARCH := x86
+endif
+
+# Additional ARCH settings for sparc
+ifeq ($(ARCH),sparc32)
+       SRCARCH := sparc
+endif
+ifeq ($(ARCH),sparc64)
+       SRCARCH := sparc
+endif
+
+# Additional ARCH settings for sh
+ifeq ($(ARCH),sh64)
+       SRCARCH := sh
+endif
+
+# Additional ARCH settings for tile
+ifeq ($(ARCH),tilepro)
+       SRCARCH := tile
+endif
+ifeq ($(ARCH),tilegx)
+       SRCARCH := tile
+endif
+
+# Where to locate arch specific headers
+hdr-arch  := $(SRCARCH)
+
+KCONFIG_CONFIG	?= .config
+export KCONFIG_CONFIG
+
+# SHELL used by kbuild
+CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
+	  else if [ -x /bin/bash ]; then echo /bin/bash; \
+	  else echo sh; fi ; fi)
+
+HOSTCC       = gcc
+HOSTCXX      = g++
+HOSTCFLAGS   = -Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
+HOSTCXXFLAGS = -O2
+
+# Decide whether to build built-in, modular, or both.
+# Normally, just do built-in.
+
+KBUILD_MODULES :=
+KBUILD_BUILTIN := 1
+
+#	If we have only "make modules", don't compile built-in objects.
+#	When we're building modules with modversions, we need to consider
+#	the built-in objects during the descend as well, in order to
+#	make sure the checksums are up to date before we record them.
+
+ifeq ($(MAKECMDGOALS),modules)
+  KBUILD_BUILTIN := $(if $(CONFIG_MODVERSIONS),1)
+endif
+
+#	If we have "make <whatever> modules", compile modules
+#	in addition to whatever we do anyway.
+#	Just "make" or "make all" shall build modules as well
+
+ifneq ($(filter all _all modules,$(MAKECMDGOALS)),)
+  KBUILD_MODULES := 1
+endif
+
+ifeq ($(MAKECMDGOALS),)
+  KBUILD_MODULES := 1
+endif
+
+export KBUILD_MODULES KBUILD_BUILTIN
+export KBUILD_CHECKSRC KBUILD_SRC KBUILD_EXTMOD
+
+# Beautify output
+# ---------------------------------------------------------------------------
+#
+# Normally, we echo the whole command before executing it. By making
+# that echo $($(quiet)$(cmd)), we now have the possibility to set
+# $(quiet) to choose other forms of output instead, e.g.
+#
+#         quiet_cmd_cc_o_c = Compiling $(RELDIR)/$@
+#         cmd_cc_o_c       = $(CC) $(c_flags) -c -o $@ $<
+#
+# If $(quiet) is empty, the whole command will be printed.
+# If it is set to "quiet_", only the short version will be printed. 
+# If it is set to "silent_", nothing will be printed at all, since
+# the variable $(silent_cmd_cc_o_c) doesn't exist.
+#
+# A simple variant is to prefix commands with $(Q) - that's useful
+# for commands that shall be hidden in non-verbose mode.
+#
+#	$(Q)ln $@ :<
+#
+# If KBUILD_VERBOSE equals 0 then the above command will be hidden.
+# If KBUILD_VERBOSE equals 1 then the above command is displayed.
+
+ifeq ($(KBUILD_VERBOSE),1)
+  quiet =
+  Q =
+else
+  quiet=quiet_
+  Q = @
+endif
+
+# If the user is running make -s (silent mode), suppress echoing of
+# commands
+
+ifneq ($(filter s% -s%,$(MAKEFLAGS)),)
+  quiet=silent_
+endif
+
+export quiet Q KBUILD_VERBOSE
+
+
+# Look for make include files relative to root of kernel src
+MAKEFLAGS += --include-dir=$(srctree)
+
+# We need some generic definitions (do not try to remake the file).
+$(srctree)/scripts/Kbuild.include: ;
+include $(srctree)/scripts/Kbuild.include
+
+# Make variables (CC, etc...)
+
+AS		= $(CROSS_COMPILE)as
+LD		= $(CROSS_COMPILE)ld
+CC		= $(CROSS_COMPILE)gcc
+CPP		= $(CC) -E
+AR		= $(CROSS_COMPILE)ar
+NM		= $(CROSS_COMPILE)nm
+STRIP		= $(CROSS_COMPILE)strip
+OBJCOPY		= $(CROSS_COMPILE)objcopy
+OBJDUMP		= $(CROSS_COMPILE)objdump
+AWK		= awk
+GENKSYMS	= scripts/genksyms/genksyms
+INSTALLKERNEL  := installkernel
+DEPMOD		= /sbin/depmod
+PERL		= perl
+CHECK		= sparse
+
+CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ \
+		  -Wbitwise -Wno-return-void $(CF)
+CFLAGS_MODULE   =
+AFLAGS_MODULE   =
+LDFLAGS_MODULE  =
+CFLAGS_KERNEL	=
+AFLAGS_KERNEL	=
+CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage
+
+
+# Use USERINCLUDE when you must reference the UAPI directories only.
+USERINCLUDE    := \
+		-I$(srctree)/arch/$(hdr-arch)/include/uapi \
+		-Iarch/$(hdr-arch)/include/generated/uapi \
+		-I$(srctree)/include/uapi \
+		-Iinclude/generated/uapi \
+                -include $(srctree)/include/linux/kconfig.h
+
+# Use LINUXINCLUDE when you must reference the include/ directory.
+# Needed to be compatible with the O= option
+LINUXINCLUDE    := \
+		-I$(srctree)/arch/$(hdr-arch)/include \
+		-Iarch/$(hdr-arch)/include/generated \
+		$(if $(KBUILD_SRC), -I$(srctree)/include) \
+		-Iinclude \
+		$(USERINCLUDE)
+
+KBUILD_CPPFLAGS := -D__KERNEL__
+
+KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
+		   -fno-strict-aliasing -fno-common \
+		   -Werror-implicit-function-declaration \
+		   -Wno-format-security \
+		   -fno-delete-null-pointer-checks
+KBUILD_AFLAGS_KERNEL :=
+KBUILD_CFLAGS_KERNEL :=
+KBUILD_AFLAGS   := -D__ASSEMBLY__
+KBUILD_AFLAGS_MODULE  := -DMODULE
+KBUILD_CFLAGS_MODULE  := -DMODULE
+KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
+
+# Read KERNELRELEASE from include/config/kernel.release (if it exists)
+KERNELRELEASE = $(shell cat include/config/kernel.release 2> /dev/null)
+KERNELVERSION = $(VERSION)$(if $(PATCHLEVEL),.$(PATCHLEVEL)$(if $(SUBLEVEL),.$(SUBLEVEL)))$(EXTRAVERSION)
+
+export VERSION PATCHLEVEL SUBLEVEL KERNELRELEASE KERNELVERSION
+export ARCH SRCARCH CONFIG_SHELL HOSTCC HOSTCFLAGS CROSS_COMPILE AS LD CC
+export CPP AR NM STRIP OBJCOPY OBJDUMP
+export MAKE AWK GENKSYMS INSTALLKERNEL PERL UTS_MACHINE
+export HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
+
+export KBUILD_CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS LDFLAGS
+export KBUILD_CFLAGS CFLAGS_KERNEL CFLAGS_MODULE CFLAGS_GCOV
+export KBUILD_AFLAGS AFLAGS_KERNEL AFLAGS_MODULE
+export KBUILD_AFLAGS_MODULE KBUILD_CFLAGS_MODULE KBUILD_LDFLAGS_MODULE
+export KBUILD_AFLAGS_KERNEL KBUILD_CFLAGS_KERNEL
+export KBUILD_ARFLAGS
+
+# When compiling out-of-tree modules, put MODVERDIR in the module
+# tree rather than in the kernel tree. The kernel tree might
+# even be read-only.
+export MODVERDIR := $(if $(KBUILD_EXTMOD),$(firstword $(KBUILD_EXTMOD))/).tmp_versions
+
+# Files to ignore in find ... statements
+
+RCS_FIND_IGNORE := \( -name SCCS -o -name BitKeeper -o -name .svn -o -name CVS \
+		   -o -name .pc -o -name .hg -o -name .git \) -prune -o
+export RCS_TAR_IGNORE := --exclude SCCS --exclude BitKeeper --exclude .svn \
+			 --exclude CVS --exclude .pc --exclude .hg --exclude .git
+
+# ===========================================================================
+# Rules shared between *config targets and build targets
+
+# Basic helpers built in scripts/
+PHONY += scripts_basic
+scripts_basic:
+	$(Q)$(MAKE) $(build)=scripts/basic
+	$(Q)rm -f .tmp_quiet_recordmcount
+
+# To avoid any implicit rule to kick in, define an empty command.
+scripts/basic/%: scripts_basic ;
+
+PHONY += outputmakefile
+# outputmakefile generates a Makefile in the output directory, if using a
+# separate output directory. This allows convenient use of make in the
+# output directory.
+outputmakefile:
+ifneq ($(KBUILD_SRC),)
+	$(Q)ln -fsn $(srctree) source
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \
+	    $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)
+endif
+
+# Support for using generic headers in asm-generic
+PHONY += asm-generic
+asm-generic:
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.asm-generic \
+	            src=asm obj=arch/$(SRCARCH)/include/generated/asm
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.asm-generic \
+	            src=uapi/asm obj=arch/$(SRCARCH)/include/generated/uapi/asm
+
+# To make sure we do not include .config for any of the *config targets
+# catch them early, and hand them over to scripts/kconfig/Makefile
+# It is allowed to specify more targets when calling make, including
+# mixing *config targets and build targets.
+# For example 'make oldconfig all'.
+# Detect when mixed targets is specified, and make a second invocation
+# of make so .config is not included in this case either (for *config).
+
+version_h := include/generated/uapi/linux/version.h
+
+no-dot-config-targets := clean mrproper distclean \
+			 cscope gtags TAGS tags help %docs check% coccicheck \
+			 $(version_h) headers_% archheaders archscripts \
+			 kernelversion %src-pkg
+
+config-targets := 0
+mixed-targets  := 0
+dot-config     := 1
+
+ifneq ($(filter $(no-dot-config-targets), $(MAKECMDGOALS)),)
+	ifeq ($(filter-out $(no-dot-config-targets), $(MAKECMDGOALS)),)
+		dot-config := 0
+	endif
+endif
+
+ifeq ($(KBUILD_EXTMOD),)
+        ifneq ($(filter config %config,$(MAKECMDGOALS)),)
+                config-targets := 1
+                ifneq ($(filter-out config %config,$(MAKECMDGOALS)),)
+                        mixed-targets := 1
+                endif
+        endif
+endif
+
+ifeq ($(mixed-targets),1)
+# ===========================================================================
+# We're called with mixed targets (*config and build targets).
+# Handle them one by one.
+
+%:: FORCE
+	$(Q)$(MAKE) -C $(srctree) KBUILD_SRC= $@
+
+else
+ifeq ($(config-targets),1)
+# ===========================================================================
+# *config targets only - make sure prerequisites are updated, and descend
+# in scripts/kconfig to make the *config target
+
+# Read arch specific Makefile to set KBUILD_DEFCONFIG as needed.
+# KBUILD_DEFCONFIG may point out an alternative default configuration
+# used for 'make defconfig'
+include $(srctree)/arch/$(SRCARCH)/Makefile
+export KBUILD_DEFCONFIG KBUILD_KCONFIG
+
+config: scripts_basic outputmakefile FORCE
+	$(Q)mkdir -p include/linux include/config
+	$(Q)$(MAKE) $(build)=scripts/kconfig $@
+
+%config: scripts_basic outputmakefile FORCE
+	$(Q)mkdir -p include/linux include/config
+	$(Q)$(MAKE) $(build)=scripts/kconfig $@
+
+else
+# ===========================================================================
+# Build targets only - this includes vmlinux, arch specific targets, clean
+# targets and others. In general all targets except *config targets.
+
+ifeq ($(KBUILD_EXTMOD),)
+# Additional helpers built in scripts/
+# Carefully list dependencies so we do not try to build scripts twice
+# in parallel
+PHONY += scripts
+scripts: scripts_basic include/config/auto.conf include/config/tristate.conf \
+	 asm-generic
+	$(Q)$(MAKE) $(build)=$(@)
+
+# Objects we will link into vmlinux / subdirs we need to visit
+init-y		:= init/
+drivers-y	:= drivers/ sound/ firmware/
+net-y		:= net/
+libs-y		:= lib/
+core-y		:= usr/
+endif # KBUILD_EXTMOD
+
+ifeq ($(dot-config),1)
+# Read in config
+-include include/config/auto.conf
+
+ifeq ($(KBUILD_EXTMOD),)
+# Read in dependencies to all Kconfig* files, make sure to run
+# oldconfig if changes are detected.
+-include include/config/auto.conf.cmd
+
+# To avoid any implicit rule to kick in, define an empty command
+$(KCONFIG_CONFIG) include/config/auto.conf.cmd: ;
+
+# If .config is newer than include/config/auto.conf, someone tinkered
+# with it and forgot to run make oldconfig.
+# if auto.conf.cmd is missing then we are probably in a cleaned tree so
+# we execute the config step to be sure to catch updated Kconfig files
+include/config/%.conf: $(KCONFIG_CONFIG) include/config/auto.conf.cmd
+	$(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig
+else
+# external modules needs include/generated/autoconf.h and include/config/auto.conf
+# but do not care if they are up-to-date. Use auto.conf to trigger the test
+PHONY += include/config/auto.conf
+
+include/config/auto.conf:
+	$(Q)test -e include/generated/autoconf.h -a -e $@ || (		\
+	echo >&2;							\
+	echo >&2 "  ERROR: Kernel configuration is invalid.";		\
+	echo >&2 "         include/generated/autoconf.h or $@ are missing.";\
+	echo >&2 "         Run 'make oldconfig && make prepare' on kernel src to fix it.";	\
+	echo >&2 ;							\
+	/bin/false)
+
+endif # KBUILD_EXTMOD
+
+else
+# Dummy target needed, because used as prerequisite
+include/config/auto.conf: ;
+endif # $(dot-config)
+
+# The all: target is the default when no target is given on the
+# command line.
+# This allow a user to issue only 'make' to build a kernel including modules
+# Defaults to vmlinux, but the arch makefile usually adds further targets
+all: vmlinux
+
+ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
+KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)
+else
+KBUILD_CFLAGS	+= -O2
+endif
+
+include $(srctree)/arch/$(SRCARCH)/Makefile
+
+ifdef CONFIG_READABLE_ASM
+# Disable optimizations that make assembler listings hard to read.
+# reorder blocks reorders the control in the function
+# ipa clone creates specialized cloned functions
+# partial inlining inlines only parts of functions
+KBUILD_CFLAGS += $(call cc-option,-fno-reorder-blocks,) \
+                 $(call cc-option,-fno-ipa-cp-clone,) \
+                 $(call cc-option,-fno-partial-inlining)
+endif
+
+ifneq ($(CONFIG_FRAME_WARN),0)
+KBUILD_CFLAGS += $(call cc-option,-Wframe-larger-than=${CONFIG_FRAME_WARN})
+endif
+
+# Force gcc to behave correct even for buggy distributions
+ifndef CONFIG_CC_STACKPROTECTOR
+KBUILD_CFLAGS += $(call cc-option, -fno-stack-protector)
+endif
+
+# This warning generated too much noise in a regular build.
+# Use make W=1 to enable this warning (see scripts/Makefile.build)
+KBUILD_CFLAGS += $(call cc-disable-warning, unused-but-set-variable)
+
+ifdef CONFIG_FRAME_POINTER
+KBUILD_CFLAGS	+= -fno-omit-frame-pointer -fno-optimize-sibling-calls
+else
+# Some targets (ARM with Thumb2, for example), can't be built with frame
+# pointers.  For those, we don't have FUNCTION_TRACER automatically
+# select FRAME_POINTER.  However, FUNCTION_TRACER adds -pg, and this is
+# incompatible with -fomit-frame-pointer with current GCC, so we don't use
+# -fomit-frame-pointer with FUNCTION_TRACER.
+ifndef CONFIG_FUNCTION_TRACER
+KBUILD_CFLAGS	+= -fomit-frame-pointer
+endif
+endif
+
+ifdef CONFIG_DEBUG_INFO
+KBUILD_CFLAGS	+= -g
+KBUILD_AFLAGS	+= -gdwarf-2
+endif
+
+ifdef CONFIG_DEBUG_INFO_REDUCED
+KBUILD_CFLAGS 	+= $(call cc-option, -femit-struct-debug-baseonly) \
+		   $(call cc-option,-fno-var-tracking)
+endif
+
+ifdef CONFIG_FUNCTION_TRACER
+ifdef CONFIG_HAVE_FENTRY
+CC_USING_FENTRY	:= $(call cc-option, -mfentry -DCC_USING_FENTRY)
+endif
+KBUILD_CFLAGS	+= -pg $(CC_USING_FENTRY)
+KBUILD_AFLAGS	+= $(CC_USING_FENTRY)
+ifdef CONFIG_DYNAMIC_FTRACE
+	ifdef CONFIG_HAVE_C_RECORDMCOUNT
+		BUILD_C_RECORDMCOUNT := y
+		export BUILD_C_RECORDMCOUNT
+	endif
+endif
+endif
+
+# We trigger additional mismatches with less inlining
+ifdef CONFIG_DEBUG_SECTION_MISMATCH
+KBUILD_CFLAGS += $(call cc-option, -fno-inline-functions-called-once)
+endif
+
+# arch Makefile may override CC so keep this after arch Makefile is included
+NOSTDINC_FLAGS += -nostdinc -isystem $(shell $(CC) -print-file-name=include)
+CHECKFLAGS     += $(NOSTDINC_FLAGS)
+
+# warn about C99 declaration after statement
+KBUILD_CFLAGS += $(call cc-option,-Wdeclaration-after-statement,)
+
+# disable pointer signed / unsigned warnings in gcc 4.0
+KBUILD_CFLAGS += $(call cc-disable-warning, pointer-sign)
+
+# disable invalid "can't wrap" optimizations for signed / pointers
+KBUILD_CFLAGS	+= $(call cc-option,-fno-strict-overflow)
+
+# conserve stack if available
+KBUILD_CFLAGS   += $(call cc-option,-fconserve-stack)
+
+# use the deterministic mode of AR if available
+KBUILD_ARFLAGS := $(call ar-option,D)
+
+# check for 'asm goto'
+ifeq ($(shell $(CONFIG_SHELL) $(srctree)/scripts/gcc-goto.sh $(CC)), y)
+	KBUILD_CFLAGS += -DCC_HAVE_ASM_GOTO
+endif
+
+# Add user supplied CPPFLAGS, AFLAGS and CFLAGS as the last assignments
+KBUILD_CPPFLAGS += $(KCPPFLAGS)
+KBUILD_AFLAGS += $(KAFLAGS)
+KBUILD_CFLAGS += $(KCFLAGS)
+
+# Use --build-id when available.
+LDFLAGS_BUILD_ID = $(patsubst -Wl$(comma)%,%,\
+			      $(call cc-ldoption, -Wl$(comma)--build-id,))
+KBUILD_LDFLAGS_MODULE += $(LDFLAGS_BUILD_ID)
+LDFLAGS_vmlinux += $(LDFLAGS_BUILD_ID)
+
+ifeq ($(CONFIG_STRIP_ASM_SYMS),y)
+LDFLAGS_vmlinux	+= $(call ld-option, -X,)
+endif
+
+# Default kernel image to build when no specific target is given.
+# KBUILD_IMAGE may be overruled on the command line or
+# set in the environment
+# Also any assignments in arch/$(ARCH)/Makefile take precedence over
+# this default value
+export KBUILD_IMAGE ?= vmlinux
+
+#
+# INSTALL_PATH specifies where to place the updated kernel and system map
+# images. Default is /boot, but you can set it to other values
+export	INSTALL_PATH ?= /boot
+
+#
+# INSTALL_MOD_PATH specifies a prefix to MODLIB for module directory
+# relocations required by build roots.  This is not defined in the
+# makefile but the argument can be passed to make if needed.
+#
+
+MODLIB	= $(INSTALL_MOD_PATH)/lib/modules/$(KERNELRELEASE)
+export MODLIB
+
+#
+#  INSTALL_MOD_STRIP, if defined, will cause modules to be
+#  stripped after they are installed.  If INSTALL_MOD_STRIP is '1', then
+#  the default option --strip-debug will be used.  Otherwise,
+#  INSTALL_MOD_STRIP value will be used as the options to the strip command.
+
+ifdef INSTALL_MOD_STRIP
+ifeq ($(INSTALL_MOD_STRIP),1)
+mod_strip_cmd = $(STRIP) --strip-debug
+else
+mod_strip_cmd = $(STRIP) $(INSTALL_MOD_STRIP)
+endif # INSTALL_MOD_STRIP=1
+else
+mod_strip_cmd = true
+endif # INSTALL_MOD_STRIP
+export mod_strip_cmd
+
+
+ifdef CONFIG_MODULE_SIG_ALL
+MODSECKEY = ./signing_key.priv
+MODPUBKEY = ./signing_key.x509
+export MODPUBKEY
+mod_sign_cmd = perl $(srctree)/scripts/sign-file $(CONFIG_MODULE_SIG_HASH) $(MODSECKEY) $(MODPUBKEY)
+else
+mod_sign_cmd = true
+endif
+export mod_sign_cmd
+
+
+ifeq ($(KBUILD_EXTMOD),)
+core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
+
+vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
+		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
+		     $(net-y) $(net-m) $(libs-y) $(libs-m)))
+
+vmlinux-alldirs	:= $(sort $(vmlinux-dirs) $(patsubst %/,%,$(filter %/, \
+		     $(init-n) $(init-) \
+		     $(core-n) $(core-) $(drivers-n) $(drivers-) \
+		     $(net-n)  $(net-)  $(libs-n)    $(libs-))))
+
+init-y		:= $(patsubst %/, %/built-in.o, $(init-y))
+core-y		:= $(patsubst %/, %/built-in.o, $(core-y))
+drivers-y	:= $(patsubst %/, %/built-in.o, $(drivers-y))
+net-y		:= $(patsubst %/, %/built-in.o, $(net-y))
+libs-y1		:= $(patsubst %/, %/lib.a, $(libs-y))
+libs-y2		:= $(patsubst %/, %/built-in.o, $(libs-y))
+libs-y		:= $(libs-y1) $(libs-y2)
+
+# Externally visible symbols (used by link-vmlinux.sh)
+export KBUILD_VMLINUX_INIT := $(head-y) $(init-y)
+export KBUILD_VMLINUX_MAIN := $(core-y) $(libs-y) $(drivers-y) $(net-y)
+export KBUILD_LDS          := arch/$(SRCARCH)/kernel/vmlinux.lds
+export LDFLAGS_vmlinux
+# used by scripts/pacmage/Makefile
+export KBUILD_ALLDIRS := $(sort $(filter-out arch/%,$(vmlinux-alldirs)) arch Documentation include samples scripts tools virt)
+
+vmlinux-deps := $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN)
+
+# Final link of vmlinux
+      cmd_link-vmlinux = $(CONFIG_SHELL) $< $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux)
+quiet_cmd_link-vmlinux = LINK    $@
+
+# Include targets which we want to
+# execute if the rest of the kernel build went well.
+vmlinux: scripts/link-vmlinux.sh $(vmlinux-deps) FORCE
+ifdef CONFIG_HEADERS_CHECK
+	$(Q)$(MAKE) -f $(srctree)/Makefile headers_check
+endif
+ifdef CONFIG_SAMPLES
+	$(Q)$(MAKE) $(build)=samples
+endif
+ifdef CONFIG_BUILD_DOCSRC
+	$(Q)$(MAKE) $(build)=Documentation
+endif
+	+$(call if_changed,link-vmlinux)
+
+# The actual objects are generated when descending, 
+# make sure no implicit rule kicks in
+$(sort $(vmlinux-deps)): $(vmlinux-dirs) ;
+
+# Handle descending into subdirectories listed in $(vmlinux-dirs)
+# Preset locale variables to speed up the build process. Limit locale
+# tweaks to this spot to avoid wrong language settings when running
+# make menuconfig etc.
+# Error messages still appears in the original language
+
+PHONY += $(vmlinux-dirs)
+$(vmlinux-dirs): prepare scripts
+	$(Q)$(MAKE) $(build)=$@
+
+# Store (new) KERNELRELASE string in include/config/kernel.release
+include/config/kernel.release: include/config/auto.conf FORCE
+	$(Q)rm -f $@
+	$(Q)echo "$(KERNELVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))" > $@
+
+
+# Things we need to do before we recursively start building the kernel
+# or the modules are listed in "prepare".
+# A multi level approach is used. prepareN is processed before prepareN-1.
+# archprepare is used in arch Makefiles and when processed asm symlink,
+# version.h and scripts_basic is processed / created.
+
+# Listed in dependency order
+PHONY += prepare archprepare prepare0 prepare1 prepare2 prepare3
+
+# prepare3 is used to check if we are building in a separate output directory,
+# and if so do:
+# 1) Check that make has not been executed in the kernel src $(srctree)
+prepare3: include/config/kernel.release
+ifneq ($(KBUILD_SRC),)
+	@$(kecho) '  Using $(srctree) as source for kernel'
+	$(Q)if [ -f $(srctree)/.config -o -d $(srctree)/include/config ]; then \
+		echo >&2 "  $(srctree) is not clean, please run 'make mrproper'"; \
+		echo >&2 "  in the '$(srctree)' directory.";\
+		/bin/false; \
+	fi;
+endif
+
+# prepare2 creates a makefile if using a separate output directory
+prepare2: prepare3 outputmakefile asm-generic
+
+prepare1: prepare2 $(version_h) include/generated/utsrelease.h \
+                   include/config/auto.conf
+	$(cmd_crmodverdir)
+
+archprepare: archheaders archscripts prepare1 scripts_basic
+
+prepare0: archprepare FORCE
+	$(Q)$(MAKE) $(build)=.
+
+# All the preparing..
+prepare: prepare0
+
+# Generate some files
+# ---------------------------------------------------------------------------
+
+# KERNELRELEASE can change from a few different places, meaning version.h
+# needs to be updated, so this check is forced on all builds
+
+uts_len := 64
+define filechk_utsrelease.h
+	if [ `echo -n "$(KERNELRELEASE)" | wc -c ` -gt $(uts_len) ]; then \
+	  echo '"$(KERNELRELEASE)" exceeds $(uts_len) characters' >&2;    \
+	  exit 1;                                                         \
+	fi;                                                               \
+	(echo \#define UTS_RELEASE \"$(KERNELRELEASE)\";)
+endef
+
+define filechk_version.h
+	(echo \#define LINUX_VERSION_CODE $(shell                         \
+	expr $(VERSION) \* 65536 + 0$(PATCHLEVEL) \* 256 + 0$(SUBLEVEL)); \
+	echo '#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))';)
+endef
+
+$(version_h): $(srctree)/Makefile FORCE
+	$(call filechk,version.h)
+
+include/generated/utsrelease.h: include/config/kernel.release FORCE
+	$(call filechk,utsrelease.h)
+
+PHONY += headerdep
+headerdep:
+	$(Q)find $(srctree)/include/ -name '*.h' | xargs --max-args 1 \
+	$(srctree)/scripts/headerdep.pl -I$(srctree)/include
+
+# ---------------------------------------------------------------------------
+
+PHONY += depend dep
+depend dep:
+	@echo '*** Warning: make $@ is unnecessary now.'
+
+# ---------------------------------------------------------------------------
+# Firmware install
+INSTALL_FW_PATH=$(INSTALL_MOD_PATH)/lib/firmware
+export INSTALL_FW_PATH
+
+PHONY += firmware_install
+firmware_install: FORCE
+	@mkdir -p $(objtree)/firmware
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.fwinst obj=firmware __fw_install
+
+# ---------------------------------------------------------------------------
+# Kernel headers
+
+#Default location for installed headers
+export INSTALL_HDR_PATH = $(objtree)/usr
+
+hdr-inst := -rR -f $(srctree)/scripts/Makefile.headersinst obj
+
+# If we do an all arch process set dst to asm-$(hdr-arch)
+hdr-dst = $(if $(KBUILD_HEADERS), dst=include/asm-$(hdr-arch), dst=include/asm)
+
+PHONY += archheaders
+archheaders:
+
+PHONY += archscripts
+archscripts:
+
+PHONY += __headers
+__headers: $(version_h) scripts_basic asm-generic archheaders archscripts FORCE
+	$(Q)$(MAKE) $(build)=scripts build_unifdef
+
+PHONY += headers_install_all
+headers_install_all:
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/headers.sh install
+
+PHONY += headers_install
+headers_install: __headers
+	$(if $(wildcard $(srctree)/arch/$(hdr-arch)/include/uapi/asm/Kbuild),, \
+	  $(error Headers not exportable for the $(SRCARCH) architecture))
+	$(Q)$(MAKE) $(hdr-inst)=include/uapi
+	$(Q)$(MAKE) $(hdr-inst)=arch/$(hdr-arch)/include/uapi/asm $(hdr-dst)
+
+PHONY += headers_check_all
+headers_check_all: headers_install_all
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/headers.sh check
+
+PHONY += headers_check
+headers_check: headers_install
+	$(Q)$(MAKE) $(hdr-inst)=include/uapi HDRCHECK=1
+	$(Q)$(MAKE) $(hdr-inst)=arch/$(hdr-arch)/include/uapi/asm $(hdr-dst) HDRCHECK=1
+
+# ---------------------------------------------------------------------------
+# Modules
+
+ifdef CONFIG_MODULES
+
+# By default, build modules as well
+
+all: modules
+
+#	Build modules
+#
+#	A module can be listed more than once in obj-m resulting in
+#	duplicate lines in modules.order files.  Those are removed
+#	using awk while concatenating to the final file.
+
+PHONY += modules
+modules: $(vmlinux-dirs) $(if $(KBUILD_BUILTIN),vmlinux) modules.builtin
+	$(Q)$(AWK) '!x[$$0]++' $(vmlinux-dirs:%=$(objtree)/%/modules.order) > $(objtree)/modules.order
+	@$(kecho) '  Building modules, stage 2.';
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.fwinst obj=firmware __fw_modbuild
+
+modules.builtin: $(vmlinux-dirs:%=%/modules.builtin)
+	$(Q)$(AWK) '!x[$$0]++' $^ > $(objtree)/modules.builtin
+
+%/modules.builtin: include/config/auto.conf
+	$(Q)$(MAKE) $(modbuiltin)=$*
+
+
+# Target to prepare building external modules
+PHONY += modules_prepare
+modules_prepare: prepare scripts
+
+# Target to install modules
+PHONY += modules_install
+modules_install: _modinst_ _modinst_post
+
+PHONY += _modinst_
+_modinst_:
+	@rm -rf $(MODLIB)/kernel
+	@rm -f $(MODLIB)/source
+	@mkdir -p $(MODLIB)/kernel
+	@ln -s $(srctree) $(MODLIB)/source
+	@if [ ! $(objtree) -ef  $(MODLIB)/build ]; then \
+		rm -f $(MODLIB)/build ; \
+		ln -s $(objtree) $(MODLIB)/build ; \
+	fi
+	@cp -f $(objtree)/modules.order $(MODLIB)/
+	@cp -f $(objtree)/modules.builtin $(MODLIB)/
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
+
+# This depmod is only for convenience to give the initial
+# boot a modules.dep even before / is mounted read-write.  However the
+# boot script depmod is the master version.
+PHONY += _modinst_post
+_modinst_post: _modinst_
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.fwinst obj=firmware __fw_modinst
+	$(call cmd,depmod)
+
+ifeq ($(CONFIG_MODULE_SIG), y)
+PHONY += modules_sign
+modules_sign:
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modsign
+endif
+
+else # CONFIG_MODULES
+
+# Modules not configured
+# ---------------------------------------------------------------------------
+
+modules modules_install: FORCE
+	@echo >&2
+	@echo >&2 "The present kernel configuration has modules disabled."
+	@echo >&2 "Type 'make config' and enable loadable module support."
+	@echo >&2 "Then build a kernel with module support enabled."
+	@echo >&2
+	@exit 1
+
+endif # CONFIG_MODULES
+
+###
+# Cleaning is done on three levels.
+# make clean     Delete most generated files
+#                Leave enough to build external modules
+# make mrproper  Delete the current configuration, and all generated files
+# make distclean Remove editor backup files, patch leftover files and the like
+
+# Directories & files removed with 'make clean'
+CLEAN_DIRS  += $(MODVERDIR)
+
+# Directories & files removed with 'make mrproper'
+MRPROPER_DIRS  += include/config usr/include include/generated          \
+                  arch/*/include/generated
+MRPRPPER_DIRS  += buffalo/include/generated buffalo/arch/*/include/generated
+MRPROPER_FILES += .config .config.old .version .old_version $(version_h) \
+		  Module.symvers tags TAGS cscope* GPATH GTAGS GRTAGS GSYMS \
+		  signing_key.priv signing_key.x509 x509.genkey		\
+		  extra_certificates signing_key.x509.keyid		\
+		  signing_key.x509.signer
+
+# clean - Delete most, but leave enough to build external modules
+#
+clean: rm-dirs  := $(CLEAN_DIRS)
+clean: rm-files := $(CLEAN_FILES)
+clean-dirs      := $(addprefix _clean_, . $(vmlinux-alldirs) Documentation samples)
+
+PHONY += $(clean-dirs) clean archclean vmlinuxclean
+$(clean-dirs):
+	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
+
+vmlinuxclean:
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/link-vmlinux.sh clean
+
+clean: archclean vmlinuxclean
+
+# mrproper - Delete all generated files, including .config
+#
+mrproper: rm-dirs  := $(wildcard $(MRPROPER_DIRS))
+mrproper: rm-files := $(wildcard $(MRPROPER_FILES))
+mrproper-dirs      := $(addprefix _mrproper_,Documentation/DocBook scripts)
+
+PHONY += $(mrproper-dirs) mrproper archmrproper
+$(mrproper-dirs):
+	$(Q)$(MAKE) $(clean)=$(patsubst _mrproper_%,%,$@)
+
+mrproper: clean archmrproper $(mrproper-dirs)
+	$(call cmd,rmdirs)
+	$(call cmd,rmfiles)
+
+# distclean
+#
+PHONY += distclean
+
+distclean: mrproper
+	@find $(srctree) $(RCS_FIND_IGNORE) \
+		\( -name '*.orig' -o -name '*.rej' -o -name '*~' \
+		-o -name '*.bak' -o -name '#*#' -o -name '.*.orig' \
+		-o -name '.*.rej' \
+		-o -name '*%' -o -name '.*.cmd' -o -name 'core' \) \
+		-type f -print | xargs rm -f
+
+
+# Packaging of the kernel to various formats
+# ---------------------------------------------------------------------------
+# rpm target kept for backward compatibility
+package-dir	:= $(srctree)/scripts/package
+
+%src-pkg: FORCE
+	$(Q)$(MAKE) $(build)=$(package-dir) $@
+%pkg: include/config/kernel.release FORCE
+	$(Q)$(MAKE) $(build)=$(package-dir) $@
+rpm: include/config/kernel.release FORCE
+	$(Q)$(MAKE) $(build)=$(package-dir) $@
+
+
+# Brief documentation of the typical targets used
+# ---------------------------------------------------------------------------
+
+boards := $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*_defconfig)
+boards += $(wildcard $(srctree)/buffalo/arch/$(SRCARCH)/configs/*_defconfig)
+boards := $(notdir $(boards))
+board-dirs := $(dir $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*/*_defconfig))
+board-dirs += $(dir $(wildcard $(srctree)/buffalo/arch/$(SRCARCH)/configs/*/*_defconfig))
+board-dirs := $(sort $(notdir $(board-dirs:/=)))
+
+help:
+	@echo  'Cleaning targets:'
+	@echo  '  clean		  - Remove most generated files but keep the config and'
+	@echo  '                    enough build support to build external modules'
+	@echo  '  mrproper	  - Remove all generated files + config + various backup files'
+	@echo  '  distclean	  - mrproper + remove editor backup and patch files'
+	@echo  ''
+	@echo  'Configuration targets:'
+	@$(MAKE) -f $(srctree)/scripts/kconfig/Makefile help
+	@echo  ''
+	@echo  'Other generic targets:'
+	@echo  '  all		  - Build all targets marked with [*]'
+	@echo  '* vmlinux	  - Build the bare kernel'
+	@echo  '* modules	  - Build all modules'
+	@echo  '  modules_install - Install all modules to INSTALL_MOD_PATH (default: /)'
+	@echo  '  firmware_install- Install all firmware to INSTALL_FW_PATH'
+	@echo  '                    (default: $$(INSTALL_MOD_PATH)/lib/firmware)'
+	@echo  '  dir/            - Build all files in dir and below'
+	@echo  '  dir/file.[oisS] - Build specified target only'
+	@echo  '  dir/file.lst    - Build specified mixed source/assembly target only'
+	@echo  '                    (requires a recent binutils and recent build (System.map))'
+	@echo  '  dir/file.ko     - Build module including final link'
+	@echo  '  modules_prepare - Set up for building external modules'
+	@echo  '  tags/TAGS	  - Generate tags file for editors'
+	@echo  '  cscope	  - Generate cscope index'
+	@echo  '  gtags           - Generate GNU GLOBAL index'
+	@echo  '  kernelrelease	  - Output the release version string'
+	@echo  '  kernelversion	  - Output the version stored in Makefile'
+	@echo  '  headers_install - Install sanitised kernel headers to INSTALL_HDR_PATH'; \
+	 echo  '                    (default: $(INSTALL_HDR_PATH))'; \
+	 echo  ''
+	@echo  'Static analysers'
+	@echo  '  checkstack      - Generate a list of stack hogs'
+	@echo  '  namespacecheck  - Name space analysis on compiled kernel'
+	@echo  '  versioncheck    - Sanity check on version.h usage'
+	@echo  '  includecheck    - Check for duplicate included header files'
+	@echo  '  export_report   - List the usages of all exported symbols'
+	@echo  '  headers_check   - Sanity check on exported headers'
+	@echo  '  headerdep       - Detect inclusion cycles in headers'
+	@$(MAKE) -f $(srctree)/scripts/Makefile.help checker-help
+	@echo  ''
+	@echo  'Kernel packaging:'
+	@$(MAKE) $(build)=$(package-dir) help
+	@echo  ''
+	@echo  'Documentation targets:'
+	@$(MAKE) -f $(srctree)/Documentation/DocBook/Makefile dochelp
+	@echo  ''
+	@echo  'Architecture specific targets ($(SRCARCH)):'
+	@$(if $(archhelp),$(archhelp),\
+		echo '  No architecture specific help defined for $(SRCARCH)')
+	@echo  ''
+	@$(if $(boards), \
+		$(foreach b, $(boards), \
+		printf "  %-24s - Build for %s\\n" $(b) $(subst _defconfig,,$(b));) \
+		echo '')
+	@$(if $(board-dirs), \
+		$(foreach b, $(board-dirs), \
+		printf "  %-16s - Show %s-specific targets\\n" help-$(b) $(b);) \
+		printf "  %-16s - Show all of the above\\n" help-boards; \
+		echo '')
+
+	@echo  '  make V=0|1 [targets] 0 => quiet build (default), 1 => verbose build'
+	@echo  '  make V=2   [targets] 2 => give reason for rebuild of target'
+	@echo  '  make O=dir [targets] Locate all output files in "dir", including .config'
+	@echo  '  make C=1   [targets] Check all c source with $$CHECK (sparse by default)'
+	@echo  '  make C=2   [targets] Force check of all c source with $$CHECK'
+	@echo  '  make RECORDMCOUNT_WARN=1 [targets] Warn about ignored mcount sections'
+	@echo  '  make W=n   [targets] Enable extra gcc checks, n=1,2,3 where'
+	@echo  '		1: warnings which may be relevant and do not occur too often'
+	@echo  '		2: warnings which occur quite often but may still be relevant'
+	@echo  '		3: more obscure warnings, can most likely be ignored'
+	@echo  '		Multiple levels can be combined with W=12 or W=123'
+	@echo  ''
+	@echo  'Execute "make" or "make all" to build all targets marked with [*] '
+	@echo  'For further info see the ./README file'
+
+
+help-board-dirs := $(addprefix help-,$(board-dirs))
+
+help-boards: $(help-board-dirs)
+
+boards-per-dir = $(notdir $(wildcard $(srctree)/arch/$(SRCARCH)/configs/$*/*_defconfig))
+
+$(help-board-dirs): help-%:
+	@echo  'Architecture specific targets ($(SRCARCH) $*):'
+	@$(if $(boards-per-dir), \
+		$(foreach b, $(boards-per-dir), \
+		printf "  %-24s - Build for %s\\n" $*/$(b) $(subst _defconfig,,$(b));) \
+		echo '')
+
+
+# Documentation targets
+# ---------------------------------------------------------------------------
+%docs: scripts_basic FORCE
+	$(Q)$(MAKE) $(build)=scripts build_docproc
+	$(Q)$(MAKE) $(build)=Documentation/DocBook $@
+
+else # KBUILD_EXTMOD
+
+###
+# External module support.
+# When building external modules the kernel used as basis is considered
+# read-only, and no consistency checks are made and the make
+# system is not used on the basis kernel. If updates are required
+# in the basis kernel ordinary make commands (without M=...) must
+# be used.
+#
+# The following are the only valid targets when building external
+# modules.
+# make M=dir clean     Delete all automatically generated files
+# make M=dir modules   Make all modules in specified dir
+# make M=dir	       Same as 'make M=dir modules'
+# make M=dir modules_install
+#                      Install the modules built in the module directory
+#                      Assumes install directory is already created
+
+# We are always building modules
+KBUILD_MODULES := 1
+PHONY += crmodverdir
+crmodverdir:
+	$(cmd_crmodverdir)
+
+PHONY += $(objtree)/Module.symvers
+$(objtree)/Module.symvers:
+	@test -e $(objtree)/Module.symvers || ( \
+	echo; \
+	echo "  WARNING: Symbol version dump $(objtree)/Module.symvers"; \
+	echo "           is missing; modules will have no dependencies and modversions."; \
+	echo )
+
+module-dirs := $(addprefix _module_,$(KBUILD_EXTMOD))
+PHONY += $(module-dirs) modules
+$(module-dirs): crmodverdir $(objtree)/Module.symvers
+	$(Q)$(MAKE) $(build)=$(patsubst _module_%,%,$@)
+
+modules: $(module-dirs)
+	@$(kecho) '  Building modules, stage 2.';
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
+
+PHONY += modules_install
+modules_install: _emodinst_ _emodinst_post
+
+install-dir := $(if $(INSTALL_MOD_DIR),$(INSTALL_MOD_DIR),extra)
+PHONY += _emodinst_
+_emodinst_:
+	$(Q)mkdir -p $(MODLIB)/$(install-dir)
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modinst
+
+PHONY += _emodinst_post
+_emodinst_post: _emodinst_
+	$(call cmd,depmod)
+
+clean-dirs := $(addprefix _clean_,$(KBUILD_EXTMOD))
+
+PHONY += $(clean-dirs) clean
+$(clean-dirs):
+	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
+
+clean:	rm-dirs := $(MODVERDIR)
+clean: rm-files := $(KBUILD_EXTMOD)/Module.symvers
+
+help:
+	@echo  '  Building external modules.'
+	@echo  '  Syntax: make -C path/to/kernel/src M=$$PWD target'
+	@echo  ''
+	@echo  '  modules         - default target, build the module(s)'
+	@echo  '  modules_install - install the module'
+	@echo  '  clean           - remove generated files in module directory only'
+	@echo  ''
+
+# Dummies...
+PHONY += prepare scripts
+prepare: ;
+scripts: ;
+endif # KBUILD_EXTMOD
+
+clean: $(clean-dirs)
+	$(call cmd,rmdirs)
+	$(call cmd,rmfiles)
+	@find $(if $(KBUILD_EXTMOD), $(KBUILD_EXTMOD), .) $(RCS_FIND_IGNORE) \
+		\( -name '*.[oas]' -o -name '*.ko' -o -name '.*.cmd' \
+		-o -name '*.ko.*' \
+		-o -name '.*.d' -o -name '.*.tmp' -o -name '*.mod.c' \
+		-o -name '*.symtypes' -o -name 'modules.order' \
+		-o -name modules.builtin -o -name '.tmp_*.o.*' \
+		-o -name '*.gcno' \) -type f -print | xargs rm -f
+
+# Generate tags for editors
+# ---------------------------------------------------------------------------
+quiet_cmd_tags = GEN     $@
+      cmd_tags = $(CONFIG_SHELL) $(srctree)/scripts/tags.sh $@
+
+tags TAGS cscope gtags: FORCE
+	$(call cmd,tags)
+
+# Scripts to check various things for consistency
+# ---------------------------------------------------------------------------
+
+PHONY += includecheck versioncheck coccicheck namespacecheck export_report
+
+includecheck:
+	find $(srctree)/* $(RCS_FIND_IGNORE) \
+		-name '*.[hcS]' -type f -print | sort \
+		| xargs $(PERL) -w $(srctree)/scripts/checkincludes.pl
+
+versioncheck:
+	find $(srctree)/* $(RCS_FIND_IGNORE) \
+		-name '*.[hcS]' -type f -print | sort \
+		| xargs $(PERL) -w $(srctree)/scripts/checkversion.pl
+
+coccicheck:
+	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/$@
+
+namespacecheck:
+	$(PERL) $(srctree)/scripts/namespace.pl
+
+export_report:
+	$(PERL) $(srctree)/scripts/export_report.pl
+
+endif #ifeq ($(config-targets),1)
+endif #ifeq ($(mixed-targets),1)
+
+PHONY += checkstack kernelrelease kernelversion
+
+# UML needs a little special treatment here.  It wants to use the host
+# toolchain, so needs $(SUBARCH) passed to checkstack.pl.  Everyone
+# else wants $(ARCH), including people doing cross-builds, which means
+# that $(SUBARCH) doesn't work here.
+ifeq ($(ARCH), um)
+CHECKSTACK_ARCH := $(SUBARCH)
+else
+CHECKSTACK_ARCH := $(ARCH)
+endif
+checkstack:
+	$(OBJDUMP) -d vmlinux $$(find . -name '*.ko') | \
+	$(PERL) $(src)/scripts/checkstack.pl $(CHECKSTACK_ARCH)
+
+kernelrelease:
+	@echo "$(KERNELVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))"
+
+kernelversion:
+	@echo $(KERNELVERSION)
+
+# Clear a bunch of variables before executing the submake
+tools/: FORCE
+	$(Q)mkdir -p $(objtree)/tools
+	$(Q)$(MAKE) LDFLAGS= MAKEFLAGS="$(filter --j% -j,$(MAKEFLAGS))" O=$(objtree) subdir=tools -C $(src)/tools/
+
+tools/%: FORCE
+	$(Q)mkdir -p $(objtree)/tools
+	$(Q)$(MAKE) LDFLAGS= MAKEFLAGS="$(filter --j% -j,$(MAKEFLAGS))" O=$(objtree) subdir=tools -C $(src)/tools/ $*
+
+# Single targets
+# ---------------------------------------------------------------------------
+# Single targets are compatible with:
+# - build with mixed source and output
+# - build with separate output dir 'make O=...'
+# - external modules
+#
+#  target-dir => where to store outputfile
+#  build-dir  => directory in kernel source tree to use
+
+ifeq ($(KBUILD_EXTMOD),)
+        build-dir  = $(patsubst %/,%,$(dir $@))
+        target-dir = $(dir $@)
+else
+        zap-slash=$(filter-out .,$(patsubst %/,%,$(dir $@)))
+        build-dir  = $(KBUILD_EXTMOD)$(if $(zap-slash),/$(zap-slash))
+        target-dir = $(if $(KBUILD_EXTMOD),$(dir $<),$(dir $@))
+endif
+
+%.s: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.i: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.o: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.lst: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.s: %.S prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.o: %.S prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+%.symtypes: %.c prepare scripts FORCE
+	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
+
+# Modules
+/: prepare scripts FORCE
+	$(cmd_crmodverdir)
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
+	$(build)=$(build-dir)
+%/: prepare scripts FORCE
+	$(cmd_crmodverdir)
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1) \
+	$(build)=$(build-dir)
+%.ko: prepare scripts FORCE
+	$(cmd_crmodverdir)
+	$(Q)$(MAKE) KBUILD_MODULES=$(if $(CONFIG_MODULES),1)   \
+	$(build)=$(build-dir) $(@:.ko=.o)
+	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.modpost
+
+# FIXME Should go into a make.lib or something 
+# ===========================================================================
+
+quiet_cmd_rmdirs = $(if $(wildcard $(rm-dirs)),CLEAN   $(wildcard $(rm-dirs)))
+      cmd_rmdirs = rm -rf $(rm-dirs)
+
+quiet_cmd_rmfiles = $(if $(wildcard $(rm-files)),CLEAN   $(wildcard $(rm-files)))
+      cmd_rmfiles = rm -f $(rm-files)
+
+# Run depmod only if we have System.map and depmod is executable
+quiet_cmd_depmod = DEPMOD  $(KERNELRELEASE)
+      cmd_depmod = $(CONFIG_SHELL) $(srctree)/scripts/depmod.sh $(DEPMOD) \
+                   $(KERNELRELEASE) "$(patsubst y,_,$(CONFIG_HAVE_UNDERSCORE_SYMBOL_PREFIX))"
+
+# Create temporary dir for module support files
+# clean it up only when building all modules
+cmd_crmodverdir = $(Q)mkdir -p $(MODVERDIR) \
+                  $(if $(KBUILD_MODULES),; rm -f $(MODVERDIR)/*)
+
+# read all saved command lines
+
+targets := $(wildcard $(sort $(targets)))
+cmd_files := $(wildcard .*.cmd $(foreach f,$(targets),$(dir $(f)).$(notdir $(f)).cmd))
+
+ifneq ($(cmd_files),)
+  $(cmd_files): ;	# Do not try to update included dependency files
+  include $(cmd_files)
+endif
+
+# Shorthand for $(Q)$(MAKE) -f scripts/Makefile.clean obj=dir
+# Usage:
+# $(Q)$(MAKE) $(clean)=dir
+clean := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.clean obj
+
+endif	# skip-makefile
+
+PHONY += FORCE
+FORCE:
+
+# Declare the contents of the .PHONY variable as phony.  We keep that
+# information in a variable so we can use it in if_changed and friends.
+.PHONY: $(PHONY)
diff -rubB --new-file linux-3.10.69/scripts/setlocalversion F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/scripts/setlocalversion
--- linux-3.10.69/scripts/setlocalversion	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/scripts/setlocalversion	2017-05-02 03:31:56.000000000 +0200
@@ -169,7 +169,7 @@
 	# LOCALVERSION= is not specified
 	if test "${LOCALVERSION+set}" != "set"; then
 		scm=$(scm_version --short)
-		res="$res${scm:++}"
+#		res="$res${scm:++}"
 	fi
 fi
 
diff -rubB --new-file linux-3.10.69/security/keys/request_key.c F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/security/keys/request_key.c
--- linux-3.10.69/security/keys/request_key.c	2015-02-11 07:48:30.000000000 +0100
+++ F0009-linux-inhouse-develop-3.10-ts5000-rollback-bc06587289f4fb93bdfe4268d246e10efcb94dd6/security/keys/request_key.c	2017-05-02 03:31:56.000000000 +0200
@@ -174,7 +174,8 @@
 	/* set up a minimal environment */
 	i = 0;
 	envp[i++] = "HOME=/";
-	envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+//	envp[i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+	envp[i++] = "PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin";
 	envp[i] = NULL;
 
 	/* set up the argument list */
